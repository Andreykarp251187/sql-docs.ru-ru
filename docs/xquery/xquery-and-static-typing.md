---
title: XQuery и Static введя | Документация Майкрософт
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.prod_service: sql
ms.reviewer: ''
ms.technology: xml
ms.topic: language-reference
dev_langs:
- XML
helpviewer_keywords:
- XQuery, static typing
- static typing
- checking static types
- inference [XQuery]
ms.assetid: d599c791-200d-46f8-b758-97e761a1a5c0
author: rothja
ms.author: jroth
ms.openlocfilehash: 5ad42a174f558202544650fb1580574f290d4466
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "67946080"
---
# <a name="xquery-and-static-typing"></a>XQuery и статическая типизация
[!INCLUDE[tsql-appliesto-ss2012-xxxx-xxxx-xxx-md](../includes/tsql-appliesto-ss2012-xxxx-xxxx-xxx-md.md)]

  В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] XQuery является языком со статической типизацией. Это означает, что при компиляции запросов, если выражение возвращает значение, тип или количество элементов которого неприемлемы для указанной функции или оператора, будет выдана ошибка преобразования типов. В дополнение к этому статическая проверка типов может также обнаружить несоответствие типа выражения пути в типизированном документе XML. Компилятор XQuery сначала применяет фазу нормализации, во время которой добавляются неявные операции (например атомизация), а затем производит статический вывод и статическую проверку типов.  
  
## <a name="static-type-inference"></a>Статический вывод типов  
 Во время операции вывода статического типа определяется тип возвращаемого значения выражения. Для этого берутся статические типы входных параметров и статическая семантика операции и выводится статический тип результата. Например статический тип выражения «1 + 2.3» определяется следующим образом.  
  
-   Имеет статический тип 1 **xs: Integer** и имеет статический тип 2.3 **xs: decimal**. На основе динамической семантики, статическая семантика **+** операция преобразует целочисленное значение в десятичное число, а затем возвращает десятичное число. Выведенным статическим типом будет **xs: decimal**.  
  
 Для нетипизированных экземпляров XML имеются специальные типы, обозначающие, что данные нетипизированы. Эти сведения используются при статической проверке типов и для неявного приведения некоторых типов.  
  
 Для типизированных данных входной тип выводится из коллекции XML-схем, ограничивающей экземпляр типа данных XML. Например, если схема допускает только наличие элементов типа **xs: Integer**, результат выражения пути, использующего этот элемент будет ноль или более элементов типа **xs: Integer**. В настоящее время выражается с помощью выражения, такие как `element(age,xs:integer)*` где символ звездочки (\*) определяет количество элементов результирующего типа. В этом примере результатом выражения в ноль или больше элементов с именем «age» и типом **xs: Integer**. Остальные количества элементов: ровно 1, что выражается указанием только имени типа ноль или один, что выражается указанием вопросительного знака ( **?** ) и 1 или больше и выражается указанием плюса ( **+** ) .  
  
 Иногда вывод статического типа может определить, что выражение всегда возвращает пустую последовательность. Например, если выражение пути типизированного типа данных XML ищет \<имя > элемент внутри \<клиента > элемент (/ customer/name), но схема не допускает \<имя > внутри \<customer >, статический вывод типа определит, что результат будет пустым. Это будет использоваться для выявления неправильных запросов и будут считаться статическую ошибку, если выражение было () или **данных (())** .  
  
 Подробное описание правил вывода содержится в формальной семантике спецификации XQuery. Корпорация Майкрософт только незначительно изменила их для работы с типизированными экземплярами типа данных XML. Наиболее важное отличие от стандарта заключается в том, что неявный узел документа знает тип данных экземпляра XML. Поэтому выражение пути в форме «/age» на основе этих сведений будет точно типизировано.  
  
 С помощью [шаблоны SQL Server Profiler и разрешения](../tools/sql-server-profiler/sql-server-profiler-templates-and-permissions.md), вы увидите статические типы, возвращаемые при компиляции запросов. Чтобы просмотреть их, трассировка должна включать событие XQuery Static Type в категории событий TSQL.  
  
## <a name="static-type-checking"></a>Статическая проверка типов  
 Статическая проверка типов гарантирует, что на стадии выполнения операции будут переданы только те значения, которые имеют соответствующие типы данных. Поскольку эти типы на стадии выполнения не надо проверять, потенциальные ошибки могут быть обнаружены на ранней стадии компиляции, что позволяет повысить производительность. Однако статическая типизация требует точности формулировок при написании запроса.  
  
 Ниже приведены все применимые типы:  
  
-   типы, явно допустимые для функции или операции;  
  
-   подтипы явно допустимых типов.  
  
 Подтипы определяются на основе правил создания подтипов XML-схемы при наследовании по ограничению или по расширению. Например, тип S является подтипом типа T, если все значения, которые имеет тип S, являются также экземплярами типа T.  
  
 Кроме того, в соответствии с иерархией типов XML-схемы, все целочисленные значения являются также и десятичными. Но при этом не все десятичные значения являются целочисленными. Иными словами, целочисленное является подтипом десятичного, но не наоборот. Например **+** операция принимает только значения определенных типов, например числовых типов **xs: Integer**, **xs: decimal**, **xs: число с плавающей запятой**, и **xs: double**. Если значения остальных типы, такие как **xs: String**, при передаче, операция выдает ошибку типа. Это называется строгой типизацией. Значения других типов, например атомарного типа, применяемого для обозначения нетипизированного XML, могут быть неявно преобразованы в значение типа, поддерживаемого для данной операции. Это называется слабой типизацией.  
  
 Если требуется неявное преобразование, статическая проверка типов гарантирует, что операции будут переданы только значения допустимых типов с верным количеством элементов. Для «строка» + 1, он распознает, что статическим типом значения «строка» является **xs: String**. Так как это не тип недопустим для **+** возникает ошибка типа операции.  
  
 При сложении результатов произвольного выражения E1 и произвольного выражения E2 (E1 + E2) статический вывод типов сначала определяет статические типы E1 и E2, а затем сверяет их с типами, допустимыми для данной операции. Например, если статический тип E1 может быть либо **xs: String** или **xs: Integer**, проверка статического типа выдает ошибку типа, несмотря на то, что некоторые значения на время выполнения могут быть целыми числами. То же самое может так, будто статический тип E1 **xs: Integer&#42;** . Так как **+** операция принимает только одно целочисленное значение и E1 может вернуть 0 или больше 1, статическая проверка типов выдаст ошибку.  
  
 Как говорилось ранее, вывод типов часто определяет тип более свободно, чем известно о передаваемом типе данных пользователю. В таких случаях пользователь должен переписать запрос. Некоторые наиболее распространенные причины этого:  
  
-   Тип выводит более общий тип: супертип или объединение типов. Если тип является атомарным, для обозначения действительного статического типа необходимо применить выражение явного приведения или функцию конструктора. Например, если выведенный тип выражения E1 может быть **xs: String** или **xs: Integer** а операции сложения требуется **xs: Integer**, следует писать `xs:integer(E1) + E2` вместо `E1+E2`. Это выражение может завершиться ошибкой во время выполнения, если строковое значение, не может быть приведен к **xs: Integer**. но зато теперь выражение будет проходить статическую проверку типов. Такое выражение сопоставляется с пустой последовательностью.  
  
-   Тип выводит количество элементов большее, чем в действительности содержат данные. Это происходит часто, так как **xml** тип данных может содержать более одного элемента верхнего уровня и коллекции схем XML не может быть ограничено. Чтобы ограничить статический тип и гарантировать, что передается не более одного значения, следует применять позиционный предикат `[1]`. Например, чтобы добавить 1 к значению атрибута `c` элемента `b` под элементом верхнего уровня, необходимо выполнить `write (/a/b/@c)[1]+1`. Также ключевое слово DOCUMENT может использоваться с коллекцией XML-схем.  
  
-   Некоторые операции приводят к потере типа данных во время вывода. Например, если невозможно определить тип узла, он становится **anyType**. Это не неявное приведение типа к любому другому типу. Эти преобразования наиболее заметно появляются во время перемещения с помощью родительской оси. Если выражение приводит к ошибке статической типизации, избегайте таких операций и перепишите запрос.  
  
## <a name="type-checking-of-union-types"></a>Контроль типов объединенных типов  
 Работать с объединенными типами нужно особенно внимательно из-за проверки типов. Следующие примеры поясняют две из возможных проблем.  
  
### <a name="example-function-over-union-type"></a>Пример Функции с объединенным типом  
 Рассмотрим определение элемента <`r`> типа объединения:  
  
```  
<xs:element name="r">  
<xs:simpleType>  
   <xs:union memberTypes="xs:int xs:float xs:double"/>  
</xs:simpleType>  
</xs:element>  
```  
  
 В контексте XQuery, функция «Средний» `fn:avg (//r)` возвращает статическую ошибку, потому что компилятор XQuery не может сложить значения разных типов (**xs: int**, **xs: float** или **xs: двойные**) для <`r`> элементы в аргументе **fn:avg()** . Чтобы решить эту проблему, перепишите вызов функции как `fn:avg(for $r in //r return $r cast as xs:double ?)`.  
  
### <a name="example-operator-over-union-type"></a>Пример Оператора с объединенным типом  
 Оператор сложения ('+') требует использования точных типов операндов. В результате выражение `(//r)[1] + 1` возвращает статическую ошибку, которая имеет вышеуказанное определение типа для элемента <`r`>. Единственное решение — переписать его как `(//r)[1] cast as xs:int? +1`, где «?» обозначает появление 0 или 1. В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] требуется указывать «cast as» с «?», так как любое приведение может вызвать пустую последовательность в результате ошибок во время выполнения.  
  
## <a name="see-also"></a>См. также  
 [Справочник по языку XQuery (SQL Server)](../xquery/xquery-language-reference-sql-server.md)  
  
  
