---
title: Использование расширений Visual C++ | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.custom: ''
ms.date: 11/08/2018
ms.reviewer: ''
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- Visual C++ [ADO], using VC++ extensions
- ADO, Visual C++
ms.assetid: ff759185-df41-4507-8d12-0921894ffbd9
author: MightyPen
ms.author: genemi
manager: jroth
ms.openlocfilehash: 9f89b08d968b5f601c37f89b15196d6ef03db434
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "66702907"
---
# <a name="visual-c-extensions"></a>Расширения Visual C++
## <a name="the-iadorecordbinding-interface"></a>Интерфейс IADORecordBinding
 Расширения Visual C++ Майкрософт для полей ADO associate или привязку [записей](../../../ado/reference/ado-api/recordset-object-ado.md) объекта к переменным C/C++. Каждый раз, когда текущей строки границы **записей** изменяется, привязанных полей в **записей** копируются на переменные C/C++. При необходимости, скопированные данные преобразуется объявленный тип данных переменной C/C++.

 **BindToRecordset** метод **IADORecordBinding** интерфейс привязывает поля к переменным C/C++. **AddNew** метод добавляет новую строку в качестве границы **записей**. **Обновление** метод заполняет поля в новые строки **записей**, или обновляет поля в существующих строках, значения переменных C/C++.

 **IADORecordBinding** интерфейс реализуется **записей** объекта. Не следует кодировать реализация самостоятельно.

## <a name="binding-entries"></a>Элементы привязки
 Расширения Visual C++ для ADO сопоставить поля [записей](../../../ado/reference/ado-api/recordset-object-ado.md) объекта к переменным C/C++. Определение сопоставления между полем и переменной называется *привязки запись*. Макросы предоставляют операции привязки данных числовых, фиксированной и переменной длины. Операции привязки и C/C++ переменные объявляются в классе, производном от класса расширений Visual C++, **CADORecordBinding**. **CADORecordBinding** внутри определения класса макросами операции привязки.

 ADO внутренне сопоставляется параметры в этих макросов OLE DB **DBBINDING** структурировать и создает OLE DB **доступа** объекту управлять перемещение и преобразование данных между полями и переменные. OLE DB определяет данные как состоящий из трех частей: Объект *буфера* там, где хранятся данные; *состояние* указывает ли поле успешно сохранена в буфере, или как переменной должен быть восстановлен поле; и *длина* данных. (См. в разделе [начало и данные параметров (OLE DB)](https://msdn.microsoft.com/4369708b-c9fb-4d48-a321-bf949b41a369)справочника программиста OLE DB, Дополнительные сведения.)

## <a name="header-file"></a>Файл заголовка
 Добавьте следующий файл в приложении для использования расширений Visual C++ для ADO:

```cpp
#include <icrsint.h>
```

## <a name="binding-recordset-fields"></a>Привязка полей набора записей

#### <a name="to-bind-recordset-fields-to-cc-variables"></a>Для доступа к полям набора записей переменных C/C++

1.  Создайте класс, производный от **CADORecordBinding** класса.

2.  Укажите привязку операции и соответствующие переменные C/C++ в производном классе. Квадратная скобка операции привязки между **BEGIN_ADO_BINDING** и **END_ADO_BINDING** макросы. Не прерывайте макросы с запятыми или точками с запятой. Каждый макрос автоматически задаются соответствующие разделители.

     Укажите одну запись привязки для каждого поля должны быть сопоставлены с переменной C/C++. Используйте подходящий член из **ADO_FIXED_LENGTH_ENTRY**, **ADO_NUMERIC_ENTRY**, или **ADO_VARIABLE_LENGTH_ENTRY** семейства макросов.

3.  В приложении, создайте экземпляр класса, производного от **CADORecordBinding**. Получить **IADORecordBinding** интерфейс из **записей**. Затем вызовите **BindToRecordset** метод для привязки **записей** поля для переменных C/C++.

 Дополнительные сведения см. в разделе [образец расширения Visual C++](../../../ado/guide/appendixes/visual-c-extensions-example.md).

## <a name="interface-methods"></a>Методы интерфейса
 **IADORecordBinding** интерфейс содержит три метода: **BindToRecordset**, **AddNew**, и **обновления**. Единственный аргумент для каждого метода — это указатель на экземпляр класса, производного от **CADORecordBinding**. Таким образом **AddNew** и **обновления** методы нельзя указывать параметры их namesakes метода ADO.

## <a name="syntax"></a>Синтаксис
 **BindToRecordset** связывает метод **записей** поля с переменными в C/C++.

```cpp
BindToRecordset(CADORecordBinding *binding)
```

 **AddNew** метод вызывает ее тезка ADO [AddNew](../../../ado/reference/ado-api/addnew-method-ado.md) метод, чтобы добавить новую строку к **записей**.

```cpp
AddNew(CADORecordBinding *binding)
```

 **Обновление** метод вызывает ее тезка ADO [обновление](../../../ado/reference/ado-api/update-method.md) метод, чтобы обновить **записей**.

```cpp
Update(CADORecordBinding *binding)
```

## <a name="binding-entry-macros"></a>Макросы записи привязки
 Макросы записи привязки определяют связь **записей** поля и переменной. Начальный и конечный макрос разделяет набор привязки записи.

 Семейства макросов для данных, предоставляются фиксированной длины, такие как **adDate** или **adBoolean**; числовых данных, таких как **adTinyInt**, **adInteger**, или **adDouble**; и данные переменной длины, такие как **adChar**, **adVarChar** или **adVarBinary**. Все числовые типы, за исключением **adVarNumeric**, также являются типами фиксированной длины. Каждое семейство имеет разные наборы параметров, поэтому можно исключить сведения о привязке, которая не представляет интереса.

 Дополнительные сведения см. в разделе [приложении a. Типы данных](https://msdn.microsoft.com/e3a0533a-2196-4eb0-a31e-92fe9556ada6), справочника программиста OLE DB.

### <a name="begin-binding-entries"></a>Начать привязки записи
 **BEGIN_ADO_BINDING**(*класс*)

### <a name="fixed-length-data"></a>Данные фиксированной длины
 **ADO_FIXED_LENGTH_ENTRY**(*порядковый номер, тип данных, буфер, состояние, измените*)

 **ADO_FIXED_LENGTH_ENTRY2**(*порядковый номер, тип данных, буфер, изменить*)

### <a name="numeric-data"></a>Числовые данные
 **ADO_NUMERIC_ENTRY**(*порядковый номер, тип данных, буфер, точность, масштаб, состояние, измените*)

 **ADO_NUMERIC_ENTRY2**(*порядковый номер, тип данных, в буфер, точность, масштаб, изменение*)

### <a name="variable-length-data"></a>Данные переменной длины
 **ADO_VARIABLE_LENGTH_ENTRY**(*порядковый номер, тип данных, буфер, размер, состояние, длину, измените*)

 **ADO_VARIABLE_LENGTH_ENTRY2**(*порядковый номер, тип данных, буфер, размер, состояние, измените*)

 **ADO_VARIABLE_LENGTH_ENTRY3**(*порядковый номер, тип данных, буфер, размер, длина, изменить*)

 **ADO_VARIABLE_LENGTH_ENTRY4**(*порядковый номер, тип данных, буфер, размер, измените*)

### <a name="end-binding-entries"></a>Привязка операции окончания
 **END_ADO_BINDING**()

|Параметр|Описание|
|---------------|-----------------|
|*Class*|Класс, в котором определены операции привязки и переменных C/C++.|
|*Ordinal*|Порядковый номер, считая с 1, из **записей** полю, соответствующему переменной C/C++.|
|*DataType*|Эквивалентный тип данных ADO переменной C/C++ (см. в разделе [DataTypeEnum](../../../ado/reference/ado-api/datatypeenum.md) список допустимых типов данных типы). Значение **записей** поля будут преобразовываться в этот тип данных, при необходимости.|
|*буфер*|Имя переменной C/C++ где **записей** поля будут сохранены.|
|*Размер*|Максимальный размер в байтах *буфера*. Если *буфера* будет содержать строку переменной длины, пространство для завершающего нуля.|
|*Состояние*|Имя переменной, указывающие ли содержимое *буфера* являются допустимыми и был ли преобразование поля для *DataType* прошла успешно.<br /><br /> Два самых важных значения для этой переменной **adFldOK**, что означает преобразование прошло успешно, и **adFldNull**, который означает, что значение поля будет РАЗНОВИДНОСТЬЮ VT_NULL и не просто пустой.<br /><br /> Возможные значения для *состояние* , перечислены в следующей таблице, «Состояние значения».|
|*Изменение*|Логический флаг; значение TRUE указывает, может обновлять соответствующие ADO **записей** поле значение, содержащееся в *буфера*.<br /><br /> Задает значение типа Boolean *изменить* параметр в значение TRUE, чтобы позволить ADO для обновления связанному полю и FALSE, если вы хотите проверить это поле, но не изменять его.|
|*Точность*|Количество цифр, которые могут быть представлены в числовой переменной.|
|*Масштаб*|Количество десятичных разрядов в числовой переменной.|
|*Длина*|Имя переменной размером 4 байта, который будет содержать фактическую длину данных в *буфера*.|

## <a name="status-values"></a>Индикаторы состояния
 Значение *состояние* переменной указывает ли поле успешно скопирована в переменной.

 При вводе данных, *состояние* может быть присвоено **adFldNull** для указания **записей** должно быть выбрано значение null.

|Константа|Значение|Описание|
|--------------|-----------|-----------------|
|**adFldOK**|0|Было возвращено значение поля, отличных от null.|
|**adFldBadAccessor**|1|Привязки был недопустимым.|
|**adFldCantConvertValue**|2|Не удалось преобразовать значение, по причинам, отличным от несоответствия знаков и данные переполнения.|
|**adFldNull**|3|При получении поля, указывает, что было возвращено значение null.<br /><br /> При установке поля, указывает, должно быть присвоено поле **NULL** когда поле не может закодировать **NULL** сам (например, массив символов или целое число).|
|**adFldTruncated**|4|Данные переменной длины или цифры были усечены.|
|**adFldSignMismatch**|5|Значение со знаком и тип данных переменной не подписан.|
|**adFldDataOverFlow**|6|Значение больше, чем может храниться в тип данных переменной.|
|**adFldCantCreate**|7|Неизвестный тип столбца и поле уже открыт.|
|**adFldUnavailable**|8|Значение поля не удалось определить-, например на новое поле неназначенные без значения по умолчанию.|
|**adFldPermissionDenied**|9|При обновлении, нет разрешения на запись данных.|
|**adFldIntegrityViolation**|10|При обновлении, значение поля приведет к нарушению целостности столбцов.|
|**adFldSchemaViolation**|11|При обновлении, значение поля приведет к нарушению схему столбца.|
|**adFldBadStatus**|12|При обновлении, недопустимое состояние параметра.|
|**adFldDefault**|13|При обновлении, было использовано значение по умолчанию.|

## <a name="see-also"></a>См. также
 [Образец расширения Visual C++](../../../ado/guide/appendixes/visual-c-extensions-example.md) [заголовок расширений Visual C++](../../../ado/guide/appendixes/visual-c-extensions-header.md)
