---
title: Коллекция полей | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- Field object [ADO], fields collection
- Fields collection [ADO]
ms.assetid: 574cf36e-e5f5-403b-983c-749ef93c108f
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 197a57b8a9b9ea2927a057733992a02c731a335a
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "67923936"
---
# <a name="the-fields-collection"></a>Коллекция Fields
**Поля** коллекции является одним из встроенных коллекций ADO. Коллекция — это упорядоченный набор элементов, которые можно ссылаться как единое целое. Дополнительные сведения о коллекции ADO см. в разделе [это модель объекта ADO](../../../ado/guide/data/ado-objects-and-collections.md).  
  
 **Поля** коллекция содержит **поле** объекта для каждого поля (столбца) в **записей**. Как и все коллекции ADO, он имеет **число** и **элемент** свойства, а также **Append** и **обновить** методы. Есть также **CancelUpdate**, **удалить**, **Resync**, и **обновления** методы, которые недоступны в других коллекциях ADO.  
  
## <a name="examining-the-fields-collection"></a>Изучение коллекции полей  
 Рассмотрите возможность **поля** коллекции примера **записей** представленные в этом разделе. Образец **записей** был получен из инструкции SQL  
  
```  
SELECT ProductID, ProductName, UnitPrice FROM Products WHERE CategoryID = 7  
```  
  
 Таким образом, вы должны увидеть, что **полям набора записей** коллекция содержит три поля.  
  
```  
'BeginWalkFields  
    Dim objFields As ADODB.Fields  
    Dim intLoop As Integer  
  
    objRs.Open strSQL, strConnStr, adOpenForwardOnly, adLockReadOnly, adCmdText  
  
    Set objFields = objRs.Fields  
  
    For intLoop = 0 To (objFields.Count - 1)  
        Debug.Print objFields.Item(intLoop).Name  
    Next  
'EndWalkFields  
```  
  
 Этот код определяет число **поле** объекты в **поля** коллекции с помощью **число** свойство и цикл по коллекции, возвращая значение **имя** для каждой **поле** объекта. Можно использовать многие другие **поле** свойства для получения сведений о поле. Дополнительные сведения о запросах к **поле**, см. в разделе [объект поля](../../../ado/guide/data/the-field-object.md).  
  
## <a name="counting-columns"></a>Подсчет столбцов  
 Как можно догадаться, **число** свойство возвращает фактическое количество **поле** объекты в **поля** коллекции. Поскольку нумерация для членов коллекции начинается с нуля, вам необходимо всегда кодировать циклы, начиная с нуля элемента и заканчивая значение **число** минус единица. Если вы используете Microsoft Visual Basic и хотите циклический перебор элементов коллекции без проверки **число** свойство, используйте **для каждого... Далее** команды.  
  
 Если **число** равно нулю, нет объектов в коллекции.  
  
## <a name="getting-to-the-field"></a>Приступая к полю  
 Как и в случае с любой коллекцией ADO **элемент** свойство является свойством по умолчанию в коллекцию. Он возвращает отдельные **поле** объекта, указанного по имени или индекс, переданный в него. Таким образом, следующие инструкции эквивалентны пример **записей**:  
  
```  
objField = objRecordset.Fields.Item("ProductID")  
objField = objRecordset.Fields("ProductID")  
objField = objRecordset.Fields.Item(0)  
objField = objRecordset.Fields(0)  
```  
  
 Если эти методы являются эквивалентными, который лучше? Смотря как. Использование индекса для получения **поле** из коллекции работает быстрее, так как он обращается к **поле** напрямую, без необходимости выполнять поиск строки. С другой стороны, порядок **поля** в коллекции должен быть известен, и если порядок изменения, ссылку на **поля** индекс будет содержать изменяемый везде, где оно происходит. Несмотря на то что немного медленнее, используя имя **поле** является более гибким, поскольку он не зависеть от приблизительно **поля** в коллекции.  
  
## <a name="using-the-refresh-method"></a>С помощью метода обновления  
 В отличие от некоторых других коллекции ADO, с помощью **обновить** метод **поля** коллекции не имеет видимого эффекта. Чтобы получить изменения из базовой структуры базы данных, необходимо использовать **Requery** метод, или если **записей** объект не поддерживает закладки, **MoveFirst**метод, который вызовет команду, чтобы быть выполняется поставщиком еще раз.  
  
## <a name="adding-fields-to-a-recordset"></a>Добавление поля в набор записей  
 **Append** метод используется для добавления полей к **записей**.  
  
 Можно использовать **Append** метод создания **записей** программным способом без соединения с источником данных. Ошибка времени выполнения возникает в том случае, если **Append** вызывается метод **поля** коллекции открытого **записей** или на **набор записей** где **ActiveConnection** свойства. Поля можно добавить только к **записей** , не открыт и еще не был подключен к источнику данных. Тем не менее чтобы указать значения для только что добавленных **поля**, **записей** необходимо открыть.  
  
 Разработчикам часто требуется место для временного хранения некоторых данных, или некоторые данные должны вести себя как если бы он поступил с сервера, чтобы его могли принимать участие в привязке данных в пользовательском интерфейсе. ADO (в сочетании с [служба курсора Майкрософт для OLE DB](../../../ado/guide/appendixes/microsoft-cursor-service-for-ole-db-ado-service-component.md)) позволяет разработчикам создавать пустой **записей** объекта, указав сведения о столбцах и вызова **откройте**. В следующем примере три новые поля добавляются в новую **записей** объекта. То **набор записей** открыт, две новые записи добавляются и **набор записей** сохраняется в файл. (Дополнительные сведения о **записей** сохраняемости, см. в разделе [обновление и сохранение данных](../../../ado/guide/data/updating-and-persisting-data.md).)  
  
```  
'BeginFabricate  
    Dim objRs As ADODB.Recordset  
    Set objRs = New ADODB.Recordset  
  
    With objRs.Fields  
        .Append "StudentID", adChar, 11, adFldUpdatable  
        .Append "FullName", adVarChar, 50, adFldUpdatable  
        .Append "PhoneNmbr", adVarChar, 20, adFldUpdatable  
    End With  
  
    With objRs  
        .Open  
  
        .AddNew  
        .Fields(0) = "123-45-6789"  
        .Fields(1) = "John Doe"  
        .Fields(2) = "(425) 555-5555"  
        .Update  
  
        .AddNew  
        .Fields(0) = "123-45-6780"  
        .Fields(1) = "Jane Doe"  
        .Fields(2) = "(615) 555-1212"  
        .Update  
    End With  
  
    objRs.Save App.Path & "FabriTest.adtg", adPersistADTG  
  
    objRs.Close  
'EndFabricate  
```  
  
 Использование **добавить поля** метод отличается от **записей** объекта и **записи** объекта. Дополнительные сведения о **записи** объекта, см. в разделе [записи и потоки](../../../ado/guide/data/records-and-streams.md).  
  
## <a name="see-also"></a>См. также  
 [Составление иерархических наборов записей](../../../ado/guide/data/fabricating-hierarchical-recordsets.md)
