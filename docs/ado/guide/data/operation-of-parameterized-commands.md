---
title: Параметризованных команд | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- data shaping [ADO], parameterized commands
- parameterized commands [ADO]
ms.assetid: 4fae0d54-83b6-4ead-99cc-bcf532daa121
author: MightyPen
ms.author: genemi
manager: jroth
ms.openlocfilehash: 4001ac5b449609683293cd3174dc4410cabf4c4b
ms.sourcegitcommit: 074d44994b6e84fe4552ad4843d2ce0882b92871
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2019
ms.locfileid: "66701864"
---
# <a name="operation-of-parameterized-commands"></a>Использование параметризованных команд
При работе с большой дочерним **набор записей**, особенно по сравнению с размер родительского **набор записей**, но требуется доступ только несколько дочерних главы, может оказаться эффективнее использовать параметризованные команды.  
  
 Объект *непараметризованную команду* извлекает всю родительский и дочерний **наборы записей**, добавляет столбец к родительскому элементу, а затем назначает ссылку на связанные дочерние главы, для каждой родительской строке .  
  
 Объект *параметризованные команды* извлекает всей родительской **записей**, но извлекает только глава **записей** при обращении к столбцу главе. Это различие в стратегии извлечения может дать значительные преимущества в производительности.  
  
 Например можно указать следующее:  
  
```  
SHAPE {SELECT * FROM customer}   
   APPEND ({SELECT * FROM orders WHERE cust_id = ?}   
   RELATE cust_id TO PARAMETER 0)  
```  
  
 Родительскую и дочернюю таблицы с именами столбцов в общие cust_id *.* *Дочерняя команда* имеет «?» заполнитель, на который ссылается в предложении RELATE (то есть «... ПАРАМЕТР, 0").  
  
> [!NOTE]
>  В предложении параметр относится исключительно к синтаксис команды фигуры. Она не связана с либо ADO [параметр](../../../ado/reference/ado-api/parameter-object.md) объекта или [параметры](../../../ado/reference/ado-api/parameters-collection-ado.md) коллекции.  
  
 При выполнении команды параметризованные фигуры, происходит следующее:  
  
1.  *Родительской команды* выполняется и возвращает родительский элемент **записей** из таблицы Customers.  
  
2.  Столбец добавляется к родительскому **записей**.  
  
3.  При обращении к главе столбец родительской строки, *дочерняя команда* выполняется с использованием значения customer.cust_id в качестве значения параметра.  
  
4.  Все строки в наборе строк поставщика данных, созданный на шаге 3 используются для заполнения дочерние **записей**. В этом примере это все строки в таблице Orders, в котором cust_id равен значению customer.cust_id. По умолчанию дочерние **записей**s будет кэшироваться на клиенте до все ссылки на родительский **записей** освобождаются. Чтобы изменить это поведение, установите **записей** [динамическое свойство](../../../ado/reference/ado-api/ado-dynamic-property-index.md) **дочерних строк кэша** для **False**.  
  
5.  Ссылку на полученный дочерние строки (то есть Глава дочерних **записей**) помещается в столбец текущей строки, родительского **записей**.  
  
6.  Шаги 3 – 5 повторяются, при обращении к столбцу Глава другой строки.  
  
 **Дочерних строк кэша** динамическое свойство имеет значение **True** по умолчанию. Поведение кэширования зависит от значения параметров запроса. В запросе с одним параметром, дочерние **записей** для данного параметра кэшированные значения сохраняются между запросами для ребенка с этим значением. Следующий код демонстрирует это:  
  
```  
SCmd = "SHAPE {select * from customer} " & _  
         "APPEND({select * from orders where cust_id = ?} " & _  
         "RELATE cust_id TO PARAMETER 0) AS chpCustOrder"  
Rst1.Open sCmd, Cnn1  
Set RstChild = Rst1("chpCustOrder").Value  
Rst1.MoveNext      ' Next cust_id passed to Param 0, & new rs fetched   
                   ' into RstChild.  
Rst1.MovePrevious  ' RstChild now holds cached rs, saving round trip.  
```  
  
 В запросе с двумя или несколькими параметрами кэшированные дочерние используется только в том случае, если все значения параметров соответствует кэшированных значений.  
  
## <a name="parameterized-commands-and-complex-parent-child-relations"></a>Параметризованные команды и сложных родительского дочерние отношения  
 Помимо использования параметризованных команд для повышения производительности иерархии типа эквивалентное соединение, параметризованные команды можно использовать для поддержки более сложные иерархические отношения. Например, рассмотрим небольшой лиги базу данных с двумя таблицами: один состоящий из групп (team_id, team_name), а другой игр (даты, home_team, visiting_team).  
  
 С помощью иерархии, которые содержат непараметризованные, нет способа чтобы связать эти таблицы команд и игры, в том виде, дочерние **записей** для каждой команды содержат ее полное расписание. Вы можете создать главы, которые содержат домашней расписание или расписание road, но не оба. Это обусловлено тем, в предложении RELATE ограничивается родительско дочерних отношений формы (pc1 = cc1) AND (pc2 = pc2). Таким образом Если команда включает «RELATE team_id TO home_team, team_id TO visiting_team», получится только игр где команды играл сам. Вам нужно "(team_id=home_team) или (team_id = visiting_team)», но поставщик Data Shape не поддерживает предложение OR.  
  
 Чтобы получить нужный результат, можно использовать параметризованную команду. Пример:  
  
```  
SHAPE {SELECT * FROM teams}   
APPEND ({SELECT * FROM games WHERE home_team = ? OR visiting_team = ?}   
        RELATE team_id TO PARAMETER 0,   
               team_id TO PARAMETER 1)   
```  
  
 В этом примере использует большую гибкость для получения необходимого результата предложения SQL WHERE.  
  
> [!NOTE]
>  Когда с помощью предложения WHERE, параметры можно не использовать типы данных SQL для text, ntext и image или возникнет ошибка, которая содержит следующее описание: `Invalid operator for data type`.  
  
## <a name="see-also"></a>См. также  
 [Пример формирования данных](../../../ado/guide/data/data-shaping-example.md)   
 [Грамматика формального формирования данных](../../../ado/guide/data/formal-shape-grammar.md)   
 [Общие сведения о командах формирования данных](../../../ado/guide/data/shape-commands-in-general.md)
