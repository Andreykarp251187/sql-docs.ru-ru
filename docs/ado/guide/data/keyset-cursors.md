---
title: Управляемые набором ключей курсоры | Документация Майкрософт
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.topic: conceptual
helpviewer_keywords:
- Keyset cursors [ADO]
- cursors [ADO], Keyset
ms.assetid: 14b51b17-6fd9-4146-af45-ca4b0fe6d48a
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: a2ff246d01254ceb2b526b5118553d72cc499046
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63161648"
---
# <a name="keyset-cursors"></a>Курсоры ключевого набора
Курсор набора ключей предоставляет функциональные возможности, между статический и динамический курсор в его способность обнаруживать изменения. Так же как статический курсор, он не всегда обнаруживает изменения, внесенные в членство и порядок элементов результирующего набора. Так же как динамический курсор, он обнаруживает изменения, внесенные в значения строк результирующего набора.  
  
 Такие курсоры управляются с помощью набора уникальных идентификаторов — ключей. Ключи создаются из набора столбцов, который уникально идентифицирует строки результирующего набора. Набор ключей — это набор ключевых значений всех строк, возвращаемых инструкцией запроса.  
  
 При использовании управляемых наборами ключей курсоров ключ создается для каждой строки курсора и сохраняется на клиентском компьютере или на сервере. При обращении к строке сохраненный ключ используется для получения текущих значений данных из источника данных. В курсоре, управляемом набором ключей, членство в результирующем наборе становится фиксированным, когда набор ключей полностью заполняется. Поэтому результаты операций добавления и обновления, влияющих на членство, не включаются в результирующий набор до повторного открытия.  
  
 Изменения значений данных (сделано либо владельцем keyset или другие процессы) отображаются, как пользователь прокручивает результирующего набора. Чтобы результаты вставки извне курсора (другими процессами) были видны, нужно закрыть курсор и открыть его заново. Результаты вставки внутри курсора видны в конце результирующего набора.  
  
 Когда курсор, управляемый набором ключей пытается извлечь строку, которая была удалена, строке отображается как «путь» в результирующем наборе. В наборе ключей ключ для этой строки есть, но самой строки в результирующем наборе больше нет. Если обновляются ключевых значений в строки, строка считается были удалены, а затем вставляется, поэтому такие строки также отображаются как пропуски в результирующем наборе. Хотя курсоры всегда может обнаружить строки, удаленные другим процессам, его можно удалить ключи для строк, которые он удаляет себя. Управляемые набором ключей курсоры, которые этого не может обнаружить свои собственные операции удаления, поскольку свидетельство был удален.  
  
 Обновление ключевого столбца действует аналогично удалению старого ключа, а затем вставки нового ключа. Новое значение ключа отображается не в том случае, если обновление не было выполнено через курсор. Если обновление было выполнено через курсор, новое значение ключа отображается в конце результирующего набора.  
  
 Нет вариантов на курсоры, вызывается стандартный курсоры. В стандартных курсоры фиксированных во время открытия курсора, но изменения, сделанные владельцем курсора членство строк в результирующем наборе и порядок строк и отображаются зафиксированные изменения, внесенные другими процессами. Если изменение disqualifies строку для членства или влияет на порядок строки, строки не исчезают или перемещая закрытии и повторном открытии курсора. Вставляемые данные не отображаются, но изменения к существующим данным отображаются как строки не будут выбраны.  
  
 Курсоры сложно использовать правильно, так как чувствительность к изменениям данных зависит от многих различных случаях, как описано выше. Тем не менее если приложения не занимается одновременных обновлений, можно программным образом обрабатывать bad ключи и должен напрямую обращаться к определенные строки с ключом, курсоры может решить проблему. Используйте **adOpenKeyset CursorTypeEnum** для указания, что вы хотите использовать курсоры в ADO.  
  
## <a name="see-also"></a>См. также  
 [Однопроходные курсоры](../../../ado/guide/data/forward-only-cursors.md)   
 [Статические курсоры](../../../ado/guide/data/static-cursors.md)   
 [Динамические курсоры](../../../ado/guide/data/dynamic-cursors.md)
