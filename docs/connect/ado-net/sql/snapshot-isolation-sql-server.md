---
title: Изоляция моментальных снимков в SQL Server
description: Описание поддержки изоляции моментального снимка, механизма управления версиями строк, предназначенного для сокращения блокировок в транзакционных приложениях.
ms.date: 08/15/2019
dev_langs:
- csharp
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.topic: conceptual
author: v-kaywon
ms.author: v-kaywon
ms.reviewer: rothja
ms.openlocfilehash: 8ef462246d35694ba9bf38954ca8c58635e44e7f
ms.sourcegitcommit: 9c993112842dfffe7176decd79a885dbb192a927
ms.translationtype: MTE75
ms.contentlocale: ru-RU
ms.lasthandoff: 10/16/2019
ms.locfileid: "72452088"
---
# <a name="snapshot-isolation-in-sql-server"></a>Изоляция моментальных снимков в SQL Server

![Download-DownArrow-Circled](../../../ssdt/media/download.png)[Скачать ADO.NET](../../sql-connection-libraries.md#anchor-20-drivers-relational-access)

Изоляция моментальных снимков улучшает параллелизм для приложений OLTP.  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a>Основные сведения об изоляции моментальных снимков и управлении версиями строк  
После включения изоляции моментального снимка обновленные версии строк для каждой транзакции содержатся в **tempdb**. Уникальный последовательный номер транзакции идентифицирует каждую транзакцию, и эти уникальные числа записываются для каждой версии строки. Транзакция работает с последними версиями строк, имеющими порядковый номер до порядкового номера транзакции. Более новые версии строк, созданные после начала транзакции, игнорируются транзакцией.  
  
Термин "моментальный снимок" отражает тот факт, что все запросы в транзакции имеют одну и ту же версию или моментальный снимок базы данных, исходя из состояния базы данных в момент начала транзакции. Ни одна блокировка не запрашивается на базовых строках данных или страницах данных в транзакции моментального снимка, что позволяет выполнять другие транзакции без блокировки предыдущей незавершенной транзакцией. Транзакции, изменяющие данные, не блокируют транзакции, считывающие данные, а транзакции, считывающие данные, не блокируют транзакции, которые записывают данные, так как обычно они находятся на уровне изоляции READ COMMITTED по умолчанию в SQL Server. Такое неблокирующее поведение также значительно снижает вероятность взаимоблокировок в сложных транзакциях.  
  
Изоляция моментальных снимков использует модель оптимистичного параллелизма. Если транзакция моментального снимка пытается зафиксировать изменения в данных, которые изменились с момента начала транзакции, произойдет откат транзакции и возникнет ошибка. Это можно избежать, используя указания UPDLOCK для инструкций SELECT, обращающихся к изменяемым данным. Дополнительные сведения см. в разделе "подсказки блокировки" в электронная документация на SQL Server.  
  
Изоляция моментальных снимков должна быть включена путем установки параметра ALLOW_SNAPSHOT_ISOLATION ON DATABASE перед его использованием в транзакциях. Это приводит к активизации механизма сохранения версий строк во временной базе данных (**tempdb**). Необходимо включить изоляцию моментальных снимков в каждой базе данных, которая использует ее с инструкцией Transact-SQL ALTER DATABASE. В этом отношении изоляция моментального снимка отличается от традиционных уровней изоляции READ COMMITTED, REPEATABLE READ, SERIALIZABLE и READ UNCOMMITTED, что не требует настройки. Следующие инструкции активируют изоляцию моментального снимка и заменяют зафиксированное поведение чтения по умолчанию МОМЕНТАЛЬным СНИМКом:  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
Установка параметра READ_COMMITTED_SNAPSHOT ON разрешает доступ к строкам с контролем версий на уровне изоляции READ COMMITTED. Если параметр READ_COMMITTED_SNAPSHOT имеет значение OFF, необходимо явно задать уровень изоляции моментального снимка для каждого сеанса, чтобы получить доступ к строкам с версиями.  
  
## <a name="managing-concurrency-with-isolation-levels"></a>Управление параллелизмом с помощью уровней изоляции  
Уровень изоляции, при котором выполняется инструкция Transact-SQL, определяет поведение блокировки и управления версиями строк. Уровень изоляции имеет область подключения и устанавливается для соединения с инструкцией SET TRANSACTION изоляция LEVEL, пока соединение не закрывается или не задается другой уровень изоляции. Когда соединение закрывается и возвращается в пул, сохраняется уровень изоляции из последней инструкции SET TRANSACTION изоляция уровня. Последующие соединения, использующие соединение в составе пула, используют уровень изоляции, который действовал во время объединения подключения в пул.  
  
Отдельные запросы, выдаваемые в соединении, могут содержать подсказки блокировки, которые изменяют изоляцию для отдельной инструкции или транзакции, но не влияют на уровень изоляции соединения. Уровни изоляции или указания блокировки, заданные в хранимых процедурах или функциях, не изменяют уровень изоляции соединения, вызывающего их, и действуют только на время выполнения хранимой процедуры или вызова функции.  
  
В ранних версиях SQL Server поддерживались четыре уровня изоляции, определенные в стандарте SQL-92:  
  
- READ UNCOMMITTED — это наименее узкий уровень изоляции, так как он игнорирует блокировки, размещенные другими транзакциями. Транзакции, выполняемые в режиме READ UNCOMMITTED, могут считывать измененные значения данных, которые еще не были зафиксированы другими транзакциями. они называются «грязными» операциями чтения.  
  
- READ COMMITTED является уровнем изоляции по умолчанию для SQL Server. Он предотвращает чтение «грязных» данных, указывая, что инструкции не могут считывать значения, которые были изменены, но еще не зафиксированы другими транзакциями. Другие транзакции по-прежнему могут изменять, вставлять или удалять данные между выполнениями отдельных инструкций в текущей транзакции, что приводит к неповторяемым операциям чтения или "фантомным" данным.  
  
- ПОВТОРЯЕМое чтение имеет более четкий уровень изоляции, чем зафиксированный READ. Он охватывает зафиксированный READ и дополнительно указывает, что никакие другие транзакции не могут изменять или удалять данные, считанные текущей транзакцией, до тех пор, пока текущая транзакция не зафиксирована. Уровень параллелизма ниже, чем для зафиксированного чтения, так как общие блокировки на чтение данных удерживаются в течение транзакции, а не освобождаются в конце каждой инструкции.  
  
- SERIALIZABLE — самый строгий уровень изоляции, поскольку он блокирует целые диапазоны ключей и сохраняет блокировку до завершения транзакции. Он охватывает ПОВТОРЯЕМые операции чтения и добавляет ограничение, которое другие транзакции не могут вставлять новые строки в диапазоны, считанные транзакцией до завершения транзакции.  
  
Дополнительные сведения: [Руководство по блокировке и управлению версиями строк транзакций](../../../relational-databases/sql-server-transaction-locking-and-row-versioning-guide.md).  
  
### <a name="snapshot-isolation-level-extensions"></a>Расширения уровня изоляции моментальных снимков  
SQL Server предоставляет расширения уровней изоляции стандарта SQL-92 путем представления уровня изоляции SNAPSHOT и дополнительных изменений в READ COMMITTED. Уровень изоляции READ_COMMITTED_SNAPSHOT может прозрачно заменять READ COMMITTED для всех транзакций.  
  
- Изоляция МОМЕНТАЛЬных снимков указывает, что данные, считываемые в рамках транзакции, никогда не будут отражать изменения, внесенные другими одновременными транзакциями. Транзакция использует версии строк данных, которые существуют при начале транзакции. При чтении данные не размещаются, поэтому транзакции МОМЕНТАЛЬных снимков не блокируют другие транзакции от записи данных. Транзакции, осуществляющие запись данных, не блокируют считывание данных транзакциями моментальных снимков. Необходимо включить изоляцию моментального снимка, задав параметр базы данных ALLOW_SNAPSHOT_ISOLATION, чтобы использовать его.  
  
- Параметр базы данных READ_COMMITTED_SNAPSHOT определяет поведение уровня изоляции READ COMMITTED по умолчанию, если изоляция моментальных снимков включена в базе данных. Если параметр READ_COMMITTED_SNAPSHOT не задан явным образом, для всех неявных транзакций применяется ФИКСИРОВАНное чтение. При этом происходит то же поведение, что и установка параметра READ_COMMITTED_SNAPSHOT OFF (значение по умолчанию). Если действует параметр READ_COMMITTED_SNAPSHOT OFF, ядро СУБД использует общие блокировки для применения уровня изоляции по умолчанию. Если параметру базы данных READ_COMMITTED_SNAPSHOT присвоить значение ON, то ядро СУБД использует управление версиями строк и изоляцию моментальных снимков по умолчанию вместо блокировок для защиты данных.  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a>Как работает изоляция моментальных снимков и управление версиями строк  
Если включен уровень изоляции SNAPSHOT, то при обновлении каждой строки компонент SQL Server Database Engine сохраняет копию исходной строки в базе данных **tempdb** и добавляет в строку порядковый номер транзакции. Ниже приведена последовательность событий, которые происходят в следующих случаях.  
  
1. Инициируется новая транзакция, ей назначается порядковый номер транзакции.  
  
2. Компонент Database Engine считывает строку внутри транзакции и получает версию строки из базы данных **tempdb**, чей порядковый номер наиболее близок и ниже порядкового номера транзакции.  
  
3. Ядро СУБД проверяет, не находится ли порядковый номер транзакции в списке последовательных незафиксированных транзакций, активных при запуске транзакции моментальных снимков.  
  
4. Транзакция считывает версию строки, которая была текущей во время запуска транзакции, из базы данных **tempdb**. Новые строки, вставленные после запуска транзакции, не будут видны, поскольку эти значения порядкового номера будут выше, чем значение порядкового номера транзакции.  
  
5. Текущая транзакция обнаруживает строки, которые были удалены после ее запуска, поскольку версия любой строки в базе данных **tempdb** имеет меньшее значение порядкового номера, чем транзакция.  
  
Общий результат изоляции моментального снимка заключается в том, что транзакция видит все данные в том виде, в котором они существовали в начале транзакции, без учета или размещения каких-либо блокировок в базовых таблицах. Это может привести к улучшению производительности в ситуациях, когда возникает состязание.  
  
Транзакция моментального снимка всегда использует управление оптимистичным параллелизмом, подоходя всех блокировок, которые препятствуют обновлению строк другими транзакциями. Если транзакция моментального снимка пытается зафиксировать обновление строки, которая была изменена после начала транзакции, то выполняется откат транзакции, и возникает ошибка.  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a>Работа с изоляцией моментальных снимков в ADO.NET  
Изоляция моментальных снимков поддерживается в ADO.NET классом <xref:Microsoft.Data.SqlClient.SqlTransaction>. Если в базе данных включена изоляция моментального снимка, но настройка конфигурации не выполнена с учетом параметра READ_COMMITTED_SNAPSHOT со значением ON, то необходимо инициировать транзакцию <xref:Microsoft.Data.SqlClient.SqlTransaction> с помощью значения перечисления **IsolationLevel.Snapshot** при вызове метода <xref:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction%2A>. В этом фрагменте кода предполагается, что Connection является открытым <xref:Microsoft.Data.SqlClient.SqlConnection> объектом.  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a>Пример  
В следующем примере демонстрируется поведение различных уровней изоляции путем попытки доступа к заблокированным данным и не предназначено для использования в рабочем коде.  
  
В коде устанавливается соединение с образцом базы данных **AdventureWorks** в SQL Server, создается таблица с именем **TestSnapshot** и производится вставка одной строки данных. В коде используется инструкция Transact-SQL ALTER DATABASE для включения изоляции моментального снимка для базы данных, однако параметр READ_COMMITTED_SNAPSHOT не задается, при этом действует зафиксированное поведение при уровне изоляции READ. Затем код выполняет следующие действия:  
  
1. Он начинается, но не завершается, sqlTransaction1, который использует уровень изоляции SERIALIZABLE для запуска транзакции обновления. Это влияет на блокировку таблицы.  
  
2. В коде открывается второе соединение и инициируется вторая транзакция с использованием уровня изоляции SNAPSHOT для чтения данных из таблицы **TestSnapshot**. Так как изоляция моментальных снимков включена, эта транзакция может считывать данные, существовавшие до начала sqlTransaction1.  
  
3. Он открывает третье соединение и инициирует транзакцию, используя уровень изоляции READ COMMITTED, чтобы попытаться прочитать данные в таблице. В этом случае в коде исключается возможность считывать данные, поскольку чтение не может быть выполнено после установки блокировок на таблице в первой транзакции, поэтому код завершает свою работу в связи с истечением времени ожидания. Аналогичный результат был бы получен при использовании уровней изоляции REPEATABLE READ и SERIALIZABLE, поскольку эти уровни изоляции также не позволяют выполнять чтение после установки блокировок в первой транзакции.  
  
4. Он открывает четвертое соединение и инициирует транзакцию, используя уровень изоляции READ UNCOMMITTED, который выполняет «грязное» чтение незафиксированного значения в sqlTransaction1. Это значение не может фактически существовать в базе данных, если первая транзакция не фиксируется.  
  
5. В нем выполняется откат первой транзакции и производится чистка путем удаления таблицы **TestSnapshot** и выключения изоляции моментального снимка в базе данных **AdventureWorks**.  
  
> [!NOTE]
>  В следующих примерах используется та же строка подключения, в которой отключено использование пулов соединений. Если соединение входит в пул, сброс его уровня изоляции не приводит к сброшению уровня изоляции на сервере. В результате последующие соединения, использующие одно и то же внутреннее соединение в составе пула, начинаются с уровней изоляции, заданных для соединения в составе пула. Альтернативой отключению пулов соединений является установка уровня изоляции явным образом для каждого соединения.  
  
[!code-csharp[DataWorks Isolation_Snapshot.Demo#1](~/../sqlclient/doc/samples/Isolation_Snapshot.cs#1)]
  
### <a name="example"></a>Пример  
В следующем примере демонстрируется поведение изоляции моментального снимка при изменении данных. Код выполняет следующие действия.  
  
1. Соединяется с образцом базы данных **AdventureWorks** и включает уровень изоляции SNAPSHOT.  
  
2. Создает таблицу с именем **TestSnapshotUpdate** и вставляет три строки из образца данных.  
  
3. Начинается, но не завершается, sqlTransaction1 с использованием изоляции МОМЕНТАЛЬного СНИМКа. В транзакции выбираются три строки данных.  
  
4. Открывает второе соединение **SqlConnection** с базой данных **AdventureWorks** и создает вторую транзакцию, используя уровень изоляции READ COMMITTED, который обновляет значение в одной из строк, выбранных в sqlTransaction1.  
  
5. Фиксирует sqlTransaction2.  
  
6. Возвращает в sqlTransaction1 и пытается обновить ту же строку, которая уже зафиксирована sqlTransaction1. Возникает ошибка 3960, и sqlTransaction1 выполняет автоматический откат. Сообщения **SqlException.Number** и **SqlException.Message** отображаются в окне консоли.  
  
7. Выполняет код очистки для выключения изоляции моментального снимка в **AdventureWorks** и удаления таблицы **TestSnapshotUpdate**.  
  
    [!code-csharp[DataWorks Isolation_Snapshot1#1](~/../sqlclient/doc/samples/Isolation_Snapshot1.cs#1)]
  
### <a name="using-lock-hints-with-snapshot-isolation"></a>Использование подсказок блокировки с изоляцией моментальных снимков  
В предыдущем примере первая транзакция выбирает данные, а вторая транзакция обновляет данные до того, как первая транзакция сможет завершиться, что приведет к конфликту обновления, когда первая транзакция пытается обновить одну и ту же строку. Можно уменьшить вероятность конфликтов обновления в длительных транзакциях моментальных снимков, указав подсказки блокировки в начале транзакции. Следующая инструкция SELECT использует указание UPDLOCK для блокировки выбранных строк:  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
Использование подсказки блокировки UPDLOCK блокирует любые строки, пытающиеся обновить строки до завершения первой транзакции. Это гарантирует, что выбранные строки не будут иметь конфликтов, когда они будут обновлены позже в транзакции. См. раздел "подсказки блокировки" в электронная документация на SQL Server.  
  
Если в приложении много конфликтов, изоляция моментальных снимков может быть не лучшим выбором. Указания следует использовать, только если действительно требуется. Приложение не должно быть спроектировано таким образом, чтобы оно постоянно полагается на подсказки блокировки для своей работы.  
  
## <a name="next-steps"></a>Следующие шаги
- [SQL Server и ADO.NET](index.md)
- [Руководство по блокировке и управлению версиями строк транзакций](../../../relational-databases/sql-server-transaction-locking-and-row-versioning-guide.md)
