---
title: Группы вычислений в Analysis Services табличных моделях | Документация Майкрософт
ms.date: 07/24/2019
ms.prod: sql
ms.technology: analysis-services
ms.custom: tabular-models
ms.topic: conceptual
ms.author: owend
ms.reviewer: owend
author: minewiskan
manager: kfile
monikerRange: '>=sql-server-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: af63f41555a021fc720c7d1e15778265fe7de500
ms.sourcegitcommit: 1f222ef903e6aa0bd1b14d3df031eb04ce775154
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68419526"
---
# <a name="calculation-groups-preview"></a>Группы вычислений (Предварительная версия)
 
[!INCLUDE[ssas-appliesto-sql2019-aas](../../includes/ssas-appliesto-sql2019-aas.md)]

Группы вычислений могут значительно сократить количество избыточных мер, группируя общие выражения мер как *элементы вычисления*. Группы вычислений поддерживаются в табличных моделях Azure Analysis Services и SQL Server Analysis Services 2019 с [уровнем совместимости](compatibility-level-for-tabular-models-in-analysis-services.md)1470 и выше. Модели на уровне совместимости 1470 сейчас доступны в **предварительной версии**.  

В этой статье рассматриваются следующие вопросы: 

> [!div class="checklist"]
> * Преимущества 
> * Принцип работы групп вычислений
> * Строки динамического формата
> * Упорядочение
> * Приоритет
> * Инструменты
> * Ограничения



## <a name="benefits"></a>Преимущества

Группы вычислений устраняют проблемы в сложных моделях, где могут быть распространены избыточные меры с помощью одних и тех же вычислений, наиболее распространенных с вычислениями логики операций со временем. Например, аналитику продаж требуется просмотреть итоги продаж и заказы по месяцам (MTD), квартальные данные (текущему КВАРТАЛУ), "с начала года" (YTD), заказы с начала года для предыдущего года (КОРРЕКТИРОВКа) и т. д. Средство моделирования данных должно создавать отдельные меры для каждого вычисления, что может привести к десяткам мер. Для пользователя это может означать, что нужно отсортировать столько мер и применить их к отчету по отдельности. 

Сначала рассмотрим, как группы вычисления отображаются пользователям в средстве создания отчетов, например Power BI. Затем мы рассмотрим то, что образует группа вычислений и как они создаются в модели.

Группы вычисления отображаются в клиентских отчетах как таблица с одним столбцом. Столбец не похож на обычный столбец или измерение, вместо этого он представляет один или несколько многократно используемых вычислений или *элементы вычисления* , которые можно применить к любой мере, уже добавленному в фильтр значений для визуализации.

В следующей анимации пользователь анализирует данные о продажах за годы 2012 и 2013. Прежде чем приступать к применению группы вычислений, Общая базовая мера **продаж** вычисляет сумму итоговых продаж за каждый месяц. Затем пользователь хочет применить вычисления логики операций со временем, чтобы получить итоги продаж за месяц до даты, с начала квартала, с начала года и т. д. Без групп вычислений пользователь должен будет выбрать отдельные меры логики операций со временем.

С помощью группы вычислений в этом примере логики операций со **временем**, когда пользователь перетаскивает элемент **вычисления времени** в область фильтра **столбцов** , каждый элемент вычисления отображается как отдельный столбец. Значения для каждой строки вычисляются на основе базовой меры **Sales**.  

![Применяемая группа вычислений в Power BI](media/calculation-groups/calc-groups-pbi.gif)


Группы вычислений работают с **явными** мерами DAX. В этом примере **Sales** — это явная мера, уже созданная в модели. Группы вычислений не работают с неявными мерами DAX. Например, в Power BI неявные меры создаются, когда пользователь перетаскивает столбцы на визуальные элементы для просмотра статистических значений без создания явной меры. В настоящее время Power BI создает DAX для неявных мер, написанных как встроенные вычисления DAX. Это означает, что неявные меры не могут работать с группами вычислений. Было введено новое свойство модели, видимое в модели табличных объектов (TOM), **дискауражеимплиЦитмеасурес**. В настоящее время для создания групп вычислений этому свойству должно быть присвоено значение **true**. Если задано значение true, Power BI Desktop в режиме динамического подключения отключает создание неявных мер.

## <a name="how-they-work"></a>Принцип работы

Теперь, когда вы узнали, как пользователи получают доступ к группам вычислений, давайте посмотрим, как создается пример группы вычисления логики операций со временем.

Прежде чем приступать к деталям, давайте рассмотрим некоторые новые функции DAX, специально предназначенные для групп вычислений: 

[SELECTEDMEASURE](https://docs.microsoft.com/dax/selectedmeasure-function-dax) — используется выражениями для элементов вычисления для ссылки на меру, которая в настоящее время находится в контексте. В этом примере это мера Sales.

[SELECTEDMEASURENAME](https://docs.microsoft.com/dax/selectedmeasurename-function-dax) — используется выражениями для элементов вычисления, чтобы определить меру, которая находится в контексте по имени.

[ISSELECTEDMEASURE](https://docs.microsoft.com/dax/isselectedmeasure-function-dax) — используется выражениями для элементов вычисления, чтобы определить, какая мера в контексте указана в списке мер.

[Селектедмеасуреформатстринг](https://docs.microsoft.com/dax/selectedmeasureformatstring-function-dax) — используется выражениями для элементов вычисления для получения строки формата меры, которая находится в контексте.

### <a name="time-intelligence-example"></a>Пример логики операций со временем

Имя таблицы — логика операций со **временем**   
Имя столбца — **Вычисление времени**   
Приоритет — **20**   

#### <a name="time-intelligence-calculation-items"></a>Элементы вычисления логики операций со временем

**Current**

```dax
SELECTEDMEASURE()
```

**MTD**

```dax
CALCULATE(SELECTEDMEASURE(), DATESMTD(DimDate[Date]))
```

**ТЕКУЩЕМУ КВАРТАЛУ**

```dax
CALCULATE(SELECTEDMEASURE(), DATESQTD(DimDate[Date]))
```

**НАЧАЛА**

```dax
CALCULATE(SELECTEDMEASURE(), DATESYTD(DimDate[Date]))
```

**КОРРЕКТИРОВК**

```dax
CALCULATE(SELECTEDMEASURE(), SAMEPERIODLASTYEAR(DimDate[Date]))
```

**КОПИРОВАТЬ MTD**

```dax
CALCULATE(
    SELECTEDMEASURE(),
    SAMEPERIODLASTYEAR(DimDate[Date]),
    'Time Intelligence'[Time Calculation] = "MTD"
)
```

**КОПИРОВАТЬ ТЕКУЩЕМУ КВАРТАЛУ**

```dax
CALCULATE(
    SELECTEDMEASURE(),
    SAMEPERIODLASTYEAR(DimDate[Date]),
    'Time Intelligence'[Time Calculation] = "QTD"
)
```

**КОРРЕКТИРОВКА С НАЧАЛА ГОДА**

```dax
CALCULATE(
    SELECTEDMEASURE(),
    SAMEPERIODLASTYEAR(DimDate[Date]),
    'Time Intelligence'[Time Calculation] = "YTD"
)
```

**YOY**

```dax
SELECTEDMEASURE() –
CALCULATE(
    SELECTEDMEASURE(),
    'Time Intelligence'[Time Calculation] = "PY"
)
```

**YOY**

```dax
DIVIDE(
    CALCULATE(
        SELECTEDMEASURE(),
        'Time Intelligence'[Time Calculation]="YOY"
    ),
    CALCULATE(
        SELECTEDMEASURE(),
        'Time Intelligence'[Time Calculation]="PY"
    ),
)
```

Чтобы протестировать эту группу вычислений, можно выполнить запрос DAX в SSMS или в среде [DAX](http://daxstudio.org/)с открытым исходным кодом. В этом примере запроса опущены YOY и YOY%.

#### <a name="time-intelligence-query"></a>Запрос логики операций со временем

```dax
EVALUATE
CALCULATETABLE (
    SUMMARIZECOLUMNS (
        DimDate[CalendarYear],
        DimDate[EnglishMonthName],
        "Current", CALCULATE ( [Sales], 'Time Intelligence'[Time Calculation] = "Current" ),
        "QTD",     CALCULATE ( [Sales], 'Time Intelligence'[Time Calculation] = "QTD" ),
        "YTD",     CALCULATE ( [Sales], 'Time Intelligence'[Time Calculation] = "YTD" ),
        "PY",      CALCULATE ( [Sales], 'Time Intelligence'[Time Calculation] = "PY" ),
        "PY QTD",  CALCULATE ( [Sales], 'Time Intelligence'[Time Calculation] = "PY QTD" ),
        "PY YTD",  CALCULATE ( [Sales], 'Time Intelligence'[Time Calculation] = "PY YTD" )
    ),
    DimDate[CalendarYear] IN { 2012, 2013 }
)
```

#### <a name="time-intelligence-query-return"></a>Возврат запроса логики операций со временем

В таблице возврата показаны вычисления для каждого примененного элемента вычисления. Например, можно увидеть, что текущему КВАРТАЛУ за Март 2012 — сумма за Январь, Февраль и март 2012.

![Возврат запроса](media/calculation-groups/calc-groups-query-return.png)


## <a name="dynamic-format-strings"></a>Строки динамического формата

*Строки динамического формата* с группами вычислений позволяют условным приложениям строк формата относиться к мерам без принудительного возврата строк.

Табличные модели поддерживают динамическое форматирование мер с помощью функции [формата](https://docs.microsoft.com/dax/format-function-dax) DAX. Однако функция FORMAT имеет недостаток возможного возврата строки, что приводит к возврату мер, которые в противном случае были бы числовыми, а также возвращены в виде строки. Это может иметь некоторые ограничения, например не работать с большинством Power BI визуальных элементов в зависимости от числовых значений, таких как диаграммы.

### <a name="dynamic-format-strings-for-time-intelligence"></a>Строки динамического формата для логики операций со временем

Если взглянуть на приведенный выше пример логики операций со временем, все элементы вычисления, кроме **YoY%** , должны использовать формат текущей меры в контексте. Например, значение **YTD** , вычисленное в базе мер Sales, должно быть Currency. Если это была группа вычислений для чего-то вроде базовой меры Orders, то формат будет числовым. **YoY%** , однако, должен быть в процентах, независимо от формата базовой меры.

Для **YoY%** можно переопределить строку формата, задав для свойства "строковое выражение формата" значение **0,00%;-0,00%; 0,00%** . Дополнительные сведения о свойствах строкового выражения форматирования см. в разделе [Свойства ячейки многомерных выражений — содержимое строки формата](../multidimensional-models/mdx/mdx-cell-properties-format-string-contents.md#numeric-values).

В этом визуальном элементе матрицы в Power BI отображаются текущие строки формата базовых мер **продаж Current/YoY** и **Orders Current/YoY** . Однако **YoY продаж%** и **Orders YoY%** , тем не менее, переопределяет строку формата для использования формата в *процентах* .

![Логика операций со временем в визуальном элементе матрица](media/calculation-groups/calc-groups-dynamicstring-timeintel.png)

### <a name="dynamic-format-strings-for-currency-conversion"></a>Строки динамического формата для конвертации валюты

Строки динамического формата обеспечивают простое преобразование валюты. Рассмотрим следующую модель данных Adventure Works. Он моделирует преобразование валют « *один ко многим»* в соответствии с определением [типов преобразования](../currency-conversions-analysis-services.md#conversion-types).

![Валютная ставка в табличной модели](media/calculation-groups/calc-groups-currency-conversion.png)

Столбец **FormatString** добавляется в таблицу **DimCurrency** и заполняется строками формата для соответствующих валют.

![Формат строкового столбца](media/calculation-groups/calc-groups-formatstringcolumn.png)

В этом примере следующая группа вычислений определяется следующим образом:

### <a name="currency-conversion-example"></a>Пример конвертации валюты

Имя таблицы — **конвертация валюты**   
Имя столбца — **Вычисление преобразования**   
Приоритет — **5**   

#### <a name="calculation-items-for-currency-conversion"></a>Элементы вычисления для конвертации валют

**Без преобразования**

```dax
SELECTEDMEASURE()
```

**Конвертация валюты**

```dax
IF(
    //Check one currency in context & not US Dollar, which is the pivot currency:
    SELECTEDVALUE( DimCurrency[CurrencyName], "US Dollar" ) = "US Dollar",
    SELECTEDMEASURE(),
    SUMX(
        VALUES(DimDate[Date]),
        CALCULATE( DIVIDE( SELECTEDMEASURE(), MAX(FactCurrencyRate[EndOfDayRate]) ) )
    )
)
```

Строковое выражение формата

```dax
SELECTEDVALUE(
    DimCurrency[FormatString],
    SELECTEDMEASUREFORMATSTRING()
)
```
Строковое выражение формата должно возвращать скалярную строку. Она использует новую функцию [селектедмеасуреформатстринг](https://docs.microsoft.com/dax/selectedmeasureformatstring-function-dax) для возврата к строке формата базовой меры, если в контексте фильтра имеется несколько валют.

Следующая анимация показывает преобразование валюты **Sales** в отчете в динамическом формате.

![Примененная строка динамического формата конвертации валют](media/calculation-groups/calc-groups-dynamic-format-string.gif)

## <a name="precedence"></a>Приоритет

Приоритет — это свойство, определенное для группы вычислений. Он задает порядок вычисления при наличии нескольких групп вычислений. Большее число указывает более высокий приоритет, то есть оно будет оцениваться перед группами вычислений с более низким приоритетом.

В этом примере мы будем использовать ту же модель, что и приведенный выше пример логики операций со временем, но также добавили группу вычисления **средних** значений. Группа вычисления средних значений содержит средние вычисления, которые не зависят от традиционной логики операций со временем, так как они не изменяют контекст фильтра дат — они просто применяют средние вычисления внутри него.

В этом примере определяется ежедневное среднее вычисление. Такие вычисления, как среднее число газов в день, обычно используются в приложениях для нефтегазовой и газовой работы. Другие распространенные бизнес-примеры включают в себя средний объем продаж магазина в розницу.

Хотя такие вычисления рассчитываются независимо от вычислений логики операций со временем, их сочетание может быть обязательным. Например, пользователю может потребоваться просмотреть объемы водорасходы в день с начала года, чтобы просмотреть дневную ставку по объему от начала до текущей даты. В этом сценарии Приоритет должен быть установлен для элементов вычисления.

### <a name="averages-example"></a>Пример средних значений

Имя таблицы является **средним значением**.   
Имя столбца представляет собой **Среднее вычисление**.   
Приоритет равен **10**.   

#### <a name="calculation-items-for-averages"></a>Элементы вычисления для средних значений

**Без среднего**

```dax
SELECTEDMEASURE()
```

**Среднее ежедневно**

```dax
DIVIDE(SELECTEDMEASURE(), COUNTROWS(DimDate))
```

Ниже приведен пример запроса DAX и таблицы возврата:

#### <a name="averages-query"></a>Запрос средних значений

```dax
EVALUATE
    CALCULATETABLE (
        SUMMARIZECOLUMNS (
        DimDate[CalendarYear],
        DimDate[EnglishMonthName],
        "Sales", CALCULATE (
            [Sales],
            'Time Intelligence'[Time Calculation] = "Current",
            'Averages'[Average Calculation] = "No Average"
        ),
        "YTD", CALCULATE (
            [Sales],
            'Time Intelligence'[Time Calculation] = "YTD",
            'Averages'[Average Calculation] = "No Average"
        ),
        "Daily Average", CALCULATE (
            [Sales],
            'Time Intelligence'[Time Calculation] = "Current",
            'Averages'[Average Calculation] = "Daily Average"
        ),
        "YTD Daily Average", CALCULATE (
            [Sales],
            'Time Intelligence'[Time Calculation] = "YTD",
            'Averages'[Average Calculation] = "Daily Average"
        )
    ),
    DimDate[CalendarYear] = 2012
)
```

#### <a name="averages-query-return"></a>Среднее значение возвращаемого запроса

![Возврат запроса](media/calculation-groups/calc-groups-ytd-daily-avg.png)

В следующей таблице показано, как вычисляются значения 2012 марта.


|Имя столбца  |Вид вычисления |
|---------|---------|
|YTD     |    Сумма продаж за Январь, фев, Мар 2012<br />= 495 364 + 506 994 + 373 483     |
|Среднее ежедневно    |     Продажи за Мар 2012, разделенные на число дней в марте<br />= 373 483/31       |
|Среднее ежедневное YTD     | С начала марта 2012 на число дней в январе, фев и Mar<br />= 1 375 841/(31 + 29 + 31)       |

Ниже приведено определение элемента вычисления YTD, применяемого с приоритетом **20**.

```dax
CALCULATE(SELECTEDMEASURE(), DATESYTD(DimDate[Date]))
```

Ниже приведено ежедневное среднее значение, применяемое с приоритетом **10**.

```dax
DIVIDE(SELECTEDMEASURE(), COUNTROWS(DimDate))
```

Так как приоритет группы вычислений логики операций со временем выше, чем у группы расчета средних значений, она применяется как можно более широко. Среднее время ежедневного вычисления с начала года применяется к числителю и знаменателю (число дней) среднего арифметического вычисления.

Это эквивалентно следующему выражению:

```dax
CALCULATE(DIVIDE(SELECTEDMEASURE(), COUNTROWS(DimDate)), DATESYTD(DimDate[Date]))
```

Не это выражение:

```dax
DIVIDE(CALCULATE(SELECTEDMEASURE(), DATESYTD(DimDate[Date])), COUNTROWS(DimDate)))
```

## <a name="sideways-recursion"></a>Рекурсия в сторону

В приведенном выше примере логики операций со временем некоторые элементы вычислений ссылаются на других в той же группе вычислений. Это называется бесбоковой рекурсией. Например, **YoY%** ссылается как на **YoY** , так и в параметре **корректировки**.

```dax
DIVIDE(
    CALCULATE(
        SELECTEDMEASURE(),
        'Time Intelligence'[Time Calculation]="YOY"
    ),
    CALCULATE(
        SELECTEDMEASURE(),
        'Time Intelligence'[Time Calculation]="PY"
    ),
)
```

В этом случае оба выражения вычисляются отдельно, так как они используют разные операторы Calculate. Другие типы рекурсии не поддерживаются.

## <a name="single-calculation-item-in-filter-context"></a>Элемент с одним вычислением в контексте фильтра

В нашем примере логики операций со временем для элемента вычисления с **начала года** имеется одно выражение CALCULATE:

```dax
CALCULATE(
    SELECTEDMEASURE(),
    SAMEPERIODLASTYEAR(DimDate[Date]),
    'Time Intelligence'[Time Calculation] = "YTD"
)
```

Аргумент YTD функции CALCULATE () переопределяет контекст фильтра для повторного использования логики, уже определенной в элементе вычисления YTD. В одной оценке невозможно применить как КОРРЕКТИРОВКу, так и YTD. Группы вычислений *применяются только* в том случае, если один элемент вычисления из группы вычислений находится в контексте фильтра.

## <a name="mdx-support"></a>Поддержка многомерных выражений

Группы вычислений поддерживают запросы многомерных выражений (MDX). Это означает, что пользователи Microsoft Excel, которые запрашивают модели табличных данных с помощью многомерных выражений, могут воспользоваться всеми преимуществами групп вычислений в сводных таблицах и диаграммах на листе.

## <a name="tools"></a>Инструменты

Группы вычислений пока не поддерживаются в SQL Server Data Tools, Visual Studio с расширениями Analysis Services. Однако группы вычислений можно создавать с помощью языка сценариев табличных моделей (TMSL) или [редактора таблиц](https://github.com/otykier/TabularEditor)с открытым исходным кодом.

## <a name="limitations"></a>Ограничения

[Безопасность на уровне объектов](object-level-security.md) (ОЛС), определенное в таблицах группы вычислений, не поддерживается. Однако ОЛС можно определить в других таблицах той же модели. Если элемент вычисления ссылается на защищенный объект ОЛС, возвращается общая ошибка.

[Безопасность на уровне строк](roles-ssas-tabular.md#bkmk_rowfliters) (RLS) не поддерживается. RLS можно определить для таблиц в той же модели, но не для самих групп вычислений (напрямую или косвенно).

## <a name="see-also"></a>См. также  

[DAX в табличных моделях](understanding-dax-in-tabular-models-ssas-tabular.md)   
[Справочник по DAX](https://docs.microsoft.com/dax/data-analysis-expressions-dax-reference)  
