---
title: Спецификация резервного копирования VDI - SQL Server в Linux | Документация Майкрософт
description: Спецификация интерфейса виртуального устройства резервного копирования SQL Server.
author: MikeRayMSFT
ms.author: mikeray
manager: craigg
ms.date: 03/17/2017
ms.topic: conceptual
ms.prod: sql
ms.technology: linux
ms.assetid: 0250ba2b-8cdd-450e-9109-bf74f70e1247
ms.openlocfilehash: b3917f086361128ee0c3e0a73f44f2c7cc4049b6
ms.sourcegitcommit: 074d44994b6e84fe4552ad4843d2ce0882b92871
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2019
ms.locfileid: "66713467"
---
# <a name="sql-server-on-linux-vdi-client-sdk-specification"></a>SQL Server на клиенте Linux VDI спецификации пакета SDK

[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md-linuxonly](../includes/appliesto-ss-xxxx-xxxx-xxx-md-linuxonly.md)]

В этом документе рассматриваются интерфейсы, предоставляемые SQL Server на Linux виртуального устройства клиентский пакет SDK для интерфейса (VDI). Независимые поставщики программного обеспечения (ISV) можно использовать виртуальный резервное копирование устройства прикладного программного интерфейса (API) для интеграции SQL Server в свои продукты. Как правило VDI в Linux работает аналогично элементу VDI в Windows со следующими изменениями:

- Общая память Windows становится POSIX общей памяти.
- Семафоры Windows становятся семафоры POSIX.
- Типы Windows, например HRESULT и DWORD меняется на эквиваленты целое число.
- COM-интерфейсы будут удалены и заменены пара классов C++.
- SQL Server в Linux не поддерживает именованные экземпляры, поэтому будут удалены ссылки на имя экземпляра. 
- Общая библиотека реализуется в libsqlvdi.so, установленной на /opt/mssql/lib/libsqlvdi.so

Этот документ представляет дополнением к **vbackup.chm** , сведения о VDI в Windows спецификации. Скачайте [спецификации VDI Windows](https://www.microsoft.com/download/details.aspx?id=17282).

Также просмотрите пример решения резервного копирования VDI на [репозитории GitHub примеров SQL Server](https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/sqlvdi-linux).

## <a name="user-permissions-setup"></a>Настройка разрешений пользователя

В Linux примитивы POSIX, принадлежат пользователю, создающему их и их группе по умолчанию. Для объектов, созданных в SQL Server они по умолчанию владельцем будет mssql пользователь и группа mssql. Чтобы разрешить общий доступ к SQL Server и клиента VDI, рекомендуются одно из следующих двух способов:

1. Запуск от имени пользователя mssql клиент VDI
   
   Выполните следующую команду, чтобы переключиться в режим пользователя mssql:
   
   ```bash
   sudo su mssql
   ```

2. Добавьте пользователя mssql vdiuser группы и vdiuser группу mssql.
   
   Выполните следующие команды:

   ```bash
   sudo useradd vdiuser
   sudo usermod -a -G mssql vdiuser
   sudo usermod -a -G vdiuser mssql
   ```

   Перезапустите сервер, чтобы получить новые группы для SQL Server и vdiuser

## <a name="client-functions"></a>Функции клиента

В этой главе содержит описания всех функций клиента. Описания содержат следующие сведения:

- Назначение функции
- Синтаксис функции
- список параметров
- Возвращаемые значения
- Примечания

## <a name="clientvirtualdevicesetcreate"></a>ClientVirtualDeviceSet::Create

**Назначение** эта функция создает набор виртуального устройства.

**Синтаксис**
   ```
   int ClientVirtualDeviceSet::Create (
   char *   name,       // name for the set
   VDConfig   * cfg     // configuration for the set
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| | **name** | Определяет набор виртуального устройства. Необходимо следовать правилам для имен, используемые CreateFileMapping(). Любой символ, кроме обратной косой черты (\) может использоваться. Это строка символов. Рекомендуется использовать префикс строку с названием продукта или компании и имя базы данных пользователя. |
| |**cfg** | Это конфигурация для набора виртуальных устройств. Дополнительные сведения см. в разделе «Конфигурация» далее в этом документе.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** | Функция выполнена успешно. |
| |**VD_E_NOTSUPPORTED** |Один или несколько полей в конфигурации недопустим или в противном случае не поддерживается. |
| |**VD_E_PROTOCOL** | Существует виртуального устройства, уже настроено.

**"Примечания"** The Create метод должен вызываться только один раз на каждую операцию резервного КОПИРОВАНИЯ или восстановления. После вызова метода Close, клиент может повторно использовать интерфейс, чтобы создать другой набор виртуального устройства.

## <a name="clientvirtualdevicesetgetconfiguration"></a>ClientVirtualDeviceSet::GetConfiguration

**Назначение** эта функция используется для ожидания для сервера, чтобы настроить набор виртуального устройства.
**Синтаксис**
   ```
   int ClientVirtualDeviceSet::GetConfiguration (
   time_t       timeout,    // in milliseconds
   VDConfig *       cfg // selected configuration
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| | **timeout** | Это время ожидания в миллисекундах. Используйте БЕСКОНЕЧНЫМИ или любое отрицательное целое число для предотвращения тайм-аута.
| | **cfg** | После успешного выполнения содержит выбранной сервером конфигурации. Дополнительные сведения см. в разделе «Конфигурация» далее в этом документе.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** | Конфигурация была возвращена.
| |**VD_E_ABORT** |SignalAbort был вызван.
| |**VD_E_TIMEOUT** |Истекло время ожидания функции.

**"Примечания"** блокирует эту функцию в состоянии извещающие процедуры. После успешного вызова можно открыть устройства в наборе виртуального устройства.


## <a name="clientvirtualdevicesetopendevice"></a>ClientVirtualDeviceSet::OpenDevice
**Назначение** эта функция открывает одно из устройств в наборе виртуального устройства.
**Синтаксис**
   ```
   int ClientVirtualDeviceSet::OpenDevice (
   char *           name,       // name for the set
   ClientVirtualDevice **       ppVirtualDevice // returns interface to device
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| | **name** |Определяет набор виртуального устройства.
| | **ppVirtualDevice** |Когда функция завершается успешно, возвращается указатель к виртуальному устройству. Это устройство используется метод GetCommand и CompleteCommand.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Функция выполнена успешно.
| |**VD_E_ABORT** | Запрашивалось.
| |**VD_E_OPEN** |  Все устройства должны быть открыты.
| |**VD_E_PROTOCOL** |  Набор не в состоянии инициализации или это устройство уже открыт.
| |**VD_E_INVALID** |Недопустимое имя устройства. Он не является одним из имен, известно, из набора.

**"Примечания"** VD_E_OPEN могут быть возвращены без проблем. Клиент может вызвать OpenDevice посредством цикл, пока не будет возвращено этот код.
Если более одного настройки устройства, например *n* устройств, будет возвращать набор виртуального устройства *n* интерфейсы устройств.

`GetConfiguration` Функция может использоваться ждать, пока устройства может быть открыт.
Если эта функция завершается неудачно, возвращается значение null через ppVirtualDevice.
 
## <a name="clientvirtualdevicegetcommand"></a>ClientVirtualDevice::GetCommand

**Назначение** эта функция используется для получения следующей команды в очереди на устройство. При запросе, эта функция ожидает в течение следующей команды.

**Синтаксис**
   ```
   int ClientVirtualDevice::GetCommand (
   time_t       timeout,    // time-out in milliseconds
   VDC_Command**    ppCmd   // returns the next command
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**timeout** |Это время ожидания в миллисекундах. Используйте неограниченное про СРОКАМ для неограниченного времени ожидания. Используйте 0 для опроса для команды. VD_E_TIMEOUT возвращается в том случае, если команда не доступен. Если истекло время ожидания, клиент решает следующее действие.
| |**Timeout** |Это время ожидания в миллисекундах. Используйте неограниченное про СРОКАМ или отрицательное значение в случае неограниченного ожидания. Используйте 0 для опроса для команды. VD_E_TIMEOUT возвращается в том случае, если команда не доступна, прежде чем истечет время ожидания. Если время ожидания истекает, клиент решает следующее действие.
| |**ppCmd** |Если команды возвращается успешно, параметр Возвращает адрес выполнения команды. Память выравнивается доступен только для чтения. После завершения команды этого указателя передается CompleteCommand подпрограммы. Дополнительные сведения о каждой из них см. в разделе «Команды» далее в этом документе.
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Команды, которые были выбраны.
| |**VD_E_CLOSE** |Устройство было закрыто сервером.
| |**VD_E_TIMEOUT** |Команда не была доступна и истечения тайм-аута.
| |**VD_E_ABORT** |Клиент или сервер использовал SignalAbort выключение.

**"Примечания"** возвращается, когда VD_E_CLOSE, SQL Server закрыл устройства. Это является частью стандартного завершения работы. После закрытия всех устройств, клиент вызывает ClientVirtualDeviceSet::Close, чтобы закрыть набор виртуального устройства.
Когда эта подпрограмма должна блокируют ожидания для команды, поток остается в условие извещающие процедуры.

## <a name="clientvirtualdevicecompletecommand"></a>ClientVirtualDevice::CompleteCommand

**Назначение** эта функция используется для уведомления SQL Server, команда будет выполнена. Сведения о завершении, соответствующие команды должно быть возвращено. Дополнительные сведения см. в разделе «Команды» далее в этом документе.

**Синтаксис** 

   ```
   int ClientVirtualDevice::CompleteCommand (
   VDC_Command pCmd,        // the command
   int  completionCode,     // completion code
   unsigned long    bytesTransferred,   // bytes transferred
   int64_t  position        // current position
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**pCmd** |Это адрес, возвращенный ранее из ClientVirtualDevice::GetCommand команды.
| |**completionCode** |Это код состояния, который указывает состояние завершения. Этот параметр должен быть возвращен для всех команд. Возвращенный код следует подходить к выполняемой команде. ERROR_SUCCESS используется во всех случаях для обозначения успешно выполненных команд. Полный список возможных кодов, см. в файле vdierror.h. Появится список кодов состояния обычно для каждой команды в «Команды» далее в этом документе.
| |**bytesTransferred** |Это число количество успешно переданных байт. Это значение возвращается только для передачи данных команды чтения и записи.
| |**position** |Это ответ на команду GetPosition только.
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Завершение правильно была отмечена.
| |**VD_E_INVALID** |pCmd не активной команды.
| |**VD_E_ABORT** |Получил сигнал прерывания.
| |**VD_E_PROTOCOL** |Устройство не открыт.

**"Примечания"** None

## <a name="clientvirtualdevicesetsignalabort"></a>ClientVirtualDeviceSet::SignalAbort

**Назначение** эта функция используется для обозначения того, что должно произойти аварийное завершение.

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::SignalAbort ();
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |None | Неприменимо
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR**|Прерывание уведомление успешно отправлено.

**"Примечания"** в любое время, клиент может выбрать для прерывания операции резервного КОПИРОВАНИЯ или восстановления. Эта подпрограмма сигнализирует, что прекращает все операции. Состояние набора в целом виртуальное устройство переходит в состояние, он был прерван. Дополнительные команды не возвращаются на любые устройства. Автоматически завершены все незавершенные команды, возвращая ERROR_OPERATION_ABORTED как код завершения. Клиент должен вызывать ClientVirtualDeviceSet::Close завершения его безопасно любое использование необработанных буферов предоставляются клиенту. Дополнительные сведения см. в разделе «Аварийное завершение» ранее в этом документе.

## <a name="clientvirtualdevicesetclose"></a>ClientVirtualDeviceSet::Close

**Назначение** набор виртуального устройства, созданный ClientVirtualDeviceSet::Create закрывает эту функцию. Это приводит выпуска все ресурсы, связанные с набором виртуального устройства.

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::Close ();
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |None |Неприменимо
        
| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Это значение возвращается, когда набор виртуального устройства был успешно закрыт.
| |**VD_E_PROTOCOL** |Действие не выполнено, так как набор виртуального устройства не был открыт.
| |**VD_E_OPEN** |Устройства были по-прежнему открыты.

**"Примечания"** вызовом Close является объявлением клиента, что необходимо освободить все ресурсы, используемые набором виртуального устройства. Клиент необходимо убедиться, что все действия, включающие буферов данных и виртуальными устройствами завершается перед вызовом Close. Закрыть делает недействительными все интерфейсы виртуального устройства, возвращенный OpenDevice.
Клиент может выдавать вызова для создания набора интерфейса виртуального устройства, после завершения вызова Close. Такой вызов будет создание виртуального устройства для последующей операции резервного КОПИРОВАНИЯ или восстановления.
Если закрыть вызывается в том случае, если один или несколько виртуальных устройств по-прежнему открыты, возвращается VD_E_OPEN. В этом случае SignalAbort внутренне активируется, для обеспечения правильного завершения работы, если это возможно. VDI ресурсы освобождаются. Для обозначения VD_E_CLOSE на каждом устройстве перед вызовом ClientVirtualDeviceSet::Close ожидания для клиента. Если клиенту известно, что заданное виртуальное устройство уже находится в состоянии он был прерван, а затем его не следует ожидать, что можно получить представление о VD_E_CLOSE из метод GetCommand интерфейса и могут вызывать ClientVirtualDeviceSet::Close, как только завершается действие на общих буферов.
Дополнительные сведения см. в разделе «Аварийное завершение» ранее в этом документе.

## <a name="clientvirtualdevicesetopeninsecondary"></a>ClientVirtualDeviceSet::OpenInSecondary

**Назначение** эта функция открывает виртуального устройства, заданные вторичной клиенте. Основной клиент должен уже использовали Create и GetConfiguration для настройки набора виртуального устройства.

**Синтаксис** 
   
   ```
   int ClientVirtualDeviceSet::OpenInSecondary (
   char *   setName         // name of the set
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**setName** |Это определяет набор. Это имя с учетом регистра и должно соответствовать имени, используемой основной клиент при его вызове ClientVirtualDeviceSet::Create.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Функция выполнена успешно.
| |**VD_E_PROTOCOL** |Набор виртуального устройства, не был создан, уже установлен на этом клиенте или виртуального устройства набор не готова к приему открытых запросов от клиентов вторичной.
| |**VD_E_ABORT** |Операция отменяется.

**"Примечания"** при использовании нескольких модель процесса, основной клиент отвечает за обнаружение обычного и аномального завершения вторичной клиентов.

## <a name="clientvirtualdevicesetgetbufferhandle"></a>ClientVirtualDeviceSet::GetBufferHandle

**Назначение** некоторым приложениям может понадобиться несколько процессов для работы в буферы, возвращенный ClientVirtualDevice::GetCommand. В таких случаях процесс, который получает команду можно использовать GetBufferHandle, чтобы получить дескриптор независимый процесс, определяющий буфера. Затем этот дескриптор можно сообщить в любой другой процесс, который также имеет то же открытое значение виртуального устройства. Этот процесс будет затем производить ClientVirtualDeviceSet::MapBufferHandle получить адрес буфера. Адрес скорее всего будет другой адрес, чем ее партнеров, так как каждый процесс может сопоставление буферов заданы различные адреса.

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::GetBufferHandle (
   uint8_t*     pBuffer,        // in: buffer address
   unsigned int*        pBufferHandle   // out: buffer handle
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**pBuffer** |Это адрес буфера, полученный из команды чтения или записи.
| |**BufferHandle** |Возвращает уникальный идентификатор для буфера.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Функция выполнена успешно.
| |**VD_E_PROTOCOL** |Набор виртуального устройства не открыт.
| |**VD_E_INVALID** |PBuffer не является допустимым адресом.

Примечания, что процесс, который вызывает функцию GetBufferHandle отвечает за вызов ClientVirtualDevice::CompleteCommand, когда передача данных завершена.

## <a name="clientvirtualdevicesetmapbufferhandle"></a>ClientVirtualDeviceSet::MapBufferHandle

**Назначение** эта функция используется для получения адреса допустимый буфер из буфера дескриптора, полученного из другого процесса. 

**Синтаксис** 

   ```
   int ClientVirtualDeviceSet::MapBufferHandle (
   i        nt  dwBuffer,   // in: buffer handle
   uint8_t**    ppBuffer        // out: buffer address
   );
   ```

| Параметры | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**dwBuffer** |Это дескриптор, возвращенный ClientVirtualDeviceSet::GetBufferHandle.
| |**ppBuffer** |Это адрес буфера, который является допустимым в текущем процессе.

| Возвращаемые значения | Аргумент | Объяснение
| ----- | ----- | ------ |
| |**ЗНАЧЕНИЕ NOERROR** |Функция выполнена успешно.
| |**VD_E_PROTOCOL** |Набор виртуального устройства не открыт.
| |**VD_E_INVALID** |PpBuffer является недопустимым дескриптором.

**"Примечания"** Будьте осторожны должным образом взаимодействовать маркеров. Дескрипторы являются локальными для набора одного виртуального устройства. Процессы партнера, совместное использование дескриптор необходимо убедиться, буфером дескрипторов, используются только в пределах виртуального устройства от которого еще изначально был получен буфера.


