---
title: Проблемы производительности драйверов для баз данных на настольном | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- ODBC desktop database drivers [ODBC], performance
- desktop database drivers [ODBC], performance
- Jet-based ODBC drivers [ODBC], performance
ms.assetid: 1a4c4b7e-9744-411f-9b6e-06dfdad92cf7
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: b4d92d2784649e4366113b3070b54598df585370
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63240308"
---
# <a name="desktop-database-driver-performance-issues"></a>Проблемы производительности драйверов для баз данных на настольном компьютере
Чтобы обеспечить совместимость с существующими приложениями ANSI, типов данных SQL_WCHAR, SQL_WVARCHAR и SQL_WLONGVARCHAR предоставляются как SQL_CHAR и SQL_VARCHAR, SQL_LONGVARCHAR Microsoft Access 4.0 или более поздней версии источников данных. Источники данных не возвращают CHAR РАСШИРЕННЫХ типов данных, но данные по-прежнему должны отправляться Jet в форме широкий Char. Важно понимать, что преобразование будет выполняться в случае привязанного столбца SQL_C_CHAR результат или параметр с типом данных SQL_CHAR в приложение ANSI.  
  
 Это преобразование может быть особенно неэффективно с точки зрения памяти, когда типа SQL_C_CHAR привязан к параметру типа LONGVARCHAR. Так как ядро Jet 4.0 не сможет поток данных параметра LONGTEXT, буфер преобразования ЮНИКОДА должен быть выделен дважды размера буфера SQL_C_CHAR ANSI. Для приложения, для выполнения преобразования ЮНИКОДА и привязать параметр в качестве типа SQL_C_WCHAR представляет собой наиболее эффективный механизм. Если параметр помечен как данные во время выполнения и данные, предоставляются в нескольких вызовах SQLPutData, происходит при явном longtext буфер данных. Один из способов избежать затрат на увеличение размера этого буфера «Поместить данные» — предоставить длины через SQL_DATA_AT_EXEC_LEN(x), где *x* является ожидаемая длина байтов. Это будет инициализировать размер внутренний буфер PutData *x* байт.  
  
> [!NOTE]  
>  Эффективный способ вставки или обновления данных большой длины может быть выполнено с помощью **SQLBulkOperations()** или **SQLSetPos()** и длинных данных в значение SQL_DATA_AT_EXEC. (EXEC_LEN игнорируется в данном случае). Данные могут передаваться в виде фрагментов, вызвав **SQLPutData** несколько раз, который фактически данные будут добавляться в таблицу.  
  
 Когда приложения с помощью базы данных Jet 3.5 через драйверы для баз данных Microsoft ODBC Desktop обновляется до версии 4.0, может возникнуть некоторое снижение производительности и увеличение размера рабочего набора. Это обусловлено тем, когда версии 3. *x* открыть базу данных с помощью нового драйвера версии 4.0, он загружает Jet 4.0. При открытии базы данных Jet 4.0 и видит, что она является 3. *x* версии, он загружает драйвер устанавливаемый ISAM, эквивалентно загрузке ядро Jet 3.5. Чтобы удалить штраф размером и производительностью, Jet 3. *x* базы данных должны сжиматься в формате базы данных Jet 4.0. Это будет устранить, загрузка двух обработчиков Jet и свести к минимуму путь кода к данным.  
  
 Кроме того ядро Jet 4.0 — это механизм Юникода. Все строки хранить и обрабатывать в кодировке Юникод. Когда приложение ANSI обращается к Jet 3. *x* базе данных с помощью ядра Jet 4.0, данные преобразуются из ANSI в Юникод и обратно в ANSI. При обновлении базы данных в версии 4.0 формат строки преобразуются в Юникод, удалив один уровень преобразования строк и максимально сократить путь кода к данным через только одно ядро Jet.
