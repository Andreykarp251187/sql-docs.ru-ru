---
title: Проблемы с производительностью драйверов на рабочем столе (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- ODBC desktop database drivers [ODBC], performance
- desktop database drivers [ODBC], performance
- Jet-based ODBC drivers [ODBC], performance
ms.assetid: 1a4c4b7e-9744-411f-9b6e-06dfdad92cf7
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a819d99a995fd7b287beb66b94f1df526e05f201
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81303505"
---
# <a name="desktop-database-driver-performance-issues"></a>Проблемы производительности драйверов для баз данных на настольном компьютере
Для обеспечения совместимости с существующими приложениями ANSI типы данных SQL_WCHAR, SQL_WVARCHAR и SQL_WLONGVARCHAR подвергаются воздействию SQL_CHAR, SQL_VARCHAR и SQL_LONGVARCHAR для Microsoft Access 4.0 или более высоких источников данных. Источники данных не возвращают типы данных WIDE CHAR, но данные все еще должны быть отправлены в Jet в форме Wide Char. Важно понимать, что преобразование произойдет, если SQL_C_CHAR параметр или столбец результата привязан к SQL_CHAR типу данных в приложении ANSI.  
  
 Это преобразование может быть особенно неэффективным с точки зрения памяти, когда SQL_C_CHAR тип связан с параметром типа LONGVARCHAR. Поскольку движок Jet 4.0 не может передавать данные параметра LONGTEXT, необходимо выделить буфер преобразования UNICODE, который в два раза превышает SQL_C_CHAR буфера ANSI. Наиболее эффективным механизмом является выполнение приложения преобразования UNICODE и связывания параметра в качестве типа SQL_C_WCHAR. Когда параметр помечается как данные по исполнению и данные поставляются в нескольких вызовах на S'LPutData, буфер данных длиннотекстовых растет. Один из способов избежать расходов на выращивание этого буфера "Put Data" заключается в предоставлении дополнительной длины через SQL_DATA_AT_EXEC_LEN (x), где *x* является ожидаемой длиной байтов. Это позволит инициализировать размер внутреннего буфера PutData для *х* байтов.  
  
> [!NOTE]  
>  Эффективный способ вставки или обновления длинных данных может быть выполнен с помощью **S'LBulkOperations ()** или **S'LSetPos()** и установки длинных данных для SQL_DATA_AT_EXEC. (EXEC_LEN игнорируется в этом случае.) Данные могут передаваться частями, вызывая **несколько** раз, что позволит эффективно приговыть данные к таблице.  
  
 Когда приложение с использованием базы данных Jet 3.5 через Microsoft ODBC Desktop Database Drivers обновляется до версии 4.0, может произойти некоторое ухудшение производительности и увеличение размера рабочего набора. Это потому, что, когда версия 3. *база x* открыта с помощью новой версии 4.0 драйвера, она загружает Jet 4.0. Когда Jet 4.0 открывает базу данных и видит, что база данных 3. *х* версия, он загружает установить ISAM драйвер, который эквивалентен загрузке двигателя Jet 3.5, а также. Чтобы удалить производительность и размер штрафа, Jet 3. база данных *x* должна быть уплотнена в базу данных формата Jet 4.0. Это позволит устранить загрузку двух реактивных двигателей и свести к минимуму путь кода к данным.  
  
 Кроме того, двигатель Jet 4.0 является двигателем Unicode. Все строки хранятся и манипулируются в Unicode. Когда приложение ANSI получает доступ к Jet 3. *x* базы данных через движок Jet 4.0, данные преобразуются из ANSI в Unicode и обратно в ANSI. Если база данных обновлена до формата версии 4.0, строки преобразуются в Unicode, удаляя один уровень преобразования строки, а также минимизируя путь кода к данным, пройдя только один реактивный движок.
