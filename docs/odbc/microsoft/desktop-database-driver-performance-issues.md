---
title: Проблемы с производительностью драйвера базы данных настольных компьютеров | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- ODBC desktop database drivers [ODBC], performance
- desktop database drivers [ODBC], performance
- Jet-based ODBC drivers [ODBC], performance
ms.assetid: 1a4c4b7e-9744-411f-9b6e-06dfdad92cf7
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a819d99a995fd7b287beb66b94f1df526e05f201
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81303505"
---
# <a name="desktop-database-driver-performance-issues"></a>Проблемы производительности драйверов для баз данных на настольном компьютере
Для обеспечения совместимости с существующими приложениями ANSI типы данных SQL_WCHAR, SQL_WVARCHAR и SQL_WLONGVARCHAR предоставляются как SQL_CHAR, SQL_VARCHAR и SQL_LONGVARCHAR для источников данных Microsoft Access 4,0 или более поздних версий. Источники данных не возвращают типы данных WIDE CHAR, но данные по-прежнему должны отправляться в Jet в расширенной форме char. Важно понимать, что преобразование будет выполнено, если SQL_C_CHARный параметр или столбец результатов привязаны к SQL_CHAR типу данных в приложении ANSI.  
  
 Это преобразование может быть особенно неэффективным с точки зрения памяти, если тип SQL_C_CHAR привязан к параметру типа LONGVARCHAR. Поскольку подсистеме Jet 4,0 не удается выполнить потоковую передачу данных о параметрах LONGTEXT, необходимо выделить буфер преобразования Юникода, который вдвое превышает размер буфера SQL_C_CHAR ANSI. Наиболее эффективный механизм заключается в том, чтобы приложение выполнило преобразование в Юникоде и привязать параметр к типу SQL_C_WCHAR. Если параметр помечен как данные во время выполнения, а данные передаются в несколько вызовов SQLPutData, то буфер данных LONGTEXT увеличивается. Одним из способов избежать расходов на увеличение этого буфера "размещения данных" является указание дополнительной длины через SQL_DATA_AT_EXEC_LEN (x), где *x* — ожидаемая длина в байтах. Это приведет к инициализации размера внутреннего буфера Путдата до *x* байт.  
  
> [!NOTE]  
>  Эффективный способ вставки или обновления данных типа long можно выполнить с помощью **SQLBulkOperations ()** или **SQLSetPos ()** и установки данных типа long в SQL_DATA_AT_EXEC. (В этом случае EXEC_LEN игнорируется.) Данные могут передаваться в виде фрагментов путем вызова **SQLPutData** несколько раз, что позволяет эффективно добавлять данные в таблицу.  
  
 Если приложение, использующее базу данных Jet 3,5 с драйверами Microsoft ODBC для настольных систем, обновляется до версии 4,0, может произойти некоторое снижение производительности и увеличение размера рабочего множества. Это происходит потому, что при использовании версии 3. база данных *x* открыта с помощью нового драйвера версии 4,0, он загружает Jet 4,0. Когда Jet 4,0 открывает базу данных и видит, что база данных имеет значение 3. версия *x* , она загружает устанавливаемый драйвер ISAM, который также эквивалентен загрузке ядра Jet 3,5. Чтобы устранить потери производительности и размера, можно выполнить модуль Jet 3. база данных *x* должна быть сжата в базе данных формата Jet 4,0. Это позволит избежать загрузки двух ядер Jet и свести к минимальному пути кода к данным.  
  
 Кроме того, Ядро Jet 4,0 является модулем Юникода. Все строки хранятся и обрабатываются в Юникоде. Когда приложение ANSI обращается к Jet 3. база данных *x* через модуль Jet 4,0, данные преобразуются из ANSI в Юникод и обратно в ANSI. Если база данных обновлена до формата версии 4,0, строки преобразуются в Юникод, удаляются один уровень преобразования строк, а также сокращается путь кода к данным путем прохода только по одному ядру Jet.
