---
title: SELECT — команда SQL | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- select [ODBC]
ms.assetid: 2149c3ca-3a71-446d-8d53-3d056e2f301a
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 0c2d991afa179fdfbb536853e302b33de8bf12e1
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63127878"
---
# <a name="select---sql-command"></a>SELECT (команда SQL)
Извлекает данные из одной или нескольких таблиц.  
  
 Драйвер ODBC для Visual FoxPro поддерживает собственный синтаксис языка Visual FoxPro для этой команды. Сведения, см. в разделе **"Примечания" драйвер**.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SELECT [ALL | DISTINCT]  
   [Alias.] Select_Item [AS Column_Name]  
   [, [Alias.] Select_Item [AS Column_Name] ...]   
FROM [DatabaseName!]Table [Local_Alias]  
   [, [DatabaseName!]Table [Local_Alias] ...]   
[WHERE JoinCondition [AND JoinCondition  
...]  
   [AND | OR FilterCondition [AND | OR FilterCondition ...]]]  
[GROUP BY GroupColumn [, GroupColumn ...]]  
[HAVING FilterCondition]  
[UNION [ALL] SELECTCommand]  
[ORDER BY Order_Item [ASC | DESC] [, Order_Item [ASC | DESC] ...]]  
```  
  
## <a name="arguments"></a>Аргументы  
  
> [!NOTE]  
>  Объект *вложенный запрос*, упоминаемый в следующие аргументы, является выбор в SELECT и должны быть заключены в скобки. Может иметь до двух вложенных запросов на том же уровне (не вложенные) в предложении WHERE. (См. Этот раздел аргументов). Вложенные запросы могут содержать несколько условий соединения.  
  
 [Все &#124; DISTINCT]   [*Псевдоним*.] *Select_Item* [AS *Column_Name*] [, [*псевдоним*.] *Select_Item* [AS *Column_Name*]...]  
 Предложение SELECT задает поля, константы и выражения, которые отображаются в результатах запроса.  
  
 По умолчанию все отображаются все строки в результатах запроса.  
  
 Ключевое слово DISTINCT удаляет дубликаты строк в результатах запроса.  
  
> [!NOTE]  
>  Можно использовать ключевое слово DISTINCT только один раз в предложении SELECT.  
  
 *Псевдоним*. Определяет значение совпадающих имен элемента. Каждый элемент, указанный с помощью *Select_Item* формирует по одному столбцу результатов запроса. Если два или несколько элементов имеют тем же именем, включите псевдоним таблицы и точку перед именем элемента, чтобы предотвратить дублирование столбцов.  
  
 *Select_Item* указывает элемент для включения в результаты запроса. Элемент может принимать одно из следующих:  
  
-   Имя поля из таблицы в предложении FROM.  
  
-   Константа, указывающая, что то же постоянное значение будет отображаться в каждой из результатов запроса.  
  
-   Выражение, которое может быть имя определяемой пользователем функции.  
  
 **Определяемые пользователем функции с помощью SELECT**  
  
 Несмотря на то, что с помощью определяемых пользователем функций в предложении SELECT имеет очевидные преимущества, следует также учитывать следующие ограничения:  
  
-   Скорость выполнения операций, выполняемых с помощью SELECT могут быть ограничены по скорости, с которой выполняются такие определяемые пользователем функции. Большим объемом операций, с определяемые пользователем функции можно реализовать лучше с помощью API и определяемые пользователем функции, написанные на C или языка ассемблера.  
  
-   Единственным надежным способом для передачи значений в определяемые пользователем функции, вызываемые из SELECT является список аргументов, переданных в функцию, при вызове.  
  
-   Даже в том случае, если поэкспериментировать и определить мы предполагаем, что запрещенные манипуляции, правильно работающая в определенной версии FoxPro, нет никаких гарантий, что она будет продолжать работать в более поздних версиях.  
  
 Помимо эти ограничения определяемые пользователем функции являются допустимыми в предложении SELECT. Однако следует помните, что с помощью инструкции SELECT может снизить производительность.  
  
 Следующие функции поля доступны для использования с выберите элемент, который является полем или выражение, включающее поля:  
  
-   AVG (*Select_Item*) — вычисляет среднее значение столбца числовых данных.  
  
-   COUNT (*Select_Item*) — подсчитывает количество элементов, выберите в столбце. Функция Count(*) подсчитывает количество строк в выходных данных запроса.  
  
-   MIN (*Select_Item*)-определяет наименьшее значение *Select_Item* в столбце.  
  
-   MAX (*Select_Item*)-определяет наибольшее значение *Select_Item* в столбце.  
  
-   SUM (*Select_Item*)-суммирует столбец числовых данных.  
  
 Нельзя вкладывать функции полями.  
  
 AS *Column_Name*  
 Указывает заголовок для столбца в выходных данных запроса. Это полезно, когда *Select_Item* представляет собой выражение или содержит поле функции и вы хотите присвоить понятное имя столбца. *Column_Name* может быть выражением, но не может содержать символы (например, пробелы), которые не разрешены в именах полей таблицы.  
  
 ИЗ [*DatabaseName*!] *Таблицы* [*Local_Alias*] [, [*DatabaseName*!] *Таблицы* [*Local_Alias*]...]  
 Перечисляет таблицы, содержащие данные из запроса. Если таблицы не открыт, Visual FoxPro отображает **откройте** диалоговое окно, в котором можно указать расположение файла. После его открытия, таблице остается открытым после завершения запроса.  
  
 *Имя базы данных*! Указывает имя базы данных, отличный от указанного в источнике данных. Необходимо включить имя базы данных, содержащую таблицу, в том случае, если база данных не указывается с источником данных. Включить в разделители восклицательный знак (!), после имени базы данных и перед именем таблицы.  
  
 *Local_Alias* указывает временное имя таблицы, указанной в *таблицы*. Если указать локальный псевдоним, необходимо использовать локальный псевдоним, вместо имени таблицы в инструкции SELECT. Локальный псевдоним не влияет на среду Visual FoxPro.  
  
 ГДЕ *JoinCondition* [AND *JoinCondition* ...]    [AND &#124; или *FilterCondition* [AND &#124; или *FilterCondition* ...]]  
 Сообщает Visual FoxPro для включения записи в результатах запроса. При необходимости для получения данных из нескольких таблиц.  
  
 *JoinCondition* определяет поля, связывающие таблицы в предложении FROM. Если включить несколько таблиц в запросе, следует указать в условии соединения, для каждой таблицы после первого.  
  
> [!IMPORTANT]  
>  При создании условия соединения, необходимо учесть следующее:  
  
-   Если указать две таблицы в запросе и задают условие соединения, каждая запись в первой таблице соединяется с каждой записи во второй таблице до тех пор, пока выполняются условия фильтра. Такой запрос может привести к результатам длинными.  
  
-   Будьте осторожны при присоединении таблиц с пустыми полями, поскольку Visual FoxPro соответствует пустые поля. Например, если соединение по КЛИЕНТА. Счета на ОПЛАТУ и ZIP. Почтовый индекс, и если клиент содержит 100 пустой почтовые индексы, а счет 400 пустой почтовые индексы, выходных данных запроса содержит 40 000 дополнительных записей, полученный в результате пустые поля. Используйте **(пустой)** функции, чтобы исключить пустые записи из выходных данных запроса.  
  
-   Необходимо использовать оператор AND для подключения несколько условий соединения. Каждое условие соединения имеет следующий вид:  
  
     *Сравнение FieldName1 FieldName2*  
  
     *FieldName1* является имя поля из одной таблицы *FieldName2* является имя поля из другой таблицы, и *сравнения* является одним из операторов, описанные в следующей таблице.  
  
|Оператор|Сравнение|  
|--------------|----------------|  
|=|Равно|  
|==|Точно равно|  
|LIKE|НАПОДОБИЕ SQL|  
|<>, !=, #|Не равно|  
|>|Более чем|  
|>=|Больше или равно|  
|<|Меньше чем|  
|<=|Меньше или равно|  
  
 При использовании оператора = со строками, он действует по-разному, в зависимости от параметра SET ANSI. Если SET ANSI имеет значение OFF, Visual FoxPro обрабатывает сравнения строк образом знакомы пользователям Xbase. Если SET ANSI имеет значение ON, Visual FoxPro соответствует стандартам ANSI для сравнения строк. См. в разделе [SET ANSI](../../odbc/microsoft/set-ansi-command.md) и [ЗАДАТЬ ТОЧНОЕ](../../odbc/microsoft/set-exact-command.md) Дополнительные сведения о том, как Visual FoxPro выполняет сравнение строк.  
  
 *FilterCondition* указывает критерии, которым записи должны соответствовать для включения в результаты запроса. Вы можете включить как количество фильтров условий в запросе, необходимо, подключая их к AND или оператор OR. Оператор NOT можно использовать и для отмены значения логического выражения или воспользоваться **(пустой)** на наличие пустого поля. *FilterCondition* можно взять любую из форм в следующих примерах:  
  
 **Пример 1** *FieldName1 FieldName2 сравнения*  
  
 `customer.cust_id = orders.cust_id`  
  
 **Пример 2** *выражения сравнения FieldName*  
  
 `payments.amount >= 1000`  
  
 **Пример 3** *сравнения FieldName* все (*вложенный запрос*)  
  
 `company < ALL ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Если условие фильтра включает в себя все, поля должны соответствовать условием сравнения для всех значений, созданных вложенный запрос, прежде чем включать его запись в результаты запроса.  
  
 **Пример 4** *сравнения FieldName* ANY &#124; SOME (*вложенный запрос*)  
  
 `company < ANY ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Если условие фильтра содержит все или НЕКОТОРЫЕ, поля должны соответствовать условием сравнения для по крайней мере одно из значений, сформированных вложенным запросом.  
  
 Следующий пример проверяет, являются ли значения в поле в указанный диапазон значений:  
  
 **Пример 5** *FieldName* [NOT] BETWEEN *Start_Range* AND *End_Range*  
  
 `customer.postalcode BETWEEN 90000 AND 99999`  
  
 В следующем примере проверяется, чтобы определить, соответствует ли хотя бы одна строка критерии во вложенном запросе. Если условие фильтра содержит EXISTS, условие фильтра возвращает значение True (. T.) пока вложенный запрос не станет пустой набор.  
  
 **Пример 6** [NOT] EXISTS (*вложенный запрос*)  
  
 `EXISTS ;`  
  
 `(SELECT * FROM orders WHERE customer.postalcode =`  
  
 `orders.postalcode)`  
  
 **Пример 7** *FieldName* [NOT] IN *Value_Set*  
  
 `customer.postalcode NOT IN ("98052","98072","98034")`  
  
 Условие фильтра содержит IN, поле должно содержать одно из значений перед ее записью включается в результаты запроса.  
  
 **Пример 8** *FieldName* [NOT] IN (*вложенный запрос*)  
  
 `customer.cust_id IN ;`  
  
 `(SELECT orders.cust_id FROM orders WHERE orders.city="Seattle")`  
  
 Здесь поле должно содержать одно из значений, возвращенных вложенным запросом, прежде чем включать его запись в результаты запроса.  
  
 **Пример 9** *FieldName* [NOT] LIKE *cExpression*  
  
 `customer.country NOT LIKE "USA"`  
  
 Выполняет поиск данное условие фильтра для каждого поля, которое соответствует *cExpression*. Можно использовать знак процента (%) и подстановочные знаки подчеркивания (_) как часть *cExpression*. Символ подчеркивания представляет одному неизвестному символу в строке.  
  
 GROUP BY *GroupColumn* [, *GroupColumn* ...]  
 Группы строк в запросе на основе значений в один или несколько столбцов. *GroupColumn* может принимать одно из следующих:  
  
-   Имя поля обычной таблицы.  
  
-   Поле, которое включает в себя поле функции SQL.  
  
-   Числовое выражение, указывающее расположение столбца в таблице результатов. (Крайний слева столбец имеет номер 1.)  
  
 НАЛИЧИЕ *FilterCondition*  
 Условие фильтра, групп должны соответствовать для включения в результаты запроса. HAVING, следует использовать с предложением GROUP BY и может содержать столько условий фильтрации, сколько требуется, соединенных AND или оператор OR. Также можно не для того, чтобы изменить значения логического выражения.  
  
 *FilterCondition* не может содержать вложенный запрос.  
  
 Предложение HAVING без предложения GROUP BY ведет себя как предложение WHERE. Можно использовать локальный псевдонимы и функции полей в предложении HAVING. Используйте предложение WHERE для повышения производительности, если в предложении HAVING содержит функции не поля.  
  
 [[Все] ОБЪЕДИНЕНИЕ *SELECTCommand*]  
 Сочетанием относительного и окончательные результаты имеющуюся, ВЫБРАВ окончательные результаты другой выбор. По умолчанию ОБЪЕДИНЕНИЕ проверяет объединенные результаты и позволяет удалить повторяющиеся строки. Чтобы объединить несколько предложений ОБЪЕДИНЕНИЯ используйте скобки.  
  
 ВСЕ предотвращает исключая повторяющиеся строки из комбинированного результата UNION.  
  
 ОБЪЕДИНЕНИЯ предложений следующим правилам.  
  
-   UNION нельзя использовать для объединения вложенных запросов.  
  
-   Обе команды SELECT должен иметь одинаковое количество столбцов в их выходных данных запроса.  
  
-   Каждый столбец в результатах запроса имеющуюся, ВЫБРАВ должен иметь один и тот же тип данных и ширины соответствующего столбца в других SELECT.  
  
-   Только окончательный SELECT могут иметь предложение ORDER BY, который должен ссылаться на выходные столбцы, по номеру. Если предложение ORDER BY, она влияет на результат завершения.  
  
 Можно также использовать предложения UNION для моделирования внешнего соединения.  
  
 При соединении двух таблиц в запросе, в выходных данных включаются только записи с совпадающими значениями в полях соединения. Если запись в родительской таблице нет соответствующей записи в дочерней таблице, записи в родительской таблице не включается в выходные данные. Внешнее объединение позволяет включить все записи в родительской таблице в выходных данных, а также записи сопоставления в дочерней таблице. Чтобы создать внешнее соединение в Visual FoxPro, необходимо использовать вложенные команды SELECT, как показано в следующем примере:  
  
```  
SELECT customer.company, orders.order_id, orders.emp_id ;  
FROM customer, orders ;  
WHERE customer.cust_id = orders.cust_id ;  
UNION ;  
SELECT customer.company, 0, 0 ;  
FROM customer ;  
WHERE customer.cust_id NOT IN ;  
(SELECT orders.cust_id FROM orders)  
```  
  
> [!NOTE]  
>  Убедитесь, что пробел, расположенного непосредственно перед каждой точкой с запятой. В противном случае вы получите ошибку.  
  
 В части команды перед предложения UNION выбирает записи из обеих таблиц, иметь совпадающие значения. Компании клиента, у которых нет связанного счета-фактуры, не включаются. В разделе команду после предложения UNION Выбор записей в таблице customer, не имеют совпадающих записей в таблице orders.  
  
 О второй сегмент команды Обратите внимание на следующее:  
  
-   Инструкция SELECT в круглых скобках обрабатывается первым. Эта инструкция создает выделение всех номеров клиента в таблице orders.  
  
-   Предложение WHERE выполняется поиск всех номеров клиента в таблице customer, которых нет в таблице orders. Так как первая часть команды предоставлено все компании, в которых возникли номер клиента в таблице orders, все компании в таблице customer теперь включены в результаты запроса.  
  
-   Поскольку структуры таблицы, включенные в ОБЪЕДИНЕНИИ должны быть идентичными, существуют два заполнителя во второй инструкции SELECT для представления *orders.order_id* и *orders.emp_id* из первая инструкция SELECT инструкция.  
  
    > [!NOTE]  
    >  Заполнители должны иметь тот же тип, как поля, которые они представляют. Если поле имеет тип даты, должен быть заполнитель {/ /}. Если поле является полем символ, заполнитель должна быть пустой строкой (»»).  
  
 ORDER BY *Order_Item* [ASC &#124; DESC] [, *Order_Item* [ASC &#124; DESC]...]  
 Сортирует результаты запроса на основе данных в один или несколько столбцов. Каждый *Order_Item* должен соответствовать столбцу в результатах запроса и может принимать одно из следующих:  
  
-   Поле в таблицу FROM, который также является элемент select в предложении SELECT основной (не во вложенном запросе).  
  
-   Числовое выражение, указывающее расположение столбца в таблице результатов. (Крайний слева столбец имеет номер 1.)  
  
 Указывает порядок сортировки по возрастанию для результатов запроса, в соответствии с или несколько элементов, порядок ASC и используется по умолчанию для предложения ORDER BY.  
  
 DESC указывает по убыванию для результатов запроса.  
  
 Если вы не укажете заказ с предложением ORDER BY, результаты запроса отображаются неупорядоченным.  
  
## <a name="remarks"></a>Примечания  
 SELECT является команду SQL, встроенный в Visual FoxPro, как и любые другие команды Visual FoxPro. При использовании ВЫБЕРИТЕ, чтобы представлять запрос, Visual FoxPro интерпретирует запрос и получает указанные данные из таблиц. ВЫБЕРИТЕ запрос в окне командной строки или программы Visual FoxPro созданием (как и любые другие команды Visual FoxPro).  
  
> [!NOTE]  
>  ВЫБЕРИТЕ текущее условие фильтра, указанного с помощью УСТАНОВИТЬ фильтр не учитывает.  
  
## <a name="driver-remarks"></a>Драйвер "Примечания"  
 Когда приложение отправляет инструкция ODBC SQL SELECT к источнику данных, драйвера ODBC для Visual FoxPro преобразует команды в Visual FoxPro ВЫБЕРИТЕ команду без перевода, если команда не содержит escape-последовательности ODBC. Элементы, заключенные в escape-последовательности ODBC преобразуются в синтаксисе Visual FoxPro. Дополнительные сведения об использовании ODBC escape-последовательности, см. в разделе [функции даты и времени](../../odbc/microsoft/time-and-date-functions-visual-foxpro-odbc-driver.md) и в *Справочник по программированию ODBC Microsoft*, см. в разделе [escape-последовательности в ODBC](../../odbc/reference/develop-app/escape-sequences-in-odbc.md) .  
  
## <a name="see-also"></a>См. также  
 [СОЗДАНИЕ ТАБЛИЦЫ - SQL](../../odbc/microsoft/create-table-sql-command.md)   
 [INSERT - SQL](../../odbc/microsoft/insert-sql-command.md)   
 [SET ANSI](../../odbc/microsoft/set-ansi-command.md)   
 [ТОЧНЫЙ НАБОР](../../odbc/microsoft/set-exact-command.md)
