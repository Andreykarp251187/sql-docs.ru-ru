---
title: SELECT - Командование СЗЛ Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- select [ODBC]
ms.assetid: 2149c3ca-3a71-446d-8d53-3d056e2f301a
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 640189a5a31d0c21642b037e906bd6361690a9a5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81300944"
---
# <a name="select---sql-command"></a>SELECT (команда SQL)
Извлекает данные из одной или нескольких таблиц.  
  
 Visual FoxPro ODBC Driver поддерживает родной визуальный синтаксис языка FoxPro для этой команды. Для получения информации о конкретной для водителя **см.**  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SELECT [ALL | DISTINCT]  
   [Alias.] Select_Item [AS Column_Name]  
   [, [Alias.] Select_Item [AS Column_Name] ...]   
FROM [DatabaseName!]Table [Local_Alias]  
   [, [DatabaseName!]Table [Local_Alias] ...]   
[WHERE JoinCondition [AND JoinCondition  
...]  
   [AND | OR FilterCondition [AND | OR FilterCondition ...]]]  
[GROUP BY GroupColumn [, GroupColumn ...]]  
[HAVING FilterCondition]  
[UNION [ALL] SELECTCommand]  
[ORDER BY Order_Item [ASC | DESC] [, Order_Item [ASC | DESC] ...]]  
```  
  
## <a name="arguments"></a>Аргументы  
  
> [!NOTE]  
>  *Выкорок,* упомянутый в следующих аргументах, является SELECT в SELECT и должен быть заключен в скобки. Вы можете иметь до двух подзапросов на том же уровне (не вложенных) в оговорке WHERE. (См. этот раздел аргументов.) Подзапросы могут содержать несколько условий соединения.  
  
 (ВСЕ &#124; ОТЛИЧИЕ)   -"*Прозвище.* *Select_Item* «AS *Column_Name»,**«Прозвище».* *Select_Item* (AS *Column_Name*...  
 В пункте SELECT указаны поля, константы и выражения, отображаемые в результатах запроса.  
  
 По умолчанию ВСЕ отображает все строки в результатах запроса.  
  
 DISTINCT исключает дубликаты любых строк из результатов запроса.  
  
> [!NOTE]  
>  Вы можете использовать DISTINCT только один раз в пункте SELECT.  
  
 *Прозвище*. квалифицируется соответствующие имена элементов. Каждый элемент, указанный с *Select_Item* генерирует один столбец результатов запроса. Если два или более элементов имеют одно и то же имя, включите псевдоним таблицы и период до имени элемента, чтобы предотвратить дублирование столбцов.  
  
 *Select_Item* определяет элемент, который будет включен в результаты запроса. Элемент может быть одним из следующих:  
  
-   Название поля из таблицы в пункте FROM.  
  
-   Постоянное указание на то, что одно и то же постоянное значение должно отображаться в каждом ряду результатов запроса.  
  
-   Выражение, которое может быть именем функции, определяемой пользователем.  
  
 **Функции, определяемые пользователем с ПОМОЩЬю SELECT**  
  
 Хотя использование функций, определяемых пользователем в пункте SELECT, имеет очевидные преимущества, следует также рассмотреть следующие ограничения:  
  
-   Скорость операций, выполняемых с SELECT, может быть ограничена скоростью, с которой выполняются такие функции, определяемые пользователем. Высокообъемные манипуляции с функциями, определяемыми пользователями, могут быть лучше выполнены с помощью API и функций, определенных пользователем, написанных на языке C или сборки.  
  
-   Единственным надежным способом передачи значений функциям, на которые ссылаются пользователи, является список аргументов, передаваемый функции при вызове.  
  
-   Даже если вы поэкспериментируете и обнаружите якобы запрещенную манипуляцию, которая работает правильно в определенной версии FoxPro, нет никакой гарантии, что он будет продолжать работать в более поздних версиях.  
  
 Помимо этих ограничений, функции, определяемые пользователем, приемлемы в пункте SELECT. Однако помните, что использование SELECT может замедлить производительность.  
  
 Следующие полевые функции доступны для использования с выбранным элементом, который является полем или выражением, включающим поле:  
  
-   AVG *(Select_Item)*- Средний столбец численных данных.  
  
-   COUNT*Select_Item*(Select_Item)-Подсчитывает количество избранных элементов в столбце. С. С.. (К) подсчитывает количество строк в выходе запроса.  
  
-   MIN *(Select_Item)-Определяет*наименьшее значение *Select_Item* в столбце.  
  
-   MAX *(Select_Item)-Определяет*наибольшее значение *Select_Item* в столбце.  
  
-   SUM *(Select_Item)-Всего*столбец численных данных.  
  
 Вы не можете гнездить функции поля.  
  
 AS *Column_Name*  
 Осведёно заголовок для столбца в выводе запроса. Это полезно, когда *Select_Item* является выражением или содержит функцию поля, и вы хотите дать столбец значимое имя. *Column_Name* может быть выражением, но не может содержать символы (например, пробелы), которые не допускаются в названиях полей таблицы.  
  
 ИЗ *«DatabaseName*!» *Таблица* :*Local_Alias*,*«Имя базы данных»!* *Таблица* :*Local_Alias*...»  
 Списки таблиц, содержащих данные, которые получает запрос. Если таблица не открыта, Visual FoxPro отображает **окно Open** диалог, чтобы можно было указать местоположение файла. После его открытия таблица остается открытой после завершения запроса.  
  
 *База данныхИмя*! определяет название базы данных, кроме той, которая указана в источнике данных. Необходимо включить имя базы данных, содержащей таблицу, если база данных не указана с источником данных. Включите восклицательный знак (!) делимитетер после имени базы данных и перед именем таблицы.  
  
 *Local_Alias* указывает временное название таблицы, названной в *таблице*. Если вы указываете локальный псевдоним, необходимо использовать локальный псевдоним вместо названия таблицы во всей выписке SELECT. Местный псевдоним не влияет на среду Visual FoxPro.  
  
 ГДЕ *ПрисоединитьсяУсловие* (И *ПрисоединитьсяК* ...)    «И &#124; ИЛИ *ФильтрУсловие* »И &#124; или *ФильтрУсловие* ...»  
 Сообщает Visual FoxPro включить только определенные записи в результаты запроса. ГДЕ требуется для извлечения данных из нескольких таблиц.  
  
 *JoinCondition* определяет поля, которые связывают таблицы в пункте FROM. Если в запрос включено несколько таблиц, следует указать условие соединения для каждой таблицы после первого.  
  
> [!IMPORTANT]  
>  Рассмотрим следующую информацию при создании условий соединения:  
  
-   Если вы включили две таблицы в запрос и не указали условие соединения, каждая запись в первой таблице соединяется с каждой записью во второй таблице при условии, просиженных в фильтре. Такой запрос может привести к длительным результатам.  
  
-   Используйте осторожность при присоединении таблиц с пустыми полями, потому что Visual FoxPro соответствует пустым полям. Например, если вы присоединяетесь к CUSTOMER. ЗИП и INVOICE. Иесли CUSTOMER содержит 100 пустых почтовых индексов, а INVOICE содержит 400 пустых почтовых индексов, выход запроса содержит 40 000 дополнительных записей, полученных из пустых полей. Используйте функцию **EMPTY()** для устранения пустых записей из вывода запроса.  
  
-   Для подключения нескольких условий соединения необходимо использовать оператора AND. Каждое условие соединения имеет следующую форму:  
  
     *Полееимя FieldName1 Сравнение FieldName2*  
  
     *FieldName1* — это название поля из одной таблицы, *FieldName2* — это название поля из другой таблицы, а *Сравнение* — один из операторов, описанный в следующей таблице.  
  
|Оператор|Сравнение|  
|--------------|----------------|  
|=|Равно|  
|==|Точно равные|  
|LIKE|СЗЛ LIKE|  
|<>, !', #|Не равно|  
|>|Более|  
|>=|Более или равно|  
|<|Меньше чем|  
|<=|Меньше или равно|  
  
 Когда вы используете оператора со строками, он действует по-разному, в зависимости от настройки SET ANSI. Когда SET ANSI настроен на OFF, Visual FoxPro обрабатывает сравнение строк в порядке, знакомом пользователям Xbase. Когда SET ANSI настроен на ON, Visual FoxPro следует стандартам ANSI для сравнения строк. Смотрите [SET ANSI](../../odbc/microsoft/set-ansi-command.md) и [SET EXACT](../../odbc/microsoft/set-exact-command.md) для получения дополнительной информации о том, как Visual FoxPro выполняет сравнение строк.  
  
 *FilterCondition* определяет критерии, которым должны соответствовать записи, чтобы быть включенными в результаты запроса. Вы можете включить в запрос столько условий фильтра, сколько захотите, соединяя их с оператором AND или OR. Вы также можете использовать ОПЕРАТОРА NOT, чтобы изменить значение логического выражения, или вы можете использовать **EMPTY()** для проверки пустого поля. *FilterCondition* может принимать любые формы в следующих примерах:  
  
 **Пример 1** *Полеимен1 Сравнение FieldName2*  
  
 `customer.cust_id = orders.cust_id`  
  
 **Пример 2** *Выражение сравнения полевых имен*  
  
 `payments.amount >= 1000`  
  
 **Пример 3** *Полевое сравнение* ВСЕ (*Подкивы)*  
  
 `company < ALL ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Когда условие фильтра включает ВСЕ, поле должно соответствовать условию сравнения для всех значений, генерируемых вырезом, прежде чем его запись будет включена в результаты запроса.  
  
 **Пример 4** *Полевая ИменА Сравнение* любой &#124; SOME (*Подкаженное*)  
  
 `company < ANY ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Когда состояние фильтра включает В себя ЛЮБОе или SOME, поле должно соответствовать условию сравнения, по крайней мере для одного из значений, генерируемых выкорком.  
  
 Следующий пример проверяет, находятся ли значения в поле в пределах заданного диапазона значений:  
  
 **Пример 5** *Полевоеимя* имя (НЕ) МЕЖДУ *Start_Range* и *End_Range*  
  
 `customer.postalcode BETWEEN 90000 AND 99999`  
  
 Следующий пример проверяет, соответствует ли хотя бы одна строка критериям в подзапросе. Когда состояние фильтра включает EXISTS, состояние фильтра оценивается как True (. Т.), если только subquery оценивается в пустой набор.  
  
 **Пример 6** (НЕ) EXISTS *(Подкивы)*  
  
 `EXISTS ;`  
  
 `(SELECT * FROM orders WHERE customer.postalcode =`  
  
 `orders.postalcode)`  
  
 **Пример 7** *ПолеваяНаза* «НЕ» *в Value_Set*  
  
 `customer.postalcode NOT IN ("98052","98072","98034")`  
  
 Когда условие фильтра включает IN, поле должно содержать одно из значений, прежде чем его запись будет включена в результаты запроса.  
  
 **Пример 8** *Полевоеимя* ИМЯ (НЕ) В *(Подкевы)*  
  
 `customer.cust_id IN ;`  
  
 `(SELECT orders.cust_id FROM orders WHERE orders.city="Seattle")`  
  
 В данном месте поле должно содержать одно из значений, возвращенных подзапросом, прежде чем его запись будет включена в результаты запроса.  
  
 **Пример 9** *FieldName* (НЕ) LIKE *cExpression*  
  
 `customer.country NOT LIKE "USA"`  
  
 Это условие фильтра ищет для каждого поля, которое соответствует *cExpression.* Вы можете использовать знак процента (%) и подчеркнуть ( ) подстановочный знак символов как часть *cExpression*. Подчеркивание представляет собой одного неизвестного персонажа в строке.  
  
 GROUP BY *GroupColumn* *(GroupColumn...)*  
 Группирует строки в запросе на основе значений в одном или нескольких столбцах. *GroupColumn* может быть одним из следующих:  
  
-   Название обычного поля таблицы.  
  
-   Поле, включавщеввво функцию поля S'L.  
  
-   Численное выражение, указываюао расположение столбца в таблице результатов. (Самый левый номер столбца 1.)  
  
 HAVING *ФильтрУсловие*  
 Условляет условие фильтра, которое должны выполнятьгруппы для включения в результаты запроса. HAVING должны использоваться с GROUP BY и могут включать в себя столько условий фильтра, сколько вы хотите, подключенных И или или оператором. Вы также можете использовать NOT, чтобы обратить значение логического выражения.  
  
 *FilterCondition* не может содержать подкавку.  
  
 HAVING положение без положения GROUP BY ведет себя как положение ГДЕ. В пункте HAVING можно использовать локальные псевдонимы и полевые функции. Используйте положение WHERE для более высокой производительности, если пункт HAVING не содержит полевых функций.  
  
 (УНИОН (ВСЕ) *КОМАНДование SELECT*  
 Объединяет окончательные результаты одного SELECT с окончательными результатами другого SELECT. По умолчанию UNION проверяет комбинированные результаты и устраняет дубликаты строк. Используйте скобки для объединения нескольких положений UNION.  
  
 ВСЕ предотвращает UNION от устранения дубликатов строк из комбинированных результатов.  
  
 Положения UNION следуют следующим правилам:  
  
-   Вы не можете использовать UNION для объединения субзапросов.  
  
-   Обе команды SELECT должны иметь одинаковое количество столбцов в выходе запроса.  
  
-   Каждый столбец в результатах запроса одного SELECT должен иметь тот же тип и ширину данных, что и соответствующий столбец в другом SELECT.  
  
-   Только окончательный SELECT может иметь оговорку ORDER BY, которая должна относиться к выходным столбикам по номеру. Если включена оговорка ORDER BY, она влияет на полный результат.  
  
 Вы также можете использовать положение UNION для имитации внешнего соединения.  
  
 При соединении двух таблиц в запросе в вывод включены только записи с соответствующими значениями в присоединении полей. Если запись в родительской таблице не содержит соответствующей записи в таблице "ребенок", запись в родительской таблице не включена в вывод. Внешнее соединение позволяет включать все записи в таблицу родителей в выходные, вместе с соответствующими записями в таблице ребенка. Чтобы создать внешнее соединение в Visual FoxPro, необходимо использовать вложенную команду SELECT, как в следующем примере:  
  
```  
SELECT customer.company, orders.order_id, orders.emp_id ;  
FROM customer, orders ;  
WHERE customer.cust_id = orders.cust_id ;  
UNION ;  
SELECT customer.company, 0, 0 ;  
FROM customer ;  
WHERE customer.cust_id NOT IN ;  
(SELECT orders.cust_id FROM orders)  
```  
  
> [!NOTE]  
>  Убедитесь, что вы включаете пространство, которое сразу же предшествует каждой запятой. В противном случае вы получите ошибку.  
  
 Раздел команды перед положением UNION выбирает записи из обеих таблиц, которые имеют соответствующие значения. Компании-клиенты, не накоторых которых есть связанные счета-фактуры, не включены. Раздел команды после того, как положение UNION выбирает записи в таблице клиентов, которые не имеют соответствующих записей в таблице заказов.  
  
 Что касается второго раздела команды, обратите внимание на следующее:  
  
-   Заявление SELECT в скобках обрабатывается в первую очередь. Это заявление создает выбор всех номеров клиентов в таблице заказов.  
  
-   Пункт WHERE находит все номера клиентов в таблице клиентов, которые не находятся в таблице заказов. Поскольку в первом разделе команды были указаны все компании, у которых был номер клиента в таблице заказов, все компании в таблице клиентов теперь включены в результаты запроса.  
  
-   Поскольку структуры таблиц, включенных в UNION, должны быть идентичными, во втором отчете SELECT есть два заполнителя, которые представляют *заказы.order_id* и *orders.emp_id* из первого заявления SELECT.  
  
    > [!NOTE]  
    >  Заполнители должны быть того же типа, что и поля, которые они представляют. Если поле является типом даты, то заполнителем должен быть й / / . Если поле является полем символов, то заполнителем должна быть пустая строка ("").  
  
 ORDER *BY Order_Item* «ASC &#124; DESC» *(Order_Item* (ASC &#124; DESC) ...»  
 Сортирует результаты запроса на основе данных в одном или нескольких столбцах. Каждый *Order_Item* должен соответствовать столбцюку в результатах запроса и может быть одним из следующих:  
  
-   Поле в таблице FROM, которая также является выбранным элементом в основном положении SELECT (не в подкаске).  
  
-   Численное выражение, указываюао расположение столбца в таблице результатов. (Самая левая колонка — номер 1.)  
  
 ASC определяет возрастающий заказ для результатов запроса в соответствии с пунктом заказа или элементами, и является по умолчанию для ORDER BY.  
  
 DESC определяет убывающий заказ для результатов запроса.  
  
 Результаты запроса отображаются неупорядоченными, если вы не указали заказ с ORDER BY.  
  
## <a name="remarks"></a>Remarks  
 SELECT — это команда, встроенная в Visual FoxPro, как и любая другая команда Visual FoxPro. При использовании SELECT для запроса Visual FoxPro интерпретирует запрос и извлекает указанные данные из таблиц. Вы можете создать запрос SELECT из окна Command Prompt или программы Visual FoxPro (как и в любой другой команде Visual FoxPro).  
  
> [!NOTE]  
>  SELECT не уважает текущее состояние фильтра, указанное set FILTER.  
  
## <a name="driver-remarks"></a>Замечания водителя  
 Когда приложение отправляет заявление ODBC S'L SELECT в источник данных, водитель Visual FoxPro ODBC преобразует команду в команду Visual FoxPro SELECT без перевода, если только команда не содержит последовательность побега ODBC. Элементы, заключенные в последовательность побега ODBC, преобразуются в визуальный синтаксис FoxPro. Для получения дополнительной информации об использовании последовательностей побега *Microsoft ODBC Programmer's Reference*ODBC [см.](../../odbc/microsoft/time-and-date-functions-visual-foxpro-odbc-driver.md) [Escape Sequences in ODBC](../../odbc/reference/develop-app/escape-sequences-in-odbc.md)  
  
## <a name="see-also"></a>См. также:  
 [CREATE TABLE - СЗЛ](../../odbc/microsoft/create-table-sql-command.md)   
 [ВСТАВКА - СЗЛ](../../odbc/microsoft/insert-sql-command.md)   
 [SET ANSI](../../odbc/microsoft/set-ansi-command.md)   
 [УСТАНОВИТЬ ТОЧНЫЙ](../../odbc/microsoft/set-exact-command.md)
