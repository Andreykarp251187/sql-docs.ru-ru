---
title: Функция S'LFetchScroll (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLFetchScroll
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLFetchScroll
helpviewer_keywords:
- SQLFetchScroll function [ODBC]
ms.assetid: c0243667-428c-4dda-ae91-3c307616a1ac
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: b6c65ef71f5c2cb9202ab788cac5e00357674f4a
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285884"
---
# <a name="sqlfetchscroll-function"></a>Функция SQLFetchScroll
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **SLFetchScroll** изыскывает указанный набор данных из набора результатов и возвращает данные для всех связанных столбцов. Роусеты могут быть указаны в абсолютном или относительном положении или по закладке.  
  
 При работе с драйвером ODBC 2.x менеджер драйвера драйвера отображает эту функцию на **S'LExtendedFetch.** Для получения дополнительной [Mapping Replacement Functions for Backward Compatibility of Applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md)информации см.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLFetchScroll(  
      SQLHSTMT      StatementHandle,  
      SQLSMALLINT   FetchOrientation,  
      SQLLEN        FetchOffset);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *FetchOrientation*  
 (Вход)  
  
 Тип извлечения:  
  
 SQL_FETCH_NEXT  
  
 SQL_FETCH_PRIOR  
  
 SQL_FETCH_FIRST  
  
 SQL_FETCH_LAST  
  
 SQL_FETCH_ABSOLUTE  
  
 SQL_FETCH_RELATIVE  
  
 SQL_FETCH_BOOKMARK  
  
 Для получения дополнительной информации смотрите в разделе "Позиционирование курсора".  
  
 *FetchOffset*  
 (Вход)  
  
 Номер строки для получения. Толкование этого аргумента зависит от значения аргумента *FetchOrientation.* Для получения дополнительной информации смотрите в разделе "Позиционирование курсора".  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LFetchScroll** возвращается либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону s'LGetDiagRec** с помощью handleType of SQL_HANDLE_STMT и ручки обработки заявлений. В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LFetchScroll,** и приведены в контексте этой функции. нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное. Если на одном столбце произошла ошибка, можно вызвать **S'LGetDiagField** с помощью DiagIdentifier SQL_DIAG_COLUMN_NUMBER для определения столбца, на которую была допущена ошибка; и **S'LGetDiagField** можно вызвать с помощью DiagIdentifier SQL_DIAG_ROW_NUMBER для определения строки, содержащей эту колонку.  
  
 Для всех тех S'LSTATEs, которые могут вернуться SQL_SUCCESS_WITH_INFO или SQL_ERROR (кроме 01xxx S'LSTATEs), SQL_SUCCESS_WITH_INFO возвращается, если ошибка происходит на одном или нескольких, но не все строки многорычного операции, и SQL_ERROR возвращается, если ошибка происходит на однострокоперации.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Строка или двоичные данные, возвращенные для столбца, привели к усечению непустого символа или неnull двоичных данных. Если это было значение строки, то оно было правильно усечено.|  
|01S01|Ошибка в строке|Ошибка произошла при извлечении одного или нескольких строк.<br /><br /> (Если это приложение ODBC 3 .x возвращается, когда приложение ODBC 3 *.x* работает с драйвером ODBC 2 *.x,* его можно игнорировать.)|  
|01S06|Попытка получить до того, как набор результатов вернет первый ряд|Запрашиваемый ряд перекрывает начало набора результатов, когда FetchOrientation был SQL_FETCH_PRIOR, текущее положение было за пределами первого ряда, а число текущей строки меньше или равно размеру строки.<br /><br /> Запрашиваемый ряд перекрывает начало набора результатов, когда FetchOrientation был SQL_FETCH_PRIOR, текущее положение было за пределами конца набора результатов, а размер строки был больше, чем размер набора результатов.<br /><br /> Запрашиваемый ряд перекрывает начало набора результатов, когда FetchOrientation был SQL_FETCH_RELATIVE, FetchOffset был отрицательным, а абсолютное значение FetchOffset было меньше или равно размеру строки.<br /><br /> Запрашиваемый ряд перекрывает начало набора результатов, когда FetchOrientation был SQL_FETCH_ABSOLUTE, FetchOffset был отрицательным, а абсолютное значение FetchOffset было больше, чем размер набора результатов, но меньше или равен размеру строки.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Фракционная усечение|Данные, возвращенные для столбца, были усечены. Для численных типов данных дробная часть числа была усечена. Для типов времени, меток времени и интервалов данных, содержащих временной компонент, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|Значение данных столбца в наборе результатов не может быть преобразовано в тип данных, указанный *TargetType* в **S'LBindCol.**<br /><br /> Столбец 0 был связан с типом данных SQL_C_BOOKMARK, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен для SQL_UB_VARIABLE.<br /><br /> Столбец 0 был связан с типом данных SQL_C_VARBOOKMARK, и атрибут SQL_ATTR_USE_BOOKMARKS оператора не был установлен для SQL_UB_VARIABLE.|  
|07009|Недействительный индекс дескриптора|Драйвером был драйвер ODBC 2 *.x,* который не поддерживает **S'LExtendedFetch,** а номер столбца, указанный в привязке для столбца, был 0.<br /><br /> Колонка 0 была связана, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_OFF.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|22001|Строковые данные, правые усеченные|Закладка переменной длины, возвращенная для столбца, была усечена.|  
|22002|Переменная переменная индикатора требуется, но не поставляется|Данные NULL были извлечены в колонку, *StrLen_or_IndPtr* которой, установленный **S'LBindCol** (или SQL_DESC_INDICATOR_PTR, установленные **S'LSetDescField** или **S'LSetDescRec)** был нулевым указателем.|  
|22003|Числовое значение вне диапазона|Возвращение численного значения (в качестве численного или строки) для одного или нескольких связанных столбцов привело бы к тому, что вся (в отличие от дробной) часть числа была бы усечена.<br /><br /> Для получения дополнительной информации в [приложении D: Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md)см. [Converting Data from SQL to C Data Types](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md)|  
|22007|Недействительный формат дата-времени|Столбец символов в наборе результатов был привязан к структуре даты, времени или метки времени C, а значение в столбце было, соответственно, недействительной датой, временем или меткой времени.|  
|22012|Разделение на ноль|Значение из арифметического выражения было возвращено, что привело к разделению на ноль.|  
|22015|Переполниние поля интервала|Назначение от точного числа или интервала типа S'L к типу интервала C привело к потере значительных цифр в ведущем поле.<br /><br /> При извлечении данных в тип интервала C не было представлено значение типа S'L в типе интервала C.|  
|22018|Недействительное значение символов для спецификации литья|Столбец символа в наборе результатов был привязан к буферу символа C, а столбец содержал символ, для которого не было представления в наборе символов буфера.<br /><br /> Тип C был точным или приблизительным числом, временем даты или типом данных интервала; тип столбца s'L был типом данных символов; и значение в колонке не было действительным буквальным типа C.|  
|24 000|Недопустимое состояние курсора|*StatementHandle* находился в выполненном состоянии, но набор результатов не был связан с *statementHandle.*|  
|40001|Сбой сериализации|Сделка, в которой был выполнен вывод, была прекращена, чтобы предотвратить взаимоблокировку.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LFetchScroll.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Указанное *statementHandle* не находилось в выполненном состоянии. Функция была вызвана без предварительного вызова **s'LExecDirect**, **S'LExecute** или функции каталога.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) **S'LFetch** был вызван для *statementHandle* после того, как **sLExtendedFetch** был вызван и до **s'LFreeStmt** с SQL_CLOSE вариант был вызван.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|Атрибут SQL_ATTR_USE_BOOKMARK оператора был установлен для SQL_UB_VARIABLE, а столбец 0 был привязан к буферу, длина которого не была равна максимальной длине закладки для этого набора результатов. (Эта длина доступна в SQL_DESC_OCTET_LENGTH поле IRD и может быть получена по телефону **S'LDescribeCol**, **S'LColAttribute**, или **S'LGetDescfield**.)|  
|HY106|Тип извне диапазона|DM) Значение, указанное для аргумента FetchOrientation, было недействительным.<br /><br /> (DM) Аргумент FetchOrientation был SQL_FETCH_BOOKMARK, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_OFF.<br /><br /> Значение атрибута SQL_ATTR_CURSOR_TYPE оператора было SQL_CURSOR_FORWARD_ONLY, и значение аргумента FetchOrientation не было SQL_FETCH_NEXT.<br /><br /> Значение атрибута SQL_ATTR_CURSOR_SCROLLABLE оператора было SQL_NONSCROLLABLE, и значение аргумента FetchOrientation не было SQL_FETCH_NEXT.|  
|HY107|Значение строки вне диапазона|Значение, указанное в атрибуте SQL_ATTR_CURSOR_TYPE оператора, было SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное в атрибуте SQL_ATTR_KEYSET_SIZE оператора, превышало значение, указанное в атрибуте SQL_ATTR_ROW_ARRAY_SIZE оператора.|  
|HY111|Недействительная стоимость закладки|Аргумент FetchOrientation был SQL_FETCH_BOOKMARK, и закладка, указанная на значение в атрибуте SQL_ATTR_FETCH_BOOKMARK_PTR оператора, не действительна или является нулевой указателем.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает преобразование, указанное комбинацией *TargetType* в **S'LBindCol** и типом данных в соответствующем столбце.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул запрошенный набор результатов. Период тайм-аута устанавливается через s'LSetStmtAttr, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **S'LFetchScroll** возвращает определенный набор строк из набора результатов. Роусеты могут быть указаны в абсолютном или относительном положении или по закладке. **SLFetchScroll** можно вызывать только в то время, когда существует набор результатов, т.е. после вызова, который создает набор результатов, и до того, как курсор над набором результатов будет закрыт. Если какие-либо столбцы связаны, он возвращает данные в этих столбцах. Если приложение указало указатель на массив состояния строки или буфер, в котором можно вернуть количество строк, извлеченных, **S'LFetchScroll** возвращает и эту информацию. Звонки на **S'LFetchScroll** могут быть смешаны с вызовами на **S'LFetch,** но не могут быть смешаны с вызовами на **S'LExtendedFetch.**  
  
 Для получения дополнительной информации см. [Using Scrollable Cursors](../../../odbc/reference/develop-app/using-scrollable-cursors.md) [Using Block Cursors](../../../odbc/reference/develop-app/using-block-cursors.md)  
  
## <a name="positioning-the-cursor"></a>Позиционирование Курсора  
 При создании набора результатов курсор позиционируется до начала набора результатов. **S'LFetchScroll** позиционирует курсор блока на основе значений аргументов *FetchOrientation* и *FetchOffset,* как показано в следующей таблице. Точные правила определения начала нового набора строк отображаются в следующем разделе.  
  
|FetchOrientation|Значение|  
|----------------------|-------------|  
|SQL_FETCH_NEXT|Верните следующий ряд. Это эквивалентно вызову **S'LFetch**.<br /><br /> **S'LFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_PRIOR|Верните предыдущий набор строк.<br /><br /> **S'LFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_RELATIVE|Верните строку *FetchOffset* с начала текущего набора строк.|  
|SQL_FETCH_ABSOLUTE|Верните строку, начиная с строки *FetchOffset*.|  
|SQL_FETCH_FIRST|Верните первый ряд в наборе результатов.<br /><br /> **S'LFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_LAST|Верните последний полный набор строк в наборе результатов.<br /><br /> **S'LFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_BOOKMARK|Верните строки Rowset FetchOffset из закладки, указанной атрибутом SQL_ATTR_FETCH_BOOKMARK_PTR оператора.|  
  
 Водители не обязаны поддерживать все ориентации на получение; приложение вызывает **s'LGetInfo** с информационным типом SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 (в зависимости от типа курсора), чтобы определить, какие ориентации получения поддерживаются водителем. Приложение должно смотреть на SQL_CA1_NEXT, SQL_CA1_RELATIVE, SQL_CA1_ABSOLUTE и WQL_CA1_BOOKMARK бит-маски в этих типах информации. Кроме того, если курсор находится только вперед, а FetchOrientation не SQL_FETCH_NEXT, **S'LFetchScroll** возвращает S'LSTATE HY106 (тип Fetch вне диапазона).  
  
 Атрибут SQL_ATTR_ROW_ARRAY_SIZE оператора определяет количество строк в строке. Если набор строк, извлеченный **s'LFetchScroll,** перекрывает конец набора результатов, **S'LFetchScroll** возвращает частичный набор строк. То есть, если S и R - 1 больше, чем L, где S является стартовым рядом строки, извлеченной, R является размером рядов, а L является последним рядом в наборе результатов, то только первый L - S и 1 строка строки рядов действительны. Остальные строки пусты и имеют статус SQL_ROW_NOROW.  
  
 После возвращения **sLFetchScroll** текущая строка является первой строкой строки строки.  
  
## <a name="cursor-positioning-rules"></a>Правила позиционирования курсоров  
 В следующих разделах описывают точные правила для каждого значения FetchOrientation. В этих правилах используется следующая нотация.  
  
|Notation|Значение|  
|--------------|-------------|  
|*Перед началом*|Курсор блока расположен перед началом набора результатов. Если первая строка нового набора строк находится до начала набора результатов, **s'LFetchScroll** возвращается SQL_NO_DATA.|  
|*После окончания*|Курсор блока расположен после окончания набора результатов. Если первая строка нового строки находится после окончания набора результатов, **s'LFetchScroll** возвращается SQL_NO_DATA.|  
|*CurrRowsetStart*|Число первого ряда в текущем строке.|  
|*LastResultRow*|Число последней строки в наборе результатов.|  
|*RowsetSize*|Размер рядового набора.|  
|*FetchOffset*|Значение аргумента *FetchOffset.*|  
|*ЗакладкаРоу*|Строка, соответствующая закладке, указанной атрибутом SQL_ATTR_FETCH_BOOKMARK_PTR оператора.|  
  
## <a name="sql_fetch_next"></a>SQL_FETCH_NEXT  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*Перед началом*|1|  
|*CurrRowsetStart - RowsetSize* * \<*|*CurrRowsetStart - RowsetSize*|  
|*CurrRowsetStart - RowsetSize**> LastResultRow*|*После окончания*|  
|*После окончания*|*После окончания*|  
  
 Если размер строки был изменен со времени предыдущего вызова для получения строк, это размер строки, который был использован при предыдущем вызове.  
  
## <a name="sql_fetch_prior"></a>SQL_FETCH_PRIOR  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*Перед началом*|*Перед началом*|  
|*CurrRowsetStart No 1*|*Перед началом*|  
|*1 < CurrRowsetStart <* <sup>[2]</sup>|*1* <sup>(1)</sup>|  
|*CurrRowsetStart > RowsetSize* <sup>[2]</sup>|*CurrRowsetStart - RowsetSize* <sup>[2]</sup>|  
|*После конца и LastResultRow < RowsetSize* <sup>[2]</sup>|*1* <sup>(1)</sup>|  
|*После конца и LastResultRow >* <sup>[2]</sup>|*LastResultRow - RowsetSize No 1* <sup>[2]</sup>|  
  
 **SLFetchScroll** возвращает S'LSTATE 01S06 (Попытка получить до того, как набор результатов вернет первый ряд) и SQL_SUCCESS_WITH_INFO.  
  
 Если размер рядового был изменен со времени предыдущего вызова для получения строк, это новый размер строки.  
  
## <a name="sql_fetch_relative"></a>SQL_FETCH_RELATIVE  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*(Перед началом и FetchOffset > 0) ИЛИ (После конца и FetchOffset < 0)*|*--*<sup>(1)</sup>|  
|*Перед запуском и FetchOffset <No 0*|*Перед началом*|  
|*CurrRowsetStart No 1 И FetchOffset < 0*|*Перед началом*|  
|*CurrRowsetStart > 1 и CurrRowsetStart - FetchOffset < 1 и &#124; FetchOffset &#124; > RowsetSize* <sup>[3]</sup>|*Перед началом*|  
|*CurrRowsetStart > 1 И CurrRowsetStart - FetchOffset < 1 и &#124; FetchOffset &#124; <- RowsetSize* <sup>[3]</sup>|*1* <sup>(2)</sup>|  
|*1 <- CurrRowsetStart \<- FetchOffset - LastResultRow*|*CurrRowsetStart - FetchOffset*|  
|*CurrRowsetStart - FetchOffset > LastResultRow*|*После окончания*|  
|*После конца и FetchOffset >No 0*|*После окончания*|  
  
 ***S'LFetchScroll*** возвращает тот же ряд, как если бы он был вызван с FetchOrientation набор для SQL_FETCH_ABSOLUTE. Для получения дополнительной информации смотрите раздел "SQL_FETCH_ABSOLUTE".  
  
 **SLFetchScroll** возвращает S'LSTATE 01S06 (Попытка получить до того, как набор результатов вернет первую строку) и SQL_SUCCESS_WITH_INFO.  
  
 Если размер рядового был изменен со времени предыдущего вызова для получения строк, это новый размер строки.  
  
## <a name="sql_fetch_absolute"></a>SQL_FETCH_ABSOLUTE  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*FetchOffset < 0 И &#124; FetchOffset &#124; <- LastResultrow*|*LastResultRow - FetchOffset No 1*|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; > LastResultrow и &#124; FetchOffset &#124; > RowsetSize* <sup>[2]</sup>|*Перед началом*|  
|*FetchOffset < 0 И &#124; FetchOffset &#124; > LastResultrow И &#124; FetchOffset &#124; <* <sup>[2]</sup>|*1* <sup>(1)</sup>|  
|*FetchOffset No 0*|*Перед началом*|  
|*1 <- \<FetchOffset - LastResultRow*|*FetchOffset*|  
|*FetchOffset > LastResultRow*|*После окончания*|  
  
 **SLFetchScroll** возвращает S'LSTATE 01S06 (Попытка получить до того, как набор результатов вернет первый ряд) и SQL_SUCCESS_WITH_INFO.  
  
 Если размер рядового был изменен со времени предыдущего вызова для получения строк, это новый размер строки.  
  
 Абсолютный вывод, выполняемый против динамического курсора, не может обеспечить требуемый результат, поскольку строки в динамическом курсорах не определены. Такая операция эквивалентна получению первого, за которым следует родственник принести; это не атомная операция, как и абсолютный извлечение на статическом курсорах.  
  
## <a name="sql_fetch_first"></a>SQL_FETCH_FIRST  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*Любые*|*1*|  
  
## <a name="sql_fetch_last"></a>SQL_FETCH_LAST  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*Rowset <Size* <sup>[1]</sup>|*LastResultRow - RowsetSize No 1* <sup>[1]</sup>|  
|*RowsetSize* <sup>></sup> LastResultRow|*1*|  
  
 Если размер рядового был изменен со времени предыдущего вызова для получения строк, это новый размер строки.  
  
## <a name="sql_fetch_bookmark"></a>SQL_FETCH_BOOKMARK  
 Применяются следующие правила.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|*ЗакладкаРоу - FetchOffset < 1*|*Перед началом*|  
|*1 <- Закладная \<марка Роу и FetchOffset*|*ЗакладкаРоу - FetchOffset*|  
|*ЗакладкаРоу - FetchOffset > LastResultRow*|*После окончания*|  
  
 Для получения информации о закладках, см [Закладки (ODBC)](../../../odbc/reference/develop-app/bookmarks-odbc.md).  
  
## <a name="effect-of-deleted-added-and-error-rows-on-cursor-movement"></a>Влияние удаленных, добавленных и ошибок строк на движение Cursor  
 Статические курсоры и курсоры, управляемые ключами, иногда обнаруживают строки, добавленные в набор результатов, и удаляют строки, удаленные из набора результатов. Позвонив по телефону **s'LGetInfo** с SQL_STATIC_CURSOR_ATTRIBUTES2 и SQL_KEYSET_CURSOR_ATTRIBUTES2 опций и взглянув на SQL_CA2_SENSITIVITY_ADDITIONS, SQL_CA2_SENSITIVITY_DELETIONS и SQL_CA2_SENSITIVITY_UPDATES битмаски, приложение определяет, делают ли это курсоры, реализованные конкретным драйвером. Для драйверов, которые могут обнаружить удаленные строки и удалить их, следующие пункты описывают последствия этого поведения. Для драйверов, которые могут обнаружить удаленные строки, но не могут удалить их, удаления не влияют на движения курсора, и следующие абзацы не применяются.  
  
 Если курсор обнаруживает строки, добавленные в набор результатов, или удаляет строки, удаленные из набора результатов, он отображает сярприг, как будто он обнаруживает эти изменения только тогда, когда получает данные. Это включает в себя случай, когда **S'LFetchScroll** называется с FetchOrientation набор для SQL_FETCH_RELATIVE и FetchOffset набор для 0, чтобы refetch же rowset, но не включает в себя тот случай, когда S'LSetPos называется с fOption набор для SQL_REFRESH. В последнем случае данные в буферах строкобновляя обновляются, но не переназдаются, а удаленные строки не удаляются из набора результатов. Таким образом, когда строка удаляется из текущего набора строк или вставляется, курсор не изменяет буферы рядов. Вместо этого он обнаруживает изменение, когда получает любой ряд, который ранее включал удаленный ряд или теперь включает вставленную строку.  
  
 Пример:  
  
```cpp  
// Fetch the next rowset.  
SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);  
// Delete third row of the rowset. Does not modify the rowset buffers.  
SQLSetPos(hstmt, 3, SQL_DELETE, SQL_LOCK_NO_CHANGE);  
// The third row has a status of SQL_ROW_DELETED after this call.  
SQLSetPos(hstmt, 3, SQL_REFRESH, SQL_LOCK_NO_CHANGE);  
// Refetch the same rowset. The third row is removed, replaced by what  
// was previously the fourth row.  
SQLFetchScroll(hstmt, SQL_FETCH_RELATIVE, 0);  
```  
  
 Когда **S'LFetchScroll** возвращает новую строку, которая имеет позицию относительно текущего набора строк, т.е. FetchOrientation — это SQL_FETCH_NEXT, SQL_FETCH_PRIOR или SQL_FETCH_RELATIVE, он не включает изменения в текущий набор строк при расчете исходного положения нового рядового набора. Тем не менее, он включает изменения за пределами текущего набора строк, если он способен обнаруживать их. Кроме того, когда **S'LFetchScroll** возвращает новую строку, которая имеет позицию, не зависящая от текущего набора строк, т.е. FetchOrientation — это SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE или SQL_FETCH_BOOKMARK, он включает в себя все изменения, которые он способен обнаружить, даже если они находятся в текущем рядовом наборе.  
  
 При определении того, находятся ли новые добавленные строки внутри или за пределами текущего строки, считается, что частичный ряд заканчивается в последней действительной строке; то есть, последний ряд, для которого статус строки не является SQL_ROW_NOROW. Например, предположим, что курсор способен обнаруживать новые добавленные строки, текущий ряд — частичный ряд, приложение добавляет новые строки, а курсор добавляет эти строки в конец набора результатов. Если приложение вызывает **S'LFetchScroll** с набором FetchOrientation, чтобы SQL_FETCH_NEXT, **S'LFetchScroll** возвращает набор строк, начиная с первого недавно добавленного ряда.  
  
 Например, предположим, что текущий набор строк состоит из строк от 21 до 30, размер строки — 10, курсор удаляет строки, удаленные из набора результатов, а курсор обнаруживает строки, добавленные в набор результатов. В следующей таблице показаны строки **s'LFetchScroll** возвращается в различных ситуациях.  
  
|Change|Тип извлечения|FetchOffset|Новая строка|  
|------------|----------------|-----------------|---------------------|  
|Удалить строку 21|NEXT|0|от 31 до 40|  
|Удалить строку 31|NEXT|0|от 32 до 41|  
|Вставить строку между строками 21 и 22|NEXT|0|от 31 до 40|  
|Вставить строку между строками 30 и 31|NEXT|0|Вставленная строка, от 31 до 39|  
|Удалить строку 21|PRIOR|0|от 11 до 20|  
|Удалить строку 20|PRIOR|0|от 10 до 19|  
|Вставить строку между строками 21 и 22|PRIOR|0|от 11 до 20|  
|Вставить строку между строками 20 и 21|PRIOR|0|от 12 до 20, вставленный ряд|  
|Удалить строку 21|RELATIVE|0|от 22 до<sup>31</sup>|  
|Удалить строку 21|RELATIVE|1|от 22 до 31|  
|Вставить строку между строками 21 и 22|RELATIVE|0|21, вставленный ряд, от 22 до 29|  
|Вставить строку между строками 21 и 22|RELATIVE|1|от 22 до 31|  
|Удалить строку 21|ABSOLUTE|21|от 22 до<sup>31</sup>|  
|Удалить строку 22|ABSOLUTE|21|от 21, 23 до 31|  
|Вставить строку между строками 21 и 22|ABSOLUTE|22|Вставленная строка, от 22 до 29|  
  
 В этом столбце используются строки, прежде чем какие-либо строки были вставлены или удалены.  
  
 В этом случае курсор пытается вернуть строки, начиная с строки 21. Поскольку строка 21 была удалена, первая строка, которая возвращается, — строка 22.  
  
 Строки ошибок (т.е. строки со статусом SQL_ROW_ERROR) не влияют на движение курсора. Например, если текущий набор строк начинается с строки 11, а статус строки 11 SQL_ROW_ERROR, вызов **S'LFetchScroll** с набором FetchOrientation SQL_FETCH_RELATIVE и FetchOffset набор 5 возвращает строку, начиная с строки 16, так же, как это было бы, если статус строки 11 был SQL_SUCCESS.  
  
## <a name="returning-data-in-bound-columns"></a>Возвращение данных в связанных столбцах  
 **SLFetchScroll** возвращает данные в связанных столбцах так же, как **s'LFetch**. Для получения дополнительной информации, см. [SQLFetch Function](../../../odbc/reference/syntax/sqlfetch-function.md)  
  
 Если столбцы не связаны, **S'LFetchScroll** не возвращает данные, но перемещает курсор блока в указанное положение. Можно ли извлечь данные из несвязанных столбцов курсора блока с **помощью S'LGetData,** зависит от драйвера. Эта возможность поддерживается, если вызов в **S'LGetInfo** возвращает SQL_GD_BLOCK бит для SQL_GETDATA_EXTENSIONS типа информации.  
  
## <a name="buffer-addresses"></a>Баффер Адреса  
 **Для** определения адреса данных и буферов длины/индикатора, как **s'LFetchScroll,** используется та же формула. Для получения дополнительной информации, [SQLBindCol Function](../../../odbc/reference/syntax/sqlbindcol-function.md)см.  
  
## <a name="row-status-array"></a>Массив статусов строк  
 **SLFetchScroll** устанавливает значения в массиве статуса строки так же, как и S'LFetch. Для получения дополнительной информации, см. [SQLFetch Function](../../../odbc/reference/syntax/sqlfetch-function.md)  
  
## <a name="rows-fetched-buffer"></a>Строки Fetched буфер  
 **SLFetchScroll** возвращает количество строк, извлеченных в строках, извлеченных буфера таким же образом, как **s'LFetch**. Для получения дополнительной информации, см. [SQLFetch Function](../../../odbc/reference/syntax/sqlfetch-function.md)  
  
## <a name="error-handling"></a>Обработка ошибок  
 Когда приложение вызывает **S'LFetchScroll** в драйвере ODBC 3.x, менеджер драйвера вызывает **s'LFetchScroll** в драйвере. Когда приложение вызывает **S'LFetchScroll** в драйвере ODBC 2.x, менеджер драйвера драйвера вызывает S'LExtendedFetch в драйвере. Из-за того, что **s'LFetchScroll** и S'LExtendedFetch обрабатывают ошибки несколько иным образом, приложение видит несколько иное поведение ошибок, когда оно вызывает **S'LFetchScroll** в драйверах ODBC 2.x и ODBC 3.x.  
  
 **SLFetchScroll** возвращает ошибки и предупреждения таким же образом, как **s'LFetch;** для получения дополнительной информации, **SQLFetch**см. **СЗЛРасширенныйЧприносит** возвращает ошибки таким же образом, как **и S'LFetch,** с следующими исключениями:  
  
 При возникновении предупреждения, которое применяется к определенной строке в строке, S'LExtendedFetch устанавливает соответствующую запись в массиве состояния строки для SQL_ROW_SUCCESS, а не SQL_ROW_SUCCESS_WITH_INFO.  
  
 Если ошибки возникают в каждой строке в строке, s'LExtendedFetch возвращает SQL_SUCCESS_WITH_INFO, а не SQL_ERROR.  
  
 В каждой группе записей статуса, применимых к отдельной строке, первая запись статуса, возвращенная S'LExtendedFetch, должна содержать S'LSTATE 01S01 (Ошибка в строке); **S'LFetchScroll** не возвращает этот S'Lstate. Если S'LExtendedFetch не может вернуть дополнительные S'LSTATEs, он все равно должен вернуть этот S'LSTATE.  
  
## <a name="sqlfetchscroll-and-optimistic-concurrency"></a>СЗЛКТвкинт и Оптимистичная параллелизм  
 Если курсор использует оптимистичную параллелизм, т.е. атрибут SQL_ATTR_CONCURRENCY оператора имеет значение SQL_CONCUR_VALUES или SQL_CONCUR_ROWVER - **S'LFetchScroll** обновляет оптимистичные значения параллелизма, используемые источником данных для определения того, изменилась ли строка. Это происходит всякий раз, когда **S'LFetchScroll** получает новый набор строк, в том числе, когда он refetches текущего набора строк. (Это называется с FetchOrientation набор для SQL_FETCH_RELATIVE и FetchOffset набор 0.)  
  
## <a name="sqlfetchscroll-and-odbc-2x-drivers"></a>Драйверы S'LFetchScroll и ODBC 2.x  
 Когда приложение вызывает **S'LFetchScroll** в драйвере ODBC 2.x, менеджер драйвера драйвера драйвера драйвера драйвера драйвера определяется на **sLExtendedFetch.** Он передает следующие значения для аргументов **S'LExtendedFetch**.  
  
|Аргумент «СЗЛРасширенныйС»|Значение|  
|-------------------------------|-----------|  
|Обработка заявления|Выписка Ручка в **S'LFetchScroll**.|  
|FetchOrientation|FetchOrientation в **S'LFetchScroll**.|  
|FetchOffset|Если FetchOrientation не является SQL_FETCH_BOOKMARK, то используется значение аргумента FetchFetchв в **S'LFetchScroll.**<br /><br /> Если FetchOrientation является SQL_FETCH_BOOKMARK, используется значение, хранящееся по адресу, указанному атрибутом SQL_ATTR_FETCH_BOOKMARK_PTR оператора.|  
|RowCountPtr|Адрес, указанный атрибутом SQL_ATTR_ROWS_FETCHED_PTR оператора.|  
|РоуСтатусстрарейрей|Адрес, указанный атрибутом SQL_ATTR_ROW_STATUS_PTR оператора.|  
  
 Для получения дополнительной информации в приложении G: Driver Guidelines for Backward Comatibility можно ознакомиться с [Block Cursors, Scrollable Cursors и обратной совместимости.](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md)  
  
## <a name="descriptors-and-sqlfetchscroll"></a>Дескрипторы и S'LFetchScroll  
 **СЗЛУТСПротальт** взаимодействует с дескрипторами так же, как **и S'LFetch.** Для получения более подробной информации, см. [SQLFetch Function](../../../odbc/reference/syntax/sqlfetch-function.md)  
  
## <a name="code-example"></a>Пример кода  
 [См. Колонка-Мудрый Связывание](../../../odbc/reference/develop-app/column-wise-binding.md), [Строка-Мудрый Связывание](../../../odbc/reference/develop-app/row-wise-binding.md), [Позиционированное обновление и удаление заявлений](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md), и [Обновление строк в Rowset с S'LSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение операций по массовой вставке, обновлению или удалению|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение информации о столбце в наборе результатов|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Получение одной строки или блока данных в направлении только вперед|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Закрытие курсора на выписке|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращение числа столбцов набора результатов|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Позиционирование курсора, обновление данных в строке или обновление или удаляние данных в наборе результатов|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|Установка атрибута оператора|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
