---
title: Функция SQLFetchScroll | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLFetchScroll
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLFetchScroll
helpviewer_keywords:
- SQLFetchScroll function [ODBC]
ms.assetid: c0243667-428c-4dda-ae91-3c307616a1ac
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 20a1580503ad141817edcf8e01772dfcc8dc39a3
ms.sourcegitcommit: 7a3243c45830cb3f49a7fa71c2991a9454fd6f5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/11/2019
ms.locfileid: "65537357"
---
# <a name="sqlfetchscroll-function"></a>Функция SQLFetchScroll
**Соответствие стандартам**  
 Представленные версии: ODBC 3.0 стандартов соответствия: ISO-92  
  
 **Сводка**  
 **SQLFetchScroll** Извлекает указанный набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов. Наборы строк можно указать в абсолютные или относительные позиции или по закладкам.  
  
 При работе с драйвером ODBC 2.x, диспетчер драйверов сопоставляет эту функцию для **SQLExtendedFetch**. Дополнительные сведения см. в разделе [сопоставление замещающих функций для обеспечения обратной совместимости приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLFetchScroll(  
      SQLHSTMT      StatementHandle,  
      SQLSMALLINT   FetchOrientation,  
      SQLLEN        FetchOffset);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *FetchOrientation*  
 [Вход]  
  
 Тип выборки:  
  
 SQL_FETCH_NEXT  
  
 SQL_FETCH_PRIOR  
  
 SQL_FETCH_FIRST  
  
 SQL_FETCH_LAST  
  
 SQL_FETCH_ABSOLUTE  
  
 SQL_FETCH_RELATIVE  
  
 SQL_FETCH_BOOKMARK  
  
 Дополнительные сведения см. в разделе «Позиционирования курсора» в разделе «Примечания».  
  
 *FetchOffset*  
 [Вход]  
  
 Количество строк для выборки. Интерпретация этого аргумента зависит от значения *FetchOrientation* аргумент. Дополнительные сведения см. в разделе «Позиционирования курсора» в разделе «Примечания».  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLFetchScroll** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с HandleType значение SQL_HANDLE_STMT и дескриптор StatementHandle. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLFetchScroll** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное. При возникновении ошибки по одному столбцу, **SQLGetDiagField** может вызываться с DiagIdentifier SQL_DIAG_COLUMN_NUMBER для определения столбца, произошла ошибка; в противном и **SQLGetDiagField** может вызываться с помощью DiagIdentifier SQL_DIAG_ROW_NUMBER для определения строки, содержащий этот столбец.  
  
 Для всех этих SQLSTATE, которые могут возвращать значение SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением SQLSTATE 01xxx) возвращается SQL_SUCCESS_WITH_INFO, если в одной или нескольким, но не все строки многострочной операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка Операция одной строки.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение данных строки справа|Строка или двоичные данные, возвращаемые для столбца привело к усечение непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усекаются справа.|  
|01S01|Ошибка в строке|Произошла ошибка при извлечении одной или нескольких строк.<br /><br /> (Если это SQLSTATE возвращается в том случае, если ODBC 3 *.x* при работе с ODBC 2 *.x* драйвер, его можно пропустить.)|  
|01S06|Попытка выборки до появления результирующий набор, возвращаемый первый набор строк|Запрошенный набор строк overlapped начало результирующего набора при FetchOrientation был SQL_FETCH_PRIOR, текущая позиция оказалась вне пределов первой строки и номер текущей строки меньше или равен размеру набора строк.<br /><br /> Запрошенный набор строк overlapped начала результирующий набор, если FetchOrientation был SQL_FETCH_PRIOR, текущую позицию за пределами результирующего набора, и размер набора строк больше размер набора результатов.<br /><br /> Запрошенный набор строк overlapped начала результирующий набор, если FetchOrientation был SQL_FETCH_RELATIVE FetchOffset было отрицательным и абсолютное значение FetchOffset была меньше или равно размеру набора строк.<br /><br /> Запрошенный набор строк overlapped начала результирующий набор, если FetchOrientation был SQL_FETCH_ABSOLUTE FetchOffset было отрицательным и абсолютное значение FetchOffset было больше размер набора результатов, но меньше или равно размеру набора строк.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S07|Частичное усечение|Данные, возвращенные для столбца были усечены. Для числовых типов данных был усечен, дробная часть числа. Для времени, timestamp и интервальных типов данных, содержащего компонент времени десятичная часть времени были усечены.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе не удалось преобразовать тип данных, указанный в *TargetType* в **SQLBindCol**.<br /><br /> Столбец 0 был связан с типом данных SQL_C_BOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE.<br /><br /> Столбец 0 был связан с типом данных SQL_C_VARBOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS не было присвоено SQL_UB_VARIABLE.|  
|07009|Недопустимый индекс дескриптора|Драйвер был ODBC 2 *.x* драйвер, который не поддерживает **SQLExtendedFetch**, и номер столбца, указанный в привязке для столбца было равно 0.<br /><br /> Столбец 0 был привязан, и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_OFF.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22001|Усечение данных строки справа|Возвращено для столбца переменной длины закладки были усечены.|  
|22002|Переменная индикатора требуется, но не указано|NULL получения данных в столбец, *StrLen_or_IndPtr* задается **SQLBindCol** (или задается SQL_DESC_INDICATOR_PTR **SQLSetDescField** или  **SQLSetDescRec**) был пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение (в виде строк или чисел) для одного или нескольких привязанных столбцов вызвало бы всего (в отличие от долей) часть усекаемое число.<br /><br /> Дополнительные сведения см. в разделе [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в [приложение г Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе была привязана к даты, времени или структура отметки времени C, а значение в столбце было, соответственно, при обнаружении неверной даты, времени или метки времени.|  
|22012|Деление на ноль|Значение от арифметического выражения было возвращено, что привело к деления на ноль.|  
|22015|Переполнение поля интервала|Назначение на основе точное числовое значение или интервал тип SQL тип интервала C привело к потере значащих разрядов в начале поля.<br /><br /> При получении данных в тип интервала C, возникла не представление значения типа SQL в тип интервала C.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе была привязана к буфера символов C, а столбец содержится символ, для которого отсутствует представление, отсутствует в наборе символов из буфера.<br /><br /> Тип C был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.|  
|24000|Недопустимое состояние курсора|*StatementHandle* была выполненного состоянии, но результирующий набор не связан с *StatementHandle*.|  
|40001|Сбой сериализации|Транзакции, в котором был выполнен fetch был завершен для недопущения взаимоблокировок.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция был снова вызван для *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLFetchScroll** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполненного. Функция был вызван без предварительного вызова функции **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) **SQLFetch** был вызван для *StatementHandle* после **SQLExtendedFetch** был вызван и перед **SQLFreeStmt** с SQL_ Параметр «ЗАКРЫТЬ» был вызван.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Атрибут инструкции SQL_ATTR_USE_BOOKMARK было присвоено SQL_UB_VARIABLE, а столбец 0 была привязана к буфер, длина которого не равна длине максимального закладки для данного результирующего набора. (Эта длина доступен в поле SQL_DESC_OCTET_LENGTH IRD и может быть получен путем вызова **SQLDescribeCol**, **SQLColAttribute**, или **SQLGetDescField**.)|  
|HY106|Тип выборки за пределами диапазона|Интеллектуальный анализ данных) Недопустимое значение, указанное для аргумента FetchOrientation.<br /><br /> (DM) аргумент FetchOrientation был sql_fetch_bookmark аргумента, и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_OFF.<br /><br /> Значение атрибута SQL_ATTR_CURSOR_TYPE инструкции было SQL_CURSOR_FORWARD_ONLY, а значение аргумента, что FetchOrientation не SQL_FETCH_NEXT.<br /><br /> Значение атрибута инструкции SQL_ATTR_CURSOR_SCROLLABLE было SQL_NONSCROLLABLE, а значение аргумента, что FetchOrientation не SQL_FETCH_NEXT.|  
|HY107|Значение строки за пределами диапазона|Значение, указанное в инструкции атрибута SQL_ATTR_CURSOR_TYPE был SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное с помощью атрибута SQL_ATTR_KEYSET_SIZE атрибут инструкции больше 0 и меньше, чем значение, указанное с помощью SQL_ATTR_ROW_ARRAY_ Атрибут инструкции размер.|  
|HY111|Недопустимое значение закладки|Аргумент FetchOrientation было sql_fetch_bookmark аргумента, и закладка, на которые указывают значение атрибута инструкции SQL_ATTR_FETCH_BOOKMARK_PTR недействителен или был пустым указателем.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяемое сочетание *TargetType* в **SQLBindCol** и тип данных SQL соответствующего столбца.|  
|HYT00|Время ожидания истекло|Истекло время ожидания запроса перед источника данных, возвращаемого набора требуемого результата. SQLSetStmtAttr, SQL_ATTR_QUERY_TIMEOUT задается истечения времени ожидания.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **SQLFetchScroll** возвращает указанного набора строк из результирующего набора. Наборы строк можно указать абсолютное или относительное положение или закладка. **SQLFetchScroll** может вызываться, только пока существует результирующий набор — то есть после вызова, который создает результирующий набор и до курсора over, сам себя результирующий набор закрыт. Если какие-либо столбцы привязаны, он возвращает данные в этих столбцах. Если приложение указатель на массив состояния строк или буфер, в которую будет возвращено число возвращаемых строк, **SQLFetchScroll** возвращает эти сведения также. Вызовы **SQLFetchScroll** можно комбинировать с вызовами **SQLFetch** , но нельзя комбинировать с вызовами **SQLExtendedFetch**.  
  
 Дополнительные сведения см. в разделе [использование блочных курсоров](../../../odbc/reference/develop-app/using-block-cursors.md) и [с помощью Прокручиваемые курсоры](../../../odbc/reference/develop-app/using-scrollable-cursors.md).  
  
## <a name="positioning-the-cursor"></a>Позиционирование курсора  
 При создании результирующего набора, курсор располагается перед началом результирующего набора. **SQLFetchScroll** помещает блок курсора, в зависимости от значения *FetchOrientation* и *FetchOffset* аргументы, как показано в следующей таблице. В следующем разделе показаны конкретные правила для определения начала нового набора строк.  
  
|FetchOrientation|Значение|  
|----------------------|-------------|  
|SQL_FETCH_NEXT|Возвращает следующий набор строк. Это эквивалентно вызову **SQLFetch**.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_PRIOR|Возвращает предыдущий набор строк.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_RELATIVE|Возвращает набор строк *FetchOffset* от начала текущего набора строк.|  
|SQL_FETCH_ABSOLUTE|Возвращают набор строк, начиная со строки *FetchOffset*.|  
|SQL_FETCH_FIRST|Возвращает первый набор строк в результирующем наборе.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_LAST|Возвращает последний полный набор строк в результирующем наборе.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_BOOKMARK|Возвращает набор строк FetchOffset строки из закладки, указанном в атрибуте инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
  
 Драйверы не требуются для поддержки всех ориентациях выборки; приложение вызывает **SQLGetInfo** с типом сведения SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 (в зависимости от типа курсора) чтобы определить, какие выборки драйвер поддерживает ориентации. Просмотрите приложения и SQL_CA1_NEXT, SQL_CA1_RELATIVE, SQL_CA1_ABSOLUTE и WQL_CA1_BOOKMARK битовой маски в эти типы сведений. Кроме того, если курсор может перемещаться только вперед и FetchOrientation не SQL_FETCH_NEXT, **SQLFetchScroll** возвращает SQLSTATE HY106 (тип выборки за пределами диапазона).  
  
 Атрибут SQL_ATTR_ROW_ARRAY_SIZE инструкции указывает количество строк в наборе строк. Если набор строк к получению с **SQLFetchScroll** перекрывается конец результирующего набора, **SQLFetchScroll** возвращает частичный набор строк. То есть если S + R - 1 больше, чем L, где S — начальной строки набора строк к получению R — размер набора строк, а L является последней строки в результирующем наборе, затем первый L - S + 1 строк для набора строк являются допустимыми. Оставшиеся строки являются пустыми и имеют статус SQL_ROW_NOROW.  
  
 После **SQLFetchScroll** возвращает, текущая строка является первой строки набора строк.  
  
## <a name="cursor-positioning-rules"></a>Правила позиционирования курсора  
 В следующих разделах описаны конкретные правила для каждого значения FetchOrientation. Эти правила нотация.  
  
|Нотация|Значение|  
|--------------|-------------|  
|*Перед запуском*|Блок курсор располагается перед началом результирующего набора. Перед началом результирующего набора, если первая строка новый набор строк **SQLFetchScroll** не вернет значение SQL_NO_DATA.|  
|*После окончания*|Блок курсор располагается после конец результирующего набора. Если первая строка новый набор строк находится в конце результирующего набора, **SQLFetchScroll** не вернет значение SQL_NO_DATA.|  
|*CurrRowsetStart*|Номер первой строки в текущем наборе строк.|  
|*LastResultRow*|Номер последней строки в результирующем наборе.|  
|*RowsetSize*|Размер набора строк.|  
|*FetchOffset*|Значение *FetchOffset* аргумент.|  
|*BookmarkRow*|Строку, соответствующую закладку, указанном в атрибуте инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
  
## <a name="sqlfetchnext"></a>SQL_FETCH_NEXT  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*Перед запуском*|1|  
|*CurrRowsetStart + RowsetSize*[1]  *\<= LastResultRow*|*CurrRowsetStart + RowsetSize*[1]|  
|*CurrRowsetStart + RowsetSize*[1]*> LastResultRow*|*После окончания*|  
|*После окончания*|*После окончания*|  
  
 [1] Если размер набора строк были изменены с момента предыдущего вызова метода для получения строк, это размер набора строк, который использовался с предыдущим вызовом функции.  
  
## <a name="sqlfetchprior"></a>SQL_FETCH_PRIOR  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*Перед запуском*|*Перед запуском*|  
|*CurrRowsetStart = 1*|*Перед запуском*|  
|*1 < CurrRowsetStart < = RowsetSize* <sup>[2].</sup>|*1* <sup>[1]</sup>|  
|*CurrRowsetStart > RowsetSize* <sup>[2]</sup>|*CurrRowsetStart - RowsetSize* <sup>[2]</sup>|  
|*После окончания и LastResultRow < RowsetSize* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*После окончания LastResultRow и > = RowsetSize* <sup>[2]</sup>|*LastResultRow - RowsetSize + 1* <sup>[2].</sup>|  
  
 [1] **SQLFetchScroll** возвращает SQLSTATE 01S06 (которые попытка выборки до появления результирующий набор, возвращаемый первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [2] Если размер набора строк были изменены с момента предыдущего вызова метода для получения строк, это новый размер набора строк.  
  
## <a name="sqlfetchrelative"></a>SQL_FETCH_RELATIVE  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*(Перед работы и FetchOffset > 0) ИЛИ (после окончания и FetchOffset < 0)*|*--* <sup>[1]</sup>|  
|*BeforeStart AND FetchOffset <= 0*|*Перед запуском*|  
|*CurrRowsetStart = 1 и FetchOffset < 0*|*Перед запуском*|  
|*CurrRowsetStart > 1 AND CurrRowsetStart + FetchOffset < 1 AND &#124; FetchOffset &#124; > RowsetSize* <sup>[3]</sup>|*Перед запуском*|  
|*CurrRowsetStart > 1 AND CurrRowsetStart + FetchOffset < 1 AND &#124; FetchOffset &#124; < = RowsetSize* <sup>[3]</sup>|*1* <sup>[2]</sup>|  
|*1 < = CurrRowsetStart + FetchOffset \<= LastResultRow*|*CurrRowsetStart + FetchOffset*|  
|*CurrRowsetStart + FetchOffset > LastResultRow*|*После окончания*|  
|*После окончания FetchOffset и > = 0*|*После окончания*|  
  
 [1] ***SQLFetchScroll*** возвращает набор строк, тем же, как если бы он был вызван с FetchOrientation присвоено SQL_FETCH_ABSOLUTE. Дополнительные сведения см. в разделе «SQL_FETCH_ABSOLUTE».  
  
 [2] **SQLFetchScroll** возвращает SQLSTATE 01S06 (которые попытка выборки до появления результирующий набор, возвращаемый первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [3] Если размер набора строк были изменены с момента предыдущего вызова метода для получения строк, это новый размер набора строк.  
  
## <a name="sqlfetchabsolute"></a>SQL_FETCH_ABSOLUTE  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; < = LastResultRow*|*LastResultRow + FetchOffset + 1*|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; > LastResultRow AND &#124; FetchOffset &#124; > RowsetSize* <sup>[2]</sup>|*Перед запуском*|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; > LastResultRow AND &#124; FetchOffset &#124; < = RowsetSize* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*FetchOffset = 0*|*Перед запуском*|  
|*1 < = FetchOffset \<= LastResultRow*|*FetchOffset*|  
|*FetchOffset > LastResultRow*|*После окончания*|  
  
 [1] **SQLFetchScroll** возвращает SQLSTATE 01S06 (которые попытка выборки до появления результирующий набор, возвращаемый первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [2] Если размер набора строк были изменены с момента предыдущего вызова метода для получения строк, это новый размер набора строк.  
  
 Абсолютная выборка выполняются для динамического курсора не может предоставить требуемый результат, так как строки в динамический курсор имеют невыясненной. Такая операция эквивалентно выборки после выборки относительный; он не является атомарной операцией, как абсолютная выборка для статического курсора.  
  
## <a name="sqlfetchfirst"></a>SQL_FETCH_FIRST  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*Любой*|*1*|  
  
## <a name="sqlfetchlast"></a>SQL_FETCH_LAST  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*RowsetSize* <sup>[1]</sup> < = LastResultRow|*LastResultRow - RowsetSize + 1* <sup>[1]</sup>|  
|*RowsetSize* <sup>[1]</sup> > LastResultRow|*1*|  
  
 [1] Если размер набора строк были изменены с момента предыдущего вызова метода для получения строк, это новый размер набора строк.  
  
## <a name="sqlfetchbookmark"></a>SQL_FETCH_BOOKMARK  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*BookmarkRow + FetchOffset < 1*|*Перед запуском*|  
|*1 < = BookmarkRow + FetchOffset \<= LastResultRow*|*BookmarkRow + FetchOffset*|  
|*BookmarkRow + FetchOffset > LastResultRow*|*После окончания*|  
  
 Сведения о закладках см. в разделе [закладки (ODBC)](../../../odbc/reference/develop-app/bookmarks-odbc.md).  
  
## <a name="effect-of-deleted-added-and-error-rows-on-cursor-movement"></a>Эффект удаленные, добавленных и ошибочных строк в движение курсора  
 Статические и управляемые набором ключей курсоры иногда обнаружить строки, добавленные к результату, установки и удаления строк, удаленных из результирующего набора. Путем вызова **SQLGetInfo** SQL_STATIC_CURSOR_ATTRIBUTES2 и SQL_KEYSET_CURSOR_ATTRIBUTES2 параметры и посмотреть на SQL_CA2_SENSITIVITY_ADDITIONS, SQL_CA2_SENSITIVITY_DELETIONS и SQL_CA2_SENSITIVITY_ Битовые маски обновления, приложение определяет этого ли курсоры, реализуемые конкретный драйвер. Для драйверов, которые можно обнаружить удаленные строки и удалите их ниже описаны последствия этого поведения. Для драйверов, которые может обнаружить удаленные строки, но не может удалить их удаления не оказывают влияния на интерфейсных и ниже не применяются.  
  
 Если курсор определяет строки, добавленные к результирующему набору, или удаляет строки, удаленные из результирующего набора, он отображается, как если бы он обнаруживает эти изменения только в том случае, если этот метод извлекает данные. Это включает случай при **SQLFetchScroll** вызывается с FetchOrientation SQL_FETCH_RELATIVE и FetchOffset, равным 0 к повторному получению же набор строк, но не поддерживает так, при вызове SQLSetPos присвоено SQL_ fOption ОБНОВЛЕНИЕ. В последнем случае обновления данных в буферах набора строк, но не refetched и удаленные строки не удаляются из результирующего набора. Таким образом Если строка удаляется из или вставлены в текущем наборе строк, курсор не изменяет буферы строк. Вместо этого он обнаруживает изменения при выборке любого набора строк, ранее включенные удаленную строку или теперь включает вставленной строки.  
  
 Пример:  
  
```cpp  
// Fetch the next rowset.  
SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);  
// Delete third row of the rowset. Does not modify the rowset buffers.  
SQLSetPos(hstmt, 3, SQL_DELETE, SQL_LOCK_NO_CHANGE);  
// The third row has a status of SQL_ROW_DELETED after this call.  
SQLSetPos(hstmt, 3, SQL_REFRESH, SQL_LOCK_NO_CHANGE);  
// Refetch the same rowset. The third row is removed, replaced by what  
// was previously the fourth row.  
SQLFetchScroll(hstmt, SQL_FETCH_RELATIVE, 0);  
```  
  
 Когда **SQLFetchScroll** возвращает новый набор строк, который имеет положение относительно текущего набора строк — то есть FetchOrientation SQL_FETCH_NEXT, SQL_FETCH_PRIOR или SQL_FETCH_RELATIVE — он не включает изменения в текущем наборе строк При вычислении начальную позицию новый набор строк. Тем не менее включают изменения за пределы текущего набора строк, если он способен определить их. Кроме того, когда **SQLFetchScroll** возвращает новый набор строк, который имеет положение зависит от текущего набора строк - FetchOrientation является SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE или инструкция SQL_FETCH_BOOKMARK - его содержит все изменения, которые он способен определить, даже если они находятся в текущем наборе строк.  
  
 При определении, являются ли только что добавленных строк внутри или за пределами текущего набора строк, частичный набор строк считается концом последней строки допустимым; то есть последней строки, для которого строк не находится в состоянии SQL_ROW_NOROW. Например предположим, курсор способен определить добавленные строки, текущего набора строк является частичный набор строк, приложение добавляет новые строки и курсор добавляет эти строки в конец результирующего набора. Если приложение вызывает **SQLFetchScroll** с FetchOrientation присвоено SQL_FETCH_NEXT, **SQLFetchScroll** возвращает набор строк, начиная с первой вновь добавленной строки.  
  
 Например предположим, текущего набора строк состоит из строк 21-30, размер набора строк равно 10, курсор удаляет строки, удаленные из результирующего набора и курсора обнаруживает строки, добавленные к результирующему набору. В следующей таблице показаны строки **SQLFetchScroll** возвращает в различных ситуациях.  
  
|Изменить|Тип выборки|FetchOffset|Новый набор строк [1]|  
|------------|----------------|-----------------|---------------------|  
|Удалить строку 21|NEXT|0|31 до 40|  
|Удалить строку 31|NEXT|0|32 для 41|  
|Вставить строку между строками 21 и 22|NEXT|0|31 до 40|  
|Вставить строку между строками 30 и 31|NEXT|0|Вставленная строка 31 39|  
|Удалить строку 21|PRIOR|0|11 до 20|  
|Удалить строку 20|PRIOR|0|10 до 19|  
|Вставить строку между строками 21 и 22|PRIOR|0|11 до 20|  
|Вставить строку между строками 20 и 21|PRIOR|0|вставленная строка 12 до 20,|  
|Удалить строку 21|RELATIVE|0|22 – 31<sup>[2]</sup>|  
|Удалить строку 21|RELATIVE|1|22 – 31|  
|Вставить строку между строками 21 и 22|RELATIVE|0|21, вставленной строки, 22 до 29|  
|Вставить строку между строками 21 и 22|RELATIVE|1|22 – 31|  
|Удалить строку 21|ABSOLUTE|21|22 – 31<sup>[2]</sup>|  
|Удалить строку 22|ABSOLUTE|21|21, 23 до 31|  
|Вставить строку между строками 21 и 22|ABSOLUTE|22|Вставленная строка 22 до 29|  
  
 [1] для этого столбца используется номера строк, прежде чем все строки были вставлены или удалены.  
  
 [2] в этом случае курсор пытается вернуть строк, начиная со строки 21. Так как строка 21 была удалена, первую строку, которую он возвращает является строкой 22.  
  
 Ошибка строк (то есть с состоянием из SQL_ROW_ERROR) не влияют на движение курсора. Например, если текущий набор строк начинается с строке 11 и состояние Строка 11 является SQL_ROW_ERROR, вызвав **SQLFetchScroll** с FetchOrientation SQL_FETCH_RELATIVE и FetchOffset, равным 5 возвращает набор строк, начиная со строки 16, как и в случае, если состояние для строки 11 имело значение SQL_SUCCESS.  
  
## <a name="returning-data-in-bound-columns"></a>Возврат данных в привязанные столбцы  
 **SQLFetchScroll** возвращает данные в привязанные столбцы в так же, как **SQLFetch**. Дополнительные сведения см. в разделе «Возврат данных в привязанный столбцов» в [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
 Если столбцы не привязаны, **SQLFetchScroll** не возвращает данные, но перемещение блочного курсора в указанную позицию. Данные могут извлекаться из несвязанных столбцов из блочного курсора с **SQLGetData** зависит от драйвера. Эта возможность поддерживается в том случае, если в вызове **SQLGetInfo** возвращает SQL_GD_BLOCK бит для типа данных SQL_GETDATA_EXTENSIONS.  
  
## <a name="buffer-addresses"></a>Адреса буферов  
 **SQLFetchScroll** используется та же формула для определения адреса буферов данных и длины и индикатора как **SQLFetch**. Дополнительные сведения см. в разделе «Адреса буферов» в [SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
## <a name="row-status-array"></a>Массив статусов строк  
 **SQLFetchScroll** задает значения в массив статусов строк так же, как SQLFetch. Дополнительные сведения см. в разделе «Массив статусов строк» в [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="rows-fetched-buffer"></a>Строки выбраны буфера  
 **SQLFetchScroll** возвращает число строк в буфере строк, загружаемых в так же, как **SQLFetch**. Дополнительные сведения см. в разделе «Буфер выборка строк» в [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="error-handling"></a>Обработка ошибок  
 Если приложение вызывает **SQLFetchScroll** драйвера ODBC 3.x, диспетчер драйверов вызывает **SQLFetchScroll** в драйвере. Если приложение вызывает **SQLFetchScroll** драйвера ODBC 2.x, диспетчер драйверов вызывает SQLExtendedFetch в драйвере. Так как **SQLFetchScroll** и обработка ошибок SQLExtendedFetch немного иначе, приложение видит немного отличную ошибку, поведение при вызове **SQLFetchScroll** в ODBC 2.x и ODBC драйверы 3.x.  
  
 **SQLFetchScroll** возвращает ошибки и предупреждения в так же, как **SQLFetch**; Дополнительные сведения см. в разделе «Обработка ошибок» в **SQLFetch**. **SQLExtendedFetch** возвращает ошибки так же, как **SQLFetch**, за исключением следующих случаев:  
  
 При возникновении предупреждения, которое применяется к конкретной строки в наборе строк, SQLExtendedFetch задает соответствующая запись в массив статусов строк для SQL_ROW_SUCCESS, не SQL_ROW_SUCCESS_WITH_INFO.  
  
 В случае возникновения ошибки в каждую строку в наборе строк SQLExtendedFetch возвращает SQL_SUCCESS_WITH_INFO, а не значение SQL_ERROR.  
  
 В каждой группе записи состояния, который применяется к отдельной строке, первой записи состояния, возвращаемые SQLExtendedFetch должен содержать SQLSTATE 01S01 (ошибка в строке); **SQLFetchScroll** не возвращает этот SQLSTATE. Если SQLExtendedFetch не сможет вернуть дополнительные SQLSTATE, он, по-прежнему, вернуть этот SQLSTATE.  
  
## <a name="sqlfetchscroll-and-optimistic-concurrency"></a>SQLFetchScroll и оптимистичный параллелизм  
 Если курсор использует оптимистичный параллелизм — то есть атрибута инструкции SQL_ATTR_CONCURRENCY имеет значение SQL_CONCUR_VALUES или SQL_CONCUR_ROWVER - **SQLFetchScroll** обновляет значения оптимистичного параллелизма, используемой данными источник для обнаружения, является ли строка была изменена. Это происходит каждый раз, когда **SQLFetchScroll** выбирается новый набор строк, в том числе его refetches текущего набора строк. (Он вызывается с FetchOrientation SQL_FETCH_RELATIVE и FetchOffset, равным 0.)  
  
## <a name="sqlfetchscroll-and-odbc-2x-drivers"></a>SQLFetchScroll и ODBC 2.x драйверы  
 Если приложение вызывает **SQLFetchScroll** драйвера ODBC 2.x, диспетчер драйверов сопоставляет этот вызов **SQLExtendedFetch**. Он передает следующие значения для аргументов **SQLExtendedFetch**.  
  
|Аргумент SQLExtendedFetch|Значение|  
|-------------------------------|-----------|  
|StatementHandle|StatementHandle в **SQLFetchScroll**.|  
|FetchOrientation|FetchOrientation в **SQLFetchScroll**.|  
|FetchOffset|Если FetchOrientation не sql_fetch_bookmark аргумента, значение в аргументе FetchOffset **SQLFetchScroll** используется.<br /><br /> Если FetchOrientation sql_fetch_bookmark аргумента, используется значение хранится по адресу, указанному в атрибуте инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
|RowCountPtr|Адрес, указанный с помощью атрибута sql_attr_rows_fetched_ptr, которое указывает оператор.|  
|RowStatusArray|Адрес, указанный в атрибуте значения SQL_ATTR_ROW_STATUS_PTR инструкции.|  
  
 Дополнительные сведения см. в разделе [блочные курсоры, Прокручиваемые курсоры и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: Рекомендации по драйверов для обеспечения обратной совместимости.  
  
## <a name="descriptors-and-sqlfetchscroll"></a>Дескрипторы и SQLFetchScroll  
 **SQLFetchScroll** взаимодействует с дескрипторами в так же, как **SQLFetch**. Дополнительные сведения см. в разделе «Дескрипторы и SQLFetchScroll» [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="code-example"></a>Пример кода  
 См. в разделе [привязка на уровне столбцов](../../../odbc/reference/develop-app/column-wise-binding.md), [привязку на уровне строки](../../../odbc/reference/develop-app/row-wise-binding.md), [позиционированного обновления и инструкций Delete](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md), и [обновление строк в наборе строк с помощью SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение инструкции bulk insert, update или delete операций|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнении подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка одной строки или блока данных в направлении только вперед|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Закрытие курсора в инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Позиционирование курсора, обновление данных в наборе строк или удаления данных в результирующем наборе|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|Присвоение атрибуту инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
