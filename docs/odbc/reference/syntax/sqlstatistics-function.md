---
title: Функция S'LСтатистика (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLStatistics
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLStatistics
helpviewer_keywords:
- SQLStatistics function [ODBC]
ms.assetid: 45210682-cfea-4e5d-9951-bcf1cbe10f41
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: c2a5ef0b0e54e17a2dc091a98efc972fa608ef15
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81302948"
---
# <a name="sqlstatistics-function"></a>SQLStatistics, функция
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **S'LStatistics** получает список статистических данных о одной таблице и индексах, связанных с таблицей. Водитель возвращает информацию в результате набора.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLStatistics(  
     SQLHSTMT        StatementHandle,  
     SQLCHAR *       CatalogName,  
     SQLSMALLINT     NameLength1,  
     SQLCHAR *       SchemaName,  
     SQLSMALLINT     NameLength2,  
     SQLCHAR *       TableName,  
     SQLSMALLINT     NameLength3,  
     SQLUSMALLINT    Unique,  
     SQLUSMALLINT    Reserved);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *КаталогНайм*  
 (Вход) Название каталога. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из разных DBMS, пустая строка (") указывает на те таблицы, которые не имеют каталогов. *CatalogName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *CatalogName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *CatalogName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение. Для получения дополнительной информации смотрите [аргументы в каталоге функции](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 (Вход) Длина в символах*каталогаName*.  
  
 *Schemaname*  
 (Вход) Имя схемы. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") указывает на те таблицы, которые не имеют схем. *SchemaName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *SchemaName* рассматривается как идентификатор и его случай не является значительным. Если это SQL_FALSE, *SchemaName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength2*  
 (Вход) Длина в символах*SchemaName*.  
  
 *Tablename*  
 (Вход) Название таблицы. Этот аргумент не может быть недействительным указателем. *SchemaName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *TableName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *TableName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength3*  
 (Вход) Длина в символах*таблицыName*.  
  
 *Уникальный*  
 (Вход) Тип индекса: SQL_INDEX_UNIQUE или SQL_INDEX_ALL.  
  
 *Reserved*  
 (Вход) Указывает на важность столбцов CARDINALITY и PAGES в наборе результатов. Следующие варианты влияют только на возвращение столбцов CARDINALITY и PAGES; индексная информация возвращается, даже если CARDINALITY и PAGES не возвращаются.  
  
 SQL_ENSURE просит водителя безоговорочно получить статистику. (Водители, которые соответствуют только стандарту Open Group и не поддерживают расширения ODBC, не смогут поддерживать SQL_ENSURE.)  
  
 SQL_QUICK просит, чтобы драйвер получил CARDINALITY и PAGES только в том случае, если они легко доступны с сервера. В этом случае драйвер не гарантирует актуальность значений. (Приложения, написанные в стандарте Open Group, всегда будут получать SQL_QUICK поведение от драйверов, совместимых с ODBC *3.x.)*  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LStatistics** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону s'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'Lstate, обычно возвращаемые **S'LStatistics,** и разъясняется каждая из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|Курсор был открыт на *statementHandle*, и **S'LFetch** или **S'LFetchScroll** был вызван. Эта ошибка возвращается менеджером-драйвером, если **S'LFetch** или **S'LFetchScroll** не вернулись SQL_NO_DATA и возвращается водителем, если **S'LFetch** или **S'LFetchScroll** вернулся SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle,* но **S'LFetch** или **S'LFetchScroll** не были вызваны.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*, а затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY009|Недействительное использование нулевой указатель|Аргумент *TableName* был недействительным указателем.<br /><br /> Атрибут SQL_ATTR_METADATA_ID оператора был установлен на SQL_TRUE, аргумент *CatalogName* был недействительным указателем, а SQL_CATALOG_NAME *InfoType* возвращает, что имена каталогов поддерживаются.<br /><br /> (DM) Атрибут SQL_ATTR_METADATA_ID оператора был установлен на SQL_TRUE, а аргумент *SchemaName* был недействительным указателем.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была названа функция **S'LStatistics.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение одного из аргументов длины имени было меньше 0, но не равно SQL_NTS.<br /><br /> Значение одного из аргументов длины имени превысило значение максимальной длины соответствующего имени.|  
|HY100|Тип опции уникальности вне диапазона|(DM) Было указано недействительное *уникальное* значение.|  
|HY101|Тип параметра точности вне диапазона|(DM) Было указано недействительное *зарезервированное* значение.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Каталог был указан, и драйвер или источник данных не поддерживает каталоги.<br /><br /> Была указана схема, а драйвер или источник данных не поддерживает схемы.<br /><br /> Комбинация текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE оператора не была поддержана драйвером или источником данных.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул запрошенный набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 В стандартном наборе результатов, заказанных NON_UNIQUE, TYPE, INDEX_QUALIFIER, INDEX_NAME и ORDINAL_POSITION, **s'LStatistics** возвращает информацию о одной таблице. Набор результатов сочетает в себе статистическая информация (в столбцах CARDINALITY и PAGES набора результатов) для таблицы с информацией о каждом индексе. Информацию о том, как эта информация может быть использована, можно узнать: [«Использование данных каталогов».](../../../odbc/reference/develop-app/uses-of-catalog-data.md)  
  
 Для определения фактической длины столбцов TABLE_CAT, TABLE_SCHEM, TABLE_NAME и COLUMN_NAME приложение может позвонить в **s'LGetInfo** с вариантами SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN, SQL_MAX_TABLE_NAME_LEN и SQL_MAX_COLUMN_NAME_LEN.  
  
> [!NOTE]  
>  Для получения дополнительной информации об общем использовании, аргументах и возвращенных данных функций каталога ODBC [см.](../../../odbc/reference/develop-app/catalog-functions.md)  
  
 Следующие столбцы были переименованы в ODBC *3.x*. Изменения имени столбца не влияют на обратную совместимость, поскольку приложения связываются с номером столбца.  
  
|Колонка ODBC 2.0|Столбец ODBC *3.x*|  
|---------------------|-----------------------|  
|TABLE_QUALIFIER|TABLE_CAT|  
|TABLE_OWNER|TABLE_SCHEM|  
|SEQ_IN_INDEX|ORDINAL_POSITION|  
|COLLATION|ASC_OR_DESC|  
  
 В следующей таблице перечислены столбцы в наборе результатов. Дополнительные столбцы за столбец 13 (FILTER_CONDITION) могут быть определены драйвером. Приложение должно получить доступ к столбику, в зависимости от драйвера, отсчитывая от конца набора результатов вместо указания явного ординаторского положения. Для получения дополнительной информации смотрите [данные, возвращенные функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|TABLE_CAT (ODBC 1.0)|1|Varchar|Название таблицы, к которой применяется статистика или индекс; NULL, если не применим к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют каталогов.|  
|TABLE_SCHEM (ODBC 1.0)|2|Varchar|Название таблицы Schema, к которой применяется статистика или индекс; NULL, если не применим к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют схем.|  
|TABLE_NAME (ODBC 1.0)|3|Варчар не NULL|Название таблицы таблицы, к которой применяется статистика или индекс.|  
|NON_UNIQUE (ODBC 1.0)|4|Smallint|Указывает, не допускает ли индекс дублирующих значения:<br /><br /> SQL_TRUE, если значения индекса могут быть неуникальными.<br /><br /> SQL_FALSE, если значения индекса должны быть уникальными.<br /><br /> NULL возвращается, если TYPE SQL_TABLE_STAT.|  
|INDEX_QUALIFIER (ODBC 1.0)|5|Varchar|Идентификатор, который используется для квалификации индексного имени, выполняя **DROP INDEX;** NULL возвращается, если квалификатор индекса не поддерживается источником данных или если TYPE SQL_TABLE_STAT. Если значение ненулевого возвращается в этой колонке, оно должно быть использовано для квалификации имени индекса в выписке **DROP INDEX;** в противном случае TABLE_SCHEM следует использовать для квалификации имени индекса.|  
|INDEX_NAME (ODBC 1.0)|6|Varchar|Название индекса; NULL возвращается, если TYPE SQL_TABLE_STAT.|  
|ТИП (ODBC 1.0)|7|Smallint, не NULL|Тип возвращенной информации:<br /><br /> SQL_TABLE_STAT указывает статистику для таблицы (в столбце CARDINALITY или PAGES).<br /><br /> SQL_INDEX_BTREE указывает на индекс B-Tree.<br /><br /> SQL_INDEX_CLUSTERED указывает на кластерный индекс.<br /><br /> SQL_INDEX_CONTENT указывает на индекс содержимого.<br /><br /> SQL_INDEX_HASHED указывает на хэшированный индекс.<br /><br /> SQL_INDEX_OTHER указывает на другой тип индекса.|  
|ORDINAL_POSITION (ODBC 1.0)|8|Smallint|Номер последовательности столбцов в индексе (начиная с 1); NULL возвращается, если TYPE SQL_TABLE_STAT.|  
|COLUMN_NAME (ODBC 1.0)|9|Varchar|Имя столбца. Если столбец основан на выражении, например, SALARY и BENEFITS, выражение возвращается; если выражение не может быть определено, возвращается пустая строка. NULL возвращается, если TYPE SQL_TABLE_STAT.|  
|ASC_OR_DESC (ODBC 1.0)|10|Char(1)|Сортировка последовательности для столбца: "А" для восхождения; "D" для спуска; NULL возвращается, если последовательность сортировки столбцов не поддерживается источником данных или если TYPE SQL_TABLE_STAT.|  
|КАРДИНАЛЬНОСТЬ (ODBC 1.0)|11|Целое число|Кардинальность таблицы или индекса; количество строк в таблице, если TYPE SQL_TABLE_STAT; количество уникальных значений в индексе, если TYPE не SQL_TABLE_STAT; NULL возвращается, если значение недоступно из источника данных.|  
|СТРАНИЦЫ (ODBC 1.0)|12|Целое число|Количество страниц, используемых для хранения индекса или таблицы; количество страниц для таблицы, если TYPE SQL_TABLE_STAT; количество страниц для индекса, если TYPE не является SQL_TABLE_STAT; NULL возвращается, если значение недоступно из источника данных или если оно не применимо к источнику данных.|  
|FILTER_CONDITION (ODBC 2.0)|13|Varchar|Если индекс является отфильтрованным индексом, это условие фильтра, например, SALARY > 30000; если состояние фильтра не может быть определено, это пустая строка.<br /><br /> NULL, если индекс не является отфильтрованным индексом, невозможно определить, является ли индекс отфильтрованным индексом, или TYPE является SQL_TABLE_STAT.|  
  
 Если строка в наборе результатов соответствует таблице, драйвер устанавливает TYPE на SQL_TABLE_STAT и устанавливает NON_UNIQUE, INDEX_QUALIFIER, INDEX_NAME, ORDINAL_POSITION, COLUMN_NAME и ASC_OR_DESC null. Если CARDINALITY или PAGES недоступны из источника данных, драйвер устанавливает их в NULL.  
  
## <a name="code-example"></a>Пример кода  
 В примере кода аналогичной [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)функции см.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Получение одной строки или блока данных в направлении только вперед.|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращение колонн иностранных ключей|[Функция SQLForeignKeys](../../../odbc/reference/syntax/sqlforeignkeys-function.md)|  
|Возвращение столбцов основного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
