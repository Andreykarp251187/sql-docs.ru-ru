---
title: Функция «СЗЛПодготовка» (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLPrepare
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLPrepare
helpviewer_keywords:
- SQLPrepare function [ODBC]
ms.assetid: 332e1b4b-b0ed-4e7a-aa4d-4f35f4f4476b
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e9aedd665df2a943627207902d592d597c503c63
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306885"
---
# <a name="sqlprepare-function"></a>Функция SQLPrepare
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 К исполнению готовитстрокую строку **S'L.**  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLPrepare(  
     SQLHSTMT      StatementHandle,  
     SQLCHAR *     StatementText,  
     SQLINTEGER    TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *StatementText*  
 (Вход) Текстовая строка S'L.  
  
 *TextLength*  
 (Вход) Длина*q StatementText* в символах.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LPrepare** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону s'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LPrepare,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Изменение значения опциона|Определенный атрибут оператора был недействительным из-за условий выполнения работы, поэтому аналогичное значение было временно заменено. ( Можно назвать**S'LGetStmtAttr,** чтобы определить, что такое временно заменяемые значения.) Значение замены допустимо для *StatementHandle* до тех пор, пока курсор не будет закрыт. Атрибуты оператора, которые могут быть изменены: SQL_ATTR_CONCURRENCY SQL_ATTR_CURSOR_TYPE SQL_ATTR_KEYSET_SIZE SQL_ATTR_KEYSET_SIZE SQL_ATTR_MAX_LENGTH SQL_ATTR_MAX_ROWS SQL_ATTR_QUERY_TIMEOUT SQL_ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|21S01|Список значений вставки не соответствует списку столбцов|\**StatementText* содержал заявление **INSERT,** и количество вставленных значений не соответствовало степени производного таблицы.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|\**StatementText* содержал заявление **CREATE VIEW,** и указанное число имен не является той же степенью, что и производная таблица, определяемая спецификацией запроса.|  
|22018|Недействительное значение символов для спецификации литья|**StatementText* содержал апогея S'L, содержащая буквальный или параметр, и значение было несовместимо с типом данных ассоциированного столбца таблицы.|  
|22019|Недействительный персонаж побега|Аргумент *StatementText* содержал предикат **LIKE** с **ESCAPE** в оговорке **WHERE,** и длина персонажа побега после **ESCAPE** не была равна 1.|  
|22025|Недействительная последовательность побега|Аргумент *StatementText* содержал «**LIKE** _значение шаблона_ **ESCAPE** _escape character_» в оговорке **WHERE,** и персонаж, следующий за персонажем побега в значении шаблона, не был ни «%», ни «я».|  
|24 000|Недопустимое состояние курсора|(DM) Курсор был открыт на *StatementHandle*, и **S'LFetch** или **S'LFetchScroll** был вызван.<br /><br /> Курсор был открыт на *StatementHandle,* но **S'LFetch** или **S'LFetchScroll** не были вызваны.|  
|34000|Недопустимое имя курсора|\**StatementText* содержал позиционный **DELETE** или позиционированное **ОБНОВЛЕНИЕ,** и курсор, на который ссылается готовятся заявление, не был открыт.|  
|3D000|Недействительное название каталога|Название каталога, указанное в *StatementText,* является недействительным.|  
|3F000|Имя недействительной схемы|Имя схемы, указанное в *StatementText,* было недействительным.|  
|42000|Ошибка синтаксиса или нарушение доступа|\**StatementText* содержал апогея, которая не была предпаратаждена или содержала ошибку синтаксиса.<br /><br /> **StatementText* содержал заявление, для которого пользователь не имел требуемых привилегий.|  
|42S01|Базовая таблица или представление уже существует|\**StatementText* содержал заявление **CREATE TABLE** или **CREATE VIEW,** и указанное имя таблицы или имя представления уже существует.|  
|42S02|Базовая таблица или представление не найдено|\**StatementText* содержал **drop TABLE** или заявление DROP **VIEW,** а указанное имя таблицы или имя представления не существовало.<br /><br /> \**StatementText* содержал заявление **ALTER TABLE,** а указанное имя таблицы не существовало.<br /><br /> \**StatementText* содержал заявление **CREATE VIEW,** а имя таблицы или имя представления, определяемое спецификацией запроса, не существовало.<br /><br /> \**StatementText* содержал заявление **CREATE INDEX,** а указанное имя таблицы не существовало.<br /><br /> \**StatementText* содержал заявление **GRANT** или **REVOKE,** а указанное имя таблицы или имя представления не существовало.<br /><br /> \**StatementText* содержал заявление **SELECT,** а указанное имя таблицы или имя представления не существовало.<br /><br /> \**StatementText* содержал **DELETE**, **INSERT**, или **ОБНОВЛЕНИЕ** заявление, и указанное имя таблицы не существует.<br /><br /> \**StatementText* содержал заявление **CREATE TABLE,** а таблица, указанная в ограничении (ссылка на таблицу, кроме создаваемой) не существовала.|  
|42S11|Индекс уже существует|\**StatementText* содержал заявление **CREATE INDEX,** и указанное имя индекса уже существовало.|  
|42S12|Индекс не найден|\**StatementText* содержал заявление **DROP INDEX,** а указанное название индекса не существовало.|  
|42S21|Колонка уже существует|\**StatementText* содержал заявление **ALTER TABLE,** и столбец, указанный в оговорке **ADD,** не является уникальным или идентифицирует существующую колонку в базовой таблице.|  
|42S22|Колонка не найдена|\**StatementText* содержал заявление **CREATE INDEX,** и одно или несколько имен столбцов, указанных в списке столбцов, не существовали.<br /><br /> \**StatementText* содержал заявление **GRANT** или **REVOKE,** а указанное название столбца не существовало.<br /><br /> \**StatementText* содержал **SELECT**, **DELETE**, **INSERT**, или **ОБНОВЛЕНИЕ** заявление, и указанное название столбца не существует.<br /><br /> \**StatementText* содержал заявление **CREATE TABLE,** а столбец, указанный в ограничении (ссылка на таблицу, кроме создаваемой) не существовал.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*, а затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY009|Недействительное использование нулевой указатель|(DM) *StatementText* был нулевым указателем.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LPrepare.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Аргумент *TextLength* был меньше или равен 0, но не равен SQL_NTS.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Настройка параллелизма была недействительна для определенного типа курсора.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **вызов S'LPrepare** для отправки выписки по S'L источнику данных для подготовки. Для получения дополнительной информации о подготовленном исполнении [см.](../../../odbc/reference/develop-app/prepared-execution-odbc.md) Приложение может включать один или несколько параметрных маркеров в выписке по S'L. Для включения параметра приложение встраивает вопросительный знак (?) в строку S'L в соответствующем положении. Для получения информации о параметрах [см.](../../../odbc/reference/develop-app/statement-parameters.md)  
  
> [!NOTE]  
>  Если приложение использует **S'LPrepare** для подготовки и **S'LExecute** для отправки выписки **COMMIT** или **ROLLBACK,** оно не будет совместимо между продуктами DBMS. Чтобы совершить или откатить транзакцию, позвоните по **телефону S'LEndTran.**  
  
 Драйвер может изменить инструкцию, чтобы использовать форму S'L, используемую источником данных, а затем отправить его в источник данных для подготовки. В частности, драйвер изменяет последовательности побега, используемые для определения синтаксиса S'L для определенных функций. (Для описания грамматики оператора S'L [см.](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md) [Appendix C: SQL Grammar](../../../odbc/reference/appendixes/appendix-c-sql-grammar.md) Для драйвера ручка оператора похожа на идентификатор оператора во встроенном коде S'L. Если источник данных поддерживает идентификаторы оператора, водитель может отправить идентификатор и значения параметров в источник данных.  
  
 После подготовки оператора приложение использует рукоятку оператора для обозначения оператора в последующих вызовах функции. Подготовленное заявление, связанное с ручкой оператора, может быть повторно выполнено, позвонив в **S'LExecute** до тех пор, пока приложение не освободит выписку с вызовом на **s'LFreeStmt** с SQL_DROP опцией или до тех пор, пока ручка оператора не будет использована в вызове к **S'LPrepare**, **S'LExecDirect**, или одной из функций каталога **(S'LColumns**, **S'LTables**и так далее). Как только приложение подготовит заявление, оно может запросить информацию о формате набора результатов. Для некоторых реализаций вызов **S'LDescribeCol** или **S'LDescribeParam** после **s'LPrepare** может быть не столь эффективным, как вызов функции после **S'LExecute** или **S'LExecDirect.**  
  
 Некоторые драйверы не могут вернуть ошибки синтаксиса или нарушения доступа, когда приложение вызывает **S'LPrepare.** Драйвер может обрабатывать ошибки синтаксиса и нарушения доступа, только ошибки синтаксиса, ни ошибки синтаксиса, ни нарушения доступа. Таким образом, приложение должно быть в состоянии обрабатывать эти условия при вызове последующих связанных функций, таких как **S'LNumResultCols**, **S'LDescribeCol**, **S'LColAttribute**, и **S'LExecute.**  
  
 В зависимости от возможностей драйвера и источника данных информация о параметрах (например, типы данных) может быть проверена при подготовке оператора (если все параметры были связаны) или когда она выполнена (если все параметры не связаны). Для максимальной совместимости приложение должно отменить все параметры, применяемые к старой выписке s'L, прежде чем подготовить новую выписку по той же выписке. Это предотвращает ошибки, которые связаны со старой информацией о параметрах, применяемой к новому заявлению.  
  
> [!IMPORTANT]  
>  Совершение транзакции, либо путем явного вызова **S'LEndTran,** либо при работе в режиме автоматического коммивояжера, может привести к тому, что источник данных удалит планы доступа для всех инструкций по подключению. Для получения более подробной информации ознакомьтесь с SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR типами информации в [S'LGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) и [о влиянии транзакций на курсоры и подготовленные заявления.](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md)  
  
## <a name="code-example"></a>Пример кода  
 [См. S'LBindParameter,](../../../odbc/reference/syntax/sqlbindparameter-function.md) [S'LPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [S'LSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение ручки оператора|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка буфера к параметру|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращение количества строк, затронутых заявлением|[Функция SQLRowCount](../../../odbc/reference/syntax/sqlrowcount-function.md)|  
|Установка имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
