---
title: Функция SQLPrepare | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLPrepare
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLPrepare
helpviewer_keywords:
- SQLPrepare function [ODBC]
ms.assetid: 332e1b4b-b0ed-4e7a-aa4d-4f35f4f4476b
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 292b1c4d9cd0281de610af4e53f25aa3d0ab6f90
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68005763"
---
# <a name="sqlprepare-function"></a>Функция SQLPrepare
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLPrepare** подготавливает строкой SQL для выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLPrepare(  
     SQLHSTMT      StatementHandle,  
     SQLCHAR *     StatementText,  
     SQLINTEGER    TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *StatementText*  
 [Вход] Текстовая строка SQL.  
  
 *TextLength*  
 [Вход] Длина **StatementText* в символах.  
  
## <a name="returns"></a>Возвращает  
 Значение SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLPrepare** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLPrepare** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Атрибут указанной инструкции была Недопустимый рабочий трудностями реализации, поэтому такую же пользу за временно был заменен. (**SQLGetStmtAttr** можно вызвать для определения, что такое временно подставляемого значения.) Заменяющее значение является допустимым для *StatementHandle* до закрытия курсора. Атрибуты инструкции, которые могут быть изменены следующие: SQL_ATTR_CONCURRENCY SQL_ATTR_CURSOR_TYPE АТРИБУТА SQL_ATTR_KEYSET_SIZE ЗНАЧЕНИЯ SQL_ATTR_MAX_LENGTH SQL_ATTR_MAX_ROWS SQL_ATTR_QUERY_TIMEOUT SQL_ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|21S01|Список вставляемых значений не соответствует списку столбцов|\**StatementText* содержится **вставить** инструкции, а количество значений для вставки не совпали степень производной таблицы.|  
|21S02|Структура полученной таблицы не соответствует списку столбцов|\**StatementText* содержится **CREATE VIEW** инструкции, а также количество заданных имен не тот же угол производную таблицу, определенных в спецификации запроса.|  
|22018|Недопустимое символьное значение для спецификации приведения|**StatementText* содержатся инструкции SQL, который содержал литералом или параметром, а значение несовместим с типом данных столбца связанные таблицы.|  
|22019|Недопустимый escape-символ|Аргумент *StatementText* содержится **как** предиката с **ESCAPE** в **ГДЕ** предложения и длину escape Следующий **escape-** не равно 1.|  
|22025|Недопустимая escape-последовательность|Аргумент *StatementText* содержится "**как** _значение шаблона_ **ESCAPE** _escape-символ_"в **ГДЕ** предложение, а символ после escape-символ в значение шаблона было «%», ни «_».|  
|24000|Недопустимое состояние курсора|(DM) курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы вызывалась.<br /><br /> Курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|34000|Недопустимое имя курсора|\**StatementText* содержится позиционированные **удалить** или выполнение нацеленных **обновления**, и курсор, указанный в инструкции, подготавливаемый не был открыт.|  
|3D000|Недопустимое имя каталога|Имя каталога, указанное в *StatementText* был недопустимым.|  
|3F000|Недопустимое имя схемы|Имя схемы, указанное в *StatementText* был недопустимым.|  
|42000|Синтаксическая ошибка или нарушение доступа|\**StatementText* содержали инструкцию SQL, который не был подготавливаемых или содержит синтаксическую ошибку.<br /><br /> **StatementText* содержит инструкцию, для которой пользователь не имеет необходимых привилегий.|  
|42S01|Базовая таблица или представление уже существует|\**StatementText* содержится **CREATE TABLE** или **CREATE VIEW** инструкции и имя таблицы или представления с указанным именем уже существует.|  
|42S02|Базовая таблица или представление не найдены|\**StatementText* содержится **DROP TABLE** или **DROP VIEW** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ALTER TABLE** инструкции и указанным именем таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE VIEW** инструкции и имя таблицы или представления, имя, определенное в спецификации запроса не существует.<br /><br /> \**StatementText* содержится **CREATE INDEX** инструкции и указанным именем таблицы не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **удалить**, **вставить**, или **обновления** инструкции и указанным именем таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и таблицы, указанной в ограничении (со ссылками на таблицы не, созданный) не существует.|  
|42S11|Индекс уже существует|\**StatementText* содержится **CREATE INDEX** инструкции и индекс с указанным именем уже существует.|  
|42S12|Индекс не найден|\**StatementText* содержится **DROP INDEX** инструкции и индекс с указанным именем не существует.|  
|42S21|Столбец уже существует|\**StatementText* содержится **ALTER TABLE** инструкции и столбец, указанный в **добавить** предложение не является уникальным, или определяет существующего столбца в базовой таблице.|  
|42S22|Столбец не найден|\**StatementText* содержится **CREATE INDEX** инструкции и один или несколько столбцов, имена, указанные в списке столбцов не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** инструкции и с определенным названием столбца не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ**, **удалить**, **вставить**, или **обновления** инструкции и с определенным названием столбца не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и столбец, указанный в ограничении (со ссылками на таблицы не, созданный) не существует.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) *StatementText* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLPrepare** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) аргумент *TextLength* была меньше или равно 0, но не равно SQL_NTS.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Для типа курсора, определенного недопустимый параметр параллелизма.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE и атрибут инструкции SQL_ATTR_CURSOR_TYPE было присвоено тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Истекло время ожидания перед источник данных вернул результирующий набор. Период ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLPrepare** для отправки инструкций SQL к источнику данных для подготовки. Дополнительные сведения о подготовленное выполнение, см. в разделе [подготовленных](../../../odbc/reference/develop-app/prepared-execution-odbc.md). Приложение может включать один или несколько маркеров параметров в инструкции SQL. Чтобы включить параметр маркера, приложение внедряет знак вопроса (?) в SQL-строку в соответствующем положении. Сведения о параметрах см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md).  
  
> [!NOTE]  
>  Если приложение использует **SQLPrepare** для подготовки и **SQLExecute** для отправки **ЗАФИКСИРОВАТЬ** или **ОТКАТА** инструкции, она не будет с возможностью взаимодействия между СУБД. Чтобы зафиксировать или откатить транзакцию, вызвать **SQLEndTran**.  
  
 Драйвер можно изменить инструкцию, чтобы использовать форму SQL, используемый источником данных, а затем отправить его в источник данных для подготовки. В частности драйвер изменяет escape-последовательности, используемый для определения синтаксиса SQL, для некоторых функций. (Описание синтаксис инструкции SQL, см. в разделе [escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md) и [приложение в: Грамматика SQL](../../../odbc/reference/appendixes/appendix-c-sql-grammar.md).) Для драйвера дескриптор инструкции аналогична идентификатор инструкции во внедренном коде SQL. Если источник данных поддерживает инструкции идентификаторы, драйвер может отправлять идентификатор инструкции и значения параметров источника данных.  
  
 Подготовив инструкцию, приложение использует дескриптор инструкции для ссылки на инструкции в последующих вызовах функции. Подготовленной инструкции, связанные с дескриптором инструкции могут выполняться повторно путем вызова **SQLExecute** пока приложение освобождает инструкция с вызовом **SQLFreeStmt** с параметром SQL_DROP или пока дескриптора инструкции используется в вызове **SQLPrepare**, **SQLExecDirect**, или одну из функций каталога (**SQLColumns**,  **SQLTables**, и так далее). Когда приложение подготавливает инструкцию, оно может запросить сведения о формате результирующего набора. В некоторых реализациях вызова **SQLDescribeCol** или **SQLDescribeParam** после **SQLPrepare** не может быть настолько эффективна, насколько вызова функции после **SQLExecute** или **SQLExecDirect**.  
  
 Некоторые драйверы невозможно вернуть синтаксических ошибок или нарушений прав доступа, когда приложение вызывает **SQLPrepare**. Драйвер можно обрабатывать ошибки синтаксиса и нарушение прав доступа только ошибки синтаксиса, или ни синтаксические ошибки, ни нарушения прав доступа. Таким образом, приложения должны иметь возможность таких ситуаций, когда вызов последующих связанные функции, такие как **SQLNumResultCols**, **SQLDescribeCol**, **SQLColAttribute**, и **SQLExecute**.  
  
 В зависимости от возможностей драйвера и источника данных могут быть возвращены сведения о параметрах (например, типы данных), при подготовке инструкции (если все параметры были привязаны) или при его выполнении (если все параметры не были привязаны). Для максимальной совместимости приложения следует отменить привязку всех параметров, которые применены к старой инструкции SQL перед подготовкой новую инструкцию SQL в одной инструкции. Это позволяет избежать ошибок, из-за старые сведения о параметрах, применяемых к новой инструкции.  
  
> [!IMPORTANT]  
>  Фиксация транзакции, либо путем явного вызова **SQLEndTran** или работая в режиме автоматической фиксации, может привести к источнику данных для удаления планов доступ для всех инструкций в соединении. Дополнительные сведения см. в разделе SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR типы сведений в [SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) и [влияние транзакций на курсоры и подготовленных инструкций](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md).  
  
## <a name="code-example"></a>Пример кода  
 См. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение дескриптора инструкции|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка буфер к параметру|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнении подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращает количество строк, затронутых инструкцией|[Функция SQLRowCount](../../../odbc/reference/syntax/sqlrowcount-function.md)|  
|Задав имя курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
