---
title: Функция S'LSpecialКолонки (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSpecialColumns
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSpecialColumns
helpviewer_keywords:
- SQLSpecialColumns function [ODBC]
ms.assetid: bb2d9f21-bda0-4e50-a8be-f710db660034
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 826630e1d344322268a2f2638310b3a1e182de6d
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287174"
---
# <a name="sqlspecialcolumns-function"></a>SQLSpecialColumns, функция
**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 1.0: Open Group  
  
 **Сводка**  
 **S'LSpecialColumns** получает следующую информацию о столбцах в указанной таблице:  
  
-   Оптимальный набор столбцов, который однозначно идентифицирует строку в таблице.  
  
-   Столбцы, которые автоматически обновляются при обновлении любого значения строки транзакцией.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSpecialColumns(  
     SQLHSTMT      StatementHandle,  
     SQLSMALLINT   IdentifierType,  
     SQLCHAR *     CatalogName,  
     SQLSMALLINT   NameLength1,  
     SQLCHAR *     SchemaName,  
     SQLSMALLINT   NameLength2,  
     SQLCHAR *     TableName,  
     SQLSMALLINT   NameLength3,  
     SQLSMALLINT   Scope,  
     SQLSMALLINT   Nullable);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *ИдентификаторType*  
 (Вход) Тип столбца для возврата. Необходимо установить одно из следующих значений.  
  
 SQL_BEST_ROWID: возвращает оптимальный столбец или набор столбцов, которые, извлекая значения из столбца или столбцов, позволяют однозначно идентифицировать любую строку в указанной таблице. Столбец может быть либо псевдоколонкой, специально разработанной для этой цели (как в Oracle ROWID или Ingres TID), либо столбцом или столбцов любого уникального индекса для таблицы.  
  
 SQL_ROWVER: Возвращает столбцы или столбцы в заданную таблицу, если таковые имеются, которые автоматически обновляются источником данных, когда любое значение в строке обновляется любой транзакцией (как в S'LBase ROWID или Sybase TIMESTAMP).  
  
 *КаталогНайм*  
 (Вход) Название каталога таблицы. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют каталогов. *CatalogName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *CatalogName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *CatalogName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение. Для получения дополнительной информации смотрите [аргументы в каталоге функции](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 (Вход) Длина в символах*каталогаName*.  
  
 *Schemaname*  
 (Вход) Название схемы для таблицы. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют схем. *SchemaName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *SchemaName* рассматривается как идентификатор и его случай не является значительным. Если это SQL_FALSE, *SchemaName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength2*  
 (Вход) Длина в символах*SchemaName*.  
  
 *Tablename*  
 (Вход) Название таблицы. Этот аргумент не может быть недействительным указателем. *TableName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *TableName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *TableName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength3*  
 (Вход) Длина в символах*таблицыName*.  
  
 *Область*  
 (Вход) Минимальный требуемый объем гребного ряда. Возврат rowid может иметь большую размах. Должна быть одной из следующих:  
  
 SQL_SCOPE_CURROW: Rowid гарантированно действителен только при расположении на этом ряду. Более поздний выбор с помощью rowid не может вернуть строку, если строка была обновлена или удалена другой транзакцией.  
  
 SQL_SCOPE_TRANSACTION: Rowid гарантированно действителен в течение текущей транзакции.  
  
 SQL_SCOPE_SESSION: Rowid гарантированно действителен в течение сеанса (через границы транзакций).  
  
 *Допускает значения NULL*  
 (Вход) Определяет, возвращать ли специальные столбцы, которые могут иметь значение NULL. Должна быть одной из следующих:  
  
 SQL_NO_NULLS: Исключить специальные столбцы, которые могут иметь значения NULL. Некоторые драйверы не могут поддерживать SQL_NO_NULLS, и эти драйверы будут возвращать пустой набор результатов, если SQL_NO_NULLS указан. Заявки должны быть подготовлены к этому делу и запросить SQL_NO_NULLS только в том случае, если это абсолютно необходимо.  
  
 SQL_NULLABLE: Верните специальные столбцы, даже если они могут иметь значения NULL.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LSpecialColumns** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив по **телефону s'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LSpecialColumns,** и приведены в контексте этой функции. нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|Курсор был открыт на *statementHandle*, и **S'LFetch** или **S'LFetchScroll** был вызван. Эта ошибка возвращается менеджером-драйвером, если **S'LFetch** или **S'LFetchScroll** не вернулись SQL_NO_DATA и возвращается водителем, если **S'LFetch** или **S'LFetchScroll** вернулся SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle,* но **S'LFetch** или **S'LFetchScroll** не были вызваны.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY009|Недействительное использование нулевой указатель|Аргумент *TableName* был недействительным указателем.<br /><br /> Атрибут SQL_ATTR_METADATA_ID оператора был установлен на SQL_TRUE, аргумент *CatalogName* был недействительным указателем, а SQL_CATALOG_NAME *InfoType* возвращает, что имена каталогов поддерживаются.<br /><br /> (DM) Атрибут SQL_ATTR_METADATA_ID оператора был установлен на SQL_TRUE, а аргумент *SchemaName* был недействительным указателем.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта функция по-прежнему исполнялась, когда были **вызваны S'LSpecialColumns.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение одного из аргументов длины было меньше, чем 0, но не равно SQL_NTS.<br /><br /> Значение одного из аргументов длины превысило значение максимальной длины для соответствующего имени. Максимальную длину каждого имени можно получить, позвонив по телефону **s'LGetInfo** со значениями *InfoType:* SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN или SQL_MAX_TABLE_NAME_LEN.|  
|HY097|Тип столбца вне диапазона|(DM) Было указано недействительное значение *IdentifierType.*|  
|HY098|Тип области вне диапазона|(DM) Было указано значение *недействительной области.*|  
|HY099|Nullable тип вне диапазона|(DM) Было указано недействительное *недействительное значение nullable.*|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Каталог был указан, и драйвер или источник данных не поддерживает каталоги.<br /><br /> Была указана схема, а драйвер или источник данных не поддерживает схемы.<br /><br /> Комбинация текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE оператора не была поддержана драйвером или источником данных.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул запрошенный набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Когда аргумент *IdentifierType* SQL_BEST_ROWID, **S'LSpecialColumns** возвращает столбцы или столбцы, которые однозначно идентифицируют каждую строку в таблице. Эти столбцы всегда можно использовать в *списке выбора* или пункте **WHERE.** **S'LColumns**, который используется для возврата разнообразной информации о столбцах таблицы, не обязательно возвращает столбцы, которые однозначно идентифицируют каждую строку, или столбцы, которые автоматически обновляются, когда любое значение в строке обновляется транзакцией. Например, **S'LКолонки** могут не возвращать псевдоколонку Oracle ROWID. Вот почему для возврата этих столбцов используется **S'LSpecialColumns.** Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/uses-of-catalog-data.md)  
  
> [!NOTE]  
>  Для получения дополнительной информации об общем использовании, аргументах и возвращенных данных функций каталога ODBC [см.](../../../odbc/reference/develop-app/catalog-functions.md)  
  
 Если в таблице нет столбцов, которые однозначно идентифицировали бы каждую строку, **S'LSpecialColumns** возвращает строку без строк; последующий вызов в **S'LFetch** или **S'LFetchScroll** на выписке возвращается SQL_NO_DATA.  
  
 Если *в идентификаторах,* *области области*или *недействительных* аргументах указаны характеристики, не подкрепленные источником данных, **S'LSpecialColumns** возвращает пустой набор результатов.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора настроен на SQL_TRUE, аргументы *CatalogueName,* *SchemaName*и *TableName* рассматриваются как идентификаторы, поэтому в определенных ситуациях они не могут быть установлены на нулевую указку. (Для получения дополнительной [информации см. Аргументы в каталоге функции](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).)  
  
 **SLSpecialColumns** возвращает результаты в качестве стандартного набора результатов, заказанных SCOPE.  
  
 Следующие столбцы были переименованы в ODBC *3.x*. Изменения имени столбца не влияют на обратную совместимость, поскольку приложения связываются с номером столбца.  
  
|Колонка ODBC 2.0|Столбец ODBC *3.x*|  
|---------------------|-----------------------|  
|PRECISION|COLUMN_SIZE|  
|LENGTH|BUFFER_LENGTH|  
|SCALE|DECIMAL_DIGITS|  
  
 Для определения фактической длины COLUMN_NAME столбца приложение может позвонить в **s'LGetInfo** с SQL_MAX_COLUMN_NAME_LEN опцией.  
  
 В следующей таблице перечислены столбцы в наборе результатов. Дополнительные столбцы за столбец 8 (PSEUDO_COLUMN) могут быть определены драйвером. Приложение должно получить доступ к столбику, в зависимости от драйвера, отсчитывая от конца набора результатов, а не указывая явное обыдающееся положение. Для получения дополнительной информации смотрите [данные, возвращенные функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|ОБЛАСТЬ ДЕЙСТВИЯ (ODBC 1.0)|1|Smallint|Фактический объем гребного. Содержит одно из следующих значений:<br /><br /> SQL_SCOPE_CURROW SQL_SCOPE_TRANSACTION SQL_SCOPE_SESSION<br /><br /> NULL возвращается, когда *IdentifierType* SQL_ROWVER. Описание каждого значения можно узнать *в* разделе "Синтаксис" ранее в этом разделе.|  
|COLUMN_NAME (ODBC 1.0)|2|Варчар не NULL|Имя столбца. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|DATA_TYPE (ODBC 1.0)|3|Smallint, не NULL|Тип данных S'L. Это может быть тип данных ODBC S'L или тип данных, специфичный для драйверов, с помощью s-L. Для получения списка действительных типов данных [SQL Data Types](../../../odbc/reference/appendixes/sql-data-types.md)ODBC S'L см. Для получения информации о типах данных, специфичных для драйверов, просмотрите документацию водителя.|  
|TYPE_NAME (ODBC 1.0)|4|Варчар не NULL|Имя типа типа данных, зависящих от источников данных; например, "CHAR", "VARCHAR", "MONEY", "LONG VARBINARY", или "CHAR ( ) ДЛЯ BIT DATA".|  
|COLUMN_SIZE (ODBC 1.0)|5|Целое число|Размер столбца на источнике данных. Для получения дополнительной информации о размере столбца см. [Размер столбца, десятичные цифры, длина переноса Octet и размер дисплея](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|BUFFER_LENGTH (ODBC 1.0)|6|Целое число|Длина байтов данных, передаваемых в операции **S'LGetData** или **S'LFetch,** если указано SQL_C_DEFAULT. Для числовых данных этот размер может отличаться от размера данных, хранящихся в источнике данных. Это значение такое же, как и COLUMN_SIZE столбец для символов или двоичных данных. Для получения дополнительной информации [см. Размер столбца, десятичные цифры, длина передачи Octet и размер дисплея](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|DECIMAL_DIGITS (ODBC 1.0)|7|Smallint|Десятичные цифры столбца на источнике данных. NULL возвращается для типов данных, где десятичные цифры не применимы. Для получения дополнительной информации о десятичных цифрах [см. Размер столбца, десятичные цифры, длина передачи Octet и размер дисплея.](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)|  
|PSEUDO_COLUMN (ODBC 2.0)|8|Smallint|Указывает, является ли столбец псевдоколонкой, такой как Oracle ROWID:<br /><br /> SQL_PC_UNKNOWN SQL_PC_NOT_PSEUDO SQL_PC_PSEUDO **Примечание:** Для максимальной совместимости, псевдо-колонки не должны цитироваться с идентификатором цитатой символа, возвращенного **S'LGetInfo**.|  
  
 После того, как приложение получает значения для SQL_BEST_ROWID, приложение может использовать эти значения для перевыбора этой строки в пределах определенной области. Заявление **SELECT** гарантированно возвращает сярприз либо без строк, либо без одной строки.  
  
 Если приложение перевыбирает строку на основе столбца или столбцов строки и строка не найдена, приложение может предположить, что строка была удалена или столбцы гребной были изменены. Обратное не верно: даже если rowid не изменился, другие столбцы в строке, возможно, изменились.  
  
 Столбцы, возвращенные для типа столбцов SQL_BEST_ROWID полезны для приложений, которые должны прокрутить вперед и назад в наборе результатов для получения последних данных из набора строк. Столбцы или столбцы rowid гарантированно не изменятся при расположении на этом ряду.  
  
 Столбец или столбцы rowid могут оставаться действительными даже в том случае, если курсор не расположен на строке; приложение может определить это, проверив столбец SCOPE в наборе результатов.  
  
 Столбцы, возвращенные для типа столбцов SQL_ROWVER полезны для приложений, которым требуется возможность проверить, были ли обновлены столбцы в данной строке, в то время как строка была переизбрана с помощью rowid. Например, после повторного выбора строки с помощью rowid приложение может сравнить предыдущие значения в SQL_ROWVER столбцов с только что извлеченными. Если значение в SQL_ROWVER столбце отличается от предыдущего значения, приложение может предупредить пользователя о том, что данные на дисплее изменились.  
  
## <a name="code-example"></a>Пример кода  
 В примере кода аналогичной [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)функции см.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение столбцов в таблице или таблицах|[Функция SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)|  
|Получение одной строки или блока данных в направлении только вперед|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращение столбцов основного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
