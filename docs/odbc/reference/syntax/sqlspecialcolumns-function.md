---
title: Функция SQLSpecialColumns | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSpecialColumns
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSpecialColumns
helpviewer_keywords:
- SQLSpecialColumns function [ODBC]
ms.assetid: bb2d9f21-bda0-4e50-a8be-f710db660034
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 5f3fe596428450795426537f5c2f5913a6c83a46
ms.sourcegitcommit: 56b963446965f3a4bb0fa1446f49578dbff382e0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2019
ms.locfileid: "67793741"
---
# <a name="sqlspecialcolumns-function"></a>SQLSpecialColumns, функция
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: Open Group  
  
 **Сводка**  
 **SQLSpecialColumns** извлекает следующие сведения о столбцах в указанной таблице:  
  
-   Оптимальный набор столбцов, уникально определяющий строку в таблице.  
  
-   Столбцы, которые автоматически обновляются, когда любое значение в строке обновляется транзакцией.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSpecialColumns(  
     SQLHSTMT      StatementHandle,  
     SQLSMALLINT   IdentifierType,  
     SQLCHAR *     CatalogName,  
     SQLSMALLINT   NameLength1,  
     SQLCHAR *     SchemaName,  
     SQLSMALLINT   NameLength2,  
     SQLCHAR *     TableName,  
     SQLSMALLINT   NameLength3,  
     SQLSMALLINT   Scope,  
     SQLSMALLINT   Nullable);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *IdentifierType*  
 [Вход] Тип возвращаемого столбца. Должен принимать одно из следующих значений:  
  
 SQL_BEST_ROWID: Возвращает оптимальный столбец или набор столбцов, получая значения из столбца или столбцов, позволяет любую строку в указанной таблице для однозначной идентификации. Столбец может быть либо псевдо столбцом специально для этой цели (как в Oracle ROWID или Ingres TID) либо столбцом или столбцами любого уникального индекса для таблицы.  
  
 SQL_ROWVER: Возвращает столбец или столбцы в указанной таблице, если таковые имеются, автоматически обновляются в источнике данных при любое значение в строке обновляется транзакцией (как в ROWID программа или Sybase метки времени).  
  
 *CatalogName*  
 [Вход] Имя каталога для таблицы. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("») обозначает этих таблиц, у которых нет каталогов. *CatalogName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *CatalogName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *CatalogName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения. Дополнительные сведения см. в разделе [аргументов в функции работы с каталогами](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 [Вход] Длина в символах **CatalogName*.  
  
 *SchemaName*  
 [Вход] Имя схемы для таблицы. Если драйвер поддерживает схемы, для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("») обозначает этих таблиц, у которых нет схемы. *SchemaName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *SchemaName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *SchemaName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength2*  
 [Вход] Длина в символах **SchemaName*.  
  
 *TableName*  
 [Вход] Имя таблицы. Этот аргумент не может быть пустым указателем. *TableName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *TableName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *TableName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength3*  
 [Вход] Длина в символах **TableName*.  
  
 *Область*  
 [Вход] Минимально требуемая область rowid. Возвращаемый rowid может быть больше. Должна быть одной из следующих:  
  
 SQL_SCOPE_CURROW: Rowid гарантированно будет допустимым только в том случае, если курсор находится в этой строке. Проведенная позднее с использованием rowid не может вернуть строку, если строка была обновлена или удалена другой транзакцией.  
  
 SQL_SCOPE_TRANSACTION: Гарантируется, что rowid действовать до конца текущей транзакции.  
  
 SQL_SCOPE_SESSION: Rowid гарантированно допустимым в течение сеанса (несмотря на границы транзакций).  
  
 *Допускает значения NULL*  
 [Вход] Определяет, следует ли возвращать специальные столбцы, которые может иметь значение NULL. Должна быть одной из следующих:  
  
 SQL_NO_NULLS: Исключите специальные столбцы, которые могут иметь значения NULL. Некоторые драйверы не могут поддерживать SQL_NO_NULLS, и эти драйверы вернет пустой результирующий набор, если был указан SQL_NO_NULLS. Приложения должны быть готовы для этого случая и запрос SQL_NO_NULLS только в том случае, если это абсолютно необходимо.  
  
 SQL_NULLABLE: Возвращает специальные столбцы, даже если они могут иметь значения NULL.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSpecialColumns** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE может быть получен путем вызова **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSpecialColumns** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|24000|Недопустимое состояние курсора|Курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы вызывалась. Если эта ошибка возвращается диспетчером драйверов **SQLFetch** или **SQLFetchScroll** не вернула значение SQL_NO_DATA и возвращается с помощью драйвера, если **SQLFetch** или **SQLFetchScroll** вернула значение SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция был снова вызван для *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|*TableName* аргумент был пустым указателем.<br /><br /> Атрибут инструкции SQL_ATTR_METADATA_ID было установлено значение SQL_TRUE, *CatalogName* аргумент был пустым указателем, а также SQL_CATALOG_NAME *InfoType* возвращает этот каталога имена поддерживаются.<br /><br /> (DM) атрибут инструкции SQL_ATTR_METADATA_ID было установлено значение SQL_TRUE и *SchemaName* аргумент был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Эта функция еще выполнялась при **SQLSpecialColumns** был вызван.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение одного из аргументов длина меньше 0, но не равно SQL_NTS.<br /><br /> Значение одного из аргументов длины превышает значение максимальной длины для соответствующего имени. Максимальная длина каждого имени можно получить, вызвав **SQLGetInfo** с *InfoType* значения: SQL_MAX_CATALOG_NAME_LEN SQL_MAX_SCHEMA_NAME_LEN и SQL_MAX_TABLE_NAME_LEN.|  
|HY097|Тип столбца вне допустимого диапазона|(DM) указан недопустимый *IdentifierType* было указано значение.|  
|HY098|Тип области вне допустимого диапазона|(DM) указан недопустимый *область* было указано значение.|  
|HY099|Тип, допускающий значение NULL за пределами диапазона|(DM) указан недопустимый *Nullable* было указано значение.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Был указан каталог, а драйверу или источнику данных не поддерживает каталоги.<br /><br /> Указано схему и драйверу или источнику данных не поддерживает схемы.<br /><br /> Сочетание текущие значения атрибутов инструкции SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживается драйвером или источником данных.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE и атрибут инструкции SQL_ATTR_CURSOR_TYPE было присвоено тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Истекло время ожидания запроса перед источника данных, возвращаемого набора требуемого результата. Период ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Когда *IdentifierType* аргумент является SQL_BEST_ROWID, **SQLSpecialColumns** возвращает столбец или столбцы, которые однозначно определяют каждую строку в таблице. Эти столбцы всегда можно использовать в *список выбора* или **ГДЕ** предложение. **SQLColumns**, который используется для возврата различные сведения в столбцах таблицы, не возвращает обязательно столбцы, которые однозначно определяют каждую строку или столбцы, которые автоматически обновляются, когда любое значение в строке обновляется транзакция. Например **SQLColumns** могут не возвращать ROWID псевдо столбец Oracle. Вот почему **SQLSpecialColumns** используется для возврата этих столбцов. Дополнительные сведения см. в разделе [использует данные из каталога](../../../odbc/reference/develop-app/uses-of-catalog-data.md).  
  
> [!NOTE]  
>  Дополнительные сведения о общего использования, аргументы и возвращаемые данные функций каталога ODBC, см. в разделе [функций каталога](../../../odbc/reference/develop-app/catalog-functions.md).  
  
 Если нет столбцов, уникально определяющие каждую строку в таблице, **SQLSpecialColumns** возвращает набор строк без строк; в последующем вызове **SQLFetch** или **SQLFetchScroll**на оператор возвращает значение SQL_NO_DATA.  
  
 Если *IdentifierType*, *область*, или *Nullable* аргументы задают характеристики, которые не поддерживаются источником данных, **SQLSpecialColumns**  возвращает пустой результирующий набор.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *CatalogName*, *SchemaName*, и *TableName* аргументы должны обрабатываться как идентификаторы, поэтому они нельзя установить равным пустой указатель в определенных ситуациях. (Дополнительные сведения см. в разделе [аргументов в функции работы с каталогами](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).)  
  
 **SQLSpecialColumns** возвращает результаты в виде стандартных результирующий набор, упорядоченный по области.  
  
 Следующие столбцы были переименованы для ODBC *3.x*. Изменения имен столбцов не влияют на обратную совместимость так, как выполнить привязку приложения, номер столбца.  
  
|Столбец ODBC 2.0|ODBC *3.x* столбца|  
|---------------------|-----------------------|  
|PRECISION|COLUMN_SIZE|  
|LENGTH|BUFFER_LENGTH|  
|SCALE|DECIMAL_DIGITS|  
  
 Чтобы определить фактическую длину столбца COLUMN_NAME, приложение может вызвать **SQLGetInfo** с параметром SQL_MAX_COLUMN_NAME_LEN.  
  
 В следующей таблице перечислены столбцы в результирующем наборе. Дополнительные столбцы вслед за столбец 8 (PSEUDO_COLUMN) можно определить с помощью драйвера. Приложения должны получить доступ к от драйвера, отсчет от конца результирующего набора, вместо указания явной порядковый номер. Дополнительные сведения см. в разделе [данные, возвращаемые функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|ОБЛАСТЬ (ODBC 1.0)|1|Smallint|Фактическая область rowid. Содержит одно из следующих значений:<br /><br /> SQL_SCOPE_CURROW SQL_SCOPE_TRANSACTION SQL_SCOPE_SESSION<br /><br /> Возвращается значение NULL, когда *IdentifierType* является SQL_ROWVER. Описание каждого значения, см. в описании *область* в «Синтаксис» ранее в этом разделе.|  
|COLUMN_NAME (ODBC 1.0)|2|Varchar not NULL|Имя столбца. Драйвер возвращает пустую строку для столбца, который не имеет имени.|  
|DATA_TYPE (ODBC 1.0)|3|Smallint, не NULL|Тип данных SQL. Это может быть типом данных ODBC SQL или типом данных специфические для драйвера SQL. Список допустимых типов данных ODBC SQL, см. в разделе [типы данных SQL](../../../odbc/reference/appendixes/sql-data-types.md). Сведения о типах данных драйвера SQL см. в разделе документации по драйверу.|  
|TYPE_NAME (ODBC 1.0)|4|Varchar not NULL|Имя типа данных зависит от источника данных; Например «CHAR», «VARCHAR», «Деньги», «LONG VARBINARY» или «() CHAR FOR BIT DATA».|  
|COLUMN_SIZE (ODBC 1.0)|5|Целочисленный|Размер столбца в источнике данных. Дополнительные сведения, касающиеся размер столбца, см. в разделе [размер столбца, десятичных разрядов, длительность октета передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|BUFFER_LENGTH (ODBC 1.0)|6|Целочисленный|Длина в байтах данных, передаваемых по **SQLGetData** или **SQLFetch** операции, если SQL_C_DEFAULT указан. Для числовых данных этот размер может отличаться от размера данных, хранящихся в источнике данных. Это значение совпадает со значением столбца COLUMN_SIZE для символьных или двоичных данных. Дополнительные сведения см. в разделе [размер столбца, десятичных разрядов, длительность октета передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|DECIMAL_DIGITS (ODBC 1.0)|7|Smallint|Десятичные цифры из столбца в источнике данных. Возвращается значение NULL для типов данных, где десятичных цифр не применяются. Дополнительные сведения, касающиеся десятичных цифр, см. в разделе [размер столбца, десятичных разрядов, длительность октета передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|PSEUDO_COLUMN (ODBC 2.0)|8|Smallint|Указывает, является ли столбец столбцом псевдо, таких как Oracle ROWID:<br /><br /> SQL_PC_UNKNOWN SQL_PC_NOT_PSEUDO SQL_PC_PSEUDO **Примечание:**  Для максимальной совместимости псевдостолбцов следует не заключить в кавычки идентификатором символ кавычки возвращаемые **SQLGetInfo**.|  
  
 После приложение получает значения для SQL_BEST_ROWID, приложение может использовать эти значения, чтобы повторно выбрать эту строку в пределах области. **ВЫБЕРИТЕ** инструкции гарантированно возвращает одну строку, либо ни одной строки.  
  
 Если приложение reselects строку, основанную на rowid столбец или столбцы, и строка не найдена, приложение можно предположить, что строка была удалена или rowid столбцы были изменены. Обратное неверно: даже если rowid не была изменена, могло измениться других столбцов в строке.  
  
 Столбцы, возвращенные для столбца типа SQL_BEST_ROWID полезны для приложений, требующих прокрутку вперед и назад в результирующий набор, для получения самых последних данных из набора строк. Столбец или столбцы из rowid гарантированно не изменить, пока располагается в этой строке.  
  
 Столбец или столбцы из rowid может оставаться допустимым даже в том случае, если курсор не располагается в строку; приложение может определить это, проверив область столбца в результирующем наборе.  
  
 Столбцы, возвращенные для столбца типа SQL_ROWVER полезны для приложений, которым требуется возможность проверить, обновлены ли все столбцы в данной строке хотя строка была повторно с использованием rowid. Например после повторно выбрать строку с использованием rowid, приложение можно сравнить предыдущие значения в столбцах SQL_ROWVER, чтобы извлечь только те из них. Если значение в столбце SQL_ROWVER отличается от предыдущего значения, приложение может сообщить пользователю об изменении данных на экране.  
  
## <a name="code-example"></a>Пример кода  
 Пример кода ту же функцию, см. в разделе [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат столбцов в таблице или таблицах|[Функция SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)|  
|Выборка одной строки или блока данных в направлении только вперед|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возврат столбцов первичного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
