---
title: Функция привилегий S'LColumn Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLColumnPrivileges
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLColumnPrivileges
helpviewer_keywords:
- SQLColumnPrivileges function [ODBC]
ms.assetid: ef233d9a-6ed5-4986-9d42-5e0b1a79fb6e
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e94c5524bcde3023bae3298c8dbb6d03347a0b8e
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81301271"
---
# <a name="sqlcolumnprivileges-function"></a>Функция SQLColumnPrivileges
**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 1.0: ODBC  
  
 **Сводка**  
 **S'LColumnPrivileges** возвращает список столбцов и связанных с ними привилегий для указанной таблицы. Водитель возвращает информацию в результате, установленную на указанном *StatementHandle.*  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLColumnPrivileges(  
     SQLHSTMT      StatementHandle,  
     SQLCHAR *     CatalogName,  
     SQLSMALLINT   NameLength1,  
     SQLCHAR *     SchemaName,  
     SQLSMALLINT   NameLength2,  
     SQLCHAR *     TableName,  
     SQLSMALLINT   NameLength3,  
     SQLCHAR *     ColumnName,  
     SQLSMALLINT   NameLength4);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *КаталогНайм*  
 (Вход) Название каталога. Если драйвер поддерживает имена для некоторых каталогов, но не для других, например, когда драйвер получает данные из разных DBMS, пустая строка (") означает те каталоги, которые не имеют имен. *CatalogName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *CatalogName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *CatalogName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение. Для получения дополнительной информации смотрите [аргументы в каталоге функции](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 (Вход) Длина в символах*каталогаName*.  
  
 *Schemaname*  
 (Вход) Имя схемы. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют схем. *SchemaName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора настроен на SQL_TRUE, *SchemaName* рассматривается как идентификатор. Если это SQL_FALSE, *SchemaName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength2*  
 (Вход) Длина в символах*SchemaName*.  
  
 *Tablename*  
 (Вход) Название таблицы. Этот аргумент не может быть недействительным указателем. *TableName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *TableName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *TableName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength3*  
 (Вход) Длина в символах*таблицыName*.  
  
 *ColumnName*  
 (Вход) Шаблон поиска строк для имен столбцов.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *ColumnName* рассматривается как идентификатор, и его случай не значителен. Если это SQL_FALSE, *ColumnName* является аргументом значения шаблона; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength4*  
 (Вход) Длина в символах*колонкиName*.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LColumnPrivileges** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив по **телефону S'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LColumnPrivileges,** и приведены в изъяны каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|Курсор был открыт на *statementHandle,* и **s'LFetch** или **S'LFetchScroll** был вызван. Эта ошибка возвращается менеджером-драйвером, если **S'LFetch** или **S'LFetchScroll** не вернулись SQL_NO_DATA, и возвращается драйвером, если **S'LFetch** или **S'LFetchScroll** вернулся SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle,* но **S'LFetch** или **S'LFetchScroll** не были вызваны.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY009|Недействительное использование нулевой указатель|Аргумент *TableName* был недействительным указателем.<br /><br /> Атрибут SQL_ATTR_METADATA_ID оператора был установлен на SQL_TRUE, аргумент *CatalogName* был недействительным указателем, а SQL_CATALOG_NAME *InfoType* возвращает, что имена каталогов поддерживаются.<br /><br /> (DM) Атрибут SQL_ATTR_METADATA_ID оператора был установлен на SQL_TRUE, а аргумент *SchemaName* или *ColumnName* был нулевым указателем.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция все еще исполнялась, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение одного из аргументов длины имени было меньше 0, но не равно SQL_NTS.|  
|||Значение одного из аргументов длины имени превысило значение максимальной длины соответствующего имени. (См. "Комментарии.")|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Было указано имя каталога, а драйвер или источник данных не поддерживает каталоги.<br /><br /> Было указано имя схемы, а драйвер или источник данных не поддерживает схемы.<br /><br /> Для имени столбца был указан шаблон поиска строки, и источник данных не поддерживает шаблоны поиска для этого аргумента.<br /><br /> Комбинация текущих параметров атрибутов SQL_CONCURRENCY и SQL_CURSOR_TYPE оператора не была поддержана драйвером или источником данных.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **SLColumnPrivileges** возвращает результаты в стандартный набор результатов, заказанный TABLE_CAT, TABLE_SCHEM, TABLE_NAME, COLUMN_NAME и PRIVILEGE.  
  
> [!NOTE]  
>  **Привилегии S'LColumn Privileges** могут не возвращать привилегии для всех столбцов. Например, драйвер может не возвращать информацию о привилегиях для псевдоколонок, таких как Oracle ROWID. Приложения могут использовать любой допустимый столбец, независимо от того, возвращается ли он **s'LColumnPrivileges.**  
  
 Длина столбцов VARCHAR не отображается в таблице; фактическая длина зависит от источника данных. Для определения фактической длины столбцов CATALOG_NAME, SCHEMA_NAME, TABLE_NAME и COLUMN_NAME приложение может позвонить в **s'LGetInfo** с SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN, SQL_MAX_TABLE_NAME_LEN и SQL_MAX_COLUMN_NAME_LEN опций.  
  
> [!NOTE]  
>  Для получения дополнительной информации об общем использовании, аргументах и возвращенных данных функций каталога ODBC [см.](../../../odbc/reference/develop-app/catalog-functions.md)  
  
 Следующие столбцы были переименованы в ODBC 3. *x*. Изменения имени столбца не влияют на обратную совместимость, поскольку приложения связываются с номером столбца.  
  
|Колонка ODBC 2.0|ODBC 3. *x* колонка|  
|---------------------|-----------------------|  
|TABLE_QUALIFIER|TABLE_CAT|  
|TABLE_OWNER|TABLE_SCHEM|  
  
 В следующей таблице перечислены столбцы в наборе результатов. Дополнительные столбцы за столбец 8 (IS_GRANTABLE) могут быть определены драйвером. Приложение должно получить доступ к столбику, в зависимости от драйвера, отсчитывая от конца набора результатов, а не указывая явное обыдающееся положение. Для получения дополнительной информации смотрите [данные, возвращенные функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|TABLE_CAT (ODBC 1.0)|1|Varchar|Каталог идентификатора; NULL, если не применим к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют каталогов.|  
|TABLE_SCHEM (ODBC 1.0)|2|Varchar|Идентификатор схемы; NULL, если не применим к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют схем.|  
|TABLE_NAME (ODBC 1.0)|3|Варчар не NULL|Идентификатор таблицы.|  
|COLUMN_NAME (ODBC 1.0)|4|Варчар не NULL|Имя столбца. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|ГРАНТОР (ODBC 1.0)|5|Varchar|Имя пользователя, давшего привилегию; NULL, если не применим к источнику данных.<br /><br /> Для всех строк, в которых значение в столбце GRANTEE является владельцем объекта, столбец GRANTOR будет "_SYSTEM".|  
|ГРАНТИ (ODBC 1.0)|6|Варчар не NULL|Имя пользователя, которому была предоставлена привилегия.|  
|ПРИВИЛЕГИЯ (ODBC 1.0)|7|Варчар не NULL|Определяет привилегию столбца. Может быть одним из следующих (или других, поддерживаемых источником данных при реализации определены):<br /><br /> SELECT: Получателю гранта разрешается получать данные для столбца.<br /><br /> INSERT: Получателю гранта разрешается предоставлять данные для столбца в новых строках, вставленных в связанную таблицу.<br /><br /> ОБНОВЛЕНИЕ: Получателю гранта разрешено обновлять данные в столбце.<br /><br /> СПРАВКА: Получателю гранта разрешается ссылаться на столбец в пределах ограничения (например, уникальное, референтное или ограничение проверки таблицы).|  
|IS_GRANTABLE (ODBC 1.0)|8|Varchar|Указывает, разрешено ли получателю гранта предоставлять привилегию другим пользователям; "ДА", "НЕТ" или "NULL", если неизвестно или не применимо к источнику данных.<br /><br /> Привилегия либо предоставляется, либо не может быть дарована, но не и то, и другое. Набор результатов, возвращенный **S'LColumnPrivileges,** никогда не будет содержать два ряда, для которых все столбцы, кроме IS_GRANTABLE столбец, содержат одинаковое значение.|  
  
## <a name="code-example"></a>Пример кода  
 В примере кода аналогичной [функции](../../../odbc/reference/syntax/sqlcolumns-function.md)см.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение столбцов в таблице или таблицах|[Функция SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение нескольких строк данных|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Возвращение привилегий для таблицы или таблицы|[Функция SQLTablePrivileges](../../../odbc/reference/syntax/sqltableprivileges-function.md)|  
|Возвращение списка таблиц в источнике данных|[Функция SQLTables](../../../odbc/reference/syntax/sqltables-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
