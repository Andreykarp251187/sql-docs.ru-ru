---
title: Функция S'LAllocHandle (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLAllocHandle
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLAllocHandle
helpviewer_keywords:
- SQLAllocHandle function [ODBC]
ms.assetid: 6e7fe420-8cf4-4e72-8dad-212affaff317
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 178e3fad1ec062dd7f812125da66b7e21a7a4f4b
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81290215"
---
# <a name="sqlallochandle-function"></a>Функция SQLAllocHandle
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **S'LAllocHandle** выделяет среду, соединение, оператора или дескрипторную ручку.  
  
> [!NOTE]  
>  Эта функция является общей функцией для выделения декюры, которая заменяет функции ODBC 2.0 **S'LAllocConnect**, **S'LAllocEnv**, и **S'LAllocStmt**. Разрешить приложениям, вызываемым **в s'LAllocHandle,** работать с ODBC 2. *х* драйверов, вызов на **S'LAllocHandle** отображается в менеджер драйверов в **S'LAllocConnect**, **S'LAllocEnv**, или **S'LAllocStmt**, в случае необходимости. Для получения дополнительной информации см. Для получения дополнительной информации о том, что менеджер драйверов карты эту функцию, когда ODBC 3. *приложение x* работает с ODBC 2. *х* драйвер, см [Отображение функции замены для обратной совместимости приложений.](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLAllocHandle(  
      SQLSMALLINT   HandleType,  
      SQLHANDLE     InputHandle,  
      SQLHANDLE *   OutputHandlePtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 (Вход) Тип ручки, которая будет **выделена S'LAllocHandle.** Необходимо установить одно из следующих значений.  
  
-   SQL_HANDLE_DBC  
  
-   SQL_HANDLE_DBC_INFO_TOKEN  
  
-   SQL_HANDLE_DESC  
  
-   SQL_HANDLE_ENV  
  
-   SQL_HANDLE_STMT  
  
 SQL_HANDLE_DBC_INFO_TOKEN ручка используется только менеджером водителя и водителем. Приложения не должны использовать этот тип рукоятки. Для получения дополнительной информации о SQL_HANDLE_DBC_INFO_TOKEN [см.](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md)  
  
 *Вхотливая ручка*  
 (Вход) Ручка ввода, в контексте которой должна быть выделена новая ручка. Если *HandleType* SQL_HANDLE_ENV, это SQL_NULL_HANDLE. Если *HandleType* SQL_HANDLE_DBC, это должна быть ручка среды, а если она SQL_HANDLE_STMT или SQL_HANDLE_DESC, то она должна быть ручкой соединения.  
  
 *Выходная ручкаPtr*  
 (Выход) Указатель на буфер, в котором можно вернуть ручку в недавно выделенную структуру данных.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_INVALID_HANDLE или SQL_ERROR.  
  
 При выделении ручки, кроме обработки среды, если **S'LAllocHandle** возвращается SQL_ERROR, он устанавливает *OutputHandlePtr* для SQL_NULL_HDBC, SQL_NULL_HSTMT или SQL_NULL_HDESC, в зависимости от значения *HandleType*, если аргумент вывода не является указателем на недействительной. Приложение может получить дополнительную информацию из структуры диагностических данных, связанной с ручкой в аргументе *InputHandle.*  
  
## <a name="environment-handle-allocation-errors"></a>Ошибки распределения окружающей среды  
 Распределение среды происходит как в драйвере менеджера, так и в каждом драйвере. Ошибка, возвращенная **S'LAllocHandle** с *помощью SQL_HANDLE_ENV,* зависит от уровня, на котором произошла ошибка.  
  
 Если менеджер драйвера не может выделить память для * \*OutputHandlePtr,* когда **s'LAllocHandle** с *помощью HandleType* SQL_HANDLE_ENV, или приложение предоставляет нулевую указатель для *OutputHandlePtr*, **S'LAllocHandle** возвращает сяSQL_ERROR. Менеджер драйвера устанавливает и*устанавливает outputHandlePtr* для SQL_NULL_HENV (если в приложении не предусмотрена нулевая указка, которая возвращает SQL_ERROR). Не существует ручки, с которой можно связать дополнительную диагностическую информацию.  
  
 Менеджер драйвера не вызывает функцию распределения обработки системы обработки на уровне драйвера до тех пор, пока приложение не вызовет **S'LConnect,** **S'LBrowseConnect**или **S'LDriverConnect.** Если ошибка возникает в функции **уровня драйвера S'LAllocHandle,** то функция менеджера-менеджера драйвера **s'LConnect,** **S'LBrowseConnect**или **sLDriverConnect** возвращается SQL_ERROR. Структура диагностических данных содержит S'LSTATE IM004 (Не удалось **водителю S'LAllocHandle).** Ошибка возвращается на ручку соединения.  
  
 Для получения более подробной информации о потоке вызовов функции между менеджером драйвера и [драйвером,](../../../odbc/reference/syntax/sqlconnect-function.md)см.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LAllocHandle** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **s'LGetDiagRec** с соответствующим *набором HandleType* и *ручкой* к значению *InputHandle.* SQL_SUCCESS_WITH_INFO (но не SQL_ERROR) может быть возвращен для аргумента *OutputHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LAllocHandle,** и приведены в изъяны каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08003|Подключение не открыто|(DM) Аргумент *HandleType* был SQL_HANDLE_STMT или SQL_HANDLE_DESC, но соединение, указанное аргументом *InputHandle,* не было открытым. Процесс подключения должен быть успешно завершен (и соединение должно быть открытым) для водителя, чтобы выделить оператора или дескриптор ручку.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в буфере*MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|(DM) Менеджер драйвера не смог выделить память для указанной ручки.<br /><br /> Водитель не смог выделить память для указанной ручки.|  
|HY009|Недействительное использование нулевой указатель|(DM) *Аргумент OutputHandlePtr* был нулевым указателем.|  
|HY010|Ошибка последовательности функций|(DM) Аргумент *HandleType* был SQL_HANDLE_DBC, и **S'LSetEnvAttr** не был вызван для установки атрибута SQL_ODBC_VERSION среды.<br /><br /> (DM) Асинхронно исполняющая функция была вызвана для **InputHandle** и по-прежнему исполнялась, когда функция **S'LAllocHandle** была вызвана с **набором HandleType,** чтобы SQL_HANDLE_STMT или SQL_HANDLE_DESC.|  
|HY013|Ошибка управления памятью|Аргумент *HandleType* был SQL_HANDLE_DBC, SQL_HANDLE_STMT или SQL_HANDLE_DESC; и вызов функции не может быть обработан, потому что основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY014|Превышение лимита на количество ручек|Достигнут определенный драйвером предел количества ручек, которые могут быть выделены для типа ручки, указанного аргументом *HandleType.*|  
|HY092|Недействительный идентификатор атрибута/опциона|(DM) Аргумент *HandleType* не был: SQL_HANDLE_ENV, SQL_HANDLE_DBC, SQL_HANDLE_STMT или SQL_HANDLE_DESC.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Аргумент *HandleType* был SQL_HANDLE_DESC и водитель был ODBC 2. *x* драйвер.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Аргумент *HandleType* был SQL_HANDLE_STMT, и водитель не был действительным драйвером ODBC.<br /><br /> (DM) Аргумент *HandleType* был SQL_HANDLE_DESC, и драйвер не поддерживает выделение дескриптора.|  
  
## <a name="comments"></a>Комментарии  
 **S'LAllocHandle** используется для распределения дескрипторов для сред, соединений, инструкций и дескрипторов, как описано в следующих разделах. Для получения общей информации [Handles](../../../odbc/reference/develop-app/handles.md)о ручках см.  
  
 Несколько среда, ручка соединения или оператора могут быть выделены приложением одновременно, если несколько распределений поддерживаются драйвером. В ODBC не определено ограничение на количество дескрипторов среды, соединения, оператора или дескриптора, которые могут быть выделены в любой момент времени. Водители могут налагать ограничение на количество определенного типа ручки, которое может быть выделено одновременно; для получения дополнительной информации ознакомьтесь с документацией водителя.  
  
 Если приложение вызывает **s'LAllocHandle** с * \*набором outputHandlePtr* на уже существующий набор среды, соединения, оператора или дескриптора, драйвер перезаписывает информацию, связанную с *ручкой,* если приложение не использует объединение соединений (см. "Распределение атрибута среды для объединения соединений" позже в этом разделе). Менеджер драйвера не проверяет, используется ли *ручка,* введенная в * \*OutputHandlePtr,* и не проверяет предыдущее содержимое ручки, прежде чем переписать их.  
  
> [!NOTE]  
>  Неправильное программирование приложений ODBC для вызова **S'LAllocHandle** два раза с той же переменной приложения, определенной для * \*OutputHandlePtr* без вызова **S'LFreeHandle,** чтобы освободить ручку перед ее перераспределением. Перезапись ручек ODBC таким образом может привести к непоследовательному поведению или ошибкам со стороны драйверов ODBC.  
  
 На операционных системах, поддерживающих несколько потоков, приложения могут использовать одну и ту же среду, соединение, оператора или дескрипторную ручку на разных потоках. Поэтому водители должны поддерживать безопасный, многопоточный доступ к этой информации; один из способов достижения этой цели, например, с помощью критического раздела или семафора. Для получения дополнительной информации о потоке [см.](../../../odbc/reference/develop-app/multithreading.md)  
  
 **S'LAllocHandle** не устанавливает атрибут среды SQL_ATTR_ODBC_VERSION, когда он вызывается для выделения ручки среды; атрибут среды должен быть установлен приложением, или s'LSTATE HY010 (ошибка последовательности функций) будет возвращен, когда **s'LAllocHandle** будет вызван для выделения ручки соединения.  
  
 Для приложений, совместимых со стандартами, **s'LAllocHandle** отображается на карте **s'LAllocHandleStd** во время компиляции. Разница между этими двумя функциями заключается в том, что **S'LAllocHandleStd** устанавливает атрибут SQL_ATTR_ODBC_VERSION среды SQL_OV_ODBC3, когда он вызывается с аргументом *HandleType,* установленным для SQL_HANDLE_ENV. Это делается потому, что приложения, совместимые со стандартами, всегда являются ODBC 3. *x* приложений. Кроме того, стандарты не требуют регистрации версии приложения. Это единственное различие между этими двумя функциями; в противном случае, они идентичны. В драйвер-менеджере отображается карта **s'LAllocHandleStd.** **SQLAllocHandle** Таким образом, сторонние драйверы не должны реализовывать **S'LAllocHandleStd.**  
  
 Приложения ODBC 3.8 должны использовать:  
  
-   **S'LAllocHandle, а не S'LAllocHandleStd** для выделения ручки среды.  
  
-   **СЗЛСетЕнвАттр** для установки атрибута SQL_ATTR_ODBC_VERSION среды на SQL_OV_ODBC3_80.  
  
## <a name="allocating-an-environment-handle"></a>Выделение дескриптора среды  
 Ручка среды обеспечивает доступ к глобальной информации, такой как действительные ручки соединения и активные ручки соединения. Для получения общей информации [Environment Handles](../../../odbc/reference/develop-app/environment-handles.md)о обработках среды см.  
  
 Чтобы запросить обработку среды, приложение вызывает **S'LAllocHandle** с *помощью SQL_HANDLE_ENV и* *ввода* SQL_NULL_HANDLE. Драйвер выделяет память для информации об окружающей среде и передает значение связанной ручки обратно в аргументе * \*OutputHandlePtr.* Приложение передает значение * \*OutputHandle* во всех последующих вызовах, требующих аргумента обработки среды. Для получения дополнительной [Allocating the Environment Handle](../../../odbc/reference/develop-app/allocating-the-environment-handle.md)информации см.  
  
 В соответствии с системой обработки среды менеджера драйвера, если уже существует ручка среды драйвера, то **s'LAllocHandle** с *SQL_HANDLE_ENV не* вызывается в этом драйвере при подключении, только **S'LAllocHandle** с *ручкой SQL_HANDLE_DBC.* Если ручка среды драйвера не существует под ручкой среды менеджера драйвера, то как S'LAllocHandle с ручкой SQL_HANDLE_ENV, так и S'LAllocHandle с ручкой SQL_HANDLE_DBC вызываются в драйвере, когда первая ручка соединения среды подключена к водителю.  
  
 Когда менеджер драйвера обрабатывает функцию **S'LAllocHandle** с *помощью handleType* SQL_HANDLE_ENV, он проверяет ключевое слово **Trace** в разделе «ODBC» системной информации. Если он установлен до 1, менеджер драйвера позволяет отслеживать текущее приложение. При установке флага трассировки начинается при выделении первой ручки среды и заканчивается при освобождении последней ручки среды. Для получения дополнительной [информации см.](../../../odbc/reference/install/configuring-data-sources.md)  
  
 После выделения ручки среды приложение должно вызвать **s'LSetEnvAttr** на ручку среды, чтобы настроить атрибут SQL_ATTR_ODBC_VERSION среды. Если этот атрибут не установлен до того, как **s'LAllocHandle** будет вызван для выделения ручки соединения в среде, вызов для выделения соединения вернет s'LSTATE HY010 (ошибка последовательности функций). Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/declaring-the-application-s-odbc-version.md)  
  
## <a name="allocating-shared-environments-for-connection-pooling"></a>Распределение общих сред для объединения подключений  
 Среды могут быть общими между несколькими компонентами в одном процессе. Общая среда может использоваться несколько одним компонентом одновременно. Когда компонент использует общую среду, он может использовать объединенные соединения, которые позволяют ему выделять и использовать существующее соединение без повторного создания этого соединения.  
  
 Прежде чем выделять общую среду, которая может быть использована для объединения соединений, приложение должно вызвать **S'LSetEnvAttr,** чтобы настроить атрибут среды SQL_ATTR_CONNECTION_POOLING SQL_CP_ONE_PER_DRIVER или SQL_CP_ONE_PER_HENV. В данном случае **s'LSetEnvAttr** называется набором *EnvironmentHandle,* который делает атрибут омичения на уровне процесса.  
  
 После включения объединения соединения приложение вызывает **s'LAllocHandle** с аргументом *HandleType,* установленным для SQL_HANDLE_ENV. Среда, выделенная этим вызовом, будет неявной общей средой, поскольку объединение соединений было включено.  
  
 При выделении общей среды среда, которая будет использоваться, не определяется до тех пор, пока не будет **названа среда,** которая будет использоваться с помощью *SQL_HANDLE_DBC.* В этот момент менеджер драйвера пытается найти существующую среду, которая соответствует атрибутам среды, запрошенным приложением. Если такой среды не существует, она создается как общая среда. Менеджер драйвера поддерживает подсчет ссылок для каждой общей среды; подсчет устанавливается до 1 при первом создании среды. При обнаружении соответствующей среды ручка этой среды возвращается в приложение и приравывается количество ссылок. Ручка среды, выделенная таким образом, может использоваться в любой функции ODBC, которая принимает обработку среды в качестве аргумента ввода.  
  
## <a name="allocating-a-connection-handle"></a>Выделение дескриптора соединения  
 Ручка соединения обеспечивает доступ к информации, такой как действительное заявление и дескрипторные ручки на соединение и является ли транзакция в настоящее время открыта. Для получения общей информации [Connection Handles](../../../odbc/reference/develop-app/connection-handles.md)о ручках соединения см.  
  
 Чтобы запросить ручку соединения, приложение вызывает **S'LAllocHandle** с *помощью handleType* SQL_HANDLE_DBC. Аргумент *InputHandle* устанавливается для ручки среды, которая была возвращена вызовом в **s'LAllocHandle,** который выделил эту ручку. Драйвер выделяет память для информации о подключении и передает значение связанной ручки обратно в * \*OutputHandlePtr.* Приложение передает значение * \*OutputHandlePtr* во всех последующих вызовах, требующих ручки соединения. Для получения дополнительной [Allocating a Connection Handle](../../../odbc/reference/develop-app/allocating-a-connection-handle-odbc.md)информации см.  
  
 Менеджер драйвера обрабатывает функцию **S'LAllocHandle** и вызывает функцию **драйвера S'LAllocHandle,** когда приложение вызывает **S'LConnect,** **S'LBrowseConnect**, или **S'LDriverConnect.** (Для получения дополнительной информации, [см.](../../../odbc/reference/syntax/sqlconnect-function.md)  
  
 Если атрибут среды SQL_ATTR_ODBC_VERSION не установлен до того, как **s'LAllocHandle** будет вызван для выделения ручки соединения в среде, вызов для выделения соединения вернет S'LSTATE HY010 (ошибка последовательности функций).  
  
 Когда приложение вызывает **s'LAllocHandle** с аргументом *InputHandle,* установленным для SQL_HANDLE_DBC а также установленным на общей ручке среды, менеджер драйвера пытается найти существующую общую среду, которая соответствует атрибутам среды, установленным приложением. Если такой среды не существует, создается один, с отсчетом ссылки (поддерживается менеджером драйвера) 1. При обнаружении соответствующей общей среды эта ручка возвращается в приложение и приравывается ее количество ссылок.  
  
 Фактическое соединение, которое будет использоваться, не определяется менеджером драйвера до тех пор, пока не будет вызвано **соединение S'LConnect** или **S'LDriverConnect.** Менеджер драйвера использует параметры подключения в вызове к **S'LConnect** (или ключевые слова соединения в вызове к **S'LDriverConnect)** и атрибуты соединения, установленные после распределения соединения, чтобы определить, какое соединение в пуле должно быть использовано. Для получения более [SQLConnect Function](../../../odbc/reference/syntax/sqlconnect-function.md)подробной информации, см.  
  
## <a name="allocating-a-statement-handle"></a>Выделение дескриптора инструкции  
 Ручка оператора предоставляет доступ к информации оператора, такой как сообщения об ошибках, имя курсора и информация о состоянии для обработки оператора S'L. Для получения общей информации [Statement Handles](../../../odbc/reference/develop-app/statement-handles.md)о ручках оператора см.  
  
 Чтобы запросить ручку оператора, приложение подключается к источнику данных, а затем вызывает **S'LAllocHandle,** прежде чем представить заявления s'L. В этом *вызове, HandleType* должны быть установлены в SQL_HANDLE_STMT и *Вхотистый ручка* должна быть установлена на ручку соединения, которая была возвращена вызовом **на S'LAllocHandle,** который выделил эту ручку. Драйвер выделяет память для информации о выписке, связывает ручку оператора с указанным соединением и передает значение связанной ручки обратно в * \*OutputHandlePtr.* Приложение передает значение * \*OutputHandlePtr* во всех последующих вызовах, требующих ручки оператора. Для получения дополнительной [Allocating a Statement Handle](../../../odbc/reference/develop-app/allocating-a-statement-handle-odbc.md)информации см.  
  
 При выделении ручки оператора драйвер автоматически выделяет набор из четырех дескрипторов и присваивает дескрипторы этим дескрипторам SQL_ATTR_APP_ROW_DESC, SQL_ATTR_APP_PARAM_DESC, SQL_ATTR_IMP_ROW_DESC и SQL_ATTR_IMP_PARAM_DESC атрибуты оператора. Они называются *неявно* выделенными дескрипторами. Для четкого распределения дескриптора приложения см.  
  
## <a name="allocating-a-descriptor-handle"></a>Выделение дескрипторной ручки  
 Когда приложение вызывает **S'LAllocHandle** с *помощью handleType* SQL_HANDLE_DESC, драйвер выделяет дескриптор приложения. Они называются *явно* выделенными дескрипторами. Приложение предписывает водителю использовать явно выделенный дескриптор приложения вместо автоматически выделенного для данной ручки оператора, вызывая функцию **S'LSetStmtAttr** с SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC атрибутом. Дескриптор реализации не может быть выделен явно, равно как и дескриптор реализации не может быть указан в вызове функции **S'LSetStmtAttr.**  
  
 Явно выделенные дескрипторы связаны с ручкой соединения вместо ручки оператора (как автоматически выделенные дескрипторы). Дескрипторы остаются выделенными только тогда, когда приложение фактически подключено к базе данных. Поскольку явно выделенные дескрипторы связаны с ручкой соединения, приложение может связать явно выделенный дескриптор с более чем одним утверждением в соединении. С другой стороны, неявно выделенный дескриптор приложения не может быть связан с более чем одной ручкой оператора. (Он не может быть связан с какой-либо обработкой оператора, кроме той, для которую она была выделена.) Явно выделенные дескрипторные ручки могут быть освобождены явно либо приложением, либо путем вызова **S'LFreeHandle** с *помощью SQL_HANDLE_DESC,* или неявно, когда соединение закрыто.  
  
 При освобождении явно выделенного дескриптора неявно выделенный дескриптор снова ассоциируется с утверждением. (Атрибут SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC для этого оператора снова устанавливается на неявно выделенную ручку дескриптора.) Это относится ко всем утверждениям, которые были связаны с явно выделенным дескриптором на соединении.  
  
 Для получения дополнительной информации о [Descriptors](../../../odbc/reference/develop-app/descriptors.md)дескрипторах см.  
  
## <a name="code-example"></a>Пример кода  
 [См. Примеры программы ODBC,](../../../odbc/reference/sample-odbc-program.md) [функции S'LBrowseConnect,](../../../odbc/reference/syntax/sqlbrowseconnect-function.md) [функции S'LConnect](../../../odbc/reference/syntax/sqlconnect-function.md)и [функции S'LSetCursorName.](../../../odbc/reference/syntax/sqlsetcursorname-function.md)  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Освобождение обработки среды, соединения, оператора или дескриптора|[SQLFreeHandle, функция](../../../odbc/reference/syntax/sqlfreehandle-function.md)|  
|Подготовка выписки для исполнения|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Установка атрибута соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Настройка поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Установка атрибута среды|[Функция SQLSetEnvAttr](../../../odbc/reference/syntax/sqlsetenvattr-function.md)|  
|Установка атрибута оператора|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
