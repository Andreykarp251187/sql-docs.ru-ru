---
title: Функция S'LMoreResults (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLMoreResults
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLMoreResults
helpviewer_keywords:
- SQLMoreResults function [ODBC]
ms.assetid: bf169ed5-4d55-412c-b184-12065a726e89
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 78bbb277e4b783eb46c79f59939a1080feae2b60
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81304745"
---
# <a name="sqlmoreresults-function"></a>SQLMoreResults, функция
**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 1.0: ODBC  
  
 **Сводка**  
 **S'LMoreResults** определяет, доступны ли дополнительные результаты по заявлению, содержащему **SELECT,** **UPDATE,** **INSERT**, или **DELETE** заявления и, если да, инициализирует обработку для этих результатов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLMoreResults(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_NO_DATA, SQL_ERROR, SQL_INVALID_HANDLE SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LMoreResults** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью HandleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LMoreResults,** и разъясняются каждые из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Значение опциона изменилось|Значение атрибута оператора изменяется при обработке пакета. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция **S'LMoreResults** была вызвана, и, прежде чем она завершила выполнение, **S'LCancel** или **S'LКансортхенд** был вызван в *StatementHandle*. Затем функция **S'LMoreResults** была снова вызвана на *statementHandle*.<br /><br /> Функция **S'LMoreResults** была вызвана, и до завершения **выполнения, S'LCancel** или **S'LКансортхенд** был вызван в *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LMoreResults.**<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Наборы результатов возврата инструкций **SELECT.** **ОБНОВЛЕНИЕ**, **INSERT**, и **DELETE** заявления вернуть количество пострадавших строк. Если какие-либо из этих инструкций упакованы, представлены с массивами параметров (число в порядке увеличения параметра, в порядке, в каком они отображаются в пакете), или в процедурах, они могут вернуть несколько наборов результатов или строки. Для получения информации о пакетах заявлений и массивах параметров [Arrays of Parameter Values](../../../odbc/reference/develop-app/arrays-of-parameter-values.md) [см.](../../../odbc/reference/develop-app/batches-of-sql-statements.md)  
  
 После выполнения пакета приложение позиционируется на первом наборе результатов. Приложение может вызывать **s'LBindCol**, **S'LBulkOperations**, **S'LFetch**, **S'LGetData**, **S'LFetchScroll**, **S'LSetPos**, и все функции метаданных, на первом или любом последующих наборов результатов, так же, как если бы был только один набор результатов. Как только это будет сделано с первым набором результатов, приложение вызывает **S'LMoreResults,** чтобы перейти к следующему набору результатов. Если имеется другой набор результатов или отсчет, **S'LMoreResults** возвращается SQL_SUCCESS и инициализирует набор результатов или подсчитывает дополнительную обработку. Если какие-либо операторы, генерирующие количество строк, появляются между операторами, генерирующих результаты, они могут быть перешагнуны, позвонив по **S'LMoreResults.** После вызова **S'LMoreРезультаты** для **ОБНОВЛЕНИЕ**, **INSERT**, или **DELETE** заявления, приложение может вызвать **S'LRowCount**.  
  
 Если был установлен текущий набор результатов с неизвлеченными строками, **S'LMoreResults** отбрасывает этот набор результатов и делает следующий набор или подсчет результатов доступным. Если все результаты были обработаны, **sLMoreResults** возвращается SQL_NO_DATA. Для некоторых драйверов параметры вывода и значения возврата не доступны до тех пор, пока не будут обработаны все наборы результатов и строки. Для таких драйверов параметры вывода и значения возврата становятся доступными, когда SQL_NO_DATA возвращается **S'LMoreResults.**  
  
 Любые привязки, установленные для предыдущего набора результатов, остаются в силе. Если структуры столбца отличаются для этого набора результатов, то вызов **S'LFetch** или **S'LFetchScroll** может привести к ошибке или усечению. Чтобы предотвратить это, приложение должно вызвать **S'LBindCol,** чтобы явно перезавязать по мере необходимости (или сделать это, установив полей дескриптора). Кроме того, приложение может вызвать **S'LFreeStmt** с *возможностью* SQL_UNBIND развязать все буферы столбцов.  
  
 Значения атрибутов оператора, такие как тип курсора, курсор, размер набора ключей или максимальная длина, могут меняться по мере того, как приложение перемещается по пакету по вызовам на **S'LMoreResults.** Если это произойдет, **s'LMoreResults** вернет SQL_SUCCESS_WITH_INFO и S'Lstate 01S02 (опционное значение изменилось).  
  
 Вызов **S'LCloseCursor**, или **S'LFreeStmt** с *опцией* SQL_CLOSE, отбрасывает все наборы результатов и строки, которые были доступны в результате выполнения партии. Обработка оператора возвращается либо в выделенное или подготовленное состояние. Вызов **S'LCancel** для отмены асинхронно выполняющей функции, когда пакет выполнен, а ручка оператора находится в выполненном, курсорном или асинхронном состоянии, приводит ко всем наборам результатов и количествам строк, генерируемым отбрасываемым пакетом, если вызов отмены был успешным. Затем заявление возвращается в подготовленное или выделенное состояние.  
  
 Если партия заявлений или процедура смешивает другие операторы S'L с **SELECT,** **ОБНОВЛЕНИЕ,** **INSERT**, и **DELETE** заявления, эти другие заявления не влияют на **S'LMoreResults**.  
  
 Для получения дополнительной информации, [см.](../../../odbc/reference/develop-app/multiple-results.md)  
  
 Если поиск обновления, вставки или удаления оператора в пакете заявлений не влияет на какие-либо строки в источнике данных, **S'LMoreResults** возвращает сярприза SQL_SUCCESS. Это отличается от случая поиска обновления, вставки или удаления оператора, которое выполняется с помощью **S'LExecDirect**, **S'LExecute**, или **S'LParamData**, который возвращает SQL_NO_DATA, если он не влияет на любые строки в источнике данных. Если приложение вызывает **S'LRowCount** для получения количества строк после того, как звонок в **S'LMoreResults** не повлиял на какие-либо строки, **S'LRowCount** возвращается SQL_NO_DATA.  
  
 Дополнительную информацию о действительном секвенировании функций обработки результатов можно узнать в [приложении B: Таблицы перехода состояния ODBC](../../../odbc/reference/appendixes/appendix-b-odbc-state-transition-tables.md).  
  
 Для получения дополнительной информации о SQL_PARAM_DATA_AVAILABLE [Retrieving Output Parameters Using SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)и streamed параметрах вывода см.  
  
## <a name="availability-of-row-counts"></a>Наличие строковых графов  
 Когда пакет содержит несколько последовательных утверждений о том, что количество строк генерирует, возможно, что эти строки сворачиваются в один ряд. Например, если пакет имеет пять вставок, то определенные источники данных способны возвращать пять индивидуальных строк. Некоторые другие источники данных возвращают только одно количество строк, которое представляет сумму пяти отдельных строк.  
  
 Когда пакет содержит комбинацию генерирующих результатов и строки, генерирующих операторы, количество строк может быть или вообще не доступно. Поведение водителя в отношении наличия количества строк перечисляется в SQL_BATCH_ROW_COUNT типинформации, доступный через звонок в **S'LGetInfo.** Например, предположим, что партия содержит **SELECT**, а затем два **INSERT**s и другой **SELECT**. Тогда возможны следующие случаи:  
  
-   Строка подсчитывает, соответствующие двум инструкциям **INSERT,** вообще недоступна. Первый звонок на **S'LMoreResults** будет позиционировать вас на наборе результатов второго оператора **SELECT.**  
  
-   Строка подсчитывает, соответствующие двум инструкциям **INSERT,** доступны индивидуально. (Звонок в **S'LGetInfo** не возвращает SQL_BRC_ROLLED_UP бит для SQL_BATCH_ROW_COUNT типа информации.) Первый вызов на **S'LMoreResults** будет позиционировать вас на строку кол первого **INSERT**, а второй вызов будет позиционировать вас на строку кол второй **INSERT**. Третий вызов на **S'LMoreResults** будет позиционировать вас на наборе результатов второго оператора **SELECT.**  
  
-   Количество строк, соответствующих двум **INSERTs,** свернуто в одно количество строк, которое доступно. (Звонок в **S'LGetInfo** возвращает SQL_BRC_ROLLED_UP бит для SQL_BATCH_ROW_COUNT типа информации.) Первый звонок на **S'LMoreResults** будет позиционировать вас на свернутом кол-во строки, а второй звонок в **S'LMoreResults** будет позиционировать вас на наборе результатов второго **SELECT.**  
  
 Некоторые драйверы делают количество строк доступным только для явных пакетов, а не для сохраненных процедур.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одной строки или блока данных в направлении только вперед|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Получение части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
