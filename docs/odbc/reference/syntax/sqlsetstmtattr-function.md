---
title: Функция СЗЛСетстматтр Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dfbd2144e677d053f6154dfb3a1df1f6c25d9da5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287271"
---
# <a name="sqlsetstmtattr-function"></a>Функция SQLSetStmtAttr
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **SLSetStmtAttr** устанавливает атрибуты, связанные с заявлением.  
  
> [!NOTE]
>  Для получения дополнительной информации о том, что менеджер драйверов карты эту функцию, когда приложение ODBC *3.x* работает с драйвером ODBC *2.x,* см. [Mapping Replacement Functions for Backward Compatibility of Applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *Атрибут*  
 (Вход) Вариант установить, перечисленные в "Комментарии".  
  
 *ValuePtr*  
 (Вход) Значение, связанное с *атрибутом*. В зависимости от значения *attribute*, *ValuePtr* будет одним из следующих:  
  
-   Ручка дескриптора ODBC.  
  
-   Значение СЗЛУИНТЕГЕР.  
  
-   Значение СЗЛУЛЕН.  
  
-   Указатель на один из следующих:  
  
    -   Строка символов с нулевым завершением.  
  
    -   Двоичный буфер.  
  
    -   Значение или массив типа S'LLEN, S'LULEN или S'LUSMALLINT.  
  
    -   Значение, определяемое драйвером.  
  
 Если аргумент *Attribute* является значением для драйвера, *ValuePtr* может быть подписанный ряд.  
  
 *Струнная длина*  
 (Вход) Если *Attribute* является атрибутом, определяемым ODBC, а *ValuePtr* указывает на \*строку символов или бинарный буфер, этот аргумент должен быть длиной *ValuePtr.* Если *Attribute* является атрибутом, определяемым ODBC, а *ValuePtr* — неопределенным, *StringLength* игнорируется.  
  
 Если *атрибут* является атрибутом, определяемым драйвером, приложение указывает характер атрибута менеджеру драйвера, установив аргумент *StringLength.* *StringLength* может иметь следующие значения:  
  
-   Если *ValuePtr* является указателем на строку персонажа, то *StringLength* — это длина строки или SQL_NTS.  
  
-   Если *ValuePtr* является указателем на двоичный буфер, то приложение помещает результат SQL_LEN_BINARY_ATTR *(длина)* макроса в *StringLength.* Это ставит отрицательное значение в *StringLength*.  
  
-   Если *ValuePtr* является указателем на значение, кроме строки символов или двоичной строки, то *StringLength* должен иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение с фиксированной длиной, то *StringLength* является либо SQL_IS_INTEGER, либо SQL_IS_UINTEGER, в случае необходимости.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LSetStmtAttr** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив по **телефону S'LGetDiagRec** с *помощью SQL_HANDLE_STMT* и *ручки* *выписки.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LSetStmtAttr,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Изменение значения опциона|Драйвер не поддержал значение, указанное в *ValuePtr,* или значение, указанное в *ValuePtr,* было недействительным из-за условий выполнения работы, поэтому драйвер заменил аналогичное значение. ( Можно назвать**си-LGetStmtAttr** для определения временно замещенное значение.) Значение замены допустимо для *statementHandle* до тех пор, пока курсор не будет закрыт, после чего атрибут оператора возвращается к своему предыдущему значению. Атрибуты оператора, которые могут быть изменены:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|*Атрибут* был SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR или SQL_ATTR_USE_BOOKMARKS, и курсор был открыт.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY009|Недействительное использование нулевой указатель|Аргумент *Attribute* определил атрибут и атрибут, требующий атрибута строки, а аргумент *ValuePtr* был недействительным указателем.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LSetStmtAttr.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY011|Атрибут не может быть установлен сейчас|*Атрибут* был SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR или SQL_ ATTR_USE_BOOKMARKS, и заявление было подготовлено.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY017|Недействительное использование автоматической дескрипторной ручки|(DM) Аргумент *атрибута* был SQL_ATTR_IMP_ROW_DESC или SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) Аргумент *атрибута* был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC, а значение в *ValuePtr* было неявно выделенной дескрипторной ручкой, кроме ручки, первоначально выделенной для ARD или APD.|  
|HY024|Значение недействительных атрибутов|С учетом указанного значения *attribute,* недействительное значение было указано в *ValuePtr*. (Менеджер драйвера возвращает этот S'LSTATE только для атрибутов соединения и оператора, которые принимают дискретный набор значений, таких как SQL_ATTR_ACCESS_MODE или SQL_ ATTR_ASYNC_ENABLE. Для всех остальных атрибутов соединения и оператора водитель должен проверить значение, указанное в *ValuePtr.)*<br /><br /> Аргумент *Attribute* был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC, а *ValuePtr* был явно выделенной дескрипторной ручкой, которая не находится на том же соединении, что и аргумент *StatementHandle.*|  
|HY090|Недействительная длина строки или буфера|(DM) * \*ValuePtr* является строкой символов, и аргумент *StringLength* был меньше, чем 0, но не был SQL_NTS.|  
|HY092|Недействительный идентификатор атрибута/опциона|(DM) Значение, указанное для аргумента *Attribute,* не было действительным для версии ODBC, поддерживаемой драйвером.<br /><br /> (DM) Значение, указанное для аргумента *Attribute,* было атрибутом только для чтения.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Значение, указанное для аргумента *Attribute,* было допустимой атрибутом оператора ODBC для версии ODBC, поддерживаемой водителем, но не была поддержана водителем.<br /><br /> Аргумент *Attribute* был SQL_ATTR_ASYNC_ENABLE, и звонок в **S'LGetInfo** с *InfoType* SQL_ASYNC_MODE возвращает SQL_AM_CONNECTION.<br /><br /> Аргумент *Attribute* был SQL_ATTR_ENABLE_AUTO_IPD, а значение атрибута соединения SQL_ATTR_AUTO_IPD было SQL_FALSE.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|S1118|Водитель не поддерживает асинхронное уведомление|При вызове **S'LSetStmtAttr** для установки SQL_ATTR_ASYNC_STMT_EVENT; асинхронное уведомление не поддерживается драйвером.|  
  
## <a name="comments"></a>Комментарии  
 Атрибуты выписки для оператора остаются в силе до тех пор, пока они не будут изменены другим вызовом на **S'LSetStmtAttr** или до тех пор, пока заявление не будет удалено, позвонив по **телефону s'LFreeHandle**. Вызов **sLFreeStmt** с SQL_CLOSE, SQL_UNBIND или SQL_RESET_PARAMS опции не сбросить атрибуты оператора.  
  
 Некоторые оператора приписывают замену поддержки аналогичного значения, если источник данных не поддерживает значение, указанное в *ValuePtr.* В таких случаях водитель возвращает SQL_SUCCESS_WITH_INFO и S'LSTATE 01S02 (изменение стоимости опциона). Например, если *Attribute* SQL_ATTR_CONCURRENCY и *ValuePtr* SQL_CONCUR_ROWVER, и если источник данных не поддерживает это, драйвер заменяет SQL_CONCUR_VALUES и возвращает SQL_SUCCESS_WITH_INFO. Для определения замещенное значение приложение вызывает **S'LGetStmtAttr.**  
  
 Формат набора информации с *ValuePtr* зависит от указанного *атрибута.* **SLSetStmtAttr** принимает информацию об атрибутах в одном из двух различных форматов: строка символов или значение рядов. Формат каждого из них указан в описании атрибута. Этот формат применяется к информации, возвращенной для каждого атрибута в **S'LGetStmtAttr**. Строки характера, на которые указывает аргумент *ValuePtr* о **S'LSetStmtAttr,** имеют длину *струнного длины.*  
  
> [!NOTE]
>  Возможность установки атрибутов оператора на уровне соединения, позвонив в **s'LSetConnectAttr,** была универслена в ODBC *3.x*. Приложения ODBC *3.x* никогда не должны устанавливать атрибуты оператора на уровне соединения. Атрибуты оператора ODBC *3.x* не могут быть установлены на уровне соединения, за исключением SQL_ATTR_METADATA_ID и SQL_ATTR_ASYNC_ENABLE атрибутов, которые являются атрибутами соединения и атрибутами оператора, и могут быть установлены на уровне соединения или уровне оператора.  
> 
> [!NOTE]
>  Драйверам ODBC *3.x* нужна только поддержка этой функциональности, если они должны работать с приложениями ODBC *2.x,* которые устанавливают параметры оператора ODBC *2.x* на уровне соединения. Для получения дополнительной информации в приложении G: Driver Guidelines for Backward Comatibility можно ознакомиться с информацией о настройках на уровне подключения в соответствии с [картой S'LSetConnectOption.](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md)  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Заявление атрибуты, которые устанавливают дескриптор поля  
 Многие атрибуты оператора соответствуют полю дескриптора заголовка. Установка этих атрибутов фактически приводит к настройке полей дескриптора. Настройка полей по вызову на **sLSetStmtAttr,** а не на **S'LSetDesccField** имеет то преимущество, что ручка дескриптора не должна быть получена для вызова функции.  
  
> [!CAUTION]  
>  Вызов **S'LSetStmtAttr** для одного оператора может повлиять на другие операторы. Это происходит, когда APD или ARD, связанные с оператором, явно выделены и также связаны с другими операторами. Поскольку **S'LSetStmtAttr** модифицирует APD или ARD, изменения применяются ко всем утверждениям, с которыми связан этот дескриптор. Если это не является обязательным поведением, приложение должно отделить этот дескриптор от других инструкций (позвонив в **S'LSetStmtAttr,** чтобы установить поле SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC на другую ручку дескриптора), прежде чем снова позвонить в **S'LSetStmtAttr.**  
  
 Когда поле дескриптора устанавливается в результате установки соответствующего атрибута оператора, поле устанавливается только для применимых дескрипторов, которые в настоящее время связаны с утверждением, идентифицированным аргументом *StatementHandle,* и настройка атрибута не влияет на любые дескрипторы, которые могут быть связаны с этим утверждением в будущем. Когда поле дескриптора, которое также является атрибутом оператора, устанавливается вызовом в **S'LSetDescField,** соответствующий атрибут оператора устанавливается. Если явно выделенный дескриптор отделен от оператора, атрибут оператора, соответствующий поле заголовка, вернется к значению поля в неявно выделенном дескрипторе.  
  
 При выделении оператора (см. [S'LAllocHandle)](../../../odbc/reference/syntax/sqlallochandle-function.md)автоматически выделяются четыре дескрипторные ручки и связаны с утверждением. Явно выделенные дескрипторные ручки могут быть связаны с утверждением, позвонив в **S'LAllocHandle** с *fHandleType* SQL_HANDLE_DESC выделить ручку дескриптора, а затем позвонив в **s'LSetStmtAttr,** чтобы связать ручку дескриптора с утверждением.  
  
 Атрибуты оператора в следующей таблице соответствуют полям заголовка дескриптора.  
  
|Атрибут заявления|Поле заголовка|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Ard|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Ard|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Ard|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ard|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ird|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|Ird|  
  
## <a name="statement-attributes"></a>Атрибуты инструкции  
 В следующей таблице показаны определенные в настоящее время атрибуты и версия ODBC, в которой они были введены; ожидается, что драйверы определят дополнительные атрибуты, чтобы воспользоваться различными источниками данных. Диапазон атрибутов зарезервирован ODBC; разработчики драйверов должны резервировать значения для использования в открытом составе для собственного использования драйверов. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md)  
  
|Атрибут|*Содержимое ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Ручка к APD для последующих вызовов в **S'LExecute** и **S'LExecDirect** на ручке оператора. Первоначальным значением этого атрибута является дескриптор, косвенно выделенный при первоначальном выделении оператора. Если значение этого атрибута настроено на SQL_NULL_DESC или ручку, первоначально выделенную для дескриптора, явно выделенная ручка APD, которая ранее была связана с ручкой оператора, отмежевается от нее, и ручка оператора возвращается к неявно выделенной ручке APD.<br /><br /> Этот атрибут не может быть установлен на ручку дескриптора, которая была косвенно выделена для другого оператора или другой ручки дескриптора, которая была косвенно установлена на том же заявлении; неявно выделенные дескрипторные ручки не могут быть связаны с более чем одной ручкой оператора или дескриптора.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Ручка к ARD для последующих извлечений на ручке оператора. Первоначальным значением этого атрибута является дескриптор, косвенно выделенный при первоначальном выделении оператора. Если значение этого атрибута устанавливается для SQL_NULL_DESC или ручки, первоначально выделенной для дескриптора, явно выделенная ручка ARD, которая ранее была связана с ручкой оператора, отделяется от нее, и ручка оператора возвращается к неявно выделенной ручке ARD.<br /><br /> Этот атрибут не может быть установлен на ручку дескриптора, которая была косвенно выделена для другого оператора или другой ручки дескриптора, которая была косвенно установлена на том же заявлении; неявно выделенные дескрипторные ручки не могут быть связаны с более чем одной ручкой оператора или дескриптора.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Значение S'LULEN, определяемый, выполняется ли функция, вызванная указанным утверждением, асинхронно:<br /><br /> SQL_ASYNC_ENABLE_OFF - asynchronous execution<br /><br /> SQL_ASYNC_ENABLE_ON - Включить асинхронную поддержку выполнения оператора уровня.<br /><br /> Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md)<br /><br /> Для драйверов с асинхронной поддержкой выполнения уровня оператора функция атрибута SQL_ATTR_ASYNC_ENABLE читается только. Его значение такое же, как и значение атрибута уровня соединения с тем же именем на момент выделения ручки оператора.<br /><br /> Вызов **S'LSetStmtAttr** для установки SQL_ATTR_ASYNC_ENABLE, когда SQL_ASYNC_MODE *InfoType* возвращается SQL_AM_CONNECTION возвращает S'LSTATE HYC00 (необязательная функция не реализована). Для получения дополнительной информации, [см.](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Значение S'LPOINTER, которое является ручкой событий.<br /><br /> Уведомление о завершении асинхронных функций включено, позвонив в **S'LSetStmtAttr,** чтобы установить **атрибут SQL_ATTR_ASYNC_STMT_EVENT** и указать ручку события.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Функция асинхронного обратного вызова s'LPOINTER для асинхронной функции обратного вызова.<br /><br /> Только менеджер драйвера может вызвать функцию **драйвера S'LSetStmtAttr** с помощью этого атрибута.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|СЗЛУКЕР в контекстную структуру<br /><br /> Только менеджер драйвера может вызвать функцию **драйвера S'LSetStmtAttr** с помощью этого атрибута.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Значение S'LULEN, которое определяет параллелизм курсора:<br /><br /> SQL_CONCUR_READ_ONLY и Курсор читается только. Обновления не допускаются.<br /><br /> SQL_CONCUR_LOCK - Cursor использует самый низкий уровень блокировки, достаточный для обновления строки.<br /><br /> SQL_CONCUR_ROWVER cursor использует оптимистичный контроль параллелизма, сравнивая строки версий, таких как S'LBase ROWID или Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES - Cursor использует оптимистичный параллелический контроль, сравнивая значения.<br /><br /> Значение по умолчанию для SQL_ATTR_CONCURRENCY является SQL_CONCUR_READ_ONLY.<br /><br /> Этот атрибут не может быть указан для открытого курсора. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/concurrency-types.md)<br /><br /> Если SQL_ATTR_CURSOR_TYPE *атрибута* изменен на тип, не поддерживающий текущее значение SQL_ATTR_CONCURRENCY, значение SQL_ATTR_CONCURRENCY будет изменено во время выполнения, а также предупреждение, выданное при вызове **S'LExecDirect** или **S'LPrepare.**<br /><br /> Если драйвер поддерживает заявление **SELECT FOR UPDATE** и такое заявление выполняется, пока значение SQL_ATTR_CONCURRENCY настроено на SQL_CONCUR_READ_ONLY, ошибка будет возвращена. Если значение SQL_ATTR_CONCURRENCY изменено на значение, которое водитель поддерживает для определенного значения SQL_ATTR_CURSOR_TYPE но не для текущего значения SQL_ATTR_CURSOR_TYPE, значение SQL_ATTR_CURSOR_TYPE будет изменено во время выполнения, а значение S'LSTATE 01S02 (изменение опциона) выдается при вызове **S'LExecDirect** или **S'LPrepare.**<br /><br /> Если указанная параллелиней не поддерживается источником данных, драйвер заменяет другую параллели и возвращает S'LSTATE 01S02 (изменение значения опциона). Для SQL_CONCUR_VALUES водитель заменяет SQL_CONCUR_ROWVER, и наоборот. Для SQL_CONCUR_LOCK водитель заменяет, в порядке, SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Достоверность замещеемого значения не проверяется до момента выполнения.<br /><br /> Для получения дополнительной информации о взаимосвязи между SQL_ATTR_CONCURRENCY и другими атрибутами курсора см. [Характеристики курсора и тип Cursor.](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Значение S'LULEN, которое определяет уровень поддержки, который требуется приложению. Установка этого атрибута влияет на последующие вызовы в **S'LExecDirect** и **S'LExecute.**<br /><br /> SQL_NONSCROLLABLE - Прокрутки курсоры не требуются на рукоятке оператора. Если приложение вызывает **S'LFetchScroll** на этой ручке, единственным допустимой ценностью *FetchOrientation* является SQL_FETCH_NEXT. Это значение по умолчанию.<br /><br /> SQL_SCROLLABLE - На рукоятке оператора требуются прокрутки курсоров. При **вызове S'LFetchScroll,** приложение может указать любое допустимое значение *FetchOrientation,* достижение позиционирования курсора в режимах, кроме последовательного режима.<br /><br /> Для получения дополнительной информации о прокрутки курсоры, см [Прокрутки Курсоры](../../../odbc/reference/develop-app/scrollable-cursors.md). Для получения дополнительной информации о взаимосвязи между SQL_ATTR_CURSOR_SCROLLABLE и другими атрибутами курсора см. [Характеристики Курсора и Тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Значение S'LULEN, окоторомявающего, делают ли курсоры на рукоятке оператора видимыми изменения, внесенные в результат, установленный другим курсором. Установка этого атрибута влияет на последующие вызовы в **S'LExecDirect** и **S'LExecute.** Приложение может считывать значение этого атрибута, чтобы получить его исходное состояние или его состояние, как это было совсем недавно установлено приложением.<br /><br /> SQL_UNSPECIFIED - Не уточняется, что такое тип курсора и делают ли курсоры на рукоятке оператора видимыми изменения, внесенные в результат, установленный другим курсором. Курсоры на рукоятке оператора могут сделать видимыми ни, ни некоторые, ни все такие изменения. Это значение по умолчанию.<br /><br /> SQL_INSENSITIVE - Все курсоры на рукоятке оператора показывают набор результатов, не отражая никаких изменений, внесенных в него любым другим курсором. Нечувствительные курсоры читаются только для чтения. Это соответствует статическому курсору, который имеет параллель, который читается только.<br /><br /> SQL_SENSITIVE - Все курсоры на рукоятке оператора вносят видимые все изменения, внесенные в результат, установленный другим курсором.<br /><br /> Для получения дополнительной информации о взаимосвязи между SQL_ATTR_CURSOR_SENSITIVITY и другими атрибутами курсора см. [Характеристики курсора и тип Cursor.](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Значение S'LULEN, описавающего тип курсора:<br /><br /> SQL_CURSOR_FORWARD_ONLY курсор только прокручивается вперед.<br /><br /> SQL_CURSOR_STATIC данные в наборе результатов статичны.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN - Драйвер сохраняет и использует клавиши для количества строк, указанных в атрибуте SQL_ATTR_KEYSET_SIZE оператора.<br /><br /> SQL_CURSOR_DYNAMIC - Драйвер сохраняет и использует только клавиши для строк в строке.<br /><br /> Значение по умолчанию является SQL_CURSOR_FORWARD_ONLY. Этот атрибут не может быть указан после подготовки оператора S'L.<br /><br /> Если указанный тип курсора не поддерживается источником данных, драйвер заменяет другой тип курсора и возвращает S'LSTATE 01S02 (изменение значения опциона). Для смешанного или динамического курсора драйвер заменяет в порядке, клавишный или статический курсор. Для курсора, управляемого ключем, драйвер заменяет статический курсор.<br /><br /> Для получения дополнительной информации о прокрутки типов курсора, см [Прокрутки Cursor Типы](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Для получения дополнительной информации о взаимосвязи между SQL_ATTR_CURSOR_TYPE и другими атрибутами курсора см. [Характеристики курсора и тип Cursor.](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Значение S'LULEN, которое определяет, выполняется ли автоматическое население ИПД:<br /><br /> SQL_TRUE - Включает автоматическое население IPD после звонка в **S'LPrepare**. SQL_FALSE - отключает автоматическое население IPD после звонка в **S'LPrepare**. (Приложение все еще может получить информацию о поле IPD, позвонив в **S'LDescribeParam,** если она будет поддержана.) Значение атрибута оператора по умолчанию SQL_ATTR_ENABLE_AUTO_IPD является SQL_FALSE. Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md)|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|СЗЛЛЕН, \* указана на бинарное значение закладки. Когда **s'LFetchScroll** вызывается с *fFetchOrientation,* равным SQL_FETCH_BOOKMARK, водитель забирает значение закладки из этой области. Это поле по умолчанию указывает на нулевую указку. Для получения дополнительной информации [см. Прокрутка по закладке](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Значение, на которое указывается в этом поле, не используется для удаления закладкой, обновления закладкой или получения закладками операций в **S'LBulkOperations,** которые используют закладки, кэшированные в буферах строк.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Ручка для IPD. Значение этого атрибута — дескриптор, выделенный при первоначальном выделении оператора. Приложение не может установить этот атрибут.<br /><br /> Этот атрибут может быть извлечен по вызову в **S'LGetStmtAttr,** но не установлен по вызову в **S'LSetStmtAttr.**|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Ручка для IRD. Значение этого атрибута — дескриптор, выделенный при первоначальном выделении оператора. Приложение не может установить этот атрибут.<br /><br /> Этот атрибут может быть извлечен по вызову в **S'LGetStmtAttr,** но не установлен по вызову в **S'LSetStmtAttr.**|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|СЗЛУЛЕН, который определяет количество строк в клавиатуре для курсора, управляемого клавиатурой. Если размер ключа 0 (по умолчанию), курсор полностью управляется ключом. Если размер ключа больше 0, курсор смешивается (клавиша в ключе и динамическая за пределами клавиатуры). Размер ключа по умолчанию раста 0. Для получения дополнительной информации о курсорах, управляемых ключами, [см.](../../../odbc/reference/develop-app/keyset-driven-cursors.md)<br /><br /> Если указанный размер превышает максимальный размер ключа, драйвер заменяет этот размер и возвращает S'LSTATE 01S02 (изменение значения опциона).<br /><br /> **S'LFetch** или **S'LFetchScroll** возвращает ошибку, если размер набора ключей больше, чем 0 и меньше, чем размер строки.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Значение S'LULEN, которое определяет максимальный объем данных, которые водитель возвращает из символа или двоичного столбца. Если *ValuePtr* меньше, чем длина имеющихся данных, **S'LFetch** или **S'LGetData** усечения данных и возвращает SQL_SUCCESS. Если *ValuePtr* равен 0 (по умолчанию), драйвер пытается вернуть все доступные данные.<br /><br /> Если указанная длина меньше минимального объема данных, который может вернуть источник данных, или превышает максимальный объем данных, который может вернуть источник данных, драйвер заменяет это значение и возвращает S'LSTATE 01S02 (изменение значения опциона).<br /><br /> Значение этого атрибута может быть установлено на открытом курсорах; однако параметр может встретиться не сразу, и в этом случае драйвер вернет S'Lstate 01S02 (изменение значения опциона) и сброс атрибута к исходной стоимости.<br /><br /> Этот атрибут предназначен для уменьшения сетевого трафика и должен поддерживаться только тогда, когда источник данных (в отличие от драйвера) в многоуровневом драйвере может реализовать его. Этот механизм не должен использоваться приложениями для усечения данных; для усечения полученных данных, приложение должно указать максимальную длину буфера в аргументе *BufferLength* в **S'LBindCol** или **S'LGetData.**|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Значение S'LULEN, соответствующее максимальному количеству строк для возврата в приложение для выписки **SELECT.** Если \* *ValuePtr* равен 0 (по умолчанию), драйвер возвращает все строки.<br /><br /> Этот атрибут предназначен для сокращения сетевого трафика. Концептуально он применяется при создании набора результатов и ограничивает результат, установленный первыми строками *ValuePtr.* Если количество строк в наборе результатов больше *ValuePtr,* набор результатов усечен.<br /><br /> SQL_ATTR_MAX_ROWS применяется ко всем наборам результатов в *Отчете,* включая наборы, возвращенные функциями каталога. SQL_ATTR_MAX_ROWS устанавливает максимум для значения количества строк курсора.<br /><br /> Водитель не должен подражать SQL_ATTR_MAX_ROWS поведению для **S'LFetch** или **S'LFetchScroll** (если ограничения размера, установленного в результате, не могут быть реализованы в источнике данных), если он не может гарантировать, что SQL_ATTR_MAX_ROWS будет реализован должным образом.<br /><br /> Это определяется драйвером, применяется ли SQL_ATTR_MAX_ROWS к заявлениям, не всхотливой к заявлениям SELECT (например, к функциям каталога).<br /><br /> Значение этого атрибута может быть установлено на открытом курсорах; однако параметр может встретиться не сразу, и в этом случае драйвер вернет S'Lstate 01S02 (изменение значения опциона) и сброс атрибута к исходной стоимости.|  
|SQL_ATTR_METADATA_ID (ODBc 3.0)|Значение S'LULEN, определяющее, как обрабатываются строки аргументов функций каталога.<br /><br /> Если SQL_TRUE, строка аргумент функции каталога рассматриваются как идентификаторы. Дело не имеет существенного значения. Для неразграниченных строк драйвер удаляет все задние пространства, а строка складывается в верхний корпус. Для делимитированных строк, водитель удаляет любые ведущие или задние пространства и принимает все, что находится между делимитерами буквально. Если один из этих аргументов установлен на нулевую указку, функция возвращается SQL_ERROR и S'LSTATE HY009 (Недействительное использование нулевого указателя).<br /><br /> Если SQL_FALSE, строки аргументы функций каталога не рассматриваются как идентификаторы. Случай имеет важное значение. Они могут содержать шаблон поиска строки или нет, в зависимости от аргумента.<br /><br /> Значение по умолчанию составляет SQL_FALSE.<br /><br /> Аргумент *TableType,* **который**принимает список значений, не зависит от этого атрибута.<br /><br /> SQL_ATTR_METADATA_ID также может быть установлен на уровне соединения. (Это и SQL_ATTR_ASYNC_ENABLE являются единственными атрибутами оператора, которые также являются атрибутами соединения.)<br /><br /> Для получения дополнительной информации смотрите [аргументы в каталоге функции](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Значение S'LULEN, которое указывает, должен ли драйвер сканировать строки S'L для последовательностей побега:<br /><br /> SQL_NOSCAN_OFF - Драйвер сканирует строки S'L для последовательностей побега (по умолчанию).<br /><br /> SQL_NOSCAN_ON - Драйвер не сканирует строки S'L для последовательностей побега. Вместо этого водитель отправляет выписку непосредственно в источник данных.<br /><br /> Для получения дополнительной [информации, см. Побег Последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Значение S'LULEN, которое указывает на смещение, добавленное в указатели для изменения связывания динамических параметров. Если это поле не является нулевым, драйвер ссылается на указатель, добавляет декоранное значение к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и использует новые значения указателя при связке. Он установлен на нуле в ней по умолчанию.<br /><br /> Смещение связывания всегда добавляется непосредственно к SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR полям. Если смещение изменено на другое значение, новое значение по-прежнему добавляется непосредственно к значению в поле дескриптора. Новое смещение не добавляется к значению поля плюс любые предыдущие смещения.<br /><br /> Для получения дополнительной [информации](../../../odbc/reference/develop-app/parameter-binding-offsets.md)см.<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_BIND_OFFSET_PTR в заголовке APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Значение S'LULEN, указывающее на обязательную ориентацию, которая будет использоваться для динамических параметров.<br /><br /> Это поле установлено для SQL_PARAM_BIND_BY_COLUMN (по умолчанию) для выбора столбцов-мудрый связывания.<br /><br /> Для выбора связывания с рядом это поле устанавливается по длине структуры или экземпляру буфера, который будет привязан к набору динамических параметров. Эта длина должна включать пространство для всех связанных параметров и любую обивку структуры или буфера, чтобы, когда адрес связанного параметра был приращен с указанной длиной, результат будет указывать на начало одного и того же параметра в следующем наборе параметров. При использовании *оператора sizeof* в ANSI C такое поведение гарантируется.<br /><br /> Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ BIND_TYPE в заголовке APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBc 3.0)|Значение S'LUSMALLINT, \* которое указывает на массив значений S'LUSMALLINT, используемых для игнорирования параметра при выполнении оператора S'L. Каждое значение устанавливается либо SQL_PARAM_PROCEED (для выполнения параметра), либо SQL_PARAM_IGNORE (для того, чтобы параметр был проигнорирован).<br /><br /> Набор параметров может быть проигнорирован во время обработки, установив значение состояния в массиве, на который указывает SQL_DESC_ARRAY_STATUS_PTR apD, SQL_PARAM_IGNORE. Набор параметров обрабатывается, если значение его статуса установлено для SQL_PARAM_PROCEED или если элементы в массиве не установлены.<br /><br /> Этот атрибут оператора может быть установлен на нулевой указатель, и в этом случае драйвер не возвращает значения статуса параметра. Этот атрибут может быть установлен в любое время, но новое значение не будет использоваться до следующего момента, когда **будет названа s-LExecDirect** или **S'LExecute.**<br /><br /> Этот атрибут игнорируется, когда нет связанного параметра.<br /><br /> Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/using-arrays-of-parameters.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Значение S'LUSMALLINT, \* которое указывает на массив значений S'LUSMALLINT, содержащих информацию о состоянии для каждой строки значений параметров после вызова в **S'LExecute** или **S'LExecDirect.** Это поле требуется только в том случае, если PARAMSET_SIZE больше 1.<br /><br /> Значения статуса могут содержать следующие значения:<br /><br /> SQL_PARAM_SUCCESS: Для этого набора параметров была успешно выполнена выписка по S'L.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Заявление S'L было успешно выполнено для этого набора параметров; однако в структуре диагностических данных имеется предупреждающая информация.<br /><br /> SQL_PARAM_ERROR: Была ошибка в обработке этого набора параметров. Дополнительная информация об ошибках доступна в структуре данных диагностики.<br /><br /> SQL_PARAM_UNUSED: Этот набор параметров был неиспользованным, возможно, из-за того, что некоторые предыдущие набор параметров вызвали ошибку, которая прервала дальнейшую обработку, или потому, что SQL_PARAM_IGNORE был задан для этого набора параметров в массиве, указанном SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Драйвер рассматривает массивы параметров как монолитную единицу и поэтому не генерирует данный уровень информации об ошибках.<br /><br /> Этот атрибут оператора может быть установлен на нулевой указатель, и в этом случае драйвер не возвращает значения статуса параметра. Этот атрибут может быть установлен в любое время, но новое значение не используется до следующего момента, когда **будет названа s'L'LExecute** или **S'LExecDirect.** Обратите внимание, что установка этого атрибута может повлиять на поведение параметра вывода, реализованное драйвером.<br /><br /> Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/using-arrays-of-parameters.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Поле записи \* S'LULEN, которое указывает на буфер, в котором возвращается количество параметров, которые были обработаны, включая наборы ошибок. Номер не будет возвращен, если это нулевая указка.<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ROWS_PROCESSED_PTR в заголовке IPD.<br /><br /> Если вызов в **S'LExecDirect** или **S'LExecute,** который заполняет буфер, на который указывает этот атрибут, не возвращается SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.<br /><br /> Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/using-arrays-of-parameters.md)|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Значение S'LULEN, которое определяет количество значений для каждого параметра. Если SQL_ATTR_PARAMSET_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR APD указывают на массивы. Кардинальность каждого массива равна значению этого поля.<br /><br /> Этот атрибут игнорируется, когда нет связанного параметра.<br /><br /> Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/using-arrays-of-parameters.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ARRAY_SIZE в заголовке APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Значение S'LULEN, соответствующее количеству секунд, чтобы дождаться выполнения оператора S'L, прежде чем вернуться в приложение. Если *ValuePtr* равен 0 (по умолчанию), тайм-аут отсутствует.<br /><br /> Если указанный тайм-аут превышает максимальный тайм-аут в источнике данных или меньше минимального тайм-аута, **s'LSetStmtAttr** заменяет это значение и возвращает S'LSTATE 01S02 (изменение стоимости опциона).<br /><br /> Обратите внимание, что приложению не нужно вызывать **S'LCloseCursor** для повторного использования оператора, если выписка **SELECT** приурочена.<br /><br /> Время выхода запроса в атрибуте этого оператора допустимо как в синхронном, так и в асинхронном режимах.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Значение СЗЛУЛЕН:<br /><br /> SQL_RD_ON **s'LFetchScroll** и, в ODBC *3.x*, **S'LFetch** получить данные после того, как он позиционирует курсор в указанном месте. Это значение по умолчанию.<br /><br /> SQL_RD_OFF **s'LFetchScroll** и, в ODBC *3.x*, **S'LFetch** не извлекают данные после того, как он позиционирует курсор.<br /><br /> Установив SQL_RETRIEVE_DATA SQL_RD_OFF, приложение может проверить наличие строки или получить закладку для строки, не понеся накладных расходов на извлекаемые строки. Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md)<br /><br /> Значение этого атрибута может быть установлено на открытом курсорах; однако параметр может встретиться не сразу, и в этом случае драйвер вернет S'Lstate 01S02 (изменение значения опциона) и сброс атрибута к исходной стоимости.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Значение S'LULEN, которое указывает количество строк, возвращенных каждым вызовом в **S'LFetch** или **S'LFetchScroll.** Кроме того, количество строк в массиве закладок, используемых в операции навалом закладок в **S'LBulkOperations.** Значение по умолчанию — 1.<br /><br /> Если указанный размер строки превышает максимальный размер строки, поддерживаемый источником данных, драйвер заменяет это значение и возвращает S'LSTATE 01S02 (изменение значения опциона).<br /><br /> Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/rowset-size.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ARRAY_SIZE в заголовке ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Значение S'LULEN, которое указывает на смещение, добавленное в указатели для изменения связывания данных столбцов. Если это поле не является нулевым, драйвер ссылается на указатель, добавляет декоранное значение к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и использует новые значения указателя при связке. Он установлен на нуле в ней по умолчанию.<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_BIND_OFFSET_PTR в заголовке ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Значение S'LULEN, которое устанавливает обязательную ориентацию, которая будет использоваться при вызове **s'LFetch** или **S'LFetchScroll** на связанное заявление. Связывание по колонке выбирается путем установки значения для SQL_BIND_BY_COLUMN. Связывание по гребню выбирается путем установления значения длины структуры или экземпляра буфера, в который будут связаны столбцы результата.<br /><br /> Если длина указана, она должна включать пространство для всех связанных столбцов и любую обивку структуры или буфера, чтобы убедиться, что, когда адрес связанного столбца приравнирован с указанной длиной, результат укажет на начало той же колонны в следующем ряду. При использовании **оператора size of** со структурами или соединениями в ANSI C такое поведение гарантируется.<br /><br /> Связывание по поломки является обязательной ориентацией по умолчанию для **S'LFetch** и **S'LFetchScroll.**<br /><br /> Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_BIND_TYPE в заголовке ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Значение S'LULEN, то есть число текущего строки во всем наборе результатов. Если число текущей строки не может быть определено или нет текущей строки, драйвер возвращает 0.<br /><br /> Этот атрибут может быть извлечен по вызову в **S'LGetStmtAttr,** но не установлен по вызову в **S'LSetStmtAttr.**|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Значение СЗЛУСМЛИНТ, \* которое указывает на массив значений S'LUSMALLINT, используемых для игнорирования строки во время массовой операции с использованием **S'LSetPos.** Каждое значение устанавливается либо SQL_ROW_PROCEED (для включения строки в объемную операцию), либо SQL_ROW_IGNORE (для исключения строки из основной операции). (Строки не могут быть проигнорированы, используя этот массив во время вызовов на **S'LBulkOperations.)**<br /><br /> Этот атрибут оператора может быть установлен на нулевой указатель, и в этом случае драйвер не возвращает значения состояния строки. Этот атрибут может быть установлен в любое время, но новое значение не используется до следующего вызова **S'LSetPos.**<br /><br /> Для получения дополнительной информации, [см. Обновление строк в Rowset с S'LSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) и [Удаления строк в Rowset с S'LSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ARRAY_STATUS_PTR в ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Значение S'LUSMALLINT, \* которое указывает на массив значений S'LUSMALLINT, содержащих значения статуса строки после вызова в **S'LFetch** или **S'LFetchScroll.** Массив имеет столько элементов, сколько рядов в строке.<br /><br /> Этот атрибут оператора может быть установлен на нулевой указатель, и в этом случае драйвер не возвращает значения состояния строки. Этот атрибут может быть установлен в любое время, но новое значение не будет использоваться до тех пор, пока не будет названа следующая причина, когда будет названа **s-LBulkOperations,** **S'LFetchScroll**или **S'LSetPos.** **SQLFetchScroll**<br /><br /> Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке IRD.<br /><br /> Этот атрибут отображается драйвером ODBC *2.x* в *массиве rgbRowStatus* в вызове на **S'LExtendedFetch.**|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Значение S'LULEN, \* которое указывает на буфер, в котором можно вернуть количество строк, извлеченных после звонка в **S'LFetch** или **S'LFetchScroll;** количество строк, затронутых массовой операцией, выполняемой вызовом в **S'LSetPos** с *аргументом операции* SQL_REFRESH; или количество строк, затронутых массовой операцией, выполняемой **S'LBulkOperations.** Это число включает строки ошибок.<br /><br /> Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md)<br /><br /> Установка атрибута этого оператора устанавливает поле SQL_DESC_ROWS_PROCESSED_PTR в заголовке IRD.<br /><br /> Если вызов в **S'LFetch** или **S'LFetchScroll,** который заполняет буфер, на который указывает этот атрибут, не возвращается SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Значение S'LULEN, которое определяет, гарантируют ли драйверы, имитирующие позиционированные операторы обновления и удаления, что такие операторы затрагивают только одну строку.<br /><br /> Чтобы смоделировать позиционированное обновление и удаление инструкций, большинство драйверов строят поиск **ОВОТН** или заявление **DELETE,** содержащее положение **WHERE,** которое определяет значение каждого столба в текущей строке. Если эти столбцы не составляют уникальный ключ, такое утверждение может повлиять не сколько на одну строку.<br /><br /> Чтобы гарантировать, что такие операторы влияют только на одну строку, драйвер определяет столбцы в уникальном ключе и добавляет эти столбцы к набору результатов. Если приложение гарантирует, что столбцы в настроенном результате составляют уникальный ключ, водитель не обязан это делать. Это может сократить время выполнения.<br /><br /> SQL_SC_NON_UNIQUE драйвер не гарантирует, что смоделированные позиционированные операторы по обновлению или удалению затронут только одну строку; это ответственность приложения, чтобы сделать это. Если выписка затрагивает более одной строки, **то S'LExecute**, **S'LExecDirect**или **S'LSetPos** возвращает S'Lstate 01001 (конфликт операции Cursor).<br /><br /> SQL_SC_TRY_UNIQUE - Драйвер пытается гарантировать, что смоделированные позиционированные операторы появляются только по одной строке. Драйвер всегда выполняет такие операторы, даже если они могут повлиять на более чем одну строку, например, когда нет уникального ключа. Если выписка затрагивает более одной строки, **то S'LExecute**, **S'LExecDirect**или **S'LSetPos** возвращает S'Lstate 01001 (конфликт операции Cursor).<br /><br /> SQL_SC_UNIQUE драйвер гарантирует, что смоделированные позиционированные операторы обновляются или удаляют только одну строку. Если драйвер не может гарантировать это для данного оператора, **S'LExecDirect** или **S'LPrepare** возвращает ошибку.<br /><br /> Если источник данных предоставляет родную поддержку S'L для позиционируемых инструкций по обновлению и удалению, а драйвер не имитирует курсоры, SQL_SUCCESS возвращается, когда SQL_SC_UNIQUE запрашивается для SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO возвращается, если запрашивается SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE. Если источник данных обеспечивает SQL_SC_TRY_UNIQUE уровень поддержки, а водитель нет, SQL_SUCCESS возвращается за SQL_SC_TRY_UNIQUE и SQL_SUCCESS_WITH_INFO возвращается за SQL_SC_NON_UNIQUE.<br /><br /> Если указанный тип моделирования курсора не поддерживается источником данных, драйвер заменяет другой тип моделирования и возвращает S'LSTATE 01S02 (изменение значения опциона). Для SQL_SC_UNIQUE водитель заменяет, в порядке, SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE. Для SQL_SC_TRY_UNIQUE, водитель заменяет SQL_SC_NON_UNIQUE.<br /><br /> По умолчанию SQL_SC_UNIQUE.<br /><br /> Для получения дополнительной [Simulating Positioned Update and Delete Statements](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md)информации см.|  
|SQL_ATTR_USE_BOOKMARKS (ODBc 2.0)|Значение S'LULEN, которое определяет, будет ли приложение использовать закладки с курсором:<br /><br /> SQL_UB_OFF и выключен (по умолчанию)<br /><br /> SQL_UB_VARIABLE - Приложение будет использовать закладки с курсором, и водитель будет предоставлять закладки с переменной длиной, если они поддерживаются. SQL_UB_FIXED амортизированв в ODBC *3.x*. Приложения ODBC *3.x* всегда должны использовать закладки с переменной длиной, даже при работе с драйверами ODBC *2.x* (которые поддерживали только 4 байт, закладки с фиксированной длиной). Это потому, что фиксированная длина закладки просто особый случай переменной длины закладки. При работе с драйвером ODBC *2.x,* менеджер драйвера водителя SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Чтобы использовать закладки с курсором, приложение должно указать этот атрибут с SQL_UB_VARIABLE значение перед открытием курсора.<br /><br /> Для получения дополнительной [информации, см.](../../../odbc/reference/develop-app/retrieving-bookmarks.md)|  
  
 Эти функции можно назвать асинхронно только в том случае, если дескриптор является дескриптором реализации, а не дескриптором приложения.  
  
 Смотрите [колонку-Мудрый связывания](../../../odbc/reference/develop-app/column-wise-binding.md) и [строки-мудрый связывания](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение параметра атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Возвращение атрибута оператора|[Функция SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Установка атрибута соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Установка одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
