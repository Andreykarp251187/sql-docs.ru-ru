---
title: Функция SQLSetStmtAttr | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 0805cafcdae76e3f4d7f8405088f5fe93fbc985b
ms.sourcegitcommit: 56b963446965f3a4bb0fa1446f49578dbff382e0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2019
ms.locfileid: "67793914"
---
# <a name="sqlsetstmtattr-function"></a>Функция SQLSetStmtAttr
**Соответствие стандартам**  
 Представленные версии: ODBC 3.0 стандартов соответствия: ISO-92  
  
 **Сводка**  
 **SQLSetStmtAttr** задает атрибуты, связанные с инструкцию.  
  
> [!NOTE]
>  Дополнительные сведения о что диспетчер драйверов сопоставляет эту функцию, чтобы при ODBC *3.x* при работе с ODBC *2.x* драйвера, см. в разделе [сопоставление замещающих функций для назад Совместимость приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *Attribute*  
 [Вход] Возможность задания, перечисленные в «Комментарии».  
  
 *ValuePtr*  
 [Вход] Значение должно быть связано с *атрибут*. В зависимости от значения *атрибут*, *ValuePtr* будет иметь одно из следующих:  
  
-   Дескриптор ODBC.  
  
-   Значение SQLUINTEGER.  
  
-   Значение SQLULEN.  
  
-   Указатель на один из следующих:  
  
    -   Строка символов с завершающим нулем.  
  
    -   Бинарный буфер.  
  
    -   Значение или массив объектов типа SQLLEN, SQLULEN или SQLUSMALLINT.  
  
    -   Значение, определяемым драйвером.  
  
 Если *атрибут* аргумент представляет собой значение специфические для драйвера *ValuePtr* может быть целое число со знаком.  
  
 *StringLength*  
 [Вход] Если *атрибут* является атрибутом, определенных для ODBC и *ValuePtr* указывает на строку символов или двоичный буфер, данный аргумент должен иметь длину \* *ValuePtr*. Если *атрибут* является атрибутом, определенных для ODBC и *ValuePtr* должно быть целым числом, *StringLength* учитывается.  
  
 Если *атрибут* является атрибутом, определяемым драйвером, приложение указывает характер атрибут для диспетчера драйверов, задав *StringLength* аргумент. *StringLength* может иметь следующие значения:  
  
-   Если *ValuePtr* — это указатель на строку символов, затем *StringLength* длина строки или SQL_NTS.  
  
-   Если *ValuePtr* является указателем в двоичный буфер, а затем приложение размещает результат SQL_LEN_BINARY_ATTR (*длина*) в макрос *StringLength*. Это размещает отрицательное значение в *StringLength*.  
  
-   Если *ValuePtr* — это указатель на значение, отличное от строку символов или двоичная строка, затем *StringLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение фиксированной длины, то *StringLength* является SQL_IS_INTEGER или SQL_IS_UINTEGER, соответствующим образом.  
  
## <a name="returns"></a>Возвращает  
 Значение SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetStmtAttr** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE может быть получен путем вызова **SQLGetDiagRec** с *HandleType* из SQL _HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSetStmtAttr** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Драйвер не поддерживает значения, указанного в *ValuePtr*, или значение, указанное в *ValuePtr* Недопустимый рабочий трудностями реализации, драйвер заменены примерно такое же значение. (**SQLGetStmtAttr** может быть вызвана для определения временно подставляемого значения.) Заменяющее значение является допустимым для *StatementHandle* до закрытия курсора, после чего атрибут инструкции возвращается к предыдущему значению. Атрибуты инструкции, которые могут быть изменены следующие:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT  SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|24000|Недопустимое состояние курсора|*Атрибут* был SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR или SQL_ATTR_USE_BOOKMARKS, и курсор был открыт.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY009|Недопустимое использование пустого указателя|*Атрибут* аргумент определенный атрибут инструкции, которая требуемый строковый атрибут, и *ValuePtr* аргумент был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLSetStmtAttr** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY011|Атрибут нельзя установить сейчас|*Атрибут* был SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR или SQL_ ATTR_USE_BOOKMARKS и подготовленной инструкции.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY017|Недопустимое использование автоматически выделенного дескриптора|(DM) *атрибут* аргумент был SQL_ATTR_IMP_ROW_DESC или SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) *атрибут* аргумент был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC и значение в *ValuePtr* изначально был неявно выделенного дескриптора Кроме дескриптор выделить для Отменить или APD.|  
|HY024|Недопустимое значение атрибута|Дан указанный *атрибут* , недопустимое значение было указано значение в *ValuePtr*. (The Driver Manager возвращает этот SQLSTATE только для подключения и атрибуты инструкции, которые принимают дискретный набор значений, таких как SQL_ATTR_ACCESS_MODE или SQL_ ATTR_ASYNC_ENABLE. Для всех других атрибутов соединения и инструкции, драйвер должен проверить значение, указанное в *ValuePtr*.)<br /><br /> *Атрибут* аргумент был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC, и *ValuePtr* был явно выделенные дескриптора, которого нет в то же подключение, как  *StatementHandle* аргумент.|  
|HY090|Недопустимая длина строки или буфера|(DM)  *\*ValuePtr* представляет собой строку символов и *StringLength* аргумент был, но меньше 0 не SQL_NTS.|  
|HY092|Недопустимый атрибут/идентификатор параметра|(DM) значение, указанное для аргумента *атрибут* недопустимо для версии ODBC, поддерживаемых драйвером.<br /><br /> (DM) значение, указанное для аргумента *атрибут* был атрибут только для чтения.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Значение, указанное для аргумента *атрибут* был допустимым атрибут инструкции ODBC, драйвер поддерживает используемая версия ODBC, но не поддерживается драйвером.<br /><br /> *Атрибут* аргумент был атрибуту SQL_ATTR_ASYNC_ENABLE и вызов **SQLGetInfo** с *InfoType* SQL_ASYNC_MODE возвращает SQL_AM_CONNECTION.<br /><br /> *Атрибут* аргумент был SQL_ATTR_ENABLE_AUTO_IPD, и значение атрибута соединения SQL_ATTR_AUTO_IPD SQL_FALSE.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|S1118|Драйвер не поддерживает асинхронное уведомление|Если вызов **SQLSetStmtAttr** SQL_ATTR_ASYNC_STMT_EVENT; задать асинхронное уведомление не поддерживается драйвером.|  
  
## <a name="comments"></a>Комментарии  
 Атрибуты инструкции для инструкции остаются в силе, пока они были изменены другим вызовом **SQLSetStmtAttr** или до удаления путем вызова инструкции **SQLFreeHandle**. Вызов **SQLFreeStmt** SQL_CLOSE, SQL_UNBIND или SQL_RESET_PARAMS параметр не приводит к сбросу атрибуты инструкции.  
  
 Некоторые атрибуты инструкции поддерживают замену примерно такое же значение, если источник данных не поддерживает значения, указанного в *ValuePtr*. В таком случае драйвер возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01S02 (значение параметра изменено). Например если *атрибут* — SQL_ATTR_CONCURRENCY и *ValuePtr* является SQL_CONCUR_ROWVER, и если источник данных не поддерживает это, драйвер подставляет SQL_CONCUR_VALUES и возвращает SQL_ SUCCESS_WITH_INFO. Чтобы определить это значение, приложение вызывает **SQLGetStmtAttr**.  
  
 Формат данных, набор с *ValuePtr* зависит от указанного *атрибут*. **SQLSetStmtAttr** принимает сведения об атрибутах в одном из двух форматов: символьная строка или целое число. Формат каждого из них указан в описании атрибута. Применяется этот формат данных, возвращаемых для каждого атрибута в **SQLGetStmtAttr**. Символьные строки, на которые указывают *ValuePtr* аргумент **SQLSetStmtAttr** иметь длину *StringLength*.  
  
> [!NOTE]
>  Возможность устанавливать атрибуты инструкции на уровне соединения, вызвав **SQLSetConnectAttr** был объявлен устаревшим в ODBC *3.x*. ODBC *3.x* приложения никогда не следует устанавливать атрибуты инструкции на уровне соединения. ODBC *3.x* атрибуты инструкции, которые нельзя установить на уровне соединения, за исключением SQL_ATTR_METADATA_ID и атрибуту SQL_ATTR_ASYNC_ENABLE атрибуты, которые атрибуты соединения и атрибуты инструкции, но может быть задать на уровне соединения или уровне инструкций.  
> 
> [!NOTE]
>  ODBC *3.x* драйверы должен поддерживать эту функцию, только если они должны работать с ODBC *2.x* приложения, значение ODBC *2.x* параметров инструкции на уровне соединения. Дополнительные сведения см. в разделе «Параметр инструкции параметры на уровень соединения» в разделе [сопоставление SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) в приложении G: Рекомендации по драйверов для обеспечения обратной совместимости.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Атрибуты инструкции, задать поля дескриптора  
 Многие атрибуты инструкции соответствуют поле заголовка дескриптора. Установка этих атрибутов фактически результаты в параметре полей дескриптора. Задание полей с помощью вызова **SQLSetStmtAttr** , а не к **SQLSetDescField** имеет то преимущество, что дескриптор не должен получить для вызова функции.  
  
> [!CAUTION]  
>  Вызов **SQLSetStmtAttr** для одной инструкции может повлиять на другие инструкции. Это происходит, когда APD или Отменить, связанные с инструкцией явным образом выделяется, а также связан с другими инструкциями. Так как **SQLSetStmtAttr** изменяет APD или Отменить, изменения применяются ко всем операторам, с которыми связан данный дескриптор. Если это не требуемое поведение, приложение должно отменить связь этот дескриптор из других инструкций (путем вызова **SQLSetStmtAttr** задать поле SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC на другой Дескриптор) перед вызовом **SQLSetStmtAttr** еще раз.  
  
 Если поле дескриптора имеет значение в результате соответствующего задаваемого атрибута инструкции, поле имеет значение только для применимо дескрипторов, которые в настоящее время связаны с инструкцией, определяется *StatementHandle* аргумент и параметр атрибута не влияет на все дескрипторы, которые могут быть связаны с этой инструкции в будущем. Если поле дескриптора, который также является атрибут инструкции является значение путем вызова **SQLSetDescField**, устанавливается соответствующий атрибут инструкции. Если явно выделенные дескриптор является связанным с инструкцию, атрибут, оператор, который соответствует полю заголовка вернется к значение поля в дескрипторе неявно выделенные.  
  
 Когда выделяется инструкцию (см. в разделе [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), четыре указатели дескрипторов автоматически выделенных и связанные с инструкцией. Явно выделенные указатели дескрипторов можно связать с инструкцией, вызвав **SQLAllocHandle** с *fHandleType* из SQL_HANDLE_DESC для выделения дескриптора и затем вызвав  **SQLSetStmtAttr** должен быть сопоставлен дескриптора инструкции.  
  
 Атрибуты инструкции в следующей таблице соответствуют поля заголовка дескриптора.  
  
|атрибут инструкции|Поле заголовка|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Атрибуты инструкции  
 В настоящее время определены атрибуты и используемая версия ODBC, в котором они были введены показаны в следующей таблице; предполагается, что определены дополнительные атрибуты, драйверы, чтобы воспользоваться преимуществами различных источников данных. Широкий набор атрибутов зарезервировано для ODBC. разработчики драйверов необходимо зарезервировать значения для собственных нужд конкретного драйвера из Open Group. Дополнительные сведения см. в разделе [типов данных драйвера, типы дескрипторов, типы сведений, диагностические типы и атрибуты](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|*ValuePtr* содержимое|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Дескриптор APD для последующих вызовов **SQLExecute** и **SQLExecDirect** с дескриптором инструкции. Начальное значение этого атрибута является дескриптором, выделяемого неявно, если инструкция была изначально выделена. Если значение этого атрибута является значение SQL_NULL_DESC или дескриптор, исходно выделенного для дескриптора, явно выделенные дескриптор APD, который был ранее связан с дескриптором инструкции, отделена от него, и возвращается дескриптор инструкции неявно выделенные дескриптор APD.<br /><br /> Этот атрибут не может задать для дескриптора, который неявно был выделен для другой инструкции или другой дескриптор, который был неявно устанавливается на одной и той же инструкции; неявно выделенные указатели дескрипторов не может быть связан более одной инструкции или дескриптора.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Дескриптор Отменить для последующей выборке с дескриптором инструкции. Начальное значение этого атрибута является дескриптором, выделяемого неявно, если инструкция была изначально выделена. Если значение этого атрибута является значение SQL_NULL_DESC или дескриптор, исходно выделенного для дескриптора, явно выделенные дескриптор Отменить, который был ранее связан с дескриптором инструкции, отделена от него, и возвращается дескриптор инструкции неявно выделенные Отменить маркер.<br /><br /> Этот атрибут не может задать для дескриптора, который неявно был выделен для другой инструкции или другой дескриптор, который был неявно устанавливается на одной и той же инструкции; неявно выделенные указатели дескрипторов не может быть связан более одной инструкции или дескриптора.|  
|АТРИБУТУ SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|SQLULEN значение, указывающее, выполняется ли функция, вызываемая с указанной инструкцией асинхронно:<br /><br /> SQL_ASYNC_ENABLE_OFF = поддержка уровня асинхронное выполнение инструкции Disable (по умолчанию).<br /><br /> SQL_ASYNC_ENABLE_ON = Включение поддержки уровня асинхронное выполнение инструкции.<br /><br /> Дополнительные сведения см. в разделе [асинхронное выполнение (метод опроса)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Для драйверов с поддержкой уровня асинхронное выполнение инструкции атрибут инструкции атрибуту SQL_ATTR_ASYNC_ENABLE только для чтения. Значением является таким же, как значение атрибута уровня подключения с тем же именем во время был выделен с дескриптором инструкции.<br /><br /> Вызов **SQLSetStmtAttr** чтобы выставить атрибуту SQL_ATTR_ASYNC_ENABLE при SQL_ASYNC_MODE *InfoType* возвращает SQL_AM_CONNECTION возвращает SQLSTATE HYC00 (дополнительная возможность не реализована). Дополнительные сведения см. в разделе [SQLSetConnectAttr, функция](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) Дополнительные сведения.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Указатель SQLPOINTER значение дескриптора событий.<br /><br /> Уведомление о завершении асинхронной функций включена, вызвав **SQLSetStmtAttr** присвоить **SQL_ATTR_ASYNC_STMT_EVENT** и укажите дескриптор события.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Указатель SQLPOINTER, асинхронным обратным вызовом функции.<br /><br /> Только для диспетчера драйверов можно вызвать драйвера **SQLSetStmtAttr** функции с этим атрибутом.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Указатель SQLPOINTER на структура контекста<br /><br /> Только для диспетчера драйверов можно вызвать драйвера **SQLSetStmtAttr** функции с этим атрибутом.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Возвращает SQLULEN значение, указывающее параллелизм курсоров:<br /><br /> SQL_CONCUR_READ_ONLY = курсор доступен только для чтения. Обновления не разрешены.<br /><br /> SQL_CONCUR_LOCK = курсор использует самый низкий уровень блокировки достаточно, чтобы убедиться, что строки могут обновляться.<br /><br /> SQL_CONCUR_ROWVER = курсор использует управление оптимистичным параллелизмом, сравнение версий строк, например программа ROWID или Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = курсор использует управление оптимистичным параллелизмом, сравнение значений.<br /><br /> Значение по умолчанию для SQL_ATTR_CONCURRENCY — SQL_CONCUR_READ_ONLY.<br /><br /> Этот атрибут нельзя использовать для открытого курсора. Дополнительные сведения см. в разделе [типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Если SQL_ATTR_CURSOR_TYPE *атрибут* изменяется тип, который не поддерживает текущее значение SQL_ATTR_CONCURRENCY, значение SQL_ATTR_CONCURRENCY будет изменена во время выполнения и будет выдано при предупреждение **SQLExecDirect** или **SQLPrepare** вызывается.<br /><br /> Если драйвер поддерживает **SELECT FOR UPDATE** инструкции и такое яркое выполняется, хотя значение SQL_ATTR_CONCURRENCY установлено значение SQL_CONCUR_READ_ONLY, будет возвращена ошибка. Если значение SQL_ATTR_CONCURRENCY изменяется значение, драйвер поддерживает некоторые значения SQL_ATTR_CURSOR_TYPE, но не для текущего значения SQL_ATTR_CURSOR_TYPE, значение SQL_ATTR_CURSOR_TYPE изменится во время выполнения и SQLSTATE 01S02 (Значение параметра изменено) выдается **SQLExecDirect** или **SQLPrepare** вызывается.<br /><br /> Если указанный уровень параллелизма не поддерживается источником данных, драйвер подставляет разных параллелизма и возвращает SQLSTATE 01S02 (значение параметра изменено). Для SQL_CONCUR_VALUES, драйвер подставляет SQL_CONCUR_ROWVER и наоборот. Для SQL_CONCUR_LOCK драйвер подставляет в порядке, SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Допустимость подставляемого значения не проверяется только во время выполнения.<br /><br /> Дополнительные сведения о связи между SQL_ATTR_CONCURRENCY и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Возвращает SQLULEN значение, указывающее уровень поддержки, которая необходима для приложения. Установка этого атрибута влияет на последующие вызовы **SQLExecDirect** и **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = возможна прокрутка курсоры не требуются для дескриптора инструкции. Если приложение вызывает **SQLFetchScroll** на этот дескриптор, единственным допустимым значением для *FetchOrientation* является SQL_FETCH_NEXT. Это значение по умолчанию.<br /><br /> SQL_SCROLLABLE = возможна прокрутка курсоров требуются для дескриптора инструкции. При вызове **SQLFetchScroll**, приложение может задать любое допустимое значение *FetchOrientation*, достижение позиционирования курсора в режимах, отличных от последовательный режим.<br /><br /> Дополнительные сведения о Прокручиваемые курсоры, см. в разделе [Прокручиваемые курсоры](../../../odbc/reference/develop-app/scrollable-cursors.md). Дополнительные сведения о связи между SQL_ATTR_CURSOR_SCROLLABLE и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Значение SQLULEN, указывает ли курсоры для дескриптора инструкции сделать видимым изменения, внесенные в результирующий набор с другим курсором. Установка этого атрибута влияет на последующие вызовы **SQLExecDirect** и **SQLExecute**. Приложение может выполнить чтение обратно значение этого атрибута, чтобы получить исходное состояние или состояние, как наиболее недавно установленные приложением.<br /><br /> SQL_UNSPECIFIED = не уточняется, что такое тип курсора и ли курсоры для дескриптора инструкции сделать видимым изменения, внесенные в результирующий набор с другим курсором. Курсоры для дескриптора инструкции может сделать видимыми none, некоторые или все такие изменения. Это значение по умолчанию.<br /><br /> SQL_INSENSITIVE = все курсоры шоу дескриптор инструкции, результирующий набор не отражает все изменения, внесенные в него все другие курсора. Нечувствительных курсоров доступны только для чтения. Это соответствует статический курсор, который имеет параллелизма, который доступен только для чтения.<br /><br /> SQL_SENSITIVE = всех курсоров в инструкции дескриптор сделать видимыми все изменения, внесенные в результирующий набор с другим курсором.<br /><br /> Дополнительные сведения о связи между SQL_ATTR_CURSOR_SENSITIVITY и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|SQLULEN значение, которое указывает тип курсора:<br /><br /> SQL_CURSOR_FORWARD_ONLY = курсор только выполняет прокрутку вперед.<br /><br /> SQL_CURSOR_STATIC = данные в результирующем наборе является статическим.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = драйвер сохраняет и использует ключи для числа строк, указанной в атрибуте атрибута SQL_ATTR_KEYSET_SIZE инструкции.<br /><br /> SQL_CURSOR_DYNAMIC = драйвер сохраняет и использует только ключи для строк в наборе строк.<br /><br /> Значение по умолчанию — SQL_CURSOR_FORWARD_ONLY. Этот атрибут нельзя использовать после подготовки инструкции SQL.<br /><br /> Если тип указанного курсора не поддерживается источником данных, драйвер подставляет другой тип курсора и возвращает SQLSTATE 01S02 (значение параметра изменено). Для смешанного или динамического курсора драйвер подставляет в порядке, управляемых набором ключей или статических курсоров. Для курсора, управляемого набором ключей драйвер подставляет статического курсора.<br /><br /> Дополнительные сведения о типах прокручиваемого курсора см. в разделе [Прокручиваемый курсор типы](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Дополнительные сведения о связи между SQL_ATTR_CURSOR_TYPE и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|SQLULEN значение, указывающее, выполняется ли автоматическое заполнение IPD:<br /><br /> SQL_TRUE = Включение на автоматическое заполнение IPD после вызова **SQLPrepare**. Значение SQL_FALSE = Включение выключено автоматическое заполнение IPD после вызова **SQLPrepare**. (Приложение по-прежнему может получить сведения о полях IPD путем вызова **SQLDescribeParam**, если поддерживается.) Значение по умолчанию атрибута инструкции SQL_ATTR_ENABLE_AUTO_IPD — SQL_FALSE. Дополнительные сведения см. в разделе [автоматическое заполнение IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|SQLLEN \* , указывающего на значение двоичного закладки. Когда **SQLFetchScroll** вызывается с *fFetchOrientation* равно sql_fetch_bookmark аргумента, драйвер принимает значение из этого поля. По умолчанию это поле является пустым указателем. Дополнительные сведения см. в разделе [прокрутка по закладкам](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Значение, на которые указывает это поле не используется для удаления по закладкам и обновление по закладкам выборки операциями закладки в **SQLBulkOperations**, который с помощью закладок, кэшированные в буферы строк.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Дескриптор IPD. Значение этого атрибута является дескриптор, выделенных во время инструкция изначально был выделен. Приложение не может задавать этот атрибут.<br /><br /> Этот атрибут можно получить путем вызова **SQLGetStmtAttr** , но не задано с помощью вызова **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Дескриптор IRD. Значение этого атрибута является дескриптор, выделенных во время инструкция изначально был выделен. Приложение не может задавать этот атрибут.<br /><br /> Этот атрибут можно получить путем вызова **SQLGetStmtAttr** , но не задано с помощью вызова **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Значение SQLULEN, указывающее количество строк в наборе ключей для ключей, управляющий курсором. Если размер набора ключей равен 0 (по умолчанию), курсор полностью управляемые набором ключей. Если размер набора ключей больше 0, курсор является mixed (управляемые набором ключей в наборе ключей и динамические вне набора ключей). Размер набора ключей по умолчанию равно 0. Дополнительные сведения о курсоры, см. в разделе [курсоры](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Если указанный размер превышает размер максимального набора ключей, драйвер подставляет вместо этого размера и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> **SQLFetch** или **SQLFetchScroll** возвращает ошибку, если размер набора ключей, больше 0 и меньше, чем размер набора строк.|  
|ЗНАЧЕНИЯ SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Возвращает SQLULEN значение, указывающее максимальный объем данных, драйвер возвращает из символов или двоичного столбца. Если *ValuePtr* меньше, чем длина доступных данных, **SQLFetch** или **SQLGetData** производит усечение данных и возвращает значение SQL_SUCCESS. Если *ValuePtr* равно 0 (по умолчанию), драйвер пытается вернуть все доступные данные.<br /><br /> Если указанная длина меньше, чем минимальный объем данных, который может возвращать источника данных или больше, чем максимальный объем данных, который может возвращать источника данных, подстановочного драйвера, значение и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Можно задать значение этого атрибута применительно к открытому курсору; Тем не менее, этот параметр может не вступают в силу немедленно, в этом случае драйвер вернет SQLSTATE 01S02 (значение параметра изменено) и сбрасывает атрибут к своему исходному значению.<br /><br /> Этот атрибут предназначен для снижения сетевого трафика и должны поддерживаться только в том случае, если источник данных (в отличие от драйвера) в драйвере многоуровневая можно реализовать его. Этот механизм не следует приложениями для усечения данных. усечение данных, полученных, приложение должно указать длину максимальный размер буфера в *BufferLength* аргумента в **SQLBindCol** или **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|SQLULEN значение, соответствующее максимальное число строк, возвращаемых для приложения, **ВЫБЕРИТЕ** инструкции. Если \* *ValuePtr* равен 0 (по умолчанию), драйвер возвращает все строки.<br /><br /> Этот атрибут предназначен для снижения сетевого трафика. По сути, он применяется при создании результирующего набора и ограничить результирующий набор с первым *ValuePtr* строк. Если количество строк в результирующем наборе больше, чем *ValuePtr*, результирующий набор будет усечено.<br /><br /> SQL_ATTR_MAX_ROWS применяется для всех результирующих наборов на *инструкции*, включая тех, которые возвращаются функциями каталога. SQL_ATTR_MAX_ROWS устанавливает максимальное значение количества строк курсора.<br /><br /> Драйвер должен эмулирует поведение SQL_ATTR_MAX_ROWS для **SQLFetch** или **SQLFetchScroll** (если ограничения размера результирующего набора не может быть реализован в источнике данных), если он не может гарантировать, SQL_ATTR_ MAX_ROWS будет реализован должным образом.<br /><br /> Это определенное драйвером от того, применяется ли SQL_ATTR_MAX_ROWS операторам, кроме инструкций SELECT (например, функции работы с каталогами).<br /><br /> Можно задать значение этого атрибута применительно к открытому курсору; Тем не менее, этот параметр может не вступают в силу немедленно, в этом случае драйвер вернет SQLSTATE 01S02 (значение параметра изменено) и сбрасывает атрибут к своему исходному значению.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Значение SQLULEN, которое определяет, как обрабатываются строковые аргументы функции функции работы с каталогами.<br /><br /> Если SQL_TRUE, строковый аргумент функции работы с каталогами должны обрабатываться как идентификаторы. Регистр не имеет значения. Для nondelimited строк драйвер удаляет все конечные пробелы и строка складывается в верхний регистр. Для строк с разделителями драйвер удаляет все начальные и конечные пробелы и принимает все, что находится между разделителями буквально. Если один из этих аргументов имеет значение является пустым указателем, функция возвращает значение SQL_ERROR и SQLSTATE HY009 (недопустимое использование пустого указателя).<br /><br /> Если значение SQL_FALSE, что строковые аргументы функции каталога не интерпретируются как идентификаторы. Так важен. Они могут содержать либо шаблон поиска строки или нет, в зависимости от аргумента.<br /><br /> Значение по умолчанию — SQL_FALSE.<br /><br /> *TableType* аргумент **SQLTables**, который принимает список значений, не зависит от этого атрибута.<br /><br /> SQL_ATTR_METADATA_ID можно настроить на уровне соединения. (Он и атрибуту SQL_ATTR_ASYNC_ENABLE являются единственной инструкцией атрибуты, которые также являются атрибуты соединения).<br /><br /> Дополнительные сведения см. в разделе [аргументов в функции работы с каталогами](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|SQLULEN значение, которое указывает, должно ли драйвер проверять строки SQL для escape-последовательности:<br /><br /> SQL_NOSCAN_OFF = драйвер сканирование строк SQL для escape-последовательности (по умолчанию).<br /><br /> SQL_NOSCAN_ON = драйвер не проверяет строки SQL для escape-последовательности. Вместо этого драйвер отправляет инструкцию непосредственно к источнику данных.<br /><br /> Дополнительные сведения см. в разделе [escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|SQLULEN * значение, которое указывает на смещение добавляемый указатели, чтобы изменить привязки динамических параметров. Если это поле не равно null, драйвер разыменовывает указатель, добавляет разыменованное значение к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и используют новые значения указателя При привязке. Он устанавливается в значение null по умолчанию.<br /><br /> Смещение привязки всегда добавляется непосредственно SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR поля. Если смещение изменяется с другим значением, новое значение по-прежнему добавляется непосредственно к значению в поле дескриптора. Новое смещение не добавляется значение поля, а также любые более ранние смещения.<br /><br /> Дополнительные сведения см. в разделе [параметр привязки Offsets](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_BIND_OFFSET_PTR в заголовке APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|SQLULEN значение, указывающее ориентацию привязки для использования динамических параметров.<br /><br /> Это поле будет присвоено значение SQL_PARAM_BIND_BY_COLUMN (по умолчанию), чтобы выбрать привязку по столбцам.<br /><br /> Чтобы выбрать привязку на уровне строки, это поле имеет значение длины структуры или экземпляра буфера, который будет привязан к набору динамических параметров. Эта длина должна включать пробел для всех привязанных параметров и все заполнения структуры или буфера для убедитесь, что если адрес привязанного параметра увеличивается с указанным значением длины, результат будет указывают в начале этого параметра в следующем набор параметров. При использовании *sizeof* оператор в ANSI C, такое поведение гарантируется.<br /><br /> Дополнительные сведения см. в разделе [привязка массивов параметров](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ BIND_TYPE в заголовке APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|SQLUSMALLINT \* значение, которое указывает на массив значений SQLUSMALLINT используется для пропуска параметра во время выполнения инструкции SQL. Каждое значение будет присвоено SQL_PARAM_PROCEED (для параметра, который будет выполнен) или SQL_PARAM_IGNORE (для параметра игнорируется).<br /><br /> Набор параметров может игнорироваться во время обработки, задав значение состояния в массиве, на которые указывают SQL_DESC_ARRAY_STATUS_PTR в APD для SQL_PARAM_IGNORE. Набор параметров обрабатывается в том случае, если его состояние имеет значение SQL_PARAM_PROCEED или если ни один элемент в массиве.<br /><br /> Этот атрибут инструкции может быть присвоено значение является пустым указателем, в котором регистр драйвер не возвращает параметр состояния значения. Этот атрибут можно задать в любое время, но новое значение не используется до следующего **SQLExecDirect** или **SQLExecute** вызывается.<br /><br /> Этот атрибут учитывается при отсутствии связанного параметра.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|SQLUSMALLINT \* значение, которое указывает на массив SQLUSMALLINT значений, содержащий сведения о состоянии для каждой строки значений параметров после вызова **SQLExecute** или **SQLExecDirect**. Это поле является обязательным только в том случае, если PARAMSET_SIZE больше 1.<br /><br /> Значения состояния может содержать следующие значения:<br /><br /> SQL_PARAM_SUCCESS: Инструкция SQL была выполнена успешно для данного набора параметров.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Инструкция SQL была выполнена успешно для данного набора параметров; Тем не менее предупреждение сведения можно найти в структуре данных диагностики.<br /><br /> SQL_PARAM_ERROR: Произошла ошибка при обработке этого набора параметров. Дополнительные сведения об ошибке доступен в структуре данных диагностики.<br /><br /> SQL_PARAM_UNUSED: Этот набор параметров не была задействована, возможно из-за того, что некоторые предыдущий набор параметров вызвала ошибку, что прервана дальнейшей обработки или SQL_PARAM_IGNORE было задано для данного набора параметров массива, заданного параметром SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Драйвер рассматривает массивы параметров как единое монолитных и поэтому не создает такой уровень сведений об ошибках.<br /><br /> Этот атрибут инструкции может быть присвоено значение является пустым указателем, в котором регистр драйвер не возвращает параметр состояния значения. Этот атрибут можно задать в любое время, но новое значение не используется до следующего **SQLExecute** или **SQLExecDirect** вызывается. Обратите внимание на то, что установка этого атрибута могут повлиять на поведение параметра output, реализованным в драйвере.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|SQLULEN \* полями записей, который указывает на буфер, в которую будет возвращено число наборов параметров, которые будут обработаны, включая наборы ошибка. Номер не будет возвращаться, если это является пустым указателем.<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ROWS_PROCESSED_PTR в заголовке IPD.<br /><br /> Если вызов **SQLExecDirect** или **SQLExecute** заливки в буфере, на который указывает этот атрибут не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Возвращает SQLULEN значение, указывающее количество значений для каждого параметра. Если SQL_ATTR_PARAMSET_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR в APD точки к массивам. Количество элементов каждого массива равно значению этого поля.<br /><br /> Этот атрибут учитывается при отсутствии связанного параметра.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_SIZE в заголовке APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Значение SQLULEN, соответствующее количество секунд ожидания для инструкции SQL, выполняемый перед возвратом в приложение. Если *ValuePtr* будет равно 0 (по умолчанию), что таймаут не используется.<br /><br /> Если заданное время ожидания превышает максимальное время ожидания в источнике данных или меньше, чем минимальное время ожидания, **SQLSetStmtAttr** заменяет это значение и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Обратите внимание, что приложение не должны вызвать **SQLCloseCursor** для повторного использования инструкции, если **ВЫБЕРИТЕ** истекло время ожидания инструкции.<br /><br /> Время ожидания запроса, заданное в этом атрибуте инструкции является допустимым в синхронных и асинхронных режимах.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Значение SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** и, в ODBC *3.x*, **SQLFetch** получения данных после его помещает курсор в указанное расположение. Это значение по умолчанию.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** и, в ODBC *3.x*, **SQLFetch** не извлекают данные после он помещает курсор.<br /><br /> Установив SQL_RETRIEVE_DATA SQL_RD_OFF, приложение можно проверить, существует или извлекать закладка для строки без затрат, связанных с извлечения строк строки. Дополнительные сведения см. в разделе [прокрутка и выборка строк](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Можно задать значение этого атрибута применительно к открытому курсору; Тем не менее, этот параметр может не вступают в силу немедленно, в этом случае драйвер вернет SQLSTATE 01S02 (значение параметра изменено) и сбрасывает атрибут к своему исходному значению.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Возвращает значение SQLULEN, указывающее количество строк, возвращаемых при каждом вызове **SQLFetch** или **SQLFetchScroll**. Это также количество строк в массиве закладки, используемых в операциях массового закладки в **SQLBulkOperations**. Значение по умолчанию — 1.<br /><br /> Если размер указанного набора строк превышает размер максимального набора строк, поддерживаемых источником данных, драйвер заменяет это значение и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Дополнительные сведения см. в разделе [размер набора строк](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_SIZE в заголовке Отменить.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|SQLULEN * значение, которое указывает на смещение добавляемый указатели, чтобы изменить привязку данных столбца. Если это поле не равно null, драйвер разыменовывает указатель, добавляет разыменованное значение к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и используют новые значения указателя При привязке. Он устанавливается в значение null по умолчанию.<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_BIND_OFFSET_PTR в заголовке Отменить.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Значение типа SQLULEN, задает ориентацию привязки для использования при **SQLFetch** или **SQLFetchScroll** вызывается связанный с ним оператор. Привязка на уровне столбца выбран, задав значение, равное SQL_BIND_BY_COLUMN. Привязка на уровне строки выбирается, задав значение длины структуры или экземпляра буфера, в который будет привязан результирующих столбцов.<br /><br /> Если указана длина, она должна включать пространство для всех связанных столбцов и все заполнения структуры или буфера для убедитесь, что если адрес связанного столбца увеличивается с указанным значением длины, результат будет указывают на начало того же столбца в th e следующую строку. При использовании **sizeof** оператор структуры или объединения в ANSI C, такое поведение гарантируется.<br /><br /> Привязка на уровне столбца является направление привязки по умолчанию для **SQLFetch** и **SQLFetchScroll**.<br /><br /> Дополнительные сведения см. в разделе [привязка столбцов для использования с блочными курсорами](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_BIND_TYPE в заголовке Отменить.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Значение типа SQLULEN, — это номер текущей строки в весь результирующий набор. Если не удается определить номер текущей строки или нет текущей строки, драйвер возвращает 0.<br /><br /> Этот атрибут можно получить путем вызова **SQLGetStmtAttr** , но не задано с помощью вызова **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|SQLUSMALLINT \* значение, которое указывает на массив значений SQLUSMALLINT позволяет пропускать строки во время массовой операции с помощью **SQLSetPos**. Каждое значение будет присвоено SQL_ROW_PROCEED (для строки, которые будут включены в операции массового) или SQL_ROW_IGNORE (для строки, которые следует исключить из операции массовой). (Нельзя пропустить строк с помощью этого массива во время вызовов **SQLBulkOperations**.)<br /><br /> Этот атрибут инструкции может быть присвоено значение является пустым указателем, в котором регистр драйвер не возвращает значения строки состояния. Этот атрибут можно задать в любое время, но новое значение не используется до следующего **SQLSetPos** вызывается.<br /><br /> Дополнительные сведения см. в разделе [обновление строк в наборе строк с помощью SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) и [удаление строк в наборе строк с помощью SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_STATUS_PTR Отменить.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|SQLUSMALLINT \* значение, которое указывает на массив SQLUSMALLINT значения содержат значения строки состояния после вызова **SQLFetch** или **SQLFetchScroll**. Массив имеет столько элементов, сколько строк в наборе строк.<br /><br /> Этот атрибут инструкции может быть присвоено значение является пустым указателем, в котором регистр драйвер не возвращает значения строки состояния. Этот атрибут можно задать в любое время, но новое значение не используется до следующего **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, или  **SQLSetPos** вызывается.<br /><br /> Дополнительные сведения см. в разделе [номер строки выбраны и состояние](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_STATUS_PTR в заголовке IRD.<br /><br /> Этот атрибут сопоставляет ODBC *2.x* драйвер *rgbRowStatus* массива в вызове **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|SQLULEN \* значение, которое указывает на буфер, в которую будет возвращено число возвращаемых строк после вызова **SQLFetch** или **SQLFetchScroll**; количество строк, затронутых операцией неполного операций с помощью вызова **SQLSetPos** с *операции* аргументом SQL_REFRESH; или количество строк, затронутых операцией массового, выполненных **SQLBulkOperations**. Это число включает ошибочные строки.<br /><br /> Дополнительные сведения см. в разделе [номер строки выбраны и состояние](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ROWS_PROCESSED_PTR в заголовке IRD.<br /><br /> Если вызов **SQLFetch** или **SQLFetchScroll** заливки в буфере, на который указывает этот атрибут не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|SQLULEN значение, указывающее, является ли драйверы, которые имитируют расположен инструкции update и delete гарантирует, что такие затрагивают только одной строки.<br /><br /> Чтобы имитировать позиционированного обновления и удаления, большинство драйверов сконструировать искомая **обновление** или **удалить** содержащий инструкции **ГДЕ** предложение, определяющее значение для каждого столбца в текущей строке. Если эти столбцы составляют уникальный ключ, такое яркое может повлиять на более чем одной строке.<br /><br /> Чтобы гарантировать, что такие затрагивают только одну строку, драйвер определяет столбцы уникального ключа и добавляет эти столбцы результирующего набора. Если приложение гарантирует, что столбцы в результирующем наборе составляют уникальный ключ, драйвер для этого не требуется. Это может уменьшить время выполнения.<br /><br /> SQL_SC_NON_UNIQUE = драйвер не гарантирует, что simulated расположен обновления или инструкций delete повлияет только одну строку; Это ответственность приложения, чтобы сделать это. Если инструкция влияет на более чем одной строке **SQLExecute**, **SQLExecDirect**, или **SQLSetPos** возвращает SQLSTATE 01001 (конфликт операции с курсором).<br /><br /> SQL_SC_TRY_UNIQUE = драйвер попыток гарантировать simulated расположен обновления или удаления инструкций влияет только одну строку. Драйвер всегда такие операторы выполняются, даже если они могут повлиять на более чем одной строке, например, когда отсутствует уникальный ключ. Если инструкция влияет на более чем одной строке **SQLExecute**, **SQLExecDirect**, или **SQLSetPos** возвращает SQLSTATE 01001 (конфликт операции с курсором).<br /><br /> SQL_SC_UNIQUE = гарантии драйвера, которые simulated позиционированного обновления или удаления инструкций влияет только одну строку. Если драйвер не может гарантировать это для данной инструкции, **SQLExecDirect** или **SQLPrepare** возвращает сообщение об ошибке.<br /><br /> Если источник данных предоставляет собственный SQL поддерживает для позиционированного обновления и удаления инструкций и драйвер не поддерживает курсоры, SQL_SUCCESS возвращается при запросе SQL_SC_UNIQUE для SQL_SIMULATE_CURSOR. Если запрашивается SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE возвращается SQL_SUCCESS_WITH_INFO. Если источник данных предоставляет SQL_SC_TRY_UNIQUE уровень поддержки, драйвер не поддерживает для SQL_SC_TRY_UNIQUE и SQL_SUCCESS_WITH_INFO, возвращается для SQL_SC_NON_UNIQUE возвращается значение SQL_SUCCESS.<br /><br /> Если тип моделирования заданный курсор не поддерживается источником данных, драйвер подставляет тип разных моделирования и возвращает SQLSTATE 01S02 (значение параметра изменено). Для SQL_SC_UNIQUE драйвер подставляет в порядке, SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE. Для SQL_SC_TRY_UNIQUE драйвер подставляет SQL_SC_NON_UNIQUE.<br /><br /> По умолчанию используется SQL_SC_UNIQUE.<br /><br /> Дополнительные сведения см. в разделе [имитация расположен обновления и удаления инструкций](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|SQLULEN значение, указывающее, будет ли приложение использовать закладки с курсором:<br /><br /> SQL_UB_OFF = Off (по умолчанию)<br /><br /> SQL_UB_VARIABLE = приложение будет использовать закладки с курсором и драйвер предоставит закладки переменной длины, если они поддерживаются. В ODBC устарел SQL_UB_FIXED *3.x*. ODBC *3.x* приложения всегда должны использовать закладки переменной длины, даже в том случае, при работе с ODBC *2.x* драйверы (что поддерживается только 4 байтам, фиксированной длины закладки). Это обусловлено фиксированной длины Закладка представляет собой особый случай закладки переменной длины. При работе с ODBC *2.x* драйвера, диспетчер драйверов сопоставляется SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Чтобы использовать закладки с курсором, приложение должно указать этот атрибут со значением SQL_UB_VARIABLE перед открытием курсора.<br /><br /> Дополнительные сведения см. в разделе [извлечение закладок](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Эти функции могут вызываться асинхронно только в том случае, если дескриптор является дескриптор реализации, а не дескриптор приложений.  
  
 См. в разделе [привязка на уровне столбцов](../../../odbc/reference/develop-app/column-wise-binding.md) и [привязку на уровне строки](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращает значение атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Возвращает значение атрибута инструкции|[Функция SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Присвоение атрибуту соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Задание одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
