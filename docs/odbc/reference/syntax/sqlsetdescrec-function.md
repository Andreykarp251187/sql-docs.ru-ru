---
title: Функция S'LSetDescrecRec Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetDescRec
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLSetDescRec
helpviewer_keywords:
- SQLSetDescRec function [ODBC]
ms.assetid: bf55256c-7eb7-4e3f-97ef-b0fee09ba829
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: b29879ff7635d6eb7d5a0f7489ff3994758d4a35
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81299534"
---
# <a name="sqlsetdescrec-function"></a>Функция SQLSetDescRec
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 Функция **S'LSetDescRec** устанавливает несколько полей дескриптора, которые влияют на тип данных и буфер, привязанный к столбцу или параметрам.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetDescRec(  
      SQLHDESC      DescriptorHandle,  
      SQLSMALLINT   RecNumber,  
      SQLSMALLINT   Type,  
      SQLSMALLINT   SubType,  
      SQLLEN        Length,  
      SQLSMALLINT   Precision,  
      SQLSMALLINT   Scale,  
      SQLPOINTER    DataPtr,  
      SQLLEN *      StringLengthPtr,  
      SQLLEN *      IndicatorPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *DescriptorHandle*  
 (Вход) Ручка дескриптора. Это не должно быть ручкой IRD.  
  
 *RecNumber*  
 (Вход) Указывает запись дескриптора, содержащую поля, которые должны быть установлены. Записи дескриптора пронумероированы от 0, при этом запись закладки является рекордным номером. Этот аргумент должен быть равен или больше, чем 0. Если *RecNumber* больше, чем значение SQL_DESC_COUNT, SQL_DESC_COUNTis изменен на значение *RecNumber*.  
  
 *Type*  
 (Вход) Значение, к которому можно установить SQL_DESC_TYPE поле для записи дескриптора.  
  
 *Подтип*  
 (Вход) Для записей, тип которых SQL_DATETIME или SQL_INTERVAL, это значение, к которому можно установить поле SQL_DESC_DATETIME_INTERVAL_CODE.  
  
 *Продолжительность*  
 (Вход) Значение, в котором можно установить поле SQL_DESC_OCTET_LENGTH для записи дескриптора.  
  
 *Точность*  
 (Вход) Значение, к которому можно установить поле SQL_DESC_PRECISION для записи дескриптора.  
  
 *Масштабирование*  
 (Вход) Значение, в котором можно установить SQL_DESC_SCALE поле для записи дескриптора.  
  
 *DataPtr*  
 (Отложенный вход или выход) Значение, в котором можно установить поле SQL_DESC_DATA_PTR для записи дескриптора. *DataPtr* может быть установлен на нулевую указку.  
  
 Аргумент *DataPtr* может быть установлен на нулевую точку, чтобы установить поле SQL_DESC_DATA_PTR на нулевую указку. Если ручка в аргументе *DescriptorHandle* связана с ARD, это отсващает столбец.  
  
 *СтрунныйДлинПтр*  
 (Отложенный вход или выход) Значение, к которому можно установить SQL_DESC_OCTET_LENGTH_PTR поле для записи дескриптора. *StringLengthPtr* может быть установлен на нулевую указку, чтобы установить SQL_DESC_OCTET_LENGTH_PTR поле на нулевую указку.  
  
 *ИндикаторPtr*  
 (Отложенный вход или выход) Значение, к которому можно установить SQL_DESC_INDICATOR_PTR поле для записи дескриптора. *IndicatorPtr* может быть установлен на нулевую указку, чтобы установить поле SQL_DESC_INDICATOR_PTR на нулевую указку.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LSetDesccRec** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив по **телефону S'LGetDiagRec** с *помощью handleType* SQL_HANDLE_DESC и *ручки* *DescriptorHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LSetDescRec,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07009|Недействительный индекс дескриптора|Аргумент *RecNumber* был установлен на 0, и *DescriptorHandle* сослался на ручку IPD.<br /><br /> Аргумент *RecNumber* был меньше, чем 0.<br /><br /> Аргумент *RecNumber* был больше, чем максимальное количество столбцов или параметров, которые может поддерживать источник данных, а *аргументdescriptorHandle* был APD, IPD или ARD.<br /><br /> Аргумент *RecNumber* был равен 0, а аргумент *DescriptorHandle* сослался на косвенно выделенный APD. (Эта ошибка не возникает с явно выделенным дескриптором приложения, поскольку неизвестно, является ли явно выделенный дескриптор приложения APD или ARD до времени выполнения.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) *DescriptorHandle* был связан с *statementHandle,* для которого была вызвана асинхронно исполнительная функция (не эта) и все еще исполнялась, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle,* с которым *DescriptorHandle* был связан и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *DescriptorHandle.* Эта аинхронная функция по-прежнему исполнялась при вызове функции **S'LSetDescRec.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для одной из дескрипторов оператора, связанных с *DescriptorHandle* и возвращенных SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY016|Не удается изменить дескриптор строки реализации|Аргумент *DescriptorHandle* был связан с IRD.|  
|HY021|Несогласованная информация о дескрипторе|Поле *типа* или любое другое поле, связанное с полем SQL_DESC_TYPE в дескрипторе, не было действительным или последовательным.<br /><br /> Информация о дескрипторах, проверенная во время проверки согласованности, не соответствовала. (См. "Проверки согласованности", позже в этом разделе.)|  
|HY090|Недействительная длина строки или буфера|(DM) Драйвер был драйвером ODBC *2.x,* дескриптор был ARD, аргумент *ColumnNumber* был установлен на 0, а значение, указанное для аргумента *BufferLength,* не было равно 4.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *DescriptorHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение может вызвать **S'LSetDescRec,** чтобы установить следующие поля для одного столбца или параметра:  
  
-   SQL_DESC_TYPE  
  
-   SQL_DESC_DATETIME_INTERVAL_CODE (для записей, тип которых SQL_DATETIME или SQL_INTERVAL)  
  
-   SQL_DESC_OCTET_LENGTH  
  
-   SQL_DESC_PRECISION  
  
-   SQL_DESC_SCALE  
  
-   SQL_DESC_DATA_PTR  
  
-   SQL_DESC_OCTET_LENGTH_PTR  
  
-   SQL_DESC_INDICATOR_PTR  
  
> [!NOTE]  
>  Если вызов в **S'LSetDescCRec** не удается, содержание записи дескриптора, идентифицированной аргументом *RecNumber,* не определено.  
  
 При связывании столбца или параметра, **S'LSetDesccRec** позволяет изменять несколько полей, влияющих на привязку, не вызывая **s'LBindCol** или **S'LBindParameter** или делая несколько вызовов на **S'LSetDescField.** **SLSetDescRec** может устанавливать поля на дескрипторе, не связанном в настоящее время с утверждением. Обратите внимание, что **S'LBindParameter** устанавливает больше полей, чем **S'LSetDescCRec**, может устанавливать поля как на APD, так и на IPD в одном вызове, и не требует ручки дескриптора.  
  
> [!NOTE]  
>  Атрибут оператора SQL_ATTR_USE_BOOKMARKS всегда должен быть установлен перед вызовом **S'LSetDesccRec** с аргументом *RecNumber* 0 для установки полей закладок. Хотя это не является обязательным, настоятельно рекомендуется.  
  
## <a name="consistency-checks"></a>Проверка согласованности  
 Проверка согласованности выполняется водителем автоматически всякий раз, когда приложение устанавливает SQL_DESC_DATA_PTR поле APD, ARD или IPD. Если какое-либо из полей несовместимо с другими полями, **s'LSetDescCRec** вернет S'LSTATE HY021 (несогласованная информация о дескрипторах).  
  
 Всякий раз, когда приложение устанавливает поле SQL_DESC_DATA_PTR APD, ARD или IPD, драйвер проверяет, что значение SQL_DESC_TYPE поля и значения, применимые к этой SQL_DESC_TYPE области, являются действительными и последовательными. Эта проверка всегда выполняется при вызове **S'LBindParameter** или **S'LBindCol** или когда **S'LSetDesccRec** вызывается для APD, ARD или IPD. Эта проверка согласованности включает в себя следующие проверки полей дескриптора:  
  
-   Поле SQL_DESC_TYPE должно быть одним из действительных типов ODBC C или S'L или типа S-L, специфичным для драйверов. Поле SQL_DESC_CONCISE_TYPE должно быть одним из действительных типов ODBC C или S'L или типа C или S-L, включая краткое время даты и интервалы.  
  
-   Если поле SQL_DESC_TYPE записи SQL_DATETIME или SQL_INTERVAL, поле SQL_DESC_DATETIME_INTERVAL_CODE должно быть одним из действительных кодов дат или интервалов. (См. описание SQL_DESC_DATETIME_INTERVAL_CODE поля в [S'LSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md).)  
  
-   Если поле SQL_DESC_TYPE указывает числовое тип, SQL_DESC_PRECISION и SQL_DESC_SCALE поля проверяются как действительные.  
  
-   Если поле SQL_DESC_CONCISE_TYPE является типом данных времени или метки времени, типом интервала с компонентом секунды или одним из типов данных интервала с временным компонентом, поле SQL_DESC_PRECISION проверяется как допустимая точность секунд.  
  
-   Если SQL_DESC_CONCISE_TYPE является типом данных интервала, поле SQL_DESC_DATETIME_INTERVAL_PRECISION проверяется как допустимое значение точности интервала.  
  
 Поле SQL_DESC_DATA_PTR IPD обычно не устанавливается; однако приложение может сделать это, чтобы заставить проверку согласованности полей IPD. Проверка согласованности не может быть выполнена на IRD. Значение, на которое устанавливается SQL_DESC_DATA_PTR поля IPD, на самом деле не хранится и не может быть получено по вызову в **S'LGetDescField** или **S'LGetDescRec;** настройка сделана только для того, чтобы заставить проверку согласованности.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Связывание столбца|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Связывание параметра|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Получение одного поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Установка полей одного дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
