---
title: Функция S'LExecute (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExecute
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExecute
helpviewer_keywords:
- SQLExecute function [ODBC]
ms.assetid: 9286a01d-cde2-4b90-af94-9fd7f8da48bf
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 5306567aebc229a8bc9d1d3c91bcbd8e79391752
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81286074"
---
# <a name="sqlexecute-function"></a>Функция SQLExecute
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **SLExecute** выполняет подготовленное заявление, используя текущие значения переменных параметра, если в отчете существуют какие-либо параметры.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExecute(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, SQL_NO_DATA, SQL_INVALID_HANDLE или SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LExecute** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону s'LGetDiagRec** с *помощью HandleType* SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LExecute,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01001|Конфликт операции Cursor|Подготовленное заявление, связанное с *StatementHandle,* содержало позиционированное обновление или удаление оператора, и никакие строки или более чем одна строка не были обновлены или удалены. (Для получения дополнительной информации об обновлениях в нескольких строках *SQL_ATTR_SIMULATE_CURSOR* см. **SQLSetStmtAttr**<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01003|Null значение устранено в наборе функции|Подготовленное заявление, связанное с *StatementHandle,* содержало набор функций (например, **AVG,** **MAX,** **MIN**и т.д.), но не функция **набора COUNT,** а значения аргументов NULL были устранены до того, как функция была применена. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Строка или двоичные данные, возвращенные для параметра вывода, привели к усечению непустого символа или неnull двоичных данных. Если это было значение строки, то оно было правильно усечено. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01006|Привилегия не отменена|Подготовленное заявление, связанное с *statementHandle,* было заявлением **REVOKE,** и пользователь не имел указанной привилегии. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01007|Привилегия не предоставляется|Подготовленное заявление, связанное с *statementHandle,* является заявлением **GRANT,** и пользователю не может быть предоставлена указанная привилегия.|  
|01S02|Изменение значения опциона|Определенный атрибут оператора был недействительным из-за условий выполнения работы, поэтому аналогичное значение было временно заменено. ( Можно назвать**S'LGetStmtAttr,** чтобы определить, что такое временно заменяемые значения.) Значение замены допустимо для *statementHandle* до тех пор, пока курсор не будет закрыт, после чего атрибут оператора возвращается к своему предыдущему значению. Атрибуты оператора, которые могут быть изменены: SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_KEYSET_SIZE, SQL_ATTR_MAX_LENGTH, SQL_ATTR_MAX_ROWS, SQL_ATTR_QUERY_TIMEOUT и SQL_ATTR_SIMULATE_CURSOR. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Фракционная усечение|Данные, возвращенные для ввода/вывода или параметра вывода, были усечены таким образом, что фракционная часть типа численных данных была усечена или фракционная часть временной составляющей времени, отметки времени или типа интервальных данных была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07002|Поле COUNT неправильное|Количество параметров, указанных в **S'LBindParameter,** было меньше, чем количество \*параметров в выписке, содержащейся в *StatementText.*<br /><br /> **СЗЛБАндерПараст** был вызван с *параметромValuePtr* установлен на нулевую указатель, *StrLen_or_IndPtr* не установлен на SQL_NULL_DATA или SQL_DATA_AT_EXEC, и *InputOutputType* не установить, чтобы SQL_PARAM_OUTPUT, так что количество параметров, указанных в **S'LBindParameter** было больше, чем количество параметров в заявлении S'L, содержащихся в*заявлении StatementText*.|  
|07006|Нарушение атрибута типа ограниченного доступа|Значение данных, идентифицированное аргументом *ValueType* в **sLBindParameter** для связанного параметра, не может быть преобразовано в тип данных, определенный аргументом *ParameterType* в **S'LBindParameter.**<br /><br /> Значение данных, возвращенное для параметра, связанного как SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, не может быть преобразовано в тип данных, идентифицированный аргументом *ValueType* в **S'LBindParameter.**<br /><br /> (Если значения данных для одной или нескольких строк не могут быть преобразованы, но одна или несколько строк были успешно возвращены, эта функция возвращается SQL_SUCCESS_WITH_INFO.)|  
|07007|Нарушение значения ограниченного параметра|Тип параметра SQL_PARAM_INPUT_OUTPUT_STREAM используется только для параметра, который отправляет и получает данные частями. Для этого типа параметра не допускается буфер ввода.<br /><br /> Эта ошибка будет возникать при SQL_PARAM_INPUT_OUTPUT, \*и когда *StrLen_or_IndPtr,* указанный в **S'LBindParameter,** не равна SQL_NULL_DATA, SQL_DEFAULT_PARAM, SQL_LEN_DATA_AT_EXEC (len) или SQL_DATA_AT_EXEC.|  
|07S01|Недействительное использование параметра по умолчанию|Значение параметра, установленное с **помощью S'LBindParameter,** было SQL_DEFAULT_PARAM, и соответствующий параметр не был параметром для вызова канонической процедуры ODBC.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|Подготовленное заявление, связанное с *statementHandle,* содержало заявление **CREATE VIEW,** а неквалифицированный список столбцов (число столбцов, указанных для представления в аргументах *столбцов-идентификатора* оператора S'L) содержал больше имен, чем количество столбцов в производной таблице, определяемой аргументом *спецификации запроса* оператора S'L.|  
|22001|Строковые данные, правильное усечение|Назначение символа или двоичного значения в столбец привело к усечению непустых (символов) или не-нулевых (двоичных) символов или байтов.|  
|22002|Переменная переменная индикатора требуется, но не поставляется|Данные NULL были привязаны к параметру вывода, *StrLen_or_IndPtr* которого, установленный **S'LBindParameter,** был нулевой указателем.|  
|22003|Числовое значение вне диапазона|Подготовленное заявление, связанное с *statementHandle,* содержало связанный числовый параметр, и значение параметра привело к тому, что в сяртовидном числе следует усечь всю (в отличие от дробной) часть числа при присвоении столбцу связанной таблицы.<br /><br /> Возвращение численного значения (в качестве численного или строки) для одного или нескольких входных/выходных или выходных параметров привело бы к тому, что вся (в отличие от дробной) часть числа была бы усечена.|  
|22007|Недействительный формат дата-времени|Подготовленное заявление, связанное с *statementHandle,* содержало заявление S'L, содержащее в качестве связанного параметра структуру даты, времени или метки времени, а параметр был, соответственно, недействительной датой, временем или меткой времени.<br /><br /> Параметр ввода/вывода или вывода был привязан к структуре даты, времени или временной метки C, а значение в возвращенном параметре, соответственно, является недействительной датой, временем или меткой времени. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22008|Переполниние полей datetime|Подготовленное заявление, связанное с *statementHandle,* содержало заявление S'L, содержащее выражение времени даты, которое при вычислении приводило к недействительной структуре даты, времени или временной метки.<br /><br /> Выражение времени даты, вычисленные для ввода/вывода или параметра вывода, привело к недействительной структуре даты, времени или временной метки C.|  
|22012|Разделение на ноль|Подготовленное заявление, связанное с *StatementHandle,* содержало арифметическое выражение, вызвавшее разделение на ноль.<br /><br /> Арифметическое выражение, рассчитанное для ввода/вывода или вывода параметра, привело к разделению на ноль.|  
|22015|Переполниние поля интервала|StatementText содержал точный числовой или интервалный параметр, который при преобразовании в тип данных интервала S'L привел к потере значительных цифр. * \**<br /><br /> StatementText содержал параметр интервала с более чем одним полем, которое при преобразовании в числовой тип данных в столбце не было представлено в типе числового данных. * \**<br /><br /> StatementText содержал данные о параметрах, которые были назначены типу интервала S'L, и не было представления значения типа C в типе интервала S'L. * \**<br /><br /> Назначение ввода/вывода или параметра вывода, который был точным числовым или интервалным типом S'L, к типу интервала C привел о потере значительных цифр.<br /><br /> При присвоении входного/выходного или выходного параметра структуре интервала C не было представлено данных в структуре интервальных данных.|  
|22018|Недействительное значение символов для спецификации литья|StatementText содержал тип C, который был точным или приблизительным числом, временем даты или типом данных интервала; * \** тип столбца s'L был типом данных символов; и значение в колонке не было действительным буквальным типа C.<br /><br /> При возврате ввода/вывода или вывода параметр си-L является точным или приблизительным числом, временем даты или типом данных интервала; тип C был SQL_C_CHAR; и значение в колонке не было действительным буквальным из связанного типа S'L.|  
|22019|Недействительный персонаж побега|Подготовленное заявление, связанное с *StatementHandle,* содержало предикат **LIKE** с **ESCAPE** в оговорке **WHERE,** и длина персонажа побега после **ESCAPE** не была равна 1.|  
|22025|Недействительная последовательность побега|Подготовленное заявление, связанное с *StatementHandle,* содержало**в** оговорке **WHERE** _значение like pattern's_ **ESCAPE** _escape character,_ и персонаж, следующий за персонажем побега в значении шаблона, не был одним из "%" или "я".|  
|23000|Нарушение ограничения целостности|Подготовленное заявление, связанное с *StatementHandle,* содержало параметр. Значение параметра было NULL для столбца, определяемого как НЕ NULL в связанной таблице, дублирующее значение было поставлено для столбца, ограниченного для содержащих только уникальные значения, или было нарушено другое ограничение целостности.|  
|24 000|Недопустимое состояние курсора|Курсор был расположен на *выписке* по **S'LFetch** или **S'LFetchScroll**. Эта ошибка возвращается менеджером-драйвером, если **S'LFetch** или **S'LFetchScroll** не вернулись SQL_NO_DATA, и возвращается драйвером, если **S'LFetch** или **S'LFetchScroll** вернулся SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle*.<br /><br /> Подготовленное заявление, связанное с *StatementHandle,* содержало позиционированное обновление или удаление statemen, т и курсор был расположен до начала набора результатов или после окончания набора результатов.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|42000|Ошибка синтаксиса или нарушение доступа|Пользователь не имел разрешения на выполнение подготовленного оператора, связанного с *statementHandle.*|  
|44000|Нарушение параметра WITH CHECK OPTION|Подготовленное заявление, связанное с *statementHandle,* содержало заявление **INSERT,** выполненное на просматриваемой таблице или таблице, полученной из просматриваемой таблицы, которая была создана путем указания **С CHECK OPTION,** таким образом, что один или несколько строк, затронутых заявлением **INSERT,** больше не будут присутствовать в просмотренной таблице.<br /><br /> Подготовленное заявление, связанное с *StatementHandle,* содержало заявление **UPDATE,** выполненное на просматриваемой таблице или таблице, полученной из просматриваемой таблицы, которая была создана путем указания **С CHECK OPTION,** таким образом, что одна или несколько строк, затронутых заявлением **UPDATE,** больше не будут присутствовать в просмотренной таблице.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему выполнялась, когда была вызвана функция **S'LExecute.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) *Заявление Ручка* не была подготовлена.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|Значение параметра, установленное с **помощью s'LBindParameter,** было нулевой указателем, а значение длины параметра не составляло 0, SQL_NULL_DATA, SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение параметра, установленное с **помощью S'LBindParameter**, не было нулевой указателем; тип данных C был SQL_C_BINARY или SQL_C_CHAR; и значение длины параметра было меньше 0, но не было SQL_NTS, SQL_NULL_DATA, SQL_DEFAULT_PARAM или SQL_DATA_AT_EXEC, или меньше, чем или равна SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение длины параметра, связанное **S'LBindParameter,** было установлено в SQL_DATA_AT_EXEC; тип СЗЛ был либо SQL_LONGVARCHAR, SQL_LONGVARBINARY, либо длинным типом данных, специфичным для конкретных источников данных; а SQL_NEED_LONG_DATA_LEN информационный тип в **"СЗЛГетИнфо"** был "Y".|  
|HY105|Недействительный тип параметра|Значение, указанное для аргумента *InputOutputType* в **S'LBindParameter,** было SQL_PARAM_OUTPUT, а параметр был входним параметром.|  
|HY109|Положение недействительного курсора|Подготовленное заявление представляло собой позиционированное заявление об обновлении или удалении, и курсор был расположен (по **S'LSetPos** или **S'LFetchScroll)** на строке, которая была удалена или не может быть извлечена.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Комбинация текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE оператора не была поддержана драйвером или источником данных.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
 **СЗЛВы** могут вернуть любое s'LSTATE, которое может быть возвращено **компанией S'LPrepare,** в зависимости от того, когда источник данных оценивает выписку, связанную с заявлением.  
  
## <a name="comments"></a>Комментарии  
 **«СЗЛВы»** выполняет заявление, **подготовленное S'LPrepare.** После того, как приложение обрабатывает или отбрасывает результаты от вызова к **S'LExecute,** приложение может снова вызвать **S'LExecute** с новыми значениями параметров. Для получения дополнительной информации о подготовленном исполнении [см.](../../../odbc/reference/develop-app/prepared-execution-odbc.md)  
  
 Чтобы выполнить выписку **SELECT** более одного раза, приложение должно позвонить в **s'LCloseCursor,** прежде чем повторно ексировать выписку **SELECT.**  
  
 Если источник данных находится в режиме ручного коммита (требует явного инициирования транзакции) и транзакция еще не инициирована, драйвер инициирует транзакцию перед отправкой оператора S'L. Дополнительные сведения см. в статье о [транзакциях](../../../odbc/reference/develop-app/transactions-odbc.md).  
  
 Если приложение использует **S'LPrepare** для подготовки и **S'LExecute** для отправки выписки **COMMIT** или **ROLLBACK,** оно не будет совместимо между продуктами DBMS. Чтобы совершить или откатить транзакцию, позвоните по **телефону S'LEndTran.**  
  
 Если **S'LExecute** сталкивается с параметром выполнения данных, он возвращает SQL_NEED_DATA. Приложение отправляет данные с помощью **S'LParamData** и **S'LPutData**. [См. S'LBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [S'LParamData](../../../odbc/reference/syntax/sqlparamdata-function.md), [S'LPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [отправка длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
 Если **S'LExecute** выполняет поисковое обновление, вставляет или удаляет оператор, который не влияет на строки в источнике данных, вызов **в S'LExecute** возвращается SQL_NO_DATA.  
  
 Если значение атрибута SQL_ATTR_PARAMSET_SIZE оператора превышает 1, а заявление S'L содержит по крайней мере один параметрный маркер, **s'LExecute** выполняет выписку s-L один раз для каждого набора значений параметров в массивах, на которые указывает аргумент * \*ParameterValuePtr* в вызовах к **S'LBindParameter.** Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/arrays-of-parameter-values.md)  
  
 Если закладки включены и выполняется запрос, который не может поддерживать закладки, водитель должен попытаться принудить среду к той, которая поддерживает закладки, изменив значение атрибута и вернув значение S'LSTATE 01S02 (изменение значения опциона). Если атрибут не может быть изменен, драйвер должен вернуть значение атрибута S'Lstate.  
  
> [!NOTE]  
>  При использовании объединения соединений приложение не должно выполнять инструкции по S'L, которые меняют базу данных или контекст базы _данных,_ например заявление базы данных **USE** в сервере S'L, которое изменяет каталог, используемый источником данных.  
  
## <a name="code-example"></a>Пример кода  
 [См. S'LBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [S'LBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [S'LPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [S LSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Закрытие курсора|[Функция SQLCloseCursor](../../../odbc/reference/syntax/sqlclosecursor-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Получение нескольких строк данных|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Освобождение ручки оператора|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращение имени курсора|[Функция SQLGetCursorName](../../../odbc/reference/syntax/sqlgetcursorname-function.md)|  
|Получение части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращение следующего параметра для отправки данных для|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Подготовка выписки для исполнения|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Отправка данных параметров во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Установка имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
|Установка атрибута оператора|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
