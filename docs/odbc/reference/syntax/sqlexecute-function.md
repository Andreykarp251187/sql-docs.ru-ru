---
title: Функция SQLExecute | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExecute
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExecute
helpviewer_keywords:
- SQLExecute function [ODBC]
ms.assetid: 9286a01d-cde2-4b90-af94-9fd7f8da48bf
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 08eb9db7645448157a76b3bcfdd302f6654f68f5
ms.sourcegitcommit: 7a3243c45830cb3f49a7fa71c2991a9454fd6f5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/11/2019
ms.locfileid: "65537258"
---
# <a name="sqlexecute-function"></a>Функция SQLExecute
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLExecute** выполняет подготовленную инструкцию, используя текущие значения переменных маркера параметра в том случае, если существует любой маркер параметра в инструкции.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExecute(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, SQL_NO_DATA, SQL_INVALID_HANDLE, or SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLExecute** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, можно получить путем вызова связанного значения SQLSTATE **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLExecute** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01001|Конфликт операции с курсором|Подготовленной инструкции, связанные с *StatementHandle* автономной позиционированные инструкция update или delete, и ни одной строки или более чем одной строке были обновлены или удалены. (Дополнительные сведения об обновлениях для более одной строки см. описание SQL_ATTR_SIMULATE_CURSOR *атрибут* в **SQLSetStmtAttr**.)<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01003|Функция set не поддерживает значение NULL|Подготовленной инструкции, связанные с *StatementHandle* содержатся функции набора (такие как **AVG**, **MAX**, **MIN**, и так далее), но не **число** задать функцию и аргумент значение NULL, значения были устранены до применения функции. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение данных строки справа|Строка или двоичные данные, возвращаемые для выходного параметра завершилась усечение непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усекаются справа. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01006|Привилегия не отменена|Подготовленной инструкции, связанные с *StatementHandle* был **ОТОЗВАТЬ** инструкции и пользователь не имеет заданного права. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01007|Привилегия не предоставлена|Подготовленной инструкции, связанные с *StatementHandle* был **GRANT** инструкции и пользователь не может предоставляться заданного права.|  
|01S02|Значение параметра изменено|Атрибут указанной инструкции была Недопустимый рабочий трудностями реализации, поэтому такую же пользу за временно был заменен. (**SQLGetStmtAttr** можно вызвать для определения, что такое временно подставляемого значения.) Заменяющее значение является допустимым для *StatementHandle* до закрытия курсора, после чего атрибут инструкции возвращается к предыдущему значению. Атрибуты инструкции, которые могут быть изменены следующие: SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, атрибута SQL_ATTR_KEYSET_SIZE, значения SQL_ATTR_MAX_LENGTH, SQL_ATTR_MAX_ROWS, SQL_ATTR_QUERY_TIMEOUT и SQL_ATTR_SIMULATE_CURSOR. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S07|Частичное усечение|Данные, возвращаемые для ввода вывода или выходного параметра было усечено, дробная часть параметра числового типа данных было усечено или дробной части числа компонент времени, метка времени, интервалом времени или тип данных было усечено.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07002|Неправильное поле COUNT|Число параметров, указанных в **SQLBindParameter** был меньше, чем число параметров в инструкции SQL, содержащихся в \* *StatementText*.<br /><br /> **SQLBindParameter** был вызван с *ParameterValuePtr* значение является пустым указателем, *StrLen_or_IndPtr* не присвоено значение SQL_NULL_DATA, или значение SQL_DATA_AT_EXEC, и *InputOutputType*  не присвоено SQL_PARAM_OUTPUT, позволяющего число параметров в **SQLBindParameter** превышает число параметров в инструкции SQL, содержащихся в **StatementText* .|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных, определяемое *ValueType* аргумента в **SQLBindParameter** для привязанного параметра не удалось преобразовать в тип данных, определяемый *ParameterType*аргумента в **SQLBindParameter**.<br /><br /> Возвращаемое значение данных параметра, привязанный как SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT не удалось преобразовать в тип данных, определяемый *ValueType* аргумента в **SQLBindParameter**.<br /><br /> (Если значения данных для одной или нескольких строк не могут быть преобразованы, но один или несколько строк, возвращенных успешно, эта функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07007|Нарушение ограничения значения параметра|Тип параметра SQL_PARAM_INPUT_OUTPUT_STREAM используется только для параметра, который отправляет и получает данные в частях. Связанный входной буфер не допускается для этого параметра типа.<br /><br /> Эта ошибка возникает в том случае, когда тип параметра является SQL_PARAM_INPUT_OUTPUT и когда \* *StrLen_or_IndPtr* указано в **SQLBindParameter** не равным SQL_NULL_DATA, SQL_DEFAULT_ PARAM, SQL_LEN_DATA_AT_EXEC(len) или значение SQL_DATA_AT_EXEC.|  
|07S01|Недопустимое использование параметра по умолчанию|Задайте значение параметра с **SQLBindParameter**был SQL_DEFAULT_PARAM и соответствующий параметр не параметр для вызова процедуры каноническую ODBC.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|21S02|Структура полученной таблицы не соответствует списку столбцов|Подготовленной инструкции, связанные с *StatementHandle* содержится **CREATE VIEW** инструкции, а также список столбцов с неполными (количество столбцов, указанных для представления в  *Идентификатор столбца* аргументов инструкции SQL) содержится несколько имен, чем количество столбцов в производная таблица, определяется *спецификация запроса* аргумент инструкции SQL.|  
|22001|Строковые данные, усечение справа|Назначение символьное или двоичное значение в столбец завершилась усечение непустым (символ), отличное от null (двоичных) символов или байтов.|  
|22002|Переменная индикатора требуется, но не указано|Значение NULL, данные были привязаны к параметру вывода которого *StrLen_or_IndPtr* задается **SQLBindParameter** был пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|Подготовленной инструкции, связанные с *StatementHandle* содержится привязанного числовой параметр, и значение параметра вызвало целиком (в отличие от долей) часть номера будет усечен при назначении в связанный столбец таблицы.<br /><br /> Возвращает числовое значение (в виде строк или чисел) для одного или нескольких параметров ввода вывода или выходной вызвало бы всего (в отличие от долей) часть усекаемое число.|  
|22007|Формат недопустимые даты и времени|Подготовленной инструкции, связанные с *StatementHandle* содержатся инструкции SQL, содержащего даты, времени или структура отметки времени, как связанных параметров, а параметр был, соответственно, при обнаружении неверной даты, времени, или Отметка времени.<br /><br /> Является параметром ввода вывода или вывода был привязан к даты, времени или структура отметки времени C, а значение в параметре возвращаемый было, соответственно, при обнаружении неверной даты, времени или метки времени. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22008|Переполнение поля даты и времени|Подготовленной инструкции, связанные с *StatementHandle* автономной инструкции SQL, содержащего выражение даты и времени, что при вычислении, привело к даты, времени или метки времени структуру, в которой был недопустимым.<br /><br /> Выражение даты и времени, рассчитанное для ввода вывода или выходной параметр привело к даты, времени или C отметку времени, был недопустимым.|  
|22012|Деление на ноль|Подготовленной инструкции, связанные с *StatementHandle* содержится арифметического выражения, вызвавшего деления на ноль.<br /><br /> Арифметическое выражение вычисляется для ввода вывода или выходной параметр привело к деления на ноль.|  
|22015|Переполнение поля интервала|*\*StatementText* содержится параметр точного числового или интервал, при преобразовании в тип данных SQL интервал, привело к потере значащих цифр.<br /><br /> *\*StatementText* содержится параметр интервала с более чем одним полем, преобразованный в числовой тип данных в столбце, имел нет представления в числовой тип данных.<br /><br /> *\*StatementText* содержащихся данных параметра, назначенный период, в тип SQL, и возникла не представление значения типа C в интервале тип SQL.<br /><br /> Назначение ввода вывода или выходной параметр, который было точное числовое значение или интервал типа SQL в тип интервала C, привело к потере значащих цифр.<br /><br /> Когда параметр ввода вывода или вывода был назначен структуру интервала C, возникла нет представления данных в структуре данных интервала.|  
|22018|Недопустимое символьное значение для спецификации приведения|*\*StatementText* содержится тип C это было точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.<br /><br /> После ввода вывода или выходного параметра было возвращено, тип SQL был точное или Приблизительное числовое, datetime или тип интервала данных; Тип C был SQL_C_CHAR; и значение в столбце не является допустимым литералом связанного типа SQL.|  
|22019|Недопустимый escape-символ|Подготовленной инструкции, связанные с *StatementHandle* содержится **как** предиката с **escape-** в **ГДЕ** предложение, и Длина следующий escape **ESCAPE** не равно 1.|  
|22025|Недопустимая escape-последовательность|Подготовленной инструкции, связанные с *StatementHandle* содержится "**как** _значение шаблона_ **ESCAPE** _escape символ_"в **ГДЕ** предложение, а символ после escape-символ в значение шаблона не является одним из «%» или «_».|  
|23000|Нарушение ограничения целостности|Подготовленной инструкции, связанные с *StatementHandle* содержала значение параметра. Значение параметра было NULL для столбца, определенные как NOT NULL в столбце связанной таблицы, повторяющееся значение было указано для столбца, ограниченного должен содержать только уникальные значения или другое ограничение целостности было нарушено.|  
|24000|Недопустимое состояние курсора|Курсор был установлен на *StatementHandle* по **SQLFetch** или **SQLFetchScroll**. Если эта ошибка возвращается диспетчером драйверов **SQLFetch** или **SQLFetchScroll** не вернула значение SQL_NO_DATA и возвращается с помощью драйвера, если **SQLFetch** или **SQLFetchScroll** вернула значение SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle*.<br /><br /> Подготовленной инструкции, связанные с *StatementHandle* содержится позиционированного обновления или удаления событи "," t "и" курсор находился в позиции перед началом результирующего набора или в конце результирующего набора.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|42000|Синтаксическая ошибка или нарушение доступа|Пользователь не имеет разрешения на выполнение подготовленной инструкции, связанные с *StatementHandle*.|  
|44000|Нарушение параметра WITH CHECK OPTION|Подготовленной инструкции, связанные с *StatementHandle* содержится **вставить** инструкции в просматриваемой таблице или таблицу, полученного из просматриваемого таблицы, созданный путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк влияет **вставить** инструкции больше не присутствовать в просматриваемой таблице.<br /><br /> Подготовленной инструкции, связанные с *StatementHandle* содержится **обновления** инструкции в просматриваемой таблице или таблицу, полученного из просматриваемого таблицы, созданный путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк влияет **обновления** инструкции больше не присутствовать в просматриваемой таблице.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция был снова вызван для *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLExecute** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) *StatementHandle* не была подготовлена.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Задайте значение параметра с **SQLBindParameter**, был пустым указателем, а длина значения параметра не 0, SQL_NULL_DATA, значение SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Задайте значение параметра с **SQLBindParameter**, не является пустым указателем; был тип данных C SQL_C_BINARY и SQL_C_CHAR; и значение параметра длины было, но меньше 0 не SQL_NTS, SQL_NULL_DATA, SQL_DEFAULT_PARAM или SQL_DATA_ AT_EXEC, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Длина значения параметра, привязанного с **SQLBindParameter** был задан в значение SQL_DATA_AT_EXEC, тип SQL был SQL_LONGVARCHAR, SQL_LONGVARBINARY, или тип данных long зависящие от источника данных; и информации, SQL_NEED_LONG_DATA_LEN Введите в **SQLGetInfo** был «Y».|  
|HY105|Недопустимый тип параметра|Значение, указанное для аргумента *InputOutputType* в **SQLBindParameter** SQL_PARAM_OUTPUT, и параметр входным параметром.|  
|HY109|Недопустимое положение курсора.|Подготовленная инструкция была позиционированного обновления или инструкции delete, и курсор был установлен (по **SQLSetPos** или **SQLFetchScroll**) на строку, которая была удалена или не удалось извлечь.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Сочетание текущие значения атрибутов инструкции SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживается драйвером или источником данных.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE и атрибут инструкции SQL_ATTR_CURSOR_TYPE было присвоено тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Период ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
 **SQLExecute** может возвращать любой SQLSTATE, которые могут быть возвращены с **SQLPrepare**, в зависимости от того, если источник данных принимает инструкции SQL, связанные с инструкцией.  
  
## <a name="comments"></a>Комментарии  
 **SQLExecute** выполняет инструкцию, подготовленных методом **SQLPrepare**. Обрабатывает или отменяет результаты из-за обращения к **SQLExecute**, приложение может вызвать **SQLExecute** попытку, используя новые значения параметров. Дополнительные сведения о подготовленное выполнение, см. в разделе [подготовленных](../../../odbc/reference/develop-app/prepared-execution-odbc.md).  
  
 Для выполнения **ВЫБЕРИТЕ** инструкции более одного раза, приложение должно вызвать **SQLCloseCursor** перед останавливаясь **ВЫБЕРИТЕ** инструкции.  
  
 Если источник данных находится в режиме ручной фиксации (требуется запуска явной транзакции), и транзакция уже не было инициировано, драйвер запускает транзакцию, прежде чем он отправляет инструкции SQL. Дополнительные сведения см. в разделе [транзакции](../../../odbc/reference/develop-app/transactions-odbc.md).  
  
 Если приложение использует **SQLPrepare** для подготовки и **SQLExecute** для отправки **ЗАФИКСИРОВАТЬ** или **ОТКАТА** инструкции, она не будет с возможностью взаимодействия между СУБД. Чтобы зафиксировать или откатить транзакцию, вызвать **SQLEndTran**.  
  
 Если **SQLExecute** обнаруживают параметр данных во время выполнения, он возвращает SQL_NEED_DATA. Приложение отправляет данные с помощью **SQLParamData** и **SQLPutData**. См. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [отправка данных типа Long](../../../odbc/reference/develop-app/sending-long-data.md).  
  
 Если **SQLExecute** выполняет поисковое обновление, вставка или инструкцию delete, которая не влияет на все строки в источнике данных, вызов **SQLExecute** не вернет значение SQL_NO_DATA.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, а инструкция SQL содержит по крайней мере один маркер параметра, **SQLExecute** выполняет инструкцию SQL один раз для каждого набора значений параметров в массивах Указывает  *\*ParameterValuePtr* аргумента в вызовы **SQLBindParameter**. Дополнительные сведения см. в разделе [массивы значений параметров](../../../odbc/reference/develop-app/arrays-of-parameter-values.md).  
  
 Если включены закладки и выполняется запрос, не поддерживает закладки, драйвер должен попытаться привязкой к среде, поддерживает закладки, изменив значение атрибута и возвращение SQLSTATE 01S02 (значение параметра изменено). Если атрибут не может быть изменен, драйвер должен возвращать SQLSTATE HY024 (недопустимое значение атрибута).  
  
> [!NOTE]  
>  При использовании пула подключений, приложение не должно выполнить инструкции SQL, изменяющие базу данных или контексте базы данных, такие как **используйте** _базы данных_ инструкции в SQL Server, который изменяет каталог, используемый источником данных.  
  
## <a name="code-example"></a>Пример кода  
 См. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Закрытие курсора|[Функция SQLCloseCursor](../../../odbc/reference/syntax/sqlclosecursor-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Получение нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Освобождение дескриптора инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращает имя курсора|[Функция SQLGetCursorName](../../../odbc/reference/syntax/sqlgetcursorname-function.md)|  
|Получение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает следующий параметр для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Отправка данных параметра во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Задав имя курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
|Присвоение атрибуту инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
