---
title: Функция СЗЛЕндТран (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLEndTran
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLEndTran
helpviewer_keywords:
- SQLEndTran function [ODBC]
ms.assetid: ff375ce1-eb50-4693-b1e6-70181a6dbf9f
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: cce7792e52fce4984f3da41e11d79c34b6b79e53
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81302745"
---
# <a name="sqlendtran-function"></a>Функция SQLEndTran
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 Для всех активных операций по всем инструкциям, связанным с подключением, **s'LEndTran** запрашивает операцию фиксации или отката. Кроме того, **sLEndTran** может запросить операцию фиксации или отката для всех соединений, связанных с средой.  
  
> [!NOTE]  
>  Для получения дополнительной информации о том, что менеджер драйверов карты эту функцию, когда ODBC 3. *приложение x* работает с ODBC 2. *х* драйвер, см [Отображение функции замены для обратной совместимости приложений.](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLEndTran(  
     SQLSMALLINT   HandleType,  
     SQLHANDLE     Handle,  
     SQLSMALLINT   CompletionType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 (Вход) Идентификатор типа обработки. Содержит либо SQL_HANDLE_ENV (если *ручка* — это ручка среды), либо SQL_HANDLE_DBC (если *ручка* — ручка соединения).  
  
 *Дескриптор*  
 (Вход) Ручка, типа, указанного *HandleType*, с указанием объема транзакции. Дополнительную информацию можно узнать в "Комментарии".  
  
 *ЗавершениеТип*  
 (Вход) Одно из двух следующих значений:  
  
 SQL_COMMIT SQL_ROLLBACK  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LEndTran** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив по **телефону s'LGetDiagRec** с соответствующим *исправным handleType* и *Ручкой.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LEndTran,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08003|Подключение не открыто|(DM) *HandleType* был SQL_HANDLE_DBC, и *ручка* не была в подключенном состоянии.|  
|08007|Сбой подключения во время транзакции|*HandleType* был SQL_HANDLE_DBC, и соединение, связанное с *ручкой,* сработало во время выполнения функции, и невозможно определить, произошло ли запрашиваемое **COMMIT** или **ROLLBACK** до сбоя.|  
|25S01|Состояние транзакции неизвестно|Один или несколько соединений в *Handle* не завершили транзакцию с указанным результатом, и результат неизвестен.|  
|25S02|Транзакция по-прежнему активна|Драйвер не смог гарантировать, что все работы в глобальной транзакции могут быть завершены атомарно, и транзакция по-прежнему активна.|  
|25S03|Транзакция откатывается назад|Драйвер не смог гарантировать, что все работы в глобальной транзакции могут быть завершены атомарно, и вся работа в транзакции, активно *йенотке,* была отката.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40002|Нарушение ограничения целостности|*CompletionType* был SQL_COMMIT, и принятие изменений привело к нарушению целостности. В результате транзакция была откатной.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере szMessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *ConnectionHandle*. Функция была вызвана, и до того, как она закончила выполнение [функции S'LCancelHandle,](../../../odbc/reference/syntax/sqlcancelhandle-function.md) была вызвана на *ConnectionHandle*. Затем функция была вызвана снова на *ConnectionHandle*.<br /><br /> Функция была вызвана, и до того, как она закончила **выполнение, S'LКанстрикл** был вызван на *ConnectionHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно выполнение функции был вызван для ручки оператора, связанные с *ConnectionHandle* и по-прежнему выполнения, когда **S'LEndTran** был вызван.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *ConnectionHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (ДМ) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для ручки оператора, связанные с *ConnectionHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *ручки* с *HandleType* набор SQL_HANDLE_DBC и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) Для одной из ручек оператора, связанных с *ручкой и* возвращенной SQL_PARAM_DATA_AVAILABLE, был вызван **s'LExecDirect**, **или** **S'LMoreResults.** Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.|  
|HY012|Недействительный код операции транзакции|(DM) Значение, указанное для аргумента *CompletionType* не было ни SQL_COMMIT, ни SQL_ROLLBACK.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY092|Недействительный идентификатор атрибута/опциона|(DM) Значение, указанное для аргумента *HandleType,* не было ни SQL_HANDLE_ENV, ни SQL_HANDLE_DBC.|  
|HY115|S'LEndTran не допускается для среды, содержащей соединение с асинхронным выполнением функции|(DM) *HandleType* не может быть установлен для SQL_HANDLE_ENV если асинхронное выполнение функций соединения включено для соединения в среде.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, обратитесь в раздел Комментарии по этой теме.|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает работу **ROLLBACK.**|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *ConnectionHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Для ODBC 3. *x* драйвер, если *HandleType* является SQL_HANDLE_ENV и *ручка* является действительной ручкой среды, то менеджер драйвера вызовет **S'LEndTran** в каждом драйвере, связанном с окружающей средой. Аргументом *для* вызова к водителю будет ручка среды водителя. Для ODBC 2. *x* драйвер, если *HandleType* является SQL_HANDLE_ENV и *ручка* является допустимой ручкой среды, и есть несколько соединений в подключенном состоянии в этой среде, то менеджер драйвера вызовет **S'LTransact** в драйвере один раз для каждого соединения в подключенном состоянии в этой среде. Аргумент *ручки* в каждом вызове будет ручкой соединения. В любом случае, драйвер будет пытаться совершать или откативать транзакции, в зависимости от значения *CompletionType*, на всех соединениях, которые находятся в подключенном состоянии на этой среде. Неактивные соединения не влияют на транзакцию.  
  
> [!NOTE]  
>  **S'LEndTran** не может использоваться для совершения или отката транзакций в общей среде. S'LSTATE HY092 (идентификатор недействительных атрибутов/опционов) будет возвращен, если **S'LEndTran** будет вызван с *набором ручки* либо ручкой общей среды, либо ручкой соединения на общей среде.  
  
 Менеджер драйвера возвращает SQL_SUCCESS только в том случае, если он получает SQL_SUCCESS за каждое соединение. Если менеджер драйвера получает SQL_ERROR на одном или нескольких соединениях, он возвращает SQL_ERROR в приложение, и диагностическая информация помещается в диагностическую структуру данных среды. Чтобы определить, какое соединение или соединения не удалось во время операции коммивояжера или отката, приложение может вызвать **S'LGetDiagRec** для каждого соединения.  
  
> [!NOTE]  
>  Менеджер драйвера не моделирует глобальную транзакцию во всех соединениях и поэтому не использует двухфазные протоколы коммитов.  
  
 Если *CompletionType* является SQL_COMMIT, **S'LEndTran** выдает запрос на совершение для всех активных операций на любой выписке, связанной с затронутым соединением. Если *CompletionType* является SQL_ROLLBACK, **S'LEndTran** выдает запрос на откат для всех активных операций на любой выписке, связанной с затронутым соединением. Если транзакции не активны, **s'LEndTran** возвращает SQL_SUCCESS без каких-либо последствий для каких-либо источников данных. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/committing-and-rolling-back-transactions.md)  
  
 Если драйвер находится в режиме ручного коммита (позвонив в **s'LSetConnectAttr** с SQL_ATTR_AUTOCOMMIT атрибутом, установленным на SQL_AUTOCOMMIT_OFF), новая транзакция неявно запускается, когда выписка s'L, которая может содержаться в транзакции, выполняется в отношении текущего источника данных. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/commit-mode.md)  
  
 Чтобы определить, как операции транзакций влияют на курсоры, приложение вызывает **s'LGetInfo** с SQL_CURSOR_ROLLBACK_BEHAVIOR и SQL_CURSOR_COMMIT_BEHAVIOR опций. Для получения дополнительной информации см. [Effect of Transactions on Cursors and Prepared Statements](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md)  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR равно SQL_CB_DELETE, **S'LEndTran** закрывает и удаляет все открытые курсоры на все операторы, связанные с соединением, и отбрасывает все ожидающие результаты. **S'LEndTran** оставляет любое заявление в выделенном (неподготовленном) состоянии; приложение может повторно использовать их для последующих запросов на S-L'L или **s'LFreeHandle** с *помощью SQL_HANDLE_STMT,* чтобы разложовать их. **SQLFreeStmt**  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR равно SQL_CB_CLOSE, **S'LEndTran** закрывает все открытые курсоры на все операторы, связанные с соединением. **S'LEndTran** оставляет любое заявление в подготовленном состоянии; приложение может вызвать **S'LExecute** для оператора, связанного с подключением, без предварительного вызова **S'LPrepare.**  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR равно SQL_CB_PRESERVE, **s'LEndTran** не влияет на открытые курсоры, связанные с соединением. Курсоры остаются в строке, на который они указали до звонка в **S'LEndTran.**  
  
 Для драйверов и источников данных, поддерживающих транзакции, вызов **S'LEndTran** либо с SQL_COMMIT, либо SQL_ROLLBACK, когда транзакция не является активной возвратной SQL_SUCCESS (указывая, что нет работы, которую нужно совершить или откатить) и не влияет на источник данных.  
  
 Когда драйвер находится в режиме автоматического коммиверта, менеджер драйвера не вызывает **s'LEndTran** в драйвере. **SLEndTran** всегда возвращается SQL_SUCCESS независимо от того, называется ли он с *completionType* SQL_COMMIT или SQL_ROLLBACK.  
  
 Драйверы или источники данных, не поддерживающие транзакции *(опция* **SQL_TXN_CAPABLE sLGetInfo** находится SQL_TC_NONE) фактически всегда находится в режиме автоматического выполнения и поэтому всегда возвращает SQL_SUCCESS для **S'LEndTran** независимо от того, вызваны ли они с *помощью CompletionType* SQL_COMMIT или SQL_ROLLBACK. Такие драйверы и источники данных фактически не откатывают транзакции по запросу.  
  
## <a name="suspended-state"></a>Приостановленное состояние  
 В драйверах менеджеров, которые были выпущены до Windows 7, транзакция была активна, если **S'LEndTran** вернулся SQL_ERROR от драйвера. Однако возможно, что транзакция была успешно совершена на сервере, но драйвер клиента не был уведомлен (например, из-за ошибки сети). Это оставит соединение в плохом состоянии. Начиная с Windows 7, когда **S'LEndTran** возвращается SQL_ERROR, подключение может быть в приостановленном состоянии. В приостановленном состоянии можно вызывать функции только для чтения. В конце концов, приложение должно вызывать **S'LDisconnect** на приостановленном подключении к выпуску ресурсов.  
  
 Если все следующие условия верны, соединение будет помещено в приостановленное состояние:  
  
-   Водитель возвращается SQL_ERROR из **S'LEndTran**.  
  
-   ДрайверОМ является версия ODBC 3.8, или позже.  
  
-   Версия приложения 3.8 или более поздно; или перекомпилированное приложение ODBC 2.x или 3.x успешно отменяет функцию **S'LEndTran** через **S'LCancelHandle**.  
  
-   Водитель не ответил на одно из следующих сообщений, подтверждававшее, что транзакция не была завершена:  
  
    -   25S03: Транзакция откатывается назад  
  
    -   40001: Сбой сериализации  
  
    -   40002: Ограничение целостности  
  
    -   HYC00: Необязательная функция не реализована  
  
 Если **s'LEndTran** был вызван на ручку среды и одно из его соединений соответствовало вышеуказанным условиям, все соединения, соединяющиеся с одним и тем же драйвером, будут переведены в приостановленное состояние.  
  
 После того, как приложение вызывает **S'LDisconnect** на приостановленном подключении, соединение может быть использовано для повторного подключения к другому источнику данных или тому же источнику данных.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена функции, работающей асинхронно на ручке соединения.|[Функция SQLCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md)|  
|Возвращение информации о драйвере или источнике данных|[SQLGetInfo, функция](../../../odbc/reference/syntax/sqlgetinfo-function.md)|  
|Освобождение ручки|[SQLFreeHandle, функция](../../../odbc/reference/syntax/sqlfreehandle-function.md)|  
|Освобождение ручки оператора|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Асинхронное исполнение (Метод опроса)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md)
