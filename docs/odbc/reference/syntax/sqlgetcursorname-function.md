---
title: Функция S'LGetCursorName (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetCursorName
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetCursorName
helpviewer_keywords:
- SQLGetCursorName function [ODBC]
ms.assetid: e6e92199-7bb6-447c-8987-049a4c6ce05d
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: d3ac65dc07897ddc789ee03b06b1bc1f71d37c3c
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285552"
---
# <a name="sqlgetcursorname-function"></a>Функция SQLGetCursorName
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **S'LGetCursorName** возвращает имя курсора, связанное с указанным утверждением.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetCursorName(  
     SQLHSTMT        StatementHandle,  
     SQLCHAR *       CursorName,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   NameLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *КурсорНамь*  
 (Выход) Указатель на буфер, в котором можно вернуть имя курсора.  
  
 Если *CursorName* является NULL, *NameLengthPtr* по-прежнему возвращает общее количество символов (за исключением символа с нулевым прекращением для данных символов), доступных для возврата в буфере, на который указывает *CursorName.*  
  
 *BufferLength*  
 (Вход) Длина \* *CursorName*, в символах. Если значение в * \*CursorName* является строкой Unicode (при вызове **S'LGetCursorNameW),** аргумент *BufferLength* должен быть четным числом.  
  
 *NameLengthPtr*  
 (Выход) Указатель на память, в котором можно вернуть общее количество символов (за \*исключением символа нулевого прекращения), доступного для возврата в *CursorName.* Если количество символов, доступных для возвращения, больше или равно *персонажу BufferLength,* имя курсора в \* *CursorName* усечено до *BufferLength* за вычетом длины персонажа с нулевым окончанием.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LGetCursorName** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью handleType* SQL_HANDLE_STMT и *ручки* *выписки.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LGetCursorName,** и приведены в изъяны каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Буфер \* *CursorName* не был достаточно большим, чтобы вернуть все имя курсора, поэтому имя курсора было усечено. Длина непрохатого имени курсора возвращается в*nameLengthPtr*. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LGetCursorOrName.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY015|Имя курсора недоступно|(DM) Драйвер был ODBC 2 *.x* драйвер, не было открытого курсора на заявлении, и не было имя курсора было установлено с **S'LSetCursorName**.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение, указанное в аргументе *BufferLength,* было меньше 0.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Имена курсоров используются только в позиционированных обновлениях и удалениях (например, _название таблицы_ **UPDATE** ... **ГДЕ CURRENT Of** _курсор-имя_). Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md) Если приложение не вызывает **имя курсора s'LSetCursorName** для определения имени курсора, драйвер генерирует имя. Это название начинается с букв SQL_CUR.  
  
> [!NOTE]
>  В ODBC 2 *.x*, когда не было открытого курсора и имя не было установлено вызовом на **S'LSetCursorName**, звонок в **S'LGetCursorName** вернулся S'LSTATE HY015 (имя курсора не доступно). В ODBC 3 *.x*, это уже не так; независимо от того, когда называется **S'LGetCursorName,** водитель возвращает имя курсора.  
  
 **S'LGetCursorName** возвращает имя курсора независимо от того, было ли имя создано явно или косвенно. Имя курсора неявно генерируется, если **s'LSetCursorName** не вызывается. **SLSetCursorName** можно вызвать для переименования курсора в выписке, пока курсор находится в выделенном или подготовленном состоянии.  
  
 Имя курсора, которое устанавливается либо явно, либо косвенно, остается установленным до тех пор, пока не будет *удалена информация,* с которой оно связано, с помощью **S'LFreeHandle** с *помощью SQL_HANDLE_STMT.*  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Подготовка выписки для исполнения|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Установка имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
