---
title: Функция SQLForeignKeys | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLForeignKeys
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLForeignKeys
helpviewer_keywords:
- SQLForeignKeys function [ODBC]
ms.assetid: 07f3f645-f643-4d39-9a10-70a72f24e608
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 1aeaef9b120a0bd4be008adafe8e9a24724279a0
ms.sourcegitcommit: 7a3243c45830cb3f49a7fa71c2991a9454fd6f5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/11/2019
ms.locfileid: "65537247"
---
# <a name="sqlforeignkeys-function"></a>Функция SQLForeignKeys
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: интерфейс ODBC  
  
 **Сводка**  
 **SQLForeignKeys** может вернуть:  
  
-   Список внешних ключей в указанной таблице (столбцы в указанной таблице, которые ссылаются на первичные ключи в других таблицах).  
  
-   Список внешних ключей в других таблицах, которые ссылаются на первичный ключ в указанной таблице.  
  
 Драйвер возвращает каждого списка в виде результирующего набора на указанной инструкции.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLForeignKeys(  
     SQLHSTMT       StatementHandle,  
     SQLCHAR *      PKCatalogName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      PKSchemaName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      PKTableName,  
     SQLSMALLINT    NameLength3,  
     SQLCHAR *      FKCatalogName,  
     SQLSMALLINT    NameLength4,  
     SQLCHAR *      FKSchemaName,  
     SQLSMALLINT    NameLength5,  
     SQLCHAR *      FKTableName,  
     SQLSMALLINT    NameLength6);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *PKCatalogName*  
 [Вход] Имя каталога таблицы первичного ключа. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("») обозначает этих таблиц, у которых нет каталогов. *PKCatalogName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *PKCatalogName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *PKCatalogName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения. Дополнительные сведения см. в разделе [аргументов в функции работы с каталогами](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 [Вход] Длина **PKCatalogName*, в символах.  
  
 *PKSchemaName*  
 [Вход] Имя схемы таблицы первичного ключа. Если драйвер поддерживает схемы, для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("») обозначает этих таблиц, у которых нет схемы. *PKSchemaName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *PKSchemaName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *PKSchemaName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength2*  
 [Вход] Длина **PKSchemaName*, в символах.  
  
 *PKTableName*  
 [Вход] Имя таблицы первичных ключей. *PKTableName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *PKTableName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *PKTableName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength3*  
 [Вход] Длина **PKTableName*, в символах.  
  
 *FKCatalogName*  
 [Вход] Имя каталога таблицы внешнего ключа. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("») обозначает этих таблиц, у которых нет каталогов. *FKCatalogName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *FKCatalogName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *FKCatalogName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength4*  
 [Вход] Длина **FKCatalogName*, в символах.  
  
 *FKSchemaName*  
 [Вход] Имя схемы таблицы внешнего ключа. Если драйвер поддерживает схемы, для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("») обозначает этих таблиц, у которых нет схемы. *FKSchemaName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *FKSchemaName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *FKSchemaName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength5*  
 [Вход] Длина **FKSchemaName*, в символах.  
  
 *FKTableName*  
 [Вход] Имя таблицы внешних ключей. *FKTableName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *FKTableName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *FKTableName* обычный аргумент; интерпретируется буквально, а также его регистр имеет значения.  
  
 *NameLength6*  
 [Вход] Длина **FKTableName*, в символах.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLForeignKeys** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL _HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые при помощи **SQLForeignKeys** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|24000|Недопустимое состояние курсора|Курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы вызывалась. Если эта ошибка возвращается диспетчером драйверов **SQLFetch** или **SQLFetchScroll** не вернула значение SQL_NO_DATA и возвращается с помощью драйвера, если **SQLFetch** или **SQLFetchScroll** вернула значение SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимая для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) аргументы *PKTableName* и *FKTableName* были оба указателя null.<br /><br /> Атрибут инструкции SQL_ATTR_METADATA_ID было установлено значение SQL_TRUE, *FKCatalogName* или *PKCatalogName* аргумент был пустым указателем, а также SQL_CATALOG_NAME *InfoType*возвращает этот каталога имена поддерживаются.<br /><br /> (DM) атрибут инструкции SQL_ATTR_METADATA_ID было установлено значение SQL_TRUE и *FKSchemaName*, *PKSchemaName*, *FKTableName*, или *PKTableName*  аргумент был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. При вызове функции SQLForeignKeys по-прежнему выполнении асинхронной функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение одного из аргументов длина имени меньше 0, но не равно SQL_NTS.|  
|||Значение одного из аргументов длина имени превышает значение максимальной длины для соответствующего имени. (См. в разделе «Комментарии».)|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Было указано имя каталога, а драйверу или источнику данных не поддерживает каталоги.<br /><br /> Было указано имя схемы, а драйверу или источнику данных не поддерживает схемы.|  
|||Сочетание текущие значения атрибутов инструкции SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживается драйвером или источником данных.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE и атрибут инструкции SQL_ATTR_CURSOR_TYPE было присвоено тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Период ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Сведения о том, как может использоваться сведений, возвращаемых этой функцией, см. в разделе [использует данные из каталога](../../../odbc/reference/develop-app/uses-of-catalog-data.md).  
  
 Если \* *PKTableName* содержит имя таблицы **SQLForeignKeys** возвращает результирующий набор, содержащий первичный ключ для указанной таблицы и все внешние ключи, ссылающиеся на него. Список внешних ключей в других таблицах не поддерживает внешние ключи, которые указывают на ограничения уникальности в указанной таблице.  
  
 Если \* *FKTableName* содержит имя таблицы **SQLForeignKeys** возвращает результирующий набор, содержащий все внешние ключи в указанной таблице, которые указывают на первичные ключи других таблиц и первичные ключи других таблиц, к которым они относятся. Список внешних ключей в указанной таблице не содержит внешние ключи, ссылающиеся на ограничения уникальности в других таблицах.  
  
 Если оба \* *PKTableName* и \* *FKTableName* содержат имена таблиц, **SQLForeignKeys** Возвращает внешние ключи в таблице, указанной в \* *FKTableName* , которые ссылаются на первичный ключ таблицы, указанной в **PKTableName*. Это должно быть не более одного ключа.  
  
> [!NOTE]  
>  Дополнительные сведения о общего использования, аргументы и возвращаемые данные функций каталога ODBC, см. в разделе [функций каталога](../../../odbc/reference/develop-app/catalog-functions.md).  
  
 **SQLForeignKeys** возвращает результаты в виде стандартных результирующий набор. Если запрашиваются внешние ключи, связанные с первичным ключом, результирующий набор упорядочивается по FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME и KEY_SEQ. Если запрашиваются первичные ключи, связанные с внешним ключом, результирующий набор упорядочивается по PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME и KEY_SEQ. В следующей таблице перечислены столбцы в результирующем наборе.  
  
 Длин столбцы типа VARCHAR не отображаются в таблице. фактические значения длины зависит от источника данных. Чтобы определить фактический длин PKTABLE_CAT или FKTABLE_CAT, PKTABLE_SCHEM или FKTABLE_SCHEM, PKTABLE_NAME или FKTABLE_NAME и PKCOLUMN_NAME или FKCOLUMN_NAME столбцов, приложение может вызвать **SQLGetInfo** с SQL_MAX_ Параметры CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN, SQL_MAX_TABLE_NAME_LEN и SQL_MAX_COLUMN_NAME_LEN.  
  
 Следующие столбцы были переименованы для ODBC 3 *. x.* Изменения имен столбцов не влияют на обратную совместимость так, как выполнить привязку приложения, номер столбца.  
  
|Столбец ODBC 2.0|ODBC 3 *.x* столбца|  
|---------------------|-----------------------|  
|PKTABLE_QUALIFIER|PKTABLE_CAT|  
|PKTABLE_OWNER|PKTABLE_SCHEM|  
|FKTABLE_QUALIFIER|FK_TABLE_CAT|  
|FKTABLE_OWNER|FKTABLE_SCHEM|  
  
 В следующей таблице перечислены столбцы в результирующем наборе. Дополнительные столбцы вслед за столбца 14 ("Примечания") можно определить с помощью драйвера. Приложение должно получить доступ к от драйвера, отсчет от конца результирующего набора вместо указания явной порядковый. Дополнительные сведения см. в разделе [данные, возвращаемые функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|PKTABLE_CAT (ODBC 1.0)|1|Varchar|Имя каталога таблицы первичного ключа; Значение NULL, если не применим к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, возвращается пустая строка ("») для этих таблиц, у которых нет каталогов.|  
|PKTABLE_SCHEM (ODBC 1.0)|2|Varchar|Имя схемы таблицы первичного ключа; Значение NULL, если не применим к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, возвращается пустая строка ("») для этих таблиц, у которых нет схемы.|  
|PKTABLE_NAME (ODBC 1.0)|3|Varchar not NULL|Имя таблицы первичных ключей.|  
|PKCOLUMN_NAME (ODBC 1.0)|4|Varchar not NULL|Имя столбца первичного ключа. Драйвер возвращает пустую строку для столбца, который не имеет имени.|  
|FKTABLE_CAT (ODBC 1.0)|5|Varchar|Имя каталога таблицы внешнего ключа; Значение NULL, если не применим к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, возвращается пустая строка ("») для этих таблиц, у которых нет каталогов.|  
|FKTABLE_SCHEM (ODBC 1.0)|6|Varchar|Имя схемы таблицы внешнего ключа; Значение NULL, если не применим к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других пользователей, например, когда драйвер извлекает данные из разных СУБД, возвращается пустая строка ("») для этих таблиц, у которых нет схемы.|  
|FKTABLE_NAME (ODBC 1.0)|7|Varchar not NULL|Имя таблицы внешних ключей.|  
|FKCOLUMN_NAME (ODBC 1.0)|8|Varchar not NULL|Имя внешнего ключевого столбца. Драйвер возвращает пустую строку для столбца, который не имеет имени.|  
|KEY_SEQ (ODBC 1.0)|9|Smallint, не NULL|Порядковый номер столбца в ключе (начиная с 1).|  
|UPDATE_RULE (ODBC 1.0)|10|Smallint|Действия для применения к внешнему ключу, когда операция SQL является **обновления**. Может иметь одно из следующих значений. (Ссылочная таблица является таблицей с первичным ключом; в ссылающейся таблице является таблицей с внешним ключом).<br /><br /> ЗНАЧЕНИЕ SQL_CASCADE: При обновлении первичного ключа таблицы, на которую указывает ссылка, внешний ключ из ссылающейся таблицы также обновляется.<br /><br /> ЗНАЧЕНИЕ SQL_NO_ACTION: Если обновления первичного ключа таблицы, на которую указывает ссылка вызовет «несвязанные ссылку» в ссылающейся таблице (то есть строк в ссылающейся таблице бы не имели аналогов в указанной таблице), обновление отклоняется. Если обновление внешнего ключа из ссылающейся таблицы стало бы причиной возникновения значение, которое не существует как значение первичного ключа таблицы, на которую указывает ссылка, обновление отклоняется. (Это действие является таким же, как действие SQL_RESTRICT в ODBC 2 *.x*.)<br /><br /> SQL_SET_NULL: Когда один или несколько строк в связанной таблице обновляются таким образом, что один или несколько компонентов первичного ключа изменяются, компоненты внешнего ключа в ссылающейся таблице, которые соответствуют измененные компоненты первичный ключ, присваивается значение NULL во всех совпадающие строки из ссылающейся таблицы.<br /><br /> SQL_SET_DEFAULT: Если одну или несколько строк в связанной таблице обновляются таким образом, что один или несколько компонентов первичного ключа изменяются, компоненты внешнего ключа в ссылающейся таблице, которые соответствуют измененных компонентов первичного ключа устанавливается applicab значения по умолчанию LE в все совпадающие строки из ссылающейся таблицы.<br /><br /> Значение NULL, если не применим к источнику данных.|  
|DELETE_RULE (ODBC 1.0)|11|Smallint|Действия для применения к внешнему ключу, когда операция SQL является **удалить**. Может иметь одно из следующих значений. (Ссылочная таблица является таблицей с первичным ключом; в ссылающейся таблице является таблицей с внешним ключом).<br /><br /> ЗНАЧЕНИЕ SQL_CASCADE: При удалении строки в указанной таблице, также удаляются все совпадающие строки в ссылающейся таблицы.<br /><br /> ЗНАЧЕНИЕ SQL_NO_ACTION: Если удалить строку в указанной таблице вызовет «несвязанные ссылку» в ссылающейся таблице (то есть строк в ссылающейся таблице бы не имели аналогов в указанной таблице), обновление отклоняется. (Это действие является таким же, как действие SQL_RESTRICT в ODBC 2 *.x*.)<br /><br /> SQL_SET_NULL: При удалении одну или несколько строк в связанной таблице, каждый компонент ссылающейся таблицы внешнего ключа имеет значение NULL в все совпадающие строки из ссылающейся таблицы.<br /><br /> SQL_SET_DEFAULT: При удалении одну или несколько строк в связанной таблице, каждый компонент ссылающейся таблицы внешнего ключа присваивается применяется значение по умолчанию в все совпадающие строки из ссылающейся таблицы.<br /><br /> Значение NULL, если не применим к источнику данных.|  
|FK_NAME (ODBC 2.0)|12|Varchar|Имя внешнего ключа. Значение NULL, если не применим к источнику данных.|  
|PK_NAME (ODBC 2.0)|13|Varchar|Имя первичного ключа. Значение NULL, если не применим к источнику данных.|  
|НЕПОДДЕРЖИВАЕМОЕ (ODBC 3.0)|14|Smallint|SQL_NOT_DEFERRABLE SQL_INITIALLY_DEFERRED SQL_INITIALLY_IMMEDIATE.|  
  
## <a name="code-example"></a>Пример кода  
 Как показано в следующей таблице, в этом примере используется три таблицы, с именем ORDERS, ЛИНИЙ и КЛИЕНТОВ.  
  
|ЗАКАЗЫ|СТРОКИ|КЛИЕНТЫ|  
|------------|-----------|---------------|  
|ORDERID|ORDERID|CUSTID|  
|CUSTID|СТРОКИ|NAME|  
|ДАТА_ОТКРЫТИЯ|PARTID|АДРЕС|  
|МЕНЕДЖЕРА ПО ПРОДАЖАМ|КОЛИЧЕСТВО|ТЕЛЕФОН|  
|STATUS|||  
  
 В таблице ORDERS CUSTID определяет пользователя, которому была предпринята продажи. Это внешний ключ, который ссылается на CUSTID в таблице CUSTOMERS.  
  
 В таблице СТРОК ORDERID идентифицирует заказа на продажу, с которым связан элемент строки. Это внешний ключ, который ссылается на ORDERID в таблице ORDERS.  
  
 В этом примере вызывается **SQLPrimaryKeys** получить первичный ключ таблицы ORDERS. Результирующий набор будет иметь одну строку; в следующей таблице показаны значительные столбцы.  
  
|TABLE_NAME|COLUMN_NAME|KEY_SEQ|  
|-----------------|------------------|--------------|  
|ЗАКАЗЫ|ORDERID|1|  
  
 Затем в примере вызывается **SQLForeignKeys** для получения внешних ключей в других таблицах, на которые ссылаются на первичный ключ таблицы ORDERS. Результирующий набор будет иметь одну строку; в следующей таблице показаны значительные столбцы.  
  
|PKTABLE_NAME|PKCOLUMN_NAME|FKTABLE_NAME|FKCOLUMN_NAME|KEY_SEQ|  
|-------------------|--------------------|-------------------|--------------------|--------------|  
|ЗАКАЗЫ|CUSTID|СТРОКИ|CUSTID|1|  
  
 Наконец, в примере вызывается **SQLForeignKeys** для получения внешних ключей в таблице ORDERS, ссылающихся на первичные ключи других таблиц. Результирующий набор будет иметь одну строку; в следующей таблице показаны значительные столбцы.  
  
|PKTABLE_NAME|PKCOLUMN_NAME|FKTABLE_NAME|FKCOLUMN_NAME|KEY_SEQ|  
|-------------------|--------------------|-------------------|--------------------|--------------|  
|КЛИЕНТЫ|CUSTID|ЗАКАЗЫ|CUSTID|1|  
  
```cpp  
#define TAB_LEN SQL_MAX_TABLE_NAME_LEN + 1  
#define COL_LEN SQL_MAX_COLUMN_NAME_LEN + 1  
  
LPSTR   szTable;              /* Table to display */  
  
UCHAR szPkTable[TAB_LEN];   /* Primary key table name */  
UCHAR szFkTable[TAB_LEN];   /* Foreign key table name */  
UCHAR szPkCol[COL_LEN];     /* Primary key column */  
UCHAR szFkCol[COL_LEN];     /* Foreign key column */  
  
SQLHSTMT      hstmt;  
SQLINTEGER    cbPkTable, cbPkCol, cbFkTable, cbFkCol, cbKeySeq;  
SQLSMALLINT   iKeySeq;  
SQLRETURN     retcode;  
  
// Bind the columns that describe the primary and foreign keys.  
// Ignore the table schema, name, and catalog for this example.  
  
SQLBindCol(hstmt, 3, SQL_C_CHAR, szPkTable, TAB_LEN, &cbPkTable);  
SQLBindCol(hstmt, 4, SQL_C_CHAR, szPkCol, COL_LEN, &cbPkCol);  
SQLBindCol(hstmt, 5, SQL_C_SSHORT, &iKeySeq, TAB_LEN, &cbKeySeq);  
SQLBindCol(hstmt, 7, SQL_C_CHAR, szFkTable, TAB_LEN, &cbFkTable);  
SQLBindCol(hstmt, 8, SQL_C_CHAR, szFkCol, COL_LEN, &cbFkCol);  
  
strcpy_s(szTable, sizeof(szTable), "ORDERS");  
  
/* Get the names of the columns in the primary key. */  
  
retcode = SQLPrimaryKeys(hstmt,  
         NULL, 0,             /* Catalog name */  
         NULL, 0,             /* Schema name */  
         szTable, SQL_NTS);   /* Table name */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL SUCCESS_WITH_INFO)) {  
  
   /* Fetch and display the result set. This will be a list of the */  
   /* columns in the primary key of the ORDERS table. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "Table: %s Column: %s Key Seq: %hd \n", szPkTable, szPkCol,  
      iKeySeq);  
}  
  
/* Close the cursor (the hstmt is still allocated). */  
  
SQLFreeStmt(hstmt, SQL_CLOSE);  
  
/* Get all the foreign keys that refer to ORDERS primary key.*/   
  
retcode = SQLForeignKeys(hstmt,  
         NULL, 0,            /* Primary catalog */  
         NULL, 0,            /* Primary schema */  
         szTable, SQL_NTS,   /* Primary table */  
         NULL, 0,            /* Foreign catalog */  
         NULL, 0,            /* Foreign schema */  
         NULL, 0);           /* Foreign table */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL_SUCCESS_WITH_INFO)) {  
  
/* Fetch and display the result set. This will be all of the */  
/* foreign keys in other tables that refer to the ORDERS */  
/* primary key. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "%-s ( %-s ) <-- %-s ( %-s )\n", szPkTable,  
               szPkCol, szFkTable, szFkCol);  
}  
  
/* Close the cursor (the hstmt is still allocated). */  
  
SQLFreeStmt(hstmt, SQL_CLOSE);  
  
/* Get all the foreign keys in the ORDERS table. */  
  
retcode = SQLForeignKeys(hstmt,  
         NULL, 0,             /* Primary catalog */  
         NULL, 0,             /* Primary schema */  
         NULL, 0,             /* Primary table */  
         NULL, 0,             /* Foreign catalog */  
         NULL, 0,             /* Foreign schema */  
         szTable, SQL_NTS);   /* Foreign table */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL_SUCCESS_WITH_INFO)) {  
  
/* Fetch and display the result set. This will be all of the */  
/* primary keys in other tables that are referred to by foreign */  
/* keys in the ORDERS table. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "%-s ( %-s )--> %-s ( %-s )\n", szFkTable, szFkCol, szPkTable, szPkCol);  
}  
  
/* Free the hstmt. */  
SQLFreeStmt(hstmt, SQL_DROP);  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выборка одной строки или блока данных в направлении только вперед|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возврат столбцов первичного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
|Возврат статистики таблиц и индексов|[Функция SQLStatistics](../../../odbc/reference/syntax/sqlstatistics-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
