---
title: Функция S'LForeignKeys (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLForeignKeys
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLForeignKeys
helpviewer_keywords:
- SQLForeignKeys function [ODBC]
ms.assetid: 07f3f645-f643-4d39-9a10-70a72f24e608
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 5f2769fb378a5ee989fb6a0351537edb3de03469
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285864"
---
# <a name="sqlforeignkeys-function"></a>Функция SQLForeignKeys
**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 1.0: ODBC  
  
 **Сводка**  
 **СЗЛForeignKeys** может вернуться:  
  
-   Список иностранных ключей в указанной таблице (столбцы в указанной таблице, которые относятся к первичным ключам в других таблицах).  
  
-   Список иностранных ключей в других таблицах, которые относятся к основному ключу в указанной таблице.  
  
 Водитель возвращает каждый список в результате, установленном на указанном заявлении.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLForeignKeys(  
     SQLHSTMT       StatementHandle,  
     SQLCHAR *      PKCatalogName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      PKSchemaName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      PKTableName,  
     SQLSMALLINT    NameLength3,  
     SQLCHAR *      FKCatalogName,  
     SQLSMALLINT    NameLength4,  
     SQLCHAR *      FKSchemaName,  
     SQLSMALLINT    NameLength5,  
     SQLCHAR *      FKTableName,  
     SQLSMALLINT    NameLength6);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *PKCatalogName*  
 (Вход) Имя основного ключевого каталога таблицы. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют каталогов. *PKCatalogName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *PKCatalogName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *PKCatalogName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение. Для получения дополнительной информации смотрите [аргументы в каталоге функции](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 (Вход) Длина*PKCatalogName*, в символах.  
  
 *PKSchemaName*  
 (Вход) Имя основной ключевой таблицы схемы. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют схем. *PKSchemaName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *PKSchemaName* рассматривается как идентификатор и его случай не является значительным. Если это SQL_FALSE, *PKSchemaName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength2*  
 (Вход) Длина*PKSchemaName*, в символах.  
  
 *PKTableName*  
 (Вход) Имя основного ключевого стола. *PKTableName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *PKTableName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *PKTableName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength3*  
 (Вход) Длина*PKTableName*, в символах.  
  
 *FKCatalogName*  
 (Вход) Название каталога иностранных ключевых таблиц. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют каталогов. *FKCatalogName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *FKCatalogName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *FKCatalogName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength4*  
 (Вход) Длина*FKCatalogName*, в символах.  
  
 *FKSchemaName*  
 (Вход) Название схемы ключевой таблицы иностранных стран. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, пустая строка (") означает те таблицы, которые не имеют схем. *FKSchemaName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *FKSchemaName* рассматривается как идентификатор и его случай не является значительным. Если это SQL_FALSE, *FKSchemaName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength5*  
 (Вход) Длина*FKSchemaName*, в символах.  
  
 *FKTableName*  
 (Вход) Иностранное название ключевого стола. *FKTableName* не может содержать шаблон поиска строк.  
  
 Если атрибут SQL_ATTR_METADATA_ID оператора установлен на SQL_TRUE, *FKTableName* рассматривается как идентификатор, и его случай не является значительным. Если это SQL_FALSE, *FKTableName* является обычным аргументом; к нему относятся буквально, и его случай имеет важное значение.  
  
 *NameLength6*  
 (Вход) Длина*FKTableName*, в символах.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **sLForeignKeys** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанная с этим стоимость S'LSTATE может быть получена, позвонив по **телефону s'LGetDiagRec** с *помощью SQL_HANDLE_STMT* и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LForeignKeys,** и разъясняется каждая из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|Курсор был открыт на *statementHandle*, и **S'LFetch** или **S'LFetchScroll** был вызван. Эта ошибка возвращается менеджером-драйвером, если **S'LFetch** или **S'LFetchScroll** не вернулись SQL_NO_DATA, и возвращается драйвером, если **S'LFetch** или **S'LFetchScroll** вернулся SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle,* но **S'LFetch** или **S'LFetchScroll** не были вызваны.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*, а затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY009|Недействительное использование нулевой указатель|(DM) Аргументы *PKTableName* и *FKTableName* были нулевыми указателями.<br /><br /> Атрибут SQL_ATTR_METADATA_ID оператора был установлен для SQL_TRUE, аргумент *FKCatalogName* или *PKCatalogName* был недействительным указателем, а SQL_CATALOG_NAME *InfoType* возвращает, что имена каталога поддерживаются.<br /><br /> (DM) атрибут SQL_ATTR_METADATA_ID оператора был установлен в SQL_TRUE, и *FKSchemaName*, *PKSchemaName*, *FKTableName*, или *PKTableName* аргумент был нулевым указателем.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему выполнялась, когда была вызвана функция S'LForeignKeys.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение одного из аргументов длины имени было меньше 0, но не равно SQL_NTS.|  
|||Значение одного из аргументов длины имени превысило значение максимальной длины соответствующего имени. (См. "Комментарии.")|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Было указано имя каталога, а драйвер или источник данных не поддерживает каталоги.<br /><br /> Было указано имя схемы, а драйвер или источник данных не поддерживает схемы.|  
|||Комбинация текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE оператора не была поддержана драйвером или источником данных.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Для получения [информации](../../../odbc/reference/develop-app/uses-of-catalog-data.md)о том, как может использоваться информация, возвращенная этой функцией, см.  
  
 Если \* *PKTableName* содержит имя таблицы, **S'LForeignKeys** возвращает набор результатов, содержащий основной ключ указанной таблицы и все иностранные ключи, которые относятся к ней. Список иностранных ключей в других таблицах не включает иностранные ключи, указывать на уникальные ограничения в указанной таблице.  
  
 Если \* *FKTableName* содержит имя таблицы, **S'LForeignKeys** возвращает набор результатов, содержащий все инородные клавиши в указанной таблице, которые указывают на первичные ключи в других таблицах, и основные ключи в других таблицах, к которым они ссылаются. Список иностранных ключей в указанной таблице не содержит иностранных ключей, которые относятся к уникальным ограничениям в других таблицах.  
  
 Если \*и *PKTableName,* и \* *FKTableName* содержат названия таблиц, **S'LForeignKeys** возвращает иностранные ключи в таблице, указанной в \* *FKTableName,* которые относятся к основному ключу таблицы, указанной в*PKTableName*. Это должно быть одним из ключевых в лучшем случае.  
  
> [!NOTE]  
>  Для получения дополнительной информации об общем использовании, аргументах и возвращенных данных функций каталога ODBC [см.](../../../odbc/reference/develop-app/catalog-functions.md)  
  
 **SLForeignKeys** возвращает результаты в качестве стандартного набора результатов. Если запрашиваются иностранные ключи, связанные с основным ключом, набор результатов заказывается FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME и KEY_SEQ. Если запрашиваются основные ключи, связанные с иностранным ключом, набор результатов заказываются PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME и KEY_SEQ. В следующей таблице перечислены столбцы в наборе результатов.  
  
 Длина столбцов VARCHAR не отображается в таблице; фактическая длина зависит от источника данных. Для определения фактической длины PKTABLE_CAT или FKTABLE_CAT, PKTABLE_SCHEM или FKTABLE_SCHEM, PKTABLE_NAME или FKTABLE_NAME, а также PKCOLUMN_NAME или FKCOLUMN_NAME столбцов приложение может позвонить в **s-LGetInfo** с SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN, SQL_MAX_TABLE_NAME_LEN и SQL_MAX_COLUMN_NAME_LEN опций.  
  
 Следующие столбцы были переименованы в ODBC 3 *.x.* Изменения имени столбца не влияют на обратную совместимость, поскольку приложения связываются с номером столбца.  
  
|Колонка ODBC 2.0|Колонка ODBC 3 *.x*|  
|---------------------|-----------------------|  
|PKTABLE_QUALIFIER|PKTABLE_CAT|  
|PKTABLE_OWNER|PKTABLE_SCHEM|  
|FKTABLE_QUALIFIER|FK_TABLE_CAT|  
|FKTABLE_OWNER|FKTABLE_SCHEM|  
  
 В следующей таблице перечислены столбцы в наборе результатов. Дополнительные столбцы за столбец 14 (REMARKS) могут быть определены драйвером. Приложение должно получить доступ к столбику, в зависимости от драйвера, отсчитывая от конца набора результатов вместо указания явного ординаторского положения. Для получения дополнительной информации смотрите [данные, возвращенные функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|PKTABLE_CAT (ODBC 1.0)|1|Varchar|Название каталога основных ключевых таблиц; NULL, если не применим к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют каталогов.|  
|PKTABLE_SCHEM (ODBC 1.0)|2|Varchar|Имя основной ключевой таблицы схемы; NULL, если не применим к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют схем.|  
|PKTABLE_NAME (ODBC 1.0)|3|Варчар не NULL|Имя основного ключевого стола.|  
|PKCOLUMN_NAME (ODBC 1.0)|4|Варчар не NULL|Имя основного ключевого столбца. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|FKTABLE_CAT (ODBC 1.0)|5|Varchar|Название каталога иностранных ключевых таблиц; NULL, если не применим к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют каталогов.|  
|FKTABLE_SCHEM (ODBC 1.0)|6|Varchar|Название схемы ключевой таблицы иностранных стран; NULL, если не применим к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер получает данные из различных DBMS, он возвращает пустую строку ("") для тех таблиц, которые не имеют схем.|  
|FKTABLE_NAME (ODBC 1.0)|7|Варчар не NULL|Иностранное название ключевого стола.|  
|FKCOLUMN_NAME (ODBC 1.0)|8|Варчар не NULL|Название иностранной колонки ключа. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|KEY_SEQ (ODBC 1.0)|9|Smallint, не NULL|Номер последовательности столбцов в ключе (начиная с 1).|  
|UPDATE_RULE (ODBC 1.0)|10|Smallint|Действия, которые будут применены к иностранному ключу, когда операция S'L **является ОБНОВЛЕНИЕ**. Может иметь одно из следующих значений. (Справочная таблица — это таблица, имеющей основной ключ; таблица ссылок — это таблица с иностранным ключом.)<br /><br /> SQL_CASCADE: При обновлении основного ключа справочной таблицы также обновляется иностранный ключ таблицы ссылок.<br /><br /> SQL_NO_ACTION: Если обновление основного ключа упомянутой таблицы вызовет "висячие ссылки" в таблице ссылок (т.е. строки в таблице ссылок не будут иметь аналогов в упомянутой таблице), обновление отклоняется. Если обновление иностранного ключа таблицы ссылок приведет к значению, которое не существует как значение основного ключа упомянутой таблицы, обновление отклоняется. (Это действие такое же, как SQL_RESTRICT действие в ODBC 2 *.x*.)<br /><br /> SQL_SET_NULL: При обновлении одной или нескольких строк в таблице ссылок таким образом, что один или несколько компонентов основного ключа изменяются, компоненты иностранного ключа в таблице ссылок, которые соответствуют измененным компонентам основного ключа, устанавливаются в NULL во всех соответствующих рядах таблицы ссылок.<br /><br /> SQL_SET_DEFAULT: При обновлении одной или нескольких строк в таблице ссылок таким образом, что один или несколько компонентов основного ключа изменяются, компоненты иностранного ключа в таблице ссылок, которые соответствуют измененным компонентам основного ключа, устанавливаются к применимым значениям по умолчанию во всех соответствующих строках таблицы ссылок.<br /><br /> NULL, если не применим к источнику данных.|  
|DELETE_RULE (ODBC 1.0)|11|Smallint|Действия, которые будут применены к иностранному ключу, когда операция S'L является **DELETE.** Может иметь одно из следующих значений. (Справочная таблица — это таблица, имеющей основной ключ; таблица ссылок — это таблица с иностранным ключом.)<br /><br /> SQL_CASCADE: При удалении строки в таблице ссылок все соответствующие строки в таблицах ссылок также удаляются.<br /><br /> SQL_NO_ACTION: Если удаление строки в упомянутой таблице вызовет "висячий отсылку" в таблице ссылок (т.е. строки в таблице ссылок не будут иметь аналогов в упомянутой таблице), обновление отклоняется. (Это действие такое же, как SQL_RESTRICT действие в ODBC 2 *.x*.)<br /><br /> SQL_SET_NULL: При удалении одного или нескольких строк в таблице ссылок каждый компонент иностранного ключа таблицы ссылок устанавливается в NULL во всех соответствующих строках таблицы ссылок.<br /><br /> SQL_SET_DEFAULT: При удалении одного или нескольких строк в таблице ссылок каждый компонент иностранного ключа таблицы ссылок устанавливается на применимый по умолчанию во всех соответствующих строках таблицы ссылок.<br /><br /> NULL, если не применим к источнику данных.|  
|FK_NAME (ODBC 2.0)|12|Varchar|Иностранное ключевое имя. NULL, если не применим к источнику данных.|  
|PK_NAME (ODBC 2.0)|13|Varchar|Первичное ключевое имя. NULL, если не применим к источнику данных.|  
|ОТСРОЧКА (ODBC 3.0)|14|Smallint|SQL_INITIALLY_DEFERRED, SQL_INITIALLY_IMMEDIATE, SQL_NOT_DEFERRABLE.|  
  
## <a name="code-example"></a>Пример кода  
 Как показано в следующей таблице, в этом примере используются три таблицы, названные ORDERS, LINES и CUSTOMERS.  
  
|ЗАКАЗЫ|Линии|Клиентов|  
|------------|-----------|---------------|  
|Orderid|Orderid|CUSTID|  
|CUSTID|Линии|NAME|  
|OPENDATE|ПАРТИД|Адрес|  
|Продавца|Количество|ТЕЛЕФОН|  
|Состояние|||  
  
 В таблице ORDERS CUSTID идентифицирует клиента, которому была произведена продажа. Это иностранный ключ, который относится к CUSTID в таблице CUSTOMERS.  
  
 В таблице LINES ORDERID определяет порядок продаж, с которым связан элемент строки. Это иностранный ключ, который относится к ORDERID в таблице ORDERS.  
  
 Этот пример называется **S'LPrimaryKeys,** чтобы получить основной ключ таблицы ORDERS. Набор результатов будет иметь один ряд; значительные столбцы отображаются в следующей таблице.  
  
|TABLE_NAME|COLUMN_NAME|KEY_SEQ|  
|-----------------|------------------|--------------|  
|ЗАКАЗЫ|Orderid|1|  
  
 Далее в примере приводится **s'LForeignKeys,** чтобы получить иностранные ключи в других таблицах, которые ссылаются на основной ключ таблицы ORDERS. Набор результатов будет иметь один ряд; значительные столбцы отображаются в следующей таблице.  
  
|PKTABLE_NAME|PKCOLUMN_NAME|FKTABLE_NAME|FKCOLUMN_NAME|KEY_SEQ|  
|-------------------|--------------------|-------------------|--------------------|--------------|  
|ЗАКАЗЫ|CUSTID|Линии|CUSTID|1|  
  
 Наконец, в примере приводится **s'LForeignKeys,** чтобы получить иностранные ключи в таблице ORDERS, которые относятся к основным клавишам других таблиц. Набор результатов будет иметь один ряд; значительные столбцы отображаются в следующей таблице.  
  
|PKTABLE_NAME|PKCOLUMN_NAME|FKTABLE_NAME|FKCOLUMN_NAME|KEY_SEQ|  
|-------------------|--------------------|-------------------|--------------------|--------------|  
|Клиентов|CUSTID|ЗАКАЗЫ|CUSTID|1|  
  
```cpp  
#define TAB_LEN SQL_MAX_TABLE_NAME_LEN + 1  
#define COL_LEN SQL_MAX_COLUMN_NAME_LEN + 1  
  
LPSTR   szTable;              /* Table to display */  
  
UCHAR szPkTable[TAB_LEN];   /* Primary key table name */  
UCHAR szFkTable[TAB_LEN];   /* Foreign key table name */  
UCHAR szPkCol[COL_LEN];     /* Primary key column */  
UCHAR szFkCol[COL_LEN];     /* Foreign key column */  
  
SQLHSTMT      hstmt;  
SQLINTEGER    cbPkTable, cbPkCol, cbFkTable, cbFkCol, cbKeySeq;  
SQLSMALLINT   iKeySeq;  
SQLRETURN     retcode;  
  
// Bind the columns that describe the primary and foreign keys.  
// Ignore the table schema, name, and catalog for this example.  
  
SQLBindCol(hstmt, 3, SQL_C_CHAR, szPkTable, TAB_LEN, &cbPkTable);  
SQLBindCol(hstmt, 4, SQL_C_CHAR, szPkCol, COL_LEN, &cbPkCol);  
SQLBindCol(hstmt, 5, SQL_C_SSHORT, &iKeySeq, TAB_LEN, &cbKeySeq);  
SQLBindCol(hstmt, 7, SQL_C_CHAR, szFkTable, TAB_LEN, &cbFkTable);  
SQLBindCol(hstmt, 8, SQL_C_CHAR, szFkCol, COL_LEN, &cbFkCol);  
  
strcpy_s(szTable, sizeof(szTable), "ORDERS");  
  
/* Get the names of the columns in the primary key. */  
  
retcode = SQLPrimaryKeys(hstmt,  
         NULL, 0,             /* Catalog name */  
         NULL, 0,             /* Schema name */  
         szTable, SQL_NTS);   /* Table name */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL SUCCESS_WITH_INFO)) {  
  
   /* Fetch and display the result set. This will be a list of the */  
   /* columns in the primary key of the ORDERS table. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "Table: %s Column: %s Key Seq: %hd \n", szPkTable, szPkCol,  
      iKeySeq);  
}  
  
/* Close the cursor (the hstmt is still allocated). */  
  
SQLFreeStmt(hstmt, SQL_CLOSE);  
  
/* Get all the foreign keys that refer to ORDERS primary key.*/   
  
retcode = SQLForeignKeys(hstmt,  
         NULL, 0,            /* Primary catalog */  
         NULL, 0,            /* Primary schema */  
         szTable, SQL_NTS,   /* Primary table */  
         NULL, 0,            /* Foreign catalog */  
         NULL, 0,            /* Foreign schema */  
         NULL, 0);           /* Foreign table */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL_SUCCESS_WITH_INFO)) {  
  
/* Fetch and display the result set. This will be all of the */  
/* foreign keys in other tables that refer to the ORDERS */  
/* primary key. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "%-s ( %-s ) <-- %-s ( %-s )\n", szPkTable,  
               szPkCol, szFkTable, szFkCol);  
}  
  
/* Close the cursor (the hstmt is still allocated). */  
  
SQLFreeStmt(hstmt, SQL_CLOSE);  
  
/* Get all the foreign keys in the ORDERS table. */  
  
retcode = SQLForeignKeys(hstmt,  
         NULL, 0,             /* Primary catalog */  
         NULL, 0,             /* Primary schema */  
         NULL, 0,             /* Primary table */  
         NULL, 0,             /* Foreign catalog */  
         NULL, 0,             /* Foreign schema */  
         szTable, SQL_NTS);   /* Foreign table */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL_SUCCESS_WITH_INFO)) {  
  
/* Fetch and display the result set. This will be all of the */  
/* primary keys in other tables that are referred to by foreign */  
/* keys in the ORDERS table. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "%-s ( %-s )--> %-s ( %-s )\n", szFkTable, szFkCol, szPkTable, szPkCol);  
}  
  
/* Free the hstmt. */  
SQLFreeStmt(hstmt, SQL_DROP);  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Получение одной строки или блока данных в направлении только вперед|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращение столбцов основного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
|Статистика и индексы возвращающихся таблиц|[Функция SQLStatistics](../../../odbc/reference/syntax/sqlstatistics-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
