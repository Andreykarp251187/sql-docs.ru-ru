---
title: Функция S'LSetPos (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetPos
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLSetPos
helpviewer_keywords:
- SQLSetPos function [ODBC]
ms.assetid: 80190ee7-ae3b-45e5-92a9-693eb558f322
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 7a8839f1ae540ac9e5f29e144f7f57fb754e50ff
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287334"
---
# <a name="sqlsetpos-function"></a>Функция SQLSetPos
**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 1.0: ODBC  
  
 **Сводка**  
 **SLSetPos** устанавливает положение курсора в строке и позволяет приложению обновлять данные в строке или обновлять или удалять данные в наборе результатов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetPos(  
      SQLHSTMT        StatementHandle,  
      SQLSETPOSIROW   RowNumber,  
      SQLUSMALLINT    Operation,  
      SQLUSMALLINT    LockType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *РоуНомер*  
 (Вход) Положение строки в строке, на которой выполняется операция, указанное аргументом *Операции.* Если *rowNumber* равен 0, операция применяется к каждой строке в строке.  
  
 Для получения дополнительной информации см.  
  
 *Операции*  
 (Вход) Операция по выполнению:  
  
 SQL_POSITION SQL_REFRESH SQL_UPDATE SQL_DELETE  
  
> [!NOTE]
>  Значение SQL_ADD для *аргумента операции* было униточено для ODBC *3.x*. Драйверы ODBC *3.x* должны будут поддерживать SQL_ADD для обратной совместимости. Эта функциональность была заменена вызовом на **s'LBulkOperations** с *операцией* SQL_ADD. Когда приложение ODBC *3.x* работает с драйвером ODBC *2.x,* менеджер драйвера драйвера драйвера драйвера драйвера водителя отображает вызов в **S'LBulkOperations** с *помощью операции* SQL_ADD **с** *операцией* SQL_ADD.  
  
 Для получения дополнительной информации см.  
  
 *LockType*  
 (Вход) Определяет, как заблокировать строку после выполнения операции, указанной в аргументе *операции.*  
  
 SQL_LOCK_NO_CHANGE SQL_LOCK_EXCLUSIVE SQL_LOCK_UNLOCK  
  
 Для получения дополнительной информации см.  
  
 **Возвращает**  
  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LSetPos** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив в **S'LGetDiagRec** с *помощью handleType* SQL_HANDLE_STMT и *ручки* *обработки.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LSetPos,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
 Для всех тех S'LSTATEs, которые могут вернуться SQL_SUCCESS_WITH_INFO или SQL_ERROR (кроме 01xxx S'LSTATEs), SQL_SUCCESS_WITH_INFO возвращается, если ошибка происходит на одном или нескольких, но не все строки многорычного операции, и SQL_ERROR возвращается, если ошибка происходит на однострокоперации.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01001|Конфликт операции Cursor|Аргумент *операции* был SQL_DELETE или SQL_UPDATE, и не были удалены или обновлены строки или более одной строки. (Для получения дополнительной информации об обновлениях в нескольких строках *SQL_ATTR_SIMULATE_CURSOR* см. **SQLSetStmtAttr** (Функция возвращает SQL_SUCCESS_WITH_INFO.)<br /><br /> Аргумент *операции* был SQL_DELETE или SQL_UPDATE, и операция провалилась из-за оптимистичной параллелизма. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Усечение правой строки данных|Аргумент *операции* был SQL_REFRESH, и строка или двоичные данные, возвращенные для столбца или столбцов с типом данных SQL_C_CHAR или SQL_C_BINARY привели к усечению непустого символа или не-NULL двоичных данных.|  
|01S01|Ошибка в строке|Аргумент *RowNumber* был 0, и ошибка произошла в одном или нескольких строках при выполнении операции, указанной в аргументе *операции.*<br /><br /> (SQL_SUCCESS_WITH_INFO возвращается, если ошибка происходит на одном или нескольких, но не на всех строках многорычанной операции, и SQL_ERROR возвращается, если ошибка происходит на однострокоперации.)<br /><br /> (Этот S'LSTATE возвращается только тогда, когда **S'LSetPos** называется после **S'LExtendedFetch**, если драйвер драйвера ODBC *2.x* и библиотека курсора не используется.)|  
|01S07|Фракционная усечение|Аргумент *операции* был SQL_REFRESH, тип данных буфера приложения не был SQL_C_CHAR или SQL_C_BINARY, и данные, возвращенные в буферы приложений для одного или нескольких столбцов, были усечены. Для численных типов данных дробная часть числа была усечена. Для типов времени, меток времени и интервалов данных, содержащих временной компонент, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|Значение данных столбца в наборе результатов не может быть преобразовано в тип данных, указанный *TargetType* в вызове в **S'LBindCol.**|  
|07009|Недействительный индекс дескриптора|Аргумент *Операция* была SQL_REFRESH или SQL_UPDATE, и столбец был связан с числом столбцов, превышающее количество столбцов в наборе результатов.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|Аргумент *Операция* была SQL_UPDATE, и никакие столбцы не были updatable потому что все столбцы были или unbound, прочитано-только, или значение в связанном буфере длины/индикатора было SQL_COLUMN_IGNORE.|  
|22001|Строковые данные, правильное усечение|Аргумент *операции* был SQL_UPDATE, и назначение символа или двоичного значения в столбец привело к усечению непустых (для символов) или не-нулевых (для двоичных) символов или байтов.|  
|22003|Числовое значение вне диапазона|Аргумент *Операция* была SQL_UPDATE, и назначение численного значения столбцу в наборе результатов привело к тому, что вся (в отличие от дробной) часть числа была усечена.<br /><br /> Аргумент *Операции* был SQL_REFRESH, и возвращение численного значения для одного или нескольких связанных столбцов привело бы к потере значительных цифр.|  
|22007|Недействительный формат дата-времени|Аргумент *«Операция»* была SQL_UPDATE, и назначение значения даты или метки времени в столбец в наборе результатов привело к тому, что поле года, месяца или дня было вне диапазона.<br /><br /> Аргумент *Операции* был SQL_REFRESH, и возвращение значения даты или метки времени для одного или нескольких связанных столбцов привело бы к тому, что поле года, месяца или дня было бы вне диапазона.|  
|22008|Переполниние поля даты/времени|Аргумент *операции* был SQL_UPDATE, и выполнение арифметики дат на данных, отправляемых в столбец в наборе результатов, привело к тому, что поле времени даты (год, месяц, день, час, минута или второе поле) результата находится за пределами допустимого диапазона значений для поля или является недействительным на основе естественных правил григорианского календаря для датвремени.<br /><br /> Аргумент *операции* был SQL_REFRESH, и выполнение арифметики дат на данных, извлекаемых из набора результатов, привело к тому, что поле времени даты (год, месяц, день, час, минута или второе поле) результата находится за пределами допустимого диапазона значений для поля или является недействительным на основе естественных правил григорианского календаря для датвремени.|  
|22015|Переполниние поля интервала|Аргумент *операции* был SQL_UPDATE, и назначение точного типа числа или интервала C к интервалу типа данных S'L вызвало потерю значительных цифр.<br /><br /> Аргументом *операции* было SQL_UPDATE; при назначении к типу интервала S'L не было представления значения типа C в типе интервала S'L.<br /><br /> Аргумент *операции* был SQL_REFRESH, и назначение от точного числа или интервала типа S'L к типу интервала C вызвало потерю значительных цифр в ведущем поле.<br /><br /> Аргументом *операции* было SQL_ РЕФСО; при назначении типа интервала C в типе интервала C не было представлено значение типа S'L.|  
|22018|Недействительное значение символов для спецификации литья|Аргументом *операции* было SQL_REFRESH; тип C был точным или приблизительным числом, временем даты или типом данных интервала; тип столбца s'L был типом данных символов; и значение в колонке не было действительным буквальным типа C.<br /><br /> Аргумент *операция* была SQL_UPDATE; тип S'L был точным или приблизительным числом, временем даты или типом данных интервала; тип C был SQL_C_CHAR; и значение в колонке не было действительным буквальным из связанного типа S'L.|  
|23000|Нарушение ограничения целостности|Аргумент *Операция* была SQL_DELETE или SQL_UPDATE, и целостность ограничения было нарушено.|  
|24 000|Недопустимое состояние курсора|*StatementHandle* находился в выполненном состоянии, но ни один набор результатов не был связан с *statementHandle.*<br /><br /> (DM) Курсор был открыт на *StatementHandle*, но **S'LFetch** или **S'LFetchScroll** не был вызван.<br /><br /> Курсор был открыт на *StatementHandle,* и был вызван **S'LFetch** или **S'LFetchScroll,** но курсор был расположен до начала набора результатов или после окончания набора результатов.<br /><br /> Аргумент *Операция* была SQL_DELETE, SQL_REFRESH или SQL_UPDATE, и курсор был расположен до начала набора результатов или после окончания набора результатов.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|42000|Ошибка синтаксиса или нарушение доступа|Водитель не смог заблокировать строку по мере необходимости для выполнения операции, запрошенной в *аргументной операции.*<br /><br /> Водитель не смог заблокировать строку, как просили в аргументе *LockType*.|  
|44000|Нарушение параметра WITH CHECK OPTION|Аргумент *операции* был SQL_UPDATE, и обновление было выполнено на просматриваемой таблице или таблице, полученной из просматриваемой таблицы, которая была создана путем указания **С CHECK OPTION,** таким образом, что одна или несколько строк, затронутых обновлением, больше не будут присутствовать в просмотренной таблице.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*, а затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция S'LSetPos.<br /><br /> (DM) Указанное *statementHandle* не находилось в выполненном состоянии. Функция была вызвана без предварительного вызова **S'LExecDirect**, **S'LExecute**, или функции каталога.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) Драйвер был драйвером ODBC *2.x,* и **S'LSetPos** был вызван для *выписки* после вызова **S'LFetch.**|  
|HY011|Атрибут не может быть установлен сейчас|(DM) Водитель был водителем ODBC *2.x;* атрибут SQL_ATTR_ROW_STATUS_PTR оператора был установлен; Затем был вызван **S'LSetPos** до того, как был назван **S'LFetch,** **S'LFetchScroll**, или **S'LExtendedFetch.**|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|Аргумент *операции* был SQL_UPDATE, значение данных было нулевая указатель, и значение длины столбца не было 0, SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NULL_DATA, или меньше, чем или равна SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Аргументом *операции* было SQL_UPDATE; значение данных не является нулевой указкой; тип данных C был SQL_C_BINARY или SQL_C_CHAR; значение длины столбца было меньше 0, но не равно SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NTS или SQL_NULL_DATA или менее или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение в буфере длины/индикатора составляло SQL_DATA_AT_EXEC; тип СЗЛ был либо SQL_LONGVARCHAR, SQL_LONGVARBINARY, либо длинным типом данных, специфичным для конкретных источников данных; а SQL_NEED_LONG_DATA_LEN информационный тип в **"СЗЛГетИнфо"** был "Y".|  
|HY092|Недействительный идентификатор атрибута|(DM) Значение, указанное для аргумента *операции,* было недействительным.<br /><br /> (DM) Значение, указанное для аргумента *LockType,* было недействительным.<br /><br /> Аргумент *операции* был SQL_UPDATE или SQL_DELETE, а атрибут SQL_ATTR_CONCURRENCY оператора был SQL_ATTR_CONCUR_READ_ONLY.|  
|HY107|Значение строки вне диапазона|Значение, указанное для аргумента *RowNumber,* было больше, чем количество строк в строке.|  
|HY109|Положение недействительного курсора|Курсор, связанный с *StatementHandle,* был определен как только вперед, поэтому курсор не может быть расположен в строке. Ознакомьтесь с описанием атрибута SQL_ATTR_CURSOR_TYPE в **s'LSetStmtAttr.**<br /><br /> *Аргументоперации* был SQL_UPDATE, SQL_DELETE или SQL_REFRESH, а строка, идентифицированная аргументом *RowNumber,* была удалена или не была извлечена.<br /><br /> (DM) Аргумент *RowNumber* был 0, и *аргумент операции* был SQL_POSITION.<br /><br /> **СЗЛСетПоС** был вызван после того, как был вызван **S'LBulkOperations,** и до того, как был назван **S'LFetchScroll** или **S'LFetch.**|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает операцию, запрошенную в аргументе *операции* или аргументе *LockType.*|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr** с *атрибутом* SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
  
> [!CAUTION]
>  Для получения информации о заявлении говорится, что **S'LSetPos** может быть вызван и что он должен сделать для совместимости с приложениями ODBC *2.x,* см. [Блок Курсоры, Scrollable Cursors, и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md).  
  
## <a name="rownumber-argument"></a>Аргумент RowNumber  
 Аргумент *RowNumber* определяет число строки в строке, на которой выполняется операция, указанная аргументом *операции.* Если *rowNumber* равен 0, операция применяется к каждой строке в строке. *RowNumber* должен быть значением от 0 до количества строк в строке.  
  
> [!NOTE]  
>  На языке C массивы основаны на 0, а аргумент *RowNumber* — на 1.основе. Например, для обновления пятой строки строки приложение изменяет буферы строки в индексе массива 4, но определяет *RowNumber* 5.  
  
 Все операции позиционирует курсор на строке, указанной *RowNumber.* Следующие операции требуют позиции курсора:  
  
-   Позиционируется обновление и удаление выписок.  
  
-   Вызовы на **S'LGetData**.  
  
-   Вызовы в **S'LSetPos** с SQL_DELETE, SQL_REFRESH и SQL_UPDATE опций.  
  
 Например, если *RowNumber* — это 2 для вызова в **S'LSetPos** с *операцией* SQL_DELETE, курсор расположен на втором ряду строки, и эта строка удаляется. Запись в массиве состояния строки реализации (указывается на атрибут SQL_ATTR_ROW_STATUS_PTR оператора) для второго ряда изменяется на SQL_ROW_DELETED.  
  
 Приложение может указать положение курсора, когда оно вызывает **S'LSetPos.** Как правило, он вызывает **S'LSetPos** с SQL_POSITION или SQL_REFRESH операцию, чтобы позиционировать курсор перед выполнением позиционированного обновления или удаления оператора или вызова **S'LGetData.**  
  
## <a name="operation-argument"></a>Операция Аргумент  
 Аргумент *операции* поддерживает следующие операции. Чтобы определить, какие параметры поддерживаются источником данных, приложение вызывает **S'LGetInfo** с SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 типинформации (в зависимости от типа курсора).  
  
|*Операции*<br /><br /> — аргумент|Операция|  
|------------------------------|---------------|  
|SQL_POSITION|Водитель позиционирует курсор на строке, указанной *RowNumber.*<br /><br /> Содержимое массива состояния строки, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR оператора, игнорируется для *операции*SQL_POSITION.|  
|SQL_REFRESH|Водитель размещает курсор на строке, указанной *RowNumber,* и обновляет данные в буферах рядов для этой строки. Для получения дополнительной информации о том, как драйвер возвращает данные в буферах рядов, см. **SQLBindCol**<br /><br /> **СЗЛСетПоС** с *операцией* SQL_REFRESH обновляет статус и содержимое строк в текущем извлеченном наборе строк. Это включает в себя обновление закладок. Поскольку данные в буферах обновляются, но не переизвлечены, членство в наборе строк фиксируется. Это отличается от обновления, выполняемого вызовом на **S'LFetchScroll** с *fetchOrientation* SQL_FETCH_RELATIVE и *RowNumber,* равным 0, который refetches rowset из набора результатов, так что он может показать добавленные данные и удалить удаленные данные, если эти операции поддерживаются драйвером и курсором.<br /><br /> Успешное обновление с **помощью S'LSetPos** не изменит статус строки SQL_ROW_DELETED. Удаленные строки в строке будут по-прежнему помечаться как удаленные до следующего получения. Строки исчезнут при следующем извлечении, если курсор поддерживает упаковку (в которой последующий **S'LFetch** или **S'LFetchScroll** не возвращает удаленные строки).<br /><br /> Добавленные строки не отображаются при выполнении обновления с **помощью S'LSetPos.** Это поведение отличается от **S'LFetchScroll** с *FetchType* SQL_FETCH_RELATIVE и *RowNumber,* равным 0, который также обновляет текущий набор строк, но покажет добавленные записи или упаковать удаленные записи, если эти операции поддерживаются курсором.<br /><br /> Успешное обновление с **помощью S'LSetPos** изменит состояние строки SQL_ROW_ADDED на SQL_ROW_SUCCESS (если массив состояния строкы существует).<br /><br /> Успешное обновление с **помощью S'LSetPos** изменит статус строки SQL_ROW_UPDATED на новый статус строки (если массив состояния строки существует).<br /><br /> Если в операции **S'LSetPos** на строке происходит ошибка, статус строки устанавливается для SQL_ROW_ERROR (если массив состояния строки существует).<br /><br /> Для курсора, открывающегося с атрибутом SQL_ATTR_CONCURRENCY оператора SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES, обновление с **помощью S'LSetPos** может обновить оптимистичные значения параллелизма, используемые источником данных, чтобы обнаружить изменение строки. В этом случае версии строкили или значения, используемые для обеспечения обновления параллелизма курсора, при обновлении буферов строки с сервера. Это происходит для каждой обновленной строки.<br /><br /> Содержимое массива состояния строки, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR оператора, игнорируется для SQL_REFRESH *операции.*|  
|SQL_UPDATE|Драйвер позиционирует курсор на строке, указанной *RowNumber,* и обновляет основной ряд данных со значениями в буферах строки (аргумент *TargetValuePtr* в **S'LBindCol).** Он извлекает длины данных из буферов длины/индикатора *(аргумент StrLen_or_IndPtr* в **S'LBindCol).** Если длина столбца SQL_COLUMN_IGNORE, столбец не обновляется. После обновления строки драйвер изменяет соответствующий элемент массива состояния строки на SQL_ROW_UPDATED или SQL_ROW_SUCCESS_WITH_INFO (если массив состояния строки существует).<br /><br /> Это определяется драйвером, каково поведение, если **S'LSetPos** с *аргументом операции* SQL_UPDATE вызван на курсор, содержащий дубликаты столбцов. Водитель может вернуть драйвер-определяемый S'LSTATE, может обновить первую колонку, которая отображается в наборе результатов, или выполнить другое поведение, определяемое драйвером.<br /><br /> Массив операции строки, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR оператора, может использоваться для указания на то, что строка в текущем наборе строк должна быть проигнорирована во время массового обновления. Для получения дополнительной информации, см.|  
|SQL_DELETE|Водитель размещает курсор на строке, указанной *RowNumber,* и удаляет основной ряд данных. Он изменяет соответствующий элемент массива состояния строки на SQL_ROW_DELETED. После удаления строки для строки не действительны следующие: позиционируется обновление и удаление выписок, вызовы на **S'LGetData**и вызовы в **S'LSetPos** с *операцией,* установленной на что угодно, кроме SQL_POSITION. Для драйверов, поддерживающих упаковку, строка удаляется из курсора при извлечении новых данных из источника данных.<br /><br /> Остается ли строка видимой, зависит от типа курсора. Например, удаленные строки видны статичным курсоруи и курсору, управляемым ключами, но невидимы для динамических курсоров.<br /><br /> Массив операции строки, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR оператора, может использоваться для указания на то, что строка в текущем наборе строк должна быть проигнорирована во время массового удаления. Для получения дополнительной информации, см.|  
  
## <a name="locktype-argument"></a>Аргумент LockType  
 Аргумент *LockType* предоставляет приложениям возможность управления параллелизмом. В большинстве случаев источники данных, поддерживающие уровни параллелизма и транзакции, будут поддерживать только SQL_LOCK_NO_CHANGE значение аргумента *LockType.* Аргумент *LockType* обычно используется только для поддержки файлов.  
  
 Аргумент *LockType* определяет состояние блокировки строки после выполнения **S'LSetPos.** Если драйвер не может заблокировать строку ни для выполнения запрошенной операции, ни для удовлетворения аргумента *LockType,* он возвращает SQL_ERROR и S'LSTATE 42000 (ошибка Syntax или нарушение доступа).  
  
 Хотя аргумент *LockType* указан для одной инструкции, блокировка соответствует тем же привилегиям для всех инструкций по подключению. В частности, блокировка, приобретенная одним утверждением на соединении, может быть разблокирована другим утверждением на одном и том же соединении.  
  
 Строка, заблокированная через **S'LSetPos,** остается заблокированной до тех пор, пока приложение не вызывает **S'LSetPos** для строки с *LockType,* установленным для SQL_LOCK_UNLOCK, или до тех пор, пока приложение не вызывает **S'LFreeHandle** для выписки или **S'LFreeStmt** с SQL_CLOSE опцией. Для драйвера, поддерживающего транзакции, строка, заблокированная через **S'LSetPos,** разблокирована, когда приложение вызывает **S'LEndTran** для совершения или отката транзакции на соединение (если курсор закрыт при совершении транзакции или откате, как указано SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR типам информации, возвращенным **S'LGetInfo).**  
  
 Аргумент *LockType* поддерживает следующие типы блокировок. Чтобы определить, какие блокировки поддерживаются источником данных, приложение вызывает **S'LGetInfo** с SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 типинформации (в зависимости от типа курсора).  
  
|*Аргумент LockType*|Тип блокировки|  
|-------------------------|---------------|  
|SQL_LOCK_NO_CHANGE|Драйвер или источник данных гарантирует, что строка находится в том же заблокированном или разблокированном состоянии, как это было до вызова **S'LSetPos.** Это значение *LockType* позволяет источникам данных, которые не поддерживают явную блокировку уровня строки, использовать все блокировки, необходимые текущим уровням параллелизма и изоляции транзакций.|  
|SQL_LOCK_EXCLUSIVE|Драйвер или источник данных блокирует строку исключительно. Заявление о другом подключении или в другом приложении не может быть использовано для приобретения каких-либо блокировок на строке.|  
|SQL_LOCK_UNLOCK|Водитель или источник данных разблокирует строку.|  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, строка, которая заблокирована, будет оставаться заблокированной до тех пор, пока не появится один из вызовов функции, описанных в предыдущем абзаце.  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, строка, которая заблокирована, будет оставаться заблокированной до тех пор, пока приложение не вызывает **s'LFreeHandle** для выписки или **S'LFreeStmt** с SQL_CLOSE опцией. Если драйвер поддерживает транзакции и закрывает курсор при совершении или откате транзакции, приложение вызывает **s'LEndTran.**  
  
 Для обновления и удаления операций в **S'LSetPos**приложение использует аргумент *LockType* следующим образом:  
  
-   Чтобы гарантировать, что строка не изменится после ее извлечения, приложение вызывает **S'LSetPos** с *операцией,* установленной для SQL_REFRESH и *LockType* установлен SQL_LOCK_EXCLUSIVE.  
  
-   Если приложение устанавливает *LockType* для SQL_LOCK_NO_CHANGE, драйвер гарантирует, что операция обновления или удаления будет успешной только в том случае, если приложение, указанное SQL_CONCUR_LOCK для атрибута SQL_ATTR_CONCURRENCY оператора.  
  
-   Если приложение указывает SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES для атрибута SQL_ATTR_CONCURRENCY оператора, драйвер сравнивает строки или значения и отклоняет операцию, если строка изменилась после того, как приложение принесло строку.  
  
-   Если приложение указывает SQL_CONCUR_READ_ONLY для атрибута SQL_ATTR_CONCURRENCY оператора, драйвер отклоняет любое обновление или удаление операции.  
  
 Для получения более подробной информации о атрибуте SQL_ATTR_CONCURRENCY оператора [см.](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)  
  
## <a name="status-and-operation-arrays"></a>Статус и операции  
 При вызове **S'LSetPos**используются следующие блоки состояния и работы:  
  
-   Массив состояния строк (как указывается на поле SQL_DESC_ARRAY_STATUS_PTR в IRD и SQL_ATTR_ROW_STATUS_ARRAY атрибута оператора) содержит значения статуса для каждой строки данных в строке строки. Драйвер устанавливает значения статуса в этом массиве после звонка в **S'LFetch,** **S'LFetchScroll,** **S'LBulkOperations**или **S'LSetPos.** На этот массив указывает атрибут SQL_ATTR_ROW_STATUS_PTR оператора.  
  
-   Массив работы строки (как указывает сяртовое поле SQL_DESC_ARRAY_STATUS_PTR в ard и атрибуте SQL_ATTR_ROW_OPERATION_ARRAY оператора) содержит значение для каждой строки в строке, которая указывает, игнорируется ли или выполняется вызов в **S'LSetPos** для основной операции. Каждый элемент в массиве настроен либо на SQL_ROW_PROCEED (по умолчанию), либо SQL_ROW_IGNORE. На этот массив указывает атрибут SQL_ATTR_ROW_OPERATION_PTR оператора.  
  
 Количество элементов в массивах состояния и операций должно равняться числу строк в строке (как это определено атрибутом SQL_ATTR_ROW_ARRAY_SIZE оператора).  
  
 Для получения информации о массиве статуса строки, [см.](../../../odbc/reference/syntax/sqlfetch-function.md) Подробнее о массиве операций строки можно узнать в этом разделе "Игнорирование строки в массовой операции".  
  
## <a name="using-sqlsetpos"></a>Использование S'LSetPos  
 Перед тем, как приложение вызывает **S'LSetPos,** оно должно выполнить следующую последовательность шагов:  
  
1.  Если приложение вызовет **S'LSetPos** с *поручением SQL_UPDATE,* позвоните по **s'LBindCol** (или **S'LSetDescRec),** чтобы каждый столбец указал свой тип данных и связал буферы для данных и длины столбца.  
  
2.  Если приложение вызовет **S'LSetPos** с *набором операций,* чтобы SQL_DELETE или SQL_UPDATE, позвоните в **S'LColAttribute,** чтобы убедиться, что столбцы, которые будут удалены или обновлены, являются updatable.  
  
3.  Для создания набора результатов позвоните в **s'LExecDirect,** **S'LExecute**или функцию каталога.  
  
4.  Для получения данных позвоните по **телефону s'LFetch** или **S'LFetchScroll.**  
  
 Для получения более подробной информации [Updating Data with SQLSetPos](../../../odbc/reference/develop-app/updating-data-with-sqlsetpos.md)об использовании **S'LSetPos**см.  
  
## <a name="deleting-data-using-sqlsetpos"></a>Удалять данные с помощью S'LSetPos  
 Для удаления данных с **помощью S'LSetPos**приложение вызывает **S'LSetPos** с *rowNumber,* установленным на номер строки, чтобы удалить, и *операция* установлена для SQL_DELETE.  
  
 После удаления данных драйвер изменяет значение в массиве состояния строки реализации для соответствующего строки для SQL_ROW_DELETED (или SQL_ROW_ERROR).  
  
## <a name="updating-data-using-sqlsetpos"></a>Обновление данных с помощью S'LSetPos  
 Приложение может передавать значение для столбца либо в буфере данных, либо с одним или несколько вызовами на **S'LPutData.** Столбцы, данные которых передаются с **помощью s'LPutData,** известны как *столбцы* *данных по исполнению.* Они обычно используются для отправки данных для SQL_LONGVARBINARY и SQL_LONGVARCHAR столбцов и могут быть смешаны с другими столбцов.  
  
#### <a name="to-update-data-with-sqlsetpos-an-application"></a>Для обновления данных с помощью S'LSetPos, приложение:  
  
1.  Значения данных и буферов длины/индикатора, связанных с **S'LBindCol:**  
  
    -   Для обычных столбцов приложение помещает новое значение столбца в буфер * \*TargetValuePtr* и длину этого значения в * \*StrLen_or_IndPtr* буфер. Если строка не должна обновляться, приложение помещает SQL_ROW_IGNORE элемента этой строки в массиве операции строки.  
  
    -   Для столбцов данных по исполнению приложение помещает в буфер * \*TargetValuePtr* определенное значение, например номер столбца. Значение может быть использовано позже для определения столбца.  
  
         Приложение помещает результат SQL_LEN_DATA_AT_EXEC *(длина)* макроса в буфер*е StrLen_or_IndPtr.* Если тип данных в столбце является SQL_LONGVARBINARY, SQL_LONGVARCHAR или длинным типом исходных данных, а драйвер возвращает "Y" для SQL_NEED_LONG_DATA_LEN типа информации в **S'LGetInfo,** *длина* — это количество байтов данных, которые будут отправлены для параметра; в противном случае, он должен быть неотрицательным значением и игнорируется.  
  
2.  Вызывает **S'LSetPos** с аргументом *операции,* установленным для SQL_UPDATE для обновления строки данных.  
  
    -   Если нет столбцов данных по исполнению, процесс завершен.  
  
    -   При наличии столбцов данных по исполнению функция возвращается SQL_NEED_DATA и переходит к шагу 3.  
  
3.  Вызывает **sLParamData** для получения адреса буфера * \*TargetValuePtr* для первой колонки data-at-execution, которая будет обработана. **S'LParamData** возвращает SQL_NEED_DATA. Приложение извлекает значение, определяемое приложением, из буфера * \*TargetValuePtr.*  
  
    > [!NOTE]  
    >  Несмотря на то, что параметры «данные по исполнению» аналогичны столбику данных по исполнению, значение, возвращенное **S'LParamData,** отличается для каждого из них.  
  
    > [!NOTE]  
    >  Параметры «данные по исполнению» — это параметры, в которых данные будут отправлены с **помощью S'LPutData,** когда выписка будет выполнена с **помощью S'LExecDirect** или **S'LExecute.** Они связаны с **S'LBindParameter** или путем установки дескрипторов с **S'LSetDescRec**. Значение, возвращенное **S'LParamData,** представляет собой 32-битное значение, передаваемый в аргумент **ЕСЛБДОПлест** в аргументе *ParameterValuePtr.*  
  
    > [!NOTE]  
    >  Столбцы «Данные по исполнению» — это столбцы в строке, для которых данные будут отправляться с **помощью S'LPutData** при обновлении строки с **помощью S'LSetPos.** Они связаны с **S'LBindCol**. Значение, возвращенное **S'LParamData,** является адресом строки в буфере*TargetValuePtr,* который обрабатывается.  
  
4.  Для отправки данных для столбца один или несколько раз вызывает **s'LPutData.** Требуется несколько вызовов, если все значения данных не могут быть возвращены в * \*буфере TargetValuePtr,* указанном в **S'LPutData;** несколько вызовов на **S'LPutData** для одного и того же столбца разрешены только при отправке данных о символе C в столбец с типом данных, двоичных или данных, имеющих конкретные источники данных, или при отправке двоичных данных C в столбец с типом данных, характерных для символов, двоичных или исходных данных.  
  
5.  Снова вызывает **S'LParamData,** чтобы сигнализировать о том, что все данные отправлены в столбец.  
  
    -   При наличии большего количества столбцов данных по исполнению, **s'LParamData** возвращает SQL_NEED_DATA и адрес буфера *TargetValuePtr* для следующей колонки data-at-execution, которая будет обработана. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет столбцов данных по исполнению, процесс завершен. Если выписка была выполнена успешно, **S'LParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; если выполнение не удалось, он возвращает SQL_ERROR. На этом **этапе, S'LParamData** может вернуть любой S'Lstate, которые могут быть возвращены **S'LSetPos**.  
  
 Если данные были обновлены, драйвер изменяет значение в массиве состояния строки реализации для соответствующего строки для SQL_ROW_UPDATED.  
  
 Если операция отменена или происходит ошибка в **SQLPutData** **S'LParamData** или **SLPutData**, после того, как **S'LSetPos** возвращает SQL_NEED_DATA и до того, как данные будут отправлены для всех столбцов данных по исполнению, приложение может вызвать только **S'LCancel**, **S'LGetDiagField**, **S'LGetDiagRec**, **S'LSet.** **SQLParamData** Если он вызывает любую другую функцию для оператора или соединения, связанного с выпиской, функция возвращается SQL_ERROR и S'Lstate HY010 (ошибка последовательности функций).  
  
 Если приложение вызывает **S'LCancel,** в то время как водителю по-прежнему нужны данные для столбцов данных, драйвер отменяет операцию. Затем приложение может снова вызвать **S'LSetPos;** отмена не влияет на состояние курсора или текущее положение курсора.  
  
 Когда список select спецификации запроса, связанный с курсором, содержит несколько ссылок на один и тот же столбец, создается ли ошибка или драйвер игнорирует дублированные ссылки и выполняет запрашиваемые операции, определяется драйвером.  
  
## <a name="performing-bulk-operations"></a>Выполнение массовых операций  
 Если аргумент *RowNumber* равен 0, то драйвер выполняет операцию, указанную в аргументе *операции* для каждой строки в строке, которая имеет значение SQL_ROW_PROCEED в поле в массиве операции строки, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR оператора. Это допустимое значение аргумента *RowNumber* для *аргумента операции* SQL_DELETE, SQL_REFRESH или SQL_UPDATE, но не SQL_POSITION. **S'LSetPos** с *операцией* SQL_POSITION и *RowNumber,* равный 0, вернет S'LSTATE HY109 (недействительное положение курсора).  
  
 В случае ошибки, которая относится ко всему набору строк, например, s'Lstate HYT00 (тайм-аут истек), водитель возвращается SQL_ERROR и соответствующего S'LSTATE. Содержимое буферов строки не определено, а положение курсора остается неизменным.  
  
 При возникновении ошибки, относящейся к одной строке, драйвер:  
  
-   Устанавливает элемент для строки в массиве состояния строки, на который указывает SQL_ATTR_ROW_STATUS_PTR атрибут оператора SQL_ROW_ERROR.  
  
-   Публикация одного или нескольких дополнительных S'LSTATE за ошибку в очереди ошибок и устанавливает SQL_DIAG_ROW_NUMBER поле в структуре диагностических данных.  
  
 После обработки ошибки или предупреждения, если драйвер завершает операцию для остальных строк в строке, он возвращает SQL_SUCCESS_WITH_INFO. Таким образом, для каждой строки, вернувшей ошибку, очередь ошибок содержит ноль или больше дополнительных S'LSTATEs. Если водитель останавливает операцию после обработки ошибки или предупреждения, он возвращает SQL_ERROR.  
  
 Если водитель возвращает какие-либо предупреждения, такие как S'LSTATE 01004 (данные усечены), он возвращает предупреждения, которые применяются ко всему набору строк или к неизвестным строкам в строке, прежде чем он возвращает информацию об ошибке, которая применяется к определенным строкам. Он возвращает предупреждения для определенных строк вместе с любой другой информацией об ошибках об этих строках.  
  
 Если *RowNumber* равен 0, а *операция* — SQL_UPDATE, SQL_REFRESH или SQL_DELETE, то количество строк, на которых работает **S'LSetPos,** указывается на атрибут SQL_ATTR_ROWS_FETCHED_PTR оператора.  
  
 Если *RowNumber* равен 0, а *операция* — SQL_DELETE, SQL_REFRESH или SQL_UPDATE, то текущая строка после операции такая же, как и текущая строка перед операцией.  
  
## <a name="ignoring-a-row-in-a-bulk-operation"></a>Игнорирование строки в массовой операции  
 Массив работы строки может использоваться для указания на то, что строка в текущем наборе строк должна быть проигнорирована во время основной операции с использованием **S'LSetPos.** Чтобы поручить водителю игнорировать одну или несколько строк во время основной операции, приложение должно выполнить следующие действия:  
  
1.  Позвоните **в S'LSetStmtAttr,** чтобы настроить атрибут SQL_ATTR_ROW_OPERATION_PTR оператора, чтобы указать на массив S'LUSMALLINTs. Это поле также может быть установлено, вызывая **S'LSetDesccField,** чтобы установить SQL_DESC_ARRAY_STATUS_PTR поле заголовка ARD, которое требует, чтобы приложение получило ручку дескриптора.  
  
2.  Установите каждый элемент массива операции строки на одно из двух значений:  
  
    -   SQL_ROW_IGNORE, чтобы указать, что строка исключена для основной операции.  
  
    -   SQL_ROW_PROCEED, чтобы указать, что строка включена в объемную операцию. (Это значение по умолчанию.)  
  
3.  Для выполнения основной операции позвоните в **S'LSetPos.**  
  
 Следующие правила применяются к массиву операции строки:  
  
-   SQL_ROW_IGNORE и SQL_ROW_PROCEED затрагивают только объемные операции, использующие **S'LSetPos,** с *помощью операции* SQL_DELETE или SQL_UPDATE. Они не влияют на вызовы в **S'LSetPos** с *операцией* SQL_REFRESH или SQL_POSITION.  
  
-   Указатель установлен на нуле в ней по умолчанию.  
  
-   Если указатель недействителен, все строки обновляются так, как если бы все элементы были настроены на SQL_ROW_PROCEED.  
  
-   Установка элемента на SQL_ROW_PROCEED не гарантирует, что операция будет происходить на данном ряду. Например, если определенная строка в наборе строк имеет статус SQL_ROW_ERROR, драйвер может быть не в состоянии обновить эту строку независимо от того, указано ли приложение SQL_ROW_PROCEED. Приложение должно всегда проверять массив состояния строк, чтобы увидеть, была ли операция успешной.  
  
-   SQL_ROW_PROCEED определяется как 0 в файле заголовка. Приложение может инициализировать массив операции строки до 0 для обработки всех строк.  
  
-   Если номер элемента "n" в массиве операции строки установлен на SQL_ROW_IGNORE и **s'LSetPos** вызывается для выполнения операции массового обновления или удаления, nth строка в наборе строк остается неизменной после вызова **в S'LSetPos.**  
  
-   Приложение должно автоматически устанавливать столбец только для чтения для SQL_ROW_IGNORE.  
  
## <a name="ignoring-a-column-in-a-bulk-operation"></a>Игнорирование колонны в массовой операции  
 Чтобы избежать ненужной диагностики обработки, генерируемой попыткой обновления одного или нескольких столбцов только для чтения, приложение может установить значение в буфере длины/индикатора для SQL_COLUMN_IGNORE. Для получения более подробной информации, [см.](../../../odbc/reference/syntax/sqlbindcol-function.md)  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение позволяет пользователю просматривать таблицу ORDERS и обновлять состояние заказа. Курсор настроен на клавишу с размером ряда 20 и использует оптимистичный параллелиз-контроль, сравнивая версии строки. После того, как каждый набор строк исмочен, приложение печатает его и позволяет пользователю выбрать и обновить статус заказа. Приложение использует **S'LSetPos** для размещения курсора на выбранной строке и выполняет позиционированное обновление строки. (Обработка ошибок опущена для ясности.)  
  
```cpp  
#define ROWS 20  
#define STATUS_LEN 6  
  
SQLCHAR        szStatus[ROWS][STATUS_LEN], szReply[3];  
SQLINTEGER     cbStatus[ROWS], cbOrderID;  
SQLUSMALLINT   rgfRowStatus[ROWS];  
SQLUINTEGER    sOrderID, crow = ROWS, irow;  
SQLHSTMT       hstmtS, hstmtU;  
  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CONCURRENCY, (SQLPOINTER) SQL_CONCUR_ROWVER, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CURSOR_TYPE, (SQLPOINTER) SQL_CURSOR_KEYSET_DRIVEN, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_ARRAY_SIZE, (SQLPOINTER) ROWS, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_STATUS_PTR, (SQLPOINTER) rgfRowStatus, 0);  
SQLSetCursorName(hstmtS, "C1", SQL_NTS);  
SQLExecDirect(hstmtS, "SELECT ORDERID, STATUS FROM ORDERS ", SQL_NTS);  
  
SQLBindCol(hstmtS, 1, SQL_C_ULONG, &sOrderID, 0, &cbOrderID);  
SQLBindCol(hstmtS, 2, SQL_C_CHAR, szStatus, STATUS_LEN, &cbStatus);  
  
while ((retcode == SQLFetchScroll(hstmtS, SQL_FETCH_NEXT, 0)) != SQL_ERROR) {  
   if (retcode == SQL_NO_DATA_FOUND)  
      break;  
   for (irow = 0; irow < crow; irow++) {  
      if (rgfRowStatus[irow] != SQL_ROW_DELETED)  
         printf("%2d %5d %*s\n", irow+1, sOrderID, NAME_LEN-1, szStatus[irow]);  
   }  
   while (TRUE) {  
      printf("\nRow number to update?");  
      gets_s(szReply, 3);  
      irow = atoi(szReply);  
      if (irow > 0 && irow <= crow) {  
         printf("\nNew status?");  
         gets_s(szStatus[irow-1], (ROWS * STATUS_LEN));  
         SQLSetPos(hstmtS, irow, SQL_POSITION, SQL_LOCK_NO_CHANGE);  
         SQLPrepare(hstmtU,  
          "UPDATE ORDERS SET STATUS=? WHERE CURRENT OF C1", SQL_NTS);  
         SQLBindParameter(hstmtU, 1, SQL_PARAM_INPUT,  
            SQL_C_CHAR, SQL_CHAR,  
            STATUS_LEN, 0, szStatus[irow], 0, NULL);  
         SQLExecute(hstmtU);  
      } else if (irow == 0) {  
         break;  
      }  
   }  
}  
```  
  
 Для получения более дополнительных примеров см. [Позиционные обновления и удаления заявлений](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md) и [обновление строк в Строках с помощью S'LSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение оптовых операций, не связанных с положением курсора блока|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одного поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Установка одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
|Установка атрибута оператора|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
