---
title: Функция SQLSetPos | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetPos
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetPos
helpviewer_keywords:
- SQLSetPos function [ODBC]
ms.assetid: 80190ee7-ae3b-45e5-92a9-693eb558f322
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 63bca42adcdfc83d1bdb96361680d0c70c9a031c
ms.sourcegitcommit: 56b963446965f3a4bb0fa1446f49578dbff382e0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2019
ms.locfileid: "67793130"
---
# <a name="sqlsetpos-function"></a>Функция SQLSetPos
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: интерфейс ODBC  
  
 **Сводка**  
 **SQLSetPos** задает положение курсора в наборе строк и позволяет приложению для обновления данных в наборе строк или обновлять или удалять данные в результирующем наборе.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetPos(  
      SQLHSTMT        StatementHandle,  
      SQLSETPOSIROW   RowNumber,  
      SQLUSMALLINT    Operation,  
      SQLUSMALLINT    LockType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *RowNumber*  
 [Вход] Положение строки в наборе строк, для которого следует выполнить операцию, заданную с помощью *операции* аргумент. Если *RowNumber* равно 0, операция применяется к каждой строки в наборе строк.  
  
 Дополнительные сведения см. в разделе «Примечания».  
  
 *Операция*  
 [Вход] Выполняемая операция:  
  
 SQL_POSITION SQL_REFRESH SQL_UPDATE SQL_DELETE  
  
> [!NOTE]
>  Значение SQL_ADD *операции* аргумент является устаревшим для ODBC *3.x*. ODBC *3.x* драйверов, необходимых для работы SQL_ADD для обеспечения обратной совместимости. Эта функциональность была заменена вызов **SQLBulkOperations** с *операции* из SQL_ADD. Когда ODBC *3.x* приложение работает с ODBC *2.x* драйвера, диспетчер драйверов сопоставляет вызов **SQLBulkOperations** с *операции*из SQL_ADD для **SQLSetPos** с *операции* из SQL_ADD.  
  
 Дополнительные сведения см. в разделе «Примечания».  
  
 *LockType*  
 [Вход] Указывает, как заблокировать строку после выполнения операции, указанный в *операции* аргумент.  
  
 SQL_LOCK_NO_CHANGE SQL_LOCK_EXCLUSIVE SQL_LOCK_UNLOCK  
  
 Дополнительные сведения см. в разделе «Примечания».  
  
 **Возвращает**  
  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetPos** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE может быть получен путем вызова **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSetPos** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
 Для всех этих SQLSTATE, которые могут возвращать значение SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением SQLSTATE 01xxx) возвращается SQL_SUCCESS_WITH_INFO, если в одной или нескольким, но не все строки многострочной операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка Операция одной строки.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01001|Конфликт операции с курсором|*Операции* аргумент был SQL_DELETE или SQL_UPDATE, и ни одной строки или более одной строки были удалены или обновлены. (Дополнительные сведения об обновлениях для более одной строки см. описание SQL_ATTR_SIMULATE_CURSOR *атрибут* в **SQLSetStmtAttr**.) (Функция возвращает значение SQL_SUCCESS_WITH_INFO).<br /><br /> *Операции* аргумент был SQL_DELETE или SQL_UPDATE, и операция не выполнена из-за оптимистичного параллелизма. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение строковых данных справа|*Операции* аргумент был SQL_REFRESH и символьные или двоичные данные, возвращаемые для столбца или столбцов с типом данных SQL_C_CHAR и SQL_C_BINARY возникло усечение непустых символьных или двоичных данных от NULL.|  
|01S01|Ошибка в строке|*RowNumber* аргумент было равно 0, и в одну или несколько строк произошла ошибка при выполнении операции, заданной с помощью *операции* аргумент.<br /><br /> (SQL_SUCCESS_WITH_INFO возвращается, если в одной или нескольким, но не все строки многострочной операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка во время операции одной строкой).<br /><br /> (Этот SQLSTATE возвращается только тогда, когда **SQLSetPos** вызывается после **SQLExtendedFetch**, если драйвер ODBC *2.x* драйвера и библиотека курсоров не используется.)|  
|01S07|Частичное усечение|*Операции* аргумент был SQL_REFRESH, тип данных буфера приложения не SQL_C_CHAR и SQL_C_BINARY и данные, возвращаемые буферы приложения для одного или нескольких столбцов были усечены. Для числовых типов данных был усечен, дробная часть числа. Для времени, timestamp и интервальных типов данных, содержащего компонент времени десятичная часть времени были усечены.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе не удалось преобразовать тип данных, указанный в *TargetType* в вызове **SQLBindCol**.|  
|07009|Недопустимый индекс дескриптора|Аргумент *операции* SQL_REFRESH или SQL_UPDATE, и столбец был привязан с номером столбца больше, чем количество столбцов в результирующем наборе.|  
|21S02|Структура полученной таблицы не соответствует списку столбцов|Аргумент *операции* SQL_UPDATE, и столбцы не имели обновляемых, так как все столбцы были либо не связанного с данными, только для чтения, или значение в буфер связанного длины и индикатора было SQL_COLUMN_IGNORE.|  
|22001|Строковые данные, усечение справа|*Операции* аргумент был SQL_UPDATE и назначение символьное или двоичное значение в столбец привело к усечению непустым (для символов) или символов, отличных от null (для двоичного файла) или байтов.|  
|22003|Численное значение вне допустимого диапазона|Аргумент *операции* находилась SQL_UPDATE, и назначение числовое значение для столбца в результирующем наборе вызвало целиком (в отличие от долей) часть усекаемое число.<br /><br /> Аргумент *операции* было SQL_REFRESH, и возвращает числовое значение для одного или нескольких привязанных столбцов могло привести к потере значащих цифр.|  
|22007|Формат недопустимые даты и времени|Аргумент *операции* находилась SQL_UPDATE, и присвоение значения даты или метки времени для столбца в результирующем наборе вызвало год, месяц или день поле должно быть вне допустимого диапазона.<br /><br /> Аргумент *операции* был SQL_REFRESH и возврат значения даты или метки времени для одного или нескольких привязанных столбцов вызвало бы год, месяц или день поле должно быть вне допустимого диапазона.|  
|22008|Переполнение поля даты и времени|*Операции* аргумент был SQL_UPDATE, и привела к производительность datetime арифметика на данные, отправляемые в столбец в результирующем наборе, в поле даты и времени (год, месяц, день, час, минуту или второе поле), результат за пределами допустимого диапазона значений для поля или допустимыми на основе григорианского календаря естественным правил для значений даты и времени.<br /><br /> *Операции* аргумент был SQL_REFRESH и производительность datetime арифметика на данных, извлекаемых из результирующего набора привело к поле даты и времени (год, месяц, день, час, минуту или второе поле), результат за пределами допустимого диапазона значений для поля или допустимыми на основе григорианского календаря естественным правил для значений даты и времени.|  
|22015|Переполнение поля интервала|*Операции* аргумент был SQL_UPDATE и назначение точным или тип интервала C период, в тип данных SQL привело к потере значащих цифр.<br /><br /> *Операции* аргумент был SQL_UPDATE; произошла при назначении период, в тип SQL не представление значения типа C в интервале тип SQL.<br /><br /> *Операции* аргумент был SQL_REFRESH и присвоение тип интервала C из точное числовое значение или интервал тип SQL привело к потере значащих цифр в начале поля.<br /><br /> *Операции* аргумент был обновить SQL_; присвоить тип интервала C, возникла не представление значения типа SQL в тип интервала C.|  
|22018|Недопустимое символьное значение для спецификации приведения|*Операции* аргумент был SQL_REFRESH; тип C был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом из связанный тип C.<br /><br /> Аргумент *операции* был SQL_UPDATE; тип SQL был точное или Приблизительное числовое, datetime или тип интервала данных; тип C был SQL_C_CHAR; и значение в столбце не является допустимым литералом связанного типа SQL.|  
|23000|Нарушение ограничения целостности|Аргумент *операции* SQL_DELETE или SQL_UPDATE и было нарушено ограничение целостности.|  
|24000|Недопустимое состояние курсора|*StatementHandle* была выполненного состоянии, но результирующий набор не связан с *StatementHandle*.<br /><br /> (DM) курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.<br /><br /> Курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы вызывалась, но курсор был установлен перед началом результирующего набора или после конец результирующего набора.<br /><br /> Аргумент *операции* SQL_DELETE, SQL_REFRESH или SQL_UPDATE, и курсор был установлен перед началом результирующего набора или в конце результирующего набора.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|42000|Синтаксическая ошибка или нарушение доступа|Драйвер не удалось заблокировать строку для выполнения операции, запрашиваемой в аргументе *операции*.<br /><br /> Драйвер не удалось заблокировать ее по запросу в аргументе *LockType*.|  
|44000|Нарушение параметра WITH CHECK OPTION|*Операции* аргумент был SQL_UPDATE и обновление было выполнено в просматриваемой таблице или таблицы, производным от просматриваемого таблицу, которая была создана путем указания **WITH CHECK OPTION**, таким образом, чтобы одна или несколько строк влияет обновление больше не присутствовать в просматриваемой таблице.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. При вызове функции SQLSetPos по-прежнему выполнении асинхронной функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполненного. Функция был вызван без предварительного вызова функции **SQLExecDirect**, **SQLExecute**, или функции каталога.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) драйвер был ODBC *2.x* драйвер, и **SQLSetPos** был вызван для *StatementHandle* после **SQLFetch** был вызван.|  
|HY011|Атрибут нельзя установить сейчас|(DM) драйвер был ODBC *2.x* драйвера; значения SQL_ATTR_ROW_STATUS_PTR инструкции атрибут имел значение; затем **SQLSetPos** был вызван перед **SQLFetch**,  **SQLFetchScroll**, или **SQLExtendedFetch** был вызван.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|*Операции* аргумент был SQL_UPDATE, значение данных был пустым указателем и длина значение столбца было указано значение SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NULL_DATA, 0 или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> *Операции* аргумент был SQL_UPDATE; значение данных не был пустым указателем; был тип данных C SQL_C_BINARY и SQL_C_CHAR; и значение Длина столбца меньше 0, но не равны в значение SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE , SQL_NTS или SQL_NULL_DATA, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение в буфер длины/индикатора было значение SQL_DATA_AT_EXEC; тип SQL был SQL_LONGVARCHAR, SQL_LONGVARBINARY или тип данных long зависящие от источника данных; и введите сведения SQL_NEED_LONG_DATA_LEN **SQLGetInfo** был «Y».|  
|HY092|Недопустимый атрибут идентификатора|(DM) значение, заданное для *операции* предоставил недопустимый аргумент.<br /><br /> (DM) значение, заданное для *LockType* предоставил недопустимый аргумент.<br /><br /> *Операции* аргумент SQL_UPDATE или SQL_DELETE, и атрибута инструкции SQL_ATTR_CONCURRENCY SQL_ATTR_CONCUR_READ_ONLY.|  
|HY107|Значение строки за пределами диапазона|Значение, указанное для аргумента *RowNumber* превышает число строк в наборе строк.|  
|HY109|Недопустимое положение курсора.|Курсор, связанный с *StatementHandle* была определена как однонаправленные, чтобы курсор не может быть расположен в наборе строк. См. в описании атрибута SQL_ATTR_CURSOR_TYPE **SQLSetStmtAttr**.<br /><br /> *Операции* аргумент был SQL_UPDATE, SQL_DELETE или SQL_REFRESH, и строки, определяемый *RowNumber* аргумент была удалена или не была получена.<br /><br /> (DM) *RowNumber* аргумент было равно 0 и *операции* аргумент был SQL_POSITION.<br /><br /> **SQLSetPos** был вызван после **SQLBulkOperations** был вызван и перед **SQLFetchScroll** или **SQLFetch** был вызван.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает операции, запрашиваемой в *операции* аргумент или *LockType* аргумент.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Период ожидания задается с помощью **SQLSetStmtAttr** с *атрибут* из SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
  
> [!CAUTION]
>  Для сведения об инструкции в том, что **SQLSetPos** может вызываться в и что ему необходимо выполнять для обеспечения совместимости с ODBC *2.x* приложений, см. в разделе [блочные курсоры, Прокручиваемые курсоры и Обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md).  
  
## <a name="rownumber-argument"></a>Аргумент RowNumber функции  
 *RowNumber* аргумент задает количество строк в наборе строк для выполнения операции, заданной параметром *операции* аргумент. Если *RowNumber* равно 0, операция применяется к каждой строки в наборе строк. *RowNumber* должен быть значением от 0 до количество строк в наборе строк.  
  
> [!NOTE]  
>  На языке C, массивы начинаются с нуля и *RowNumber* аргумент отсчитывается от 1. Например, чтобы обновить пятая строка набора строк, приложение изменяет буферы строк с 4 индекса в массиве, но указывает *RowNumber* 5.  
  
 Все операции позиционирования курсора на строки, указанной в *RowNumber*. Следующие операции требуют положение курсора:  
  
-   Расположенный update и delete.  
  
-   Вызовы **SQLGetData**.  
  
-   Вызовы **SQLSetPos** с параметрами SQL_DELETE, SQL_REFRESH и SQL_UPDATE.  
  
 Например если *RowNumber* равен 2 для вызова **SQLSetPos** с *операции* из SQL_DELETE, курсор помещается на второй строке набора строк и удаления этой строки. Запись в реализации массив статусов строк (на него указывает атрибут инструкции значения SQL_ATTR_ROW_STATUS_PTR) во второй строке меняется на значение SQL_ROW_DELETED.  
  
 Приложение может указать положение курсора, при вызове **SQLSetPos**. Как правило, он вызывает **SQLSetPos** с операцией SQL_POSITION или SQL_REFRESH позиционировать курсор перед выполнением позиционированные обновления или инструкция delete или вызова **SQLGetData**.  
  
## <a name="operation-argument"></a>Аргумент операции  
 *Операции* аргумент поддерживает следующие операции. Чтобы определить, какие параметры поддерживаются источником данных, приложение вызывает **SQLGetInfo** SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_ Тип сведений CURSOR_ATTRIBUTES1 (в зависимости от типа курсора).  
  
|*Операция*<br /><br /> аргумент|Операция|  
|------------------------------|---------------|  
|SQL_POSITION|Драйвер помещает курсор на строки, указанной в *RowNumber*.<br /><br /> Содержимое массив статусов строк, на которые указывают атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR игнорируются для SQL_POSITION *операции*.|  
|SQL_REFRESH|Драйвер помещает курсор на строки, указанной в *RowNumber* и обновляет данные в буферах набора строк для этой строки. Дополнительные сведения о том, как драйвер возвращает данные в буферах набора строк см. в описаниях на уровне строки и на уровне столбца привязки в **SQLBindCol**.<br /><br /> **SQLSetPos** с *операции* из SQL_REFRESH обновляет состояние и содержимого в пределах текущего набора строк извлеченных строк. Это включает в себя обновление закладки. Так как данные в буферах обновляются, но не refetched, фиксирована членство в наборе строк. Это отличается от обновления, выполняемые с помощью вызова **SQLFetchScroll** с *FetchOrientation* из SQL_FETCH_RELATIVE и *RowNumber* равным 0, что refetches набор строк из результирующего набора, чтобы его можно отобразить добавленных данных и удалить удаленных данных, если эти операции поддерживаются драйвером и курсор.<br /><br /> Успешное обновление с **SQLSetPos** не изменит состояние строки SQL_ROW_DELETED. Удаленные строки в наборе строк по-прежнему будут отмечены как удаленные до следующей выборки. Строки будут появляться в следующей выборки, если курсор поддерживает упаковки (в котором последующая **SQLFetch** или **SQLFetchScroll** не возвращает удаленные строки).<br /><br /> Добавлены строки не отображаются, когда обновление с помощью **SQLSetPos** выполняется. Это поведение отличается от **SQLFetchScroll** с *FetchType* из SQL_FETCH_RELATIVE и *RowNumber* равным 0, а также обновляет текущего набора строк, но Показать добавленных записей или пакета удаленные записи, если эти операции поддерживаются в курсор.<br /><br /> Успешное обновление с **SQLSetPos** изменится состояние строки SQL_ROW_ADDED SQL_ROW_SUCCESS (если существует массив статусов строк).<br /><br /> Успешное обновление с **SQLSetPos** изменится состояние строки SQL_ROW_UPDATED на новое состояние строки (если существует массив статусов строк).<br /><br /> При возникновении ошибки в **SQLSetPos** операция над строкой состояния имеет значение SQL_ROW_ERROR (если существует массив статусов строк).<br /><br /> Для курсора, открыт с помощью атрибута инструкции SQL_ATTR_CONCURRENCY SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES, обновление с помощью **SQLSetPos** могут обновлять значения оптимистичного параллелизма, используемый источником данных для обнаружения, Строка была изменена. В этом случае версии строк или значений, используемых для обеспечения параллелизма курсоров обновляются каждый раз, когда буферы строк обновляются с сервера. Эта операция выполняется для каждой строки, которое обновляется.<br /><br /> Содержимое массив статусов строк, на которые указывают атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR игнорируются для SQL_REFRESH *операции*.|  
|SQL_UPDATE|Драйвер помещает курсор на строки, указанной в *RowNumber* и обновление базовой строки данных со значениями в буферах набора строк ( *TargetValuePtr* аргумента в  **SQLBindCol**). Он извлекает значения длины данных из буфера длины и индикатора ( *StrLen_or_IndPtr* аргумента в **SQLBindCol**). Если длина любого столбца SQL_COLUMN_IGNORE, столбец не обновляется. После обновления строки, драйвер изменяет соответствующий элемент в массиве строк состояния SQL_ROW_UPDATED или SQL_ROW_SUCCESS_WITH_INFO (если существует массив статусов строк).<br /><br /> Это определенное драйвером поведение — Если **SQLSetPos** с *операции* аргумент SQL_UPDATE вызывается в курсоре, который содержит повторяющиеся столбцы. Драйвер может возвращать SQLSTATE, определяемым драйвером, можно обновить первый столбец, который отображается в результирующем наборе или выполнять другие правила поведения, определяемые драйвером.<br /><br /> Указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR массива операций строк можно использовать для указания, что строки в текущем наборе строк должны пропускаться во время массового обновления. Дополнительные сведения см. в разделе «Состояние и операции массивов» далее в этом справочнике по функциям.|  
|SQL_DELETE|Драйвер помещает курсор на строки, указанной в *RowNumber* и удаляет базовой строки данных. Соответствующий элемент в массиве строк состояния примет значение SQL_ROW_DELETED. После удаления строки, следующие недопустимы для строки: расположены обновления и удаления, вызовов **SQLGetData**и вызовы **SQLSetPos** с *операции* присвоено какой-либо кроме SQL_POSITION. Для драйверов, которые поддерживают упаковки строка удаляется из курсора, при получении новых данных из источника данных.<br /><br /> Является ли строка остается видимым зависит от типа курсора. Например удаленные строки являются видимыми для статических и управляемых набором ключей курсоры, но невидимыми для динамических курсоров.<br /><br /> Указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR массива операций строк можно использовать для указания, что строки в текущем наборе строк должны пропускаться во время массового удаления. Дополнительные сведения см. в разделе «Состояние и операции массивов» далее в этом справочнике по функциям.|  
  
## <a name="locktype-argument"></a>Аргумент LockType  
 *LockType* аргумент предоставляет способ для приложений для управления параллелизмом. В большинстве случаев источников данных, поддерживающих уровней одновременности выполнения и транзакции будет поддерживать только значение SQL_LOCK_NO_CHANGE *LockType* аргумент. *LockType* аргумента используется только для поддержки на основе файлов.  
  
 *LockType* аргумент указывает состояние блокировки строки после **SQLSetPos** был выполнен. Если драйвер не удается заблокировать ее для выполнения запрошенной операции или для удовлетворения *LockType* аргумент, он возвращает значение SQL_ERROR и SQLSTATE 42000 (синтаксическая ошибка или нарушение доступа).  
  
 Несмотря на то что *LockType* аргумент указан для одного оператора, блокировка accords теми же привилегиями, чтобы все инструкции для подключения. В частности блокировку, которая получена одной инструкцией, для подключения, можно разблокировать с помощью другой инструкции относительно одного подключения.  
  
 Блокировки строки через **SQLSetPos** останется заблокированным, пока приложение не вызовет **SQLSetPos** для строки с *LockType* SQL_LOCK_UNLOCK, или пока приложение вызовы **SQLFreeHandle** для инструкции или **SQLFreeStmt** с параметром SQL_CLOSE. Драйверу, который поддерживает транзакции, строки заблокирован через **SQLSetPos** разблокируется, когда приложение вызывает **SQLEndTran** для фиксации или отката транзакции в соединении, (если курсор закрыт При фиксации или отката, обозначенный SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR типы сведений, возвращенных **SQLGetInfo**).  
  
 *LockType* аргумент поддерживает следующие типы блокировок. Чтобы определить, какие виды блокировок поддерживаются источником данных, приложение вызывает **SQLGetInfo** SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_ Тип сведений CURSOR_ATTRIBUTES1 (в зависимости от типа курсора).  
  
|*LockType* аргумент|Тип блокировки|  
|-------------------------|---------------|  
|SQL_LOCK_NO_CHANGE|Драйвер или источник данных гарантирует, что строка является в то же состояние заблокирован или разблокирован, как было до **SQLSetPos** был вызван. Это значение из *LockType* позволяет источники данных, которые не поддерживают явную блокировку на уровне строк использовать любые блокировки необходим, текущие уровни изоляции параллелизмом и транзакции.|  
|SQL_LOCK_EXCLUSIVE|Драйвер или источник данных исключительно блокирует строку. Инструкцию через другое подключение, или в другом приложении, не может использоваться для блокировки на строки.|  
|SQL_LOCK_UNLOCK|Драйвер или источник данных снимает блокировку строки.|  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, заблокированному строки будет оставаться заблокированным, пока не произойдет одно из вызовов функций, описанных в предыдущем абзаце.  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, заблокированному строки будет оставаться заблокированным до приложение вызывает **SQLFreeHandle** для инструкции или **SQLFreeStmt** с параметр SQL_CLOSE. Если драйвер поддерживает транзакции и закрывает курсор при фиксации или отката транзакции, приложение вызывает **SQLEndTran**.  
  
 Для операций update и delete в **SQLSetPos**, приложение использует *LockType* аргумент, как показано ниже:  
  
-   Чтобы гарантировать, что строка не изменяется после их получения, приложение вызывает **SQLSetPos** с *операции* присвоено SQL_REFRESH и *LockType* присвоено SQL_LOCK_ ЭКСКЛЮЗИВНЫЕ.  
  
-   Если приложение установило *LockType* для SQL_LOCK_NO_CHANGE, драйвер гарантирует успешное операцию update или delete только в том случае, если для атрибута инструкции SQL_ATTR_CONCURRENCY приложения указано SQL_CONCUR_LOCK.  
  
-   Если приложение указывает SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES для атрибута инструкции SQL_ATTR_CONCURRENCY, драйвер сравнивает версии строк или значений и отклоняет операцию, если строка была изменена, так как приложение извлечь строку.  
  
-   Если приложение указывает SQL_CONCUR_READ_ONLY для атрибута инструкции SQL_ATTR_CONCURRENCY, драйвер отклоняет любые обновления или удаления.  
  
 Дополнительные сведения о атрибута инструкции SQL_ATTR_CONCURRENCY, см. в разделе [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md).  
  
## <a name="status-and-operation-arrays"></a>Состояние и массивы операции  
 Используются следующие массивы состояние и операции, при вызове **SQLSetPos**:  
  
-   Массив статусов строк (как на него указывает поле SQL_DESC_ARRAY_STATUS_PTR в IRD и атрибут инструкции SQL_ATTR_ROW_STATUS_ARRAY) содержит значения состояния для каждой строки данных в наборе строк. Драйвер задает значения состояний в этом массиве после вызова **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, или **SQLSetPos** . Этот массив указывает атрибут значения SQL_ATTR_ROW_STATUS_PTR инструкции.  
  
-   Массива операций строк (как на него указывает поле SQL_DESC_ARRAY_STATUS_PTR Отменить и атрибут инструкции SQL_ATTR_ROW_OPERATION_ARRAY) содержит значение для каждой строки в наборе строк, указывает ли вызов **SQLSetPos**массового учитывается, либо выполнить. Каждый элемент в массиве будет присвоено SQL_ROW_PROCEED (по умолчанию) или SQL_ROW_IGNORE. Этот массив указывает атрибут SQL_ATTR_ROW_OPERATION_PTR инструкции.  
  
 Количество элементов в массивах состояние и операции должно быть равно количество строк в наборе строк (как определено в атрибуте SQL_ATTR_ROW_ARRAY_SIZE инструкции).  
  
 Сведения о массив статусов строк, см. в разделе [SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md). Сведения о массива операций строк см. в разделе «Пропуск строки в операции массового,» далее в этом разделе.  
  
## <a name="using-sqlsetpos"></a>С помощью SQLSetPos  
 Прежде чем приложение вызывает **SQLSetPos**, он должен выполнить следующие действия:  
  
1.  Если приложение вызовет **SQLSetPos** с *операции* присвоено SQL_UPDATE, вызов **SQLBindCol** (или **SQLSetDescRec**) для каждого столбец для указания типа данных и привязки буферов для данных и длина столбца.  
  
2.  Если приложение вызовет **SQLSetPos** с *операции* присвоено значение SQL_DELETE или SQL_UPDATE, вызов **SQLColAttribute** чтобы убедиться в том, что столбцы, удалить или обновить являются обновляемыми.  
  
3.  Вызовите **SQLExecDirect**, **SQLExecute**, или функции каталога для создания результирующего набора.  
  
4.  Вызовите **SQLFetch** или **SQLFetchScroll** для получения данных.  
  
 Дополнительные сведения об использовании **SQLSetPos**, см. в разделе [обновление данных с помощью SQLSetPos](../../../odbc/reference/develop-app/updating-data-with-sqlsetpos.md).  
  
## <a name="deleting-data-using-sqlsetpos"></a>Удаление данных с помощью SQLSetPos  
 Чтобы удалить данные с помощью **SQLSetPos**, приложение вызывает **SQLSetPos** с *RowNumber* задайте количество строк, чтобы удалить и *операции*значение SQL_DELETE.  
  
 После удаления данных, драйвер изменяет значение в массив статусов строк реализации для соответствующей строки SQL_ROW_DELETED (или SQL_ROW_ERROR).  
  
## <a name="updating-data-using-sqlsetpos"></a>Обновление данных с помощью SQLSetPos  
 Приложение может передавать значение для столбца в буфере привязки данных или с помощью одного или нескольких вызовов к **SQLPutData**. Столбцы, данные которого передается с **SQLPutData** известны как *данных во время выполнения* *столбцы*. Они обычно используются для отправки данных SQL_LONGVARBINARY и SQL_LONGVARCHAR столбцов и могут сочетаться с другими столбцами.  
  
#### <a name="to-update-data-with-sqlsetpos-an-application"></a>Для обновления данных с помощью SQLSetPos приложения:  
  
1.  Присоединенные разрядов значения в буферы данных и длины и индикатора **SQLBindCol**:  
  
    -   Для обычных столбцов приложение размещает новые значения столбца в  *\*TargetValuePtr* буфера и длину этого значения в  *\*StrLen_or_IndPtr* буфера. Если строка не должна быть обновлена, приложение размещает SQL_ROW_IGNORE в этой строке элемента массива операций строк.  
  
    -   Для столбцов данных времени выполнения, приложение помещает значение определяется приложением, например номер столбца в  *\*TargetValuePtr* буфера. Значение может использоваться для идентификации столбца.  
  
         Приложение размещает результат значение SQL_LEN_DATA_AT_EXEC (*длина*) макрос в **StrLen_or_IndPtr* буфера. Если тип данных SQL столбца является SQL_LONGVARBINARY, SQL_LONGVARCHAR или тип данных long зависящие от источника данных и драйвер возвращает «Y» для типа данных SQL_NEED_LONG_DATA_LEN в **SQLGetInfo**, *длина*  — количество байтов данных, отправляемых для параметра; в противном случае он должен быть неотрицательным значением и учитывается.  
  
2.  Вызовы **SQLSetPos** с *операции* аргумент значение SQL_UPDATE для обновления строки данных.  
  
    -   Если в таблице нет столбцов данных времени выполнения, процесс будет завершен.  
  
    -   Если есть столбцы данных времени выполнения, функция возвращает SQL_NEED_DATA и переходит к шагу 3.  
  
3.  Вызовы **SQLParamData** для извлечения адреса  *\*TargetValuePtr* буфера для первого столбца данных во время выполнения для обработки. **SQLParamData** возвращает SQL_NEED_DATA. Приложение извлекает значение, определенное приложением, от  *\*TargetValuePtr* буфера.  
  
    > [!NOTE]  
    >  Несмотря на то, что данные во время выполнения параметры аналогичны столбцов данных времени выполнения, значение, возвращаемое функцией **SQLParamData** отличается для каждого.  
  
    > [!NOTE]  
    >  Параметры данных во время выполнения являются параметрами в инструкции SQL, для которого данные будут отправлены с **SQLPutData** при выполнении инструкции с **SQLExecDirect** или **SQLExecute**. Они связаны с **SQLBindParameter** или задав дескрипторы с **SQLSetDescRec**. Значение, возвращенное **SQLParamData** является 32-разрядное значение, передаваемое **SQLBindParameter** в *ParameterValuePtr* аргумент.  
  
    > [!NOTE]  
    >  Столбцы данных во время выполнения являются столбцами в наборе строк, для которого данные будут отправлены с **SQLPutData** при обновлении строки с **SQLSetPos**. Они связаны с **SQLBindCol**. Значение, возвращенное **SQLParamData** — это адрес строки в **TargetValuePtr* буфера, который обрабатывается.  
  
4.  Вызовы **SQLPutData** один или несколько раз для отправки данных для столбца. Более чем один вызов является обязательным, если все значения данных не может быть возвращен в  *\*TargetValuePtr* буфера, указанного в **SQLPutData**; несколько вызовов **SQLPutData** для того же столбца разрешены только в том случае, при отправке данных символа C к столбцу с типом данных зависящие от источника символьных, двоичных или данных, или при отправке двоичных данных C для столбца с символом, двоичных данных, или тип данных зависящие от источника данных.  
  
5.  Вызовы **SQLParamData** еще раз, чтобы сообщить, что все данные отправлены для столбца.  
  
    -   Если имеются дополнительные столбцы данных времени выполнения, **SQLParamData** возвращает SQL_NEED_DATA и адрес *TargetValuePtr* буфер для следующего столбца данных во время выполнения для обработки. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет столбцов данных времени выполнения, процесс будет завершен. Если инструкция была выполнена успешно, **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; Если выполнение завершилось сбоем, возвращается значение SQL_ERROR. На этом этапе **SQLParamData** может возвращать любой SQLSTATE, которые могут быть возвращены с **SQLSetPos**.  
  
 Если данные были обновлены, драйвер изменяет значение в массив статусов строк реализации для соответствующей строки на SQL_ROW_UPDATED.  
  
 Если операция отменена, или произошла ошибка в **SQLParamData** или **SQLPutData**после **SQLSetPos** возвращает SQL_NEED_DATA и перед отправкой данных для всех столбцы данных времени выполнения, приложение может вызвать только **SQLCancel**, **SQLGetDiagField**, **SQLGetDiagRec**, **SQLGetFunctions** , **SQLParamData**, или **SQLPutData** для инструкции или соединения, связанного с инструкцией. Если он вызывает любой другой функции для инструкции или соединения, связанного с инструкцией, функция возвращает значение SQL_ERROR и параметром SQLSTATE HY010 (функционировать ошибка последовательности).  
  
 Если приложение вызывает **SQLCancel** пока драйвер по-прежнему нужны данные для столбцов данных времени выполнения, драйвер отменяет операцию. Затем приложение может вызвать **SQLSetPos** снова; Отмена не влияет на состояние курсора или текущую позицию курсора.  
  
 Если список ВЫБОРА спецификация запроса, связанный с курсором содержит несколько ссылок на один и тот же столбец, формируется ошибка, или драйвер не учитывает повторяющиеся ссылки и выполняет операции, определяемые драйвером.  
  
## <a name="performing-bulk-operations"></a>Выполнение операций массового  
 Если *RowNumber* равно 0, драйвер выполняет операцию, заданную в *операции* аргумент для каждой строки в наборе строк, имеющего значение SQL_ROW_PROCEED в поле в операцию строк Массив, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR инструкции. Это является допустимым значением для *RowNumber* аргумент для *операции* аргумент SQL_DELETE, SQL_REFRESH, или SQL_UPDATE, но не SQL_POSITION. **SQLSetPos** с *операции* из SQL_POSITION и *RowNumber* возвращает SQLSTATE HY109, равным 0 (неправильная позиция курсора).  
  
 При возникновении ошибки, относящиеся к всего набора строк, например SQLSTATE HYT00 (истекло время ожидания), драйвер возвращает значение SQL_ERROR и соответствующий код SQLSTATE. Содержимое набора строк буферов не определены, и положение курсора остается неизменным.  
  
 При возникновении ошибки, относящиеся к элементам одну строку, драйвер:  
  
-   Задает элемент для строки в массив статусов строк, указывает атрибут значения SQL_ATTR_ROW_STATUS_PTR инструкции для SQL_ROW_ERROR.  
  
-   Размещает один или несколько дополнительных SQLSTATE для ошибки в очереди ошибок и устанавливает SQL_DIAG_ROW_NUMBER поля в структуре диагностических данных.  
  
 После обработки ошибки или предупреждения, если драйвер завершает операцию для оставшихся строк в наборе строк, он возвращает значение SQL_SUCCESS_WITH_INFO. Таким образом для каждой строки, возвращается ошибка, в очередь ошибок содержит ноль или более дополнительных SQLSTATE. Если драйвер Останавливает операцию, после обработки ошибки или предупреждения, он возвращает значение SQL_ERROR.  
  
 Если драйвер возвращает все предупреждения, например SQLSTATE 01004 (данных), он возвращает предупреждения, которые применяются для всего набора строк или неизвестный строк в наборе строк, прежде чем он возвращает сведения об ошибке, которое применяется для определенных строк. Он возвращает предупреждения для определенных строк, а также сведения об ошибке о эти строки.  
  
 Если *RowNumber* равно 0 и *операции* SQL_UPDATE, SQL_REFRESH или SQL_DELETE, количество строк, **SQLSetPos** работает на нее указывает которое Атрибут инструкции _FETCHED_PTR.  
  
 Если *RowNumber* равно 0 и *операции* SQL_DELETE, SQL_REFRESH или SQL_UPDATE текущей строки после операции совпадает со значением текущей строки перед выполнением операции.  
  
## <a name="ignoring-a-row-in-a-bulk-operation"></a>Пропуск строки в операции массового  
 Можно использовать для указания, что строки в текущем наборе строк должны пропускаться во время массовой операции с помощью массива операций строк **SQLSetPos**. Чтобы направить драйвер игнорировать одну или несколько строк во время массовой операции, приложение должно выполните следующие действия:  
  
1.  Вызовите **SQLSetStmtAttr** присвоить атрибут SQL_ATTR_ROW_OPERATION_PTR инструкции, чтобы она указывала на массив SQLUSMALLINTs. Это поле можно также задать, вызвав **SQLSetDescField** задать поле заголовка SQL_DESC_ARRAY_STATUS_PTR Отменить, который требует, что приложение получает дескриптор.  
  
2.  Значение каждого элемента массива операций строк одно из двух значений:  
  
    -   SQL_ROW_IGNORE, чтобы указать, что строка исключается операции массовой.  
  
    -   SQL_ROW_PROCEED, чтобы указать, что строки будут включены в операцию массового. (Это значение по умолчанию.)  
  
3.  Вызовите **SQLSetPos** для выполнения массовой операции.  
  
 Для массива операций строк применяются следующие правила:  
  
-   SQL_ROW_IGNORE и SQL_ROW_PROCEED влияют на массовые операции, с использованием **SQLSetPos** с *операции* SQL_DELETE или SQL_UPDATE. Они не влияют на вызовы **SQLSetPos** с *операции* SQL_REFRESH или SQL_POSITION.  
  
-   Указатель устанавливается в значение null по умолчанию.  
  
-   Если указатель имеет значение null, как если все элементы были значение SQL_ROW_PROCEED обновляются все строки.  
  
-   Задание элемента для SQL_ROW_PROCEED не гарантирует, что операция будет выполняться на определенной строки. Например если определенные строки в наборе строк имеет статус SQL_ROW_ERROR, драйвер не можно обновить эту строку, независимо от того, указал ли приложение SQL_ROW_PROCEED. Приложение всегда необходимо проверить массив статусов строк, чтобы увидеть, была ли операция успешной.  
  
-   SQL_ROW_PROCEED определен как 0 в файле заголовка. Приложение можно инициализировать массива операций строк на 0, чтобы обработать все строки.  
  
-   Если задано значение «n» номер элемента в массиве строк операции SQL_ROW_IGNORE и **SQLSetPos** вызывается для выполнения массового обновления или удаления, n-й строки в наборе строк остаются без изменений после вызова **SQLSetPos**.  
  
-   Приложение должно автоматически присвоено столбца, доступное только для чтения SQL_ROW_IGNORE.  
  
## <a name="ignoring-a-column-in-a-bulk-operation"></a>Пропуск столбца в операции массового  
 Чтобы избежать лишней обработки диагностики, созданные попытки обновления один или несколько столбцов, только для чтения, приложение может задать значение привязанного длины и индикатора буфера SQL_COLUMN_IGNORE. Дополнительные сведения см. в разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение позволяет пользователю для просмотра в таблице ORDERS и обновить состояние заказа. Курсор курсоры с размером набора строк, 20 и использует управление оптимистичным параллелизмом, сравнение версий строк. После каждого набора строк извлекается, приложение выводит ее и позволяет пользователю выбрать и обновить состояние заказа. Приложение использует **SQLSetPos** для позиционирования курсора на выбранной строки и выполняет позиционированного обновления строки. (Обработка ошибок опущена для ясности).  
  
```cpp  
#define ROWS 20  
#define STATUS_LEN 6  
  
SQLCHAR        szStatus[ROWS][STATUS_LEN], szReply[3];  
SQLINTEGER     cbStatus[ROWS], cbOrderID;  
SQLUSMALLINT   rgfRowStatus[ROWS];  
SQLUINTEGER    sOrderID, crow = ROWS, irow;  
SQLHSTMT       hstmtS, hstmtU;  
  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CONCURRENCY, (SQLPOINTER) SQL_CONCUR_ROWVER, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CURSOR_TYPE, (SQLPOINTER) SQL_CURSOR_KEYSET_DRIVEN, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_ARRAY_SIZE, (SQLPOINTER) ROWS, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_STATUS_PTR, (SQLPOINTER) rgfRowStatus, 0);  
SQLSetCursorName(hstmtS, "C1", SQL_NTS);  
SQLExecDirect(hstmtS, "SELECT ORDERID, STATUS FROM ORDERS ", SQL_NTS);  
  
SQLBindCol(hstmtS, 1, SQL_C_ULONG, &sOrderID, 0, &cbOrderID);  
SQLBindCol(hstmtS, 2, SQL_C_CHAR, szStatus, STATUS_LEN, &cbStatus);  
  
while ((retcode == SQLFetchScroll(hstmtS, SQL_FETCH_NEXT, 0)) != SQL_ERROR) {  
   if (retcode == SQL_NO_DATA_FOUND)  
      break;  
   for (irow = 0; irow < crow; irow++) {  
      if (rgfRowStatus[irow] != SQL_ROW_DELETED)  
         printf("%2d %5d %*s\n", irow+1, sOrderID, NAME_LEN-1, szStatus[irow]);  
   }  
   while (TRUE) {  
      printf("\nRow number to update?");  
      gets_s(szReply, 3);  
      irow = atoi(szReply);  
      if (irow > 0 && irow <= crow) {  
         printf("\nNew status?");  
         gets_s(szStatus[irow-1], (ROWS * STATUS_LEN));  
         SQLSetPos(hstmtS, irow, SQL_POSITION, SQL_LOCK_NO_CHANGE);  
         SQLPrepare(hstmtU,  
          "UPDATE ORDERS SET STATUS=? WHERE CURRENT OF C1", SQL_NTS);  
         SQLBindParameter(hstmtU, 1, SQL_PARAM_INPUT,  
            SQL_C_CHAR, SQL_CHAR,  
            STATUS_LEN, 0, szStatus[irow], 0, NULL);  
         SQLExecute(hstmtU);  
      } else if (irow == 0) {  
         break;  
      }  
   }  
}  
```  
  
 Дополнительные примеры см. в разделе [расположен обновления и удаления инструкций](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md) и [обновление строк в наборе строк с помощью SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнения массовых операций, которые не связаны с позицией курсора блока|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одного поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Задание одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Задание нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
|Присвоение атрибуту инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
