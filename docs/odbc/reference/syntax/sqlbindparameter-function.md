---
title: Функция S'LBindParameter (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLBindParameter
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLBindParameter
helpviewer_keywords:
- SQLBindParameter function [ODBC]
ms.assetid: 38349d4b-be03-46f9-9d6a-e50dd144e225
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 02f50862bcfb0295c7f098afc6856c91e0249f66
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81301364"
---
# <a name="sqlbindparameter-function"></a>Функция SQLBindParameter

**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 2.0: ODBC  
  
 **Сводка**  
 **SLBindParameter** связывает буфер с маркером параметра в выписке s'LL. **S'LBindParameter** поддерживает привязку к типу данных Unicode C, даже если базовый драйвер не поддерживает данные Unicode.  
  
> [!NOTE]  
>  Эта функция заменяет функцию ODBC 1.0 **S'LSetParam.** Для получения дополнительной информации см.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp
  
SQLRETURN SQLBindParameter(  
      SQLHSTMT        StatementHandle,  
      SQLUSMALLINT    ParameterNumber,  
      SQLSMALLINT     InputOutputType,  
      SQLSMALLINT     ValueType,  
      SQLSMALLINT     ParameterType,  
      SQLULEN         ColumnSize,  
      SQLSMALLINT     DecimalDigits,  
      SQLPOINTER      ParameterValuePtr,  
      SQLLEN          BufferLength,  
      SQLLEN *        StrLen_or_IndPtr);  
```
  
## <a name="arguments"></a>Аргументы

 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *ParameterНомер*  
 (Вход) Номер параметра, заказанный последовательно в увеличении порядка параметра, начиная с 1.  
  
 *InputOutputType*  
 (Вход) Тип параметра. Подробнее об*этом* читайте в материале журнала "Аргументы недели" "Комментарии".  
  
 *Valuetype*  
 (Вход) Тип параметра данных C. Подробнее об этом читайте в материале журнала *"Огонек" "Аргументы ВИАза".*  
  
 *ParameterType*  
 (Вход) Тип параметра данных S'L. Подробнее об этом читайте в материале *«АргументпарамТип»* в «Комментарии».  
  
 *ColumnSize*  
 (Вход) Размер столбца или выражение соответствующего параметра маркера. Подробнее об этом читайте в материале журнала *"Огонек"* "Комментарии".  
  
 Если приложение будет работать на 64-разрядной [ODBC 64-Bit Information](../../../odbc/reference/odbc-64-bit-information.md)операционной системе Windows, см.  
  
 *DecimalDigits*  
 (Вход) Десятичные цифры столбца или выражение соответствующего параметра маркера. Для получения дополнительной информации о размере столбца см. [Размер столбца, десятичные цифры, длина переноса Octet и размер дисплея](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).  
  
 *ParameterValuePtr*  
 (Отложенный вход) Указатель на буфер для данных параметра. Подробнее об этом читайте в материале *"Аргументы параметра".*  
  
 *BufferLength*  
 (Вход/выход) Длина буфера *ParameterValuePtr* в байтах. Подробнее об этом читайте в материале *«Аргумент буферной длины»* в «Комментарии».  
  
 Смотрите [информацию ODBC 64-Bit,](../../../odbc/reference/odbc-64-bit-information.md)если ваше приложение будет работать на 64-битной операционной системе.  
  
 *StrLen_or_IndPtr*  
 (Отложенный вход) Указатель на буфер длины параметра. Подробнее об этом читайте в материале *«StrLen_or_IndPtr* Аргументы» в «Комментарии».  
  
## <a name="returns"></a>Результаты

 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика

 Когда **S'LBindParameter** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью HandleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LBindParameter,** и приведены в изъяны каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  

|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|Тип данных, идентифицированный аргументом *ValueType,* не может быть преобразован в тип данных, определенный аргументом *ParameterTypeType.* Обратите внимание на то, что эта ошибка может быть возвращена **s'LExecDirect,** **S'L'LExecute**, или **S'LPutData** во время выполнения, а не **по S'LBindParameter**.|  
|07009|Недействительный индекс дескриптора|(DM) Значение, указанное для аргумента *ParameterNumber* было меньше 1.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в буфере*MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003|Недействительный тип буфера приложения|Значение, указанное аргументом *ValueType,* не является действительным типом данных C или SQL_C_DEFAULT.|  
|HY004|Недействительный тип данных S'L|Значение, указанное для аргумента *ParameterTypeType,* не является ни действительным идентификатором типа данных ODBC S'L, ни идентификатором типа данных типа s-L, поддерживаемым драйвером.|  
|HY009|Значение недействительных аргументов|(DM) Аргумент *ParameterValuePtr* был нулевой указатель, аргумент *StrLen_or_IndPtr* был нулевой указатель, и аргумент *InputOutputType* не был SQL_PARAM_OUTPUT.<br /><br /> (DM) SQL_PARAM_OUTPUT, где аргумент *ParameterValuePtr* был нулевой указатель, тип C был символ или двоичный, и BufferLength (*cbValueMax*) был больше, чем 0.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда был вызван **S'LBindParameter.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY021|Несогласованная информация о дескрипторе|Информация о дескрипторе, проверенная во время проверки согласованности, не соответствовала. (См. раздел "Проверка согласованности" в **разделе S'LSetDescField**.)<br /><br /> Значение, указанное для аргумента *DecimalDigits,* находилось за пределами диапазона значений, поддерживаемых источником данных для столбца типа данных S'L, указанного аргументом *ParameterType.*|  
|HY090|Недействительная длина строки или буфера|(DM) Значение в *BufferLength* было меньше, чем 0. (См. описание SQL_DESC_DATA_PTR поля в **S'LSetDescField**.)|  
|HY104|Недействительное значение точности или масштаба|Значение, указанное для аргумента *ColumnSize* или *DecimalDigits,* находилось за пределами диапазона значений, поддерживаемых источником данных для столбца типа данных S'L, указанного аргументом *ParameterType.*|  
|HY105|Недействительный тип параметра|(DM) Значение, указанное для аргумента *InputOutputType,* было недействительным. (См. "Комментарии.")|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает преобразование, указанное комбинацией значения, указанного для аргумента *ValueType,* и конкретного значения драйвера, указанного для аргумента *ParameterType.*<br /><br /> Значение, указанное для аргумента *ParameterTypeType,* является действительным идентификатором типа данных ODBC для версии ODBC, поддерживаемой драйвером, но не поддерживается драйвером или источником данных.<br /><br /> Водитель поддерживает только ODBC 2. *x* и аргумент *ValueType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и все типы данных интервала C, перечисленные в [типах данных C](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: Типы данных.<br /><br /> Драйвер поддерживает версии ODBC только до 3.50, и аргумент *ValueType* был SQL_C_GUID.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии

 Приложение вызывает **S'LBindParameter,** чтобы связать каждый параметр маркера в выписке s'L. Привязки остаются в силе до тех пор, пока приложение снова не вызывает **S'LBindParameter,** вызывает **s'LFreeStmt** с опцией SQL_RESET_PARAMS или вызывает **S'LSetDescField,** чтобы установить поле заголовка SQL_DESC_COUNT APD до 0.  
  
 Для получения дополнительной информации о параметрах [см.](../../../odbc/reference/develop-app/statement-parameters.md) Для получения дополнительной информации о типах данных [Parameter Markers](../../../odbc/reference/appendixes/parameter-markers.md) параметров и маркерах параметров [см.](../../../odbc/reference/appendixes/parameter-data-types.md)  
  
## <a name="parameternumber-argument"></a>ПараметрНомер Аргумент  
 Если *ParameterNumber* в вызове к **S'LBindParameter** больше, чем значение SQL_DESC_COUNT, **S'LSetDescField** призван увеличить значение SQL_DESC_COUNT *к ParameterNumber.*  
  
## <a name="inputoutputtype-argument"></a>Аргумент вводаOutputType  
 Аргумент *InputOutputType* определяет тип параметра. Этот аргумент устанавливает SQL_DESC_PARAMETER_TYPE поле IPD. Все параметры в инструкциях по S'L, которые не вызывают процедуры, такие как операторы **INSERT,** являются *входным параметром.* Параметры в процедурных вызовах могут быть входные, входные/выходные или выходные параметры. (Приложение вызывает **S'LProcedureColumns** для определения типа параметра в вызове процедуры; параметры, тип которых не может быть определен, считаются параметрами ввода.)  
  
 Аргумент *InputOutputType* может иметь одно из следующих значений:  
  
-   SQL_PARAM_INPUT. Параметр помечает параметр в выписке s'L, которая не вызывает процедуру, например, заявление **INSERT,** или отмечает параметр ввода в процедуре. Например, параметры в **INSERT INTO Employee VALUES (?, ?, ?)** являются входными параметрами, в то время как параметры в **«вызове AddEmp( ?, ?, ?) »** могут быть, но не обязательно, входными параметрами.  
  
     Когда выписка выполняется, драйвер отправляет данные для параметра в источник данных; \*Буфер *ParameterValuePtr* должен содержать допустимое вхожее значение, или буфер*StrLen_or_IndPtr* должен содержать SQL_NULL_DATA, SQL_DATA_AT_EXEC или результат макроса SQL_LEN_DATA_AT_EXEC.  
  
     Если приложение не может определить тип параметра в вызове процедуры, оно устанавливает *InputOutputType* на SQL_PARAM_INPUT; если источник данных возвращает значение для параметра, драйвер отбрасывает его.  
  
-   SQL_PARAM_INPUT_OUTPUT. Параметр отмечает вхотогальный/выходный параметр в процедуре. Например, параметр в **«вызов GetEmpDept(?) —** это параметр ввода/вывода, который принимает имя сотрудника и возвращает имя отдела сотрудника.  
  
     Когда выписка выполняется, драйвер отправляет данные для параметра в источник данных; буфер *ParameterValuePtr* должен содержать допустимое значение \*ввода, или StrLen_or_IndPtr буфер должен содержать SQL_NULL_DATA, SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT_EXEC макроса. *StrLen_or_IndPtr* \* После выполнения оператора драйвер возвращает данные для параметра в приложение; если источник данных не возвращает значение для параметра ввода/вывода, драйвер устанавливает буфер*StrLen_or_IndPtr* в SQL_NULL_DATA.  
  
    > [!NOTE]  
    >  Когда приложение ODBC 1.0 вызывает **S'LSetParam** в драйвере ODBC 2.0, менеджер драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера — это превращается в вызов в **S'LBindParameter,** в котором аргумент *InputOutputType* установлен на SQL_PARAM_INPUT_OUTPUT.  
  
-   SQL_PARAM_OUTPUT. Параметр отмечает возвратное значение процедуры или выходный параметр в процедуре; в любом случае они известны как *параметры вывода.* Например, параметр в **«?» — вызов GetNextEmpID** — это параметр вывода, который возвращает идентификатор следующего сотрудника.  
  
     После выполнения оператора драйвер возвращает данные для параметра в приложение, если *только ParameterValuePtr* и *StrLen_or_IndPtr* аргументы не являются указателями null pointers, и в этом случае драйвер отбрасывает выходное значение. Если источник данных не возвращает значение для параметра вывода, драйвер устанавливает буфер*StrLen_or_IndPtr* в SQL_NULL_DATA.  
  
-   SQL_PARAM_INPUT_OUTPUT_STREAM. Означает, что параметр ввода/вывода должен передаваться. **СЗЛГетДата** может считывать значения параметров по частям. *BufferLength* игнорируется, потому что длина буфера будет определена по вызову **S'LGetData.** Значение *буфера StrLen_or_IndPtr* должно содержать SQL_NULL_DATA, SQL_DEFAULT_PARAM, SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT_EXEC макроса. Параметр должен быть связан как параметр data-at-execution (DAE) при вхотворе, если он будет передаваться на выходе. *ParameterValuePtr* может быть любым значением ненулевой указателя, которое будет возвращено **S'LParamData** в качестве символа, определяемого пользователем, значение которого было передано *с помощью ParameterValuePtr* как для ввода, так и для вывода. Дополнительные сведения см. в разделе [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_PARAM_OUTPUT_STREAM. То же самое, что и SQL_PARAM_INPUT_OUTPUT_STREAM, для параметра вывода. **StrLen_or_IndPtr* игнорируется при вхотре.  
  
 В следующей таблице перечислены различные комбинации *InputOutputType* и*StrLen_or_IndPtr:*  
  
|*InputOutputType*|**StrLen_or_IndPtr*|Результат|Замечание по параметруValuePtr|  
|-----------------------|----------------------------|-------------|---------------------------------|  
|SQL_PARAM_INPUT|SQL_LEN_DATA_AT_EXEC *(len)* или SQL_DATA_AT_EXEC|Вход ные части|*ParameterValuePtr* может быть любым значением указателя, которое будет возвращено **S'LParamData** в качестве символа, определяемого пользователем, значение которого было передано с *помощью ParameterValuePtr.*|  
|SQL_PARAM_INPUT|Не SQL_LEN_DATA_AT_EXEC *(len)* или SQL_DATA_AT_EXEC|Буфер вхотвора связанного|*ParameterValuePtr* — это адрес вхотоза.|  
|SQL_PARAM_OUTPUT|Игнорируется при вхотре.|Буфер, связанный с выходом|*ParameterValuePtr* — это адрес буфера вывода.|  
|SQL_PARAM_OUTPUT_STREAM|Игнорируется при вхотре.|Потоковая мощность|*ParameterValuePtr* может быть любым значением указателя, которое будет возвращено **S'LParamData** в качестве символа, определяемого пользователем, значение которого было передано с *помощью ParameterValuePtr.*|  
|SQL_PARAM_INPUT_OUTPUT|SQL_LEN_DATA_AT_EXEC *(len)* или SQL_DATA_AT_EXEC|Входные данные по частям и буферу выходного связанного|*ParameterValuePtr* — это адрес буфера вывода, который также будет возвращен **S'LParamData** в качестве символа, определяемого пользователем, значение которого было передано *с помощью ParameterValuePtr.*|  
|SQL_PARAM_INPUT_OUTPUT|Не SQL_LEN_DATA_AT_EXEC *(len)* или SQL_DATA_AT_EXEC|Буфер вхотворного связанного и выходного связанного буфера|*ParameterValuePtr* — это адрес буфера общего ввода/вывода.|
|SQL_PARAM_INPUT_OUTPUT_STREAM|SQL_LEN_DATA_AT_EXEC *(len)* или SQL_DATA_AT_EXEC|Входные данные по частям и потоковому выходу|*ParameterValuePtr* может быть любым значением ненулевой указателя, которое будет возвращено **S'LParamData** в качестве символа, определяемого пользователем, значение которого было передано *с помощью ParameterValuePtr* как для ввода, так и для вывода.|  
  
> [!NOTE]  
>  Драйвер должен решить, какие типы S'L разрешены, когда приложение связывает параметр вывода или ввода- Менеджер драйвера не генерирует ошибку для недействительного типа S'L.  
  
## <a name="valuetype-argument"></a>Аргумент ValueType

 Аргумент *ValueType* определяет тип данных C параметра. Этот аргумент устанавливает SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE поля APD. Это должно быть одно из значений в разделе [C Типы данных](../../../odbc/reference/appendixes/c-data-types.md) приложения D: Типы данных.  
  
 Если аргумент *ValueType* является одним из типов интервальных данных, SQL_DESC_TYPE поле записи *ParameterNumber* APD установлено для SQL_INTERVAL, SQL_DESC_CONCISE_TYPE поле APD устанавливается для краткого типа данных интервала, а SQL_DESC_DATETIME_INTERVAL_CODE поле записи *ParameterNumber* устанавливается в подкод для конкретного типа данных интервала. [(См. Приложение D: Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).) Для данных используются точность интервала по умолчанию (2) и точность секунд интервала по умолчанию (6), установленные в SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION полях APD соответственно. Если точность по умолчанию не подходит, приложение должно четко установить поле дескриптора по вызову на **S'LSetDesccField** или **S'LSetDescRec.**  
  
 Если аргумент *ValueType* является одним из типов данных по дате, SQL_DESC_TYPE поле записи *ParameterNumber* APD установлено для SQL_DATETIME, SQL_DESC_CONCISE_TYPE поле записи *ParameterNumber* APD устанавливается для краткого типа данных timetime C, а SQL_DESC_DATETIME_INTERVAL_CODE поле записи *ParameterNumber* устанавливается в подкод для конкретного типа данных datetime. [(См. Приложение D: Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)  
  
 Если аргумент *ValueType* является SQL_C_NUMERIC типом данных, для данных используется точность по умолчанию (которая определяется драйвером) и шкала по умолчанию (0), установленная в SQL_DESC_PRECISION и SQL_DESC_SCALE полях APD. Если точность или масштаб по умолчанию не подходит, приложение должно четко установить поле дескриптора по вызову в **S'LSetDescfield** или **S'LSetDescRec.**  
  
 SQL_C_DEFAULT указывает, что значение параметра будет перенесено из типа данных C по умолчанию для типа данных S'L, указанного *в ParameterType.*  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 Для получения дополнительной информации в приложении D: Типы данных по [умолчанию C,](../../../odbc/reference/appendixes/default-c-data-types.md) [преобразование данных от C до типов данных СЗЛ](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md)и [преобразование данных с S'L на C-типы данных.](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md)  
  
## <a name="parametertype-argument"></a>ПараметрТипТип Аргумент

 Это должно быть одно из значений, перечисленных в разделе [Типы данных в](../../../odbc/reference/appendixes/sql-data-types.md) приложении D: Типы данных, или оно должно быть значением, относяжье конкретное значение драйвера. Этот аргумент устанавливает SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE поляМи IPD.  
  
 Если аргумент *ParameterTypeType* является одним из идентификаторов времени даты, SQL_DESC_TYPE поле IPD настроено на SQL_DATETIME, поле SQL_DESC_CONCISE_TYPE IPD устанавливается в наборе типа данных datetime S'L, а SQL_DESC_DATETIME_INTERVAL_CODE поле настроено на соответствующее значение подкода datetime.  
  
 Если *ParameterTypeType* является одним из идентификаторов интервала, SQL_DESC_TYPE поле IPD настроено на SQL_INTERVAL, поле SQL_DESC_CONCISE_TYPE IPD устанавливается в наборный тип интервалов S'L, а SQL_DESC_DATETIME_INTERVAL_CODE поле IPD устанавливается в соответствующий интервальный подкод. Поле SQL_DESC_DATETIME_INTERVAL_PRECISION IPD устанавливается с интервалом, ведущей точностью, а SQL_DESC_PRECISION поле устанавливается с точностью интервалных секунд, если это применимо. Если значение по умолчанию SQL_DESC_DATETIME_INTERVAL_PRECISION или SQL_DESC_PRECISION не подходит, приложение должно четко установить его, позвонив по **s'LSetDescField.** Для получения более подробной информации о любом из этих полей, [см.](../../../odbc/reference/syntax/sqlsetdescfield-function.md)  
  
 Если аргумент *ValueType* является SQL_NUMERIC типом данных, для данных используется точность по умолчанию (которая определяется драйвером) и шкала по умолчанию (0), установленная в SQL_DESC_PRECISION и SQL_DESC_SCALE полях IPD. Если точность или масштаб по умолчанию не подходит, приложение должно четко установить поле дескриптора по вызову в **S'LSetDescfield** или **S'LSetDescRec.**  
  
 Для получения информации о том, как преобразуются данные, см. [Преобразование данных с Типа данных С-L в S-L](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md) и [преобразование данных с S'L на C типы данных](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложении D: Типы данных.  
  
## <a name="columnsize-argument"></a>КолонкаРазмер Аргумент

 Аргумент *ColumnSize* определяет размер столбца или выражения, соответствующий маркеру параметра, длину этих данных или и то, и другое. Этот аргумент устанавливает различные поля IPD, в зависимости от типа данных S'L (аргумент *ParameterTypeType).* Следующие правила применяются к этому отображению:  
  
-   Если *ParameterTypeType* SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY или один из кратких типов дат или интервалов S'L, SQL_DESC_LENGTH поле IPD устанавливается *значениеcolumnSize.* (Для получения дополнительной информации в приложении D: Типы данных [см.](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)  
  
-   Если *ParameterType* — это SQL_DECIMAL, SQL_NUMERIC, SQL_FLOAT, SQL_REAL или SQL_DOUBLE, то SQL_DESC_PRECISION поле IPD устанавливается *значением ColumnSize.*  
  
-   Для других типов данных аргумент *ColumnSize* игнорируется.  
  
 Подробнее об этом читайте в материале «Передача параметра» и SQL_DATA_AT_EXEC в *«StrLen_or_IndPtr* Аргумент».  
  
## <a name="decimaldigits-argument"></a>Аргумент десятичных дигидов

 Если *ParameterTypeявляется* SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP, SQL_INTERVAL_SECOND, SQL_INTERVAL_DAY_TO_SECOND, SQL_INTERVAL_HOUR_TO_SECOND или SQL_INTERVAL_MINUTE_TO_SECOND, SQL_DESC_PRECISION поле IPD настроено на *десятичные диджиты.* Если *ParameterType* SQL_NUMERIC или SQL_DECIMAL, SQL_DESC_SCALE поле IPD установлено на *десятичные диджиты.* Для всех других типов данных аргумент *DecimalDigits* игнорируется.  
  
## <a name="parametervalueptr-argument"></a>ПараметрВалеПтР Аргумент

 Аргумент *ParameterValuePtr* указывает на буфер, который, когда **s'LExecute** или **S'LExecDirect** вызывается, содержит фактические данные для параметра. Данные должны быть в форме, указанной аргументом *ValueType.* Этот аргумент устанавливает SQL_DESC_DATA_PTR поле APD. Приложение может установить аргумент *ParameterValuePtr* на нулевую точку, если * \*StrLen_or_IndPtr* SQL_NULL_DATA или SQL_DATA_AT_EXEC. (Это относится только к вхотворным или вхотворным/выходным параметрам.)  
  
 Если \* *StrLen_or_IndPtr* является результатом макро-макро-или SQL_DATA_AT_EXEC SQL_LEN_DATA_AT_EXEC *(длины),* то *ParameterValuePtr* представляет собой значение указателя, определяемого приложением, связанное с параметром. Возвращается в приложение через **S'LParamData**. Например, *ParameterValuePtr* может быть ненулевым токеном, таким как номер параметра, указатель на данные или указатель на структуру, которую приложение использовало для связывания параметров ввода. Однако обратите внимание, что если параметр является параметром ввода/вывода, *ParameterValuePtr* должен быть указателем на буфер, где будет храниться выходное значение. Если значение в атрибуте SQL_ATTR_PARAMSET_SIZE оператора превышает 1, приложение может использовать значение, на которое указывает атрибут SQL_ATTR_PARAMS_PROCESSED_PTR оператора вместе с аргументом *ParameterValuePtr.* Например, *ParameterValuePtr* может указывать на массив значений, а приложение может использовать значение, на которое указывает SQL_ATTR_PARAMS_PROCESSED_PTR для получения правильного значения из массива. Для получения дополнительной информации смотрите в этом разделе раздел "Проходя значения параметра".  
  
 Если аргумент *InputOutputType* SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, *ParameterValuePtr* указывает на буфер, в котором драйвер возвращает выходное значение. Если процедура возвращает один или несколько наборов результатов, \*буфер *ParameterValuePtr* не гарантируется устанавливаться до тех пор, пока не будут обработаны все наборы результатов/строки. Если буфер не установлен до завершения обработки, параметры вывода и значения возврата недоступны до тех пор, пока SQL_NO_DATA не вернется **sLMoreResults.** Вызов **S'LCloseCursor** или **S'LFreeStmt** с опцией SQL_CLOSE приведет к тому, что эти значения будут отброшены.  
  
 Если значение в SQL_ATTR_PARAMSET_SIZE атрибута оператора превышает 1, *ParameterValuePtr* указывает на массив. Одно заявление S'L обрабатывает полный массив входных значений для ввода или ввода/параметра вывода/вывода и возвращает массив выходных значений для ввода/вывода или параметра вывода.  
  
## <a name="bufferlength-argument"></a>БуферДлин Аргумент

 Для данных о характере и двоичных C аргумент \* *BufferLength* определяет длину буфера *ParameterValuePtr* (если это \*один элемент) или длину элемента в массиве *ParameterValuePtr* (если значение в атрибуте SQL_ATTR_PARAMSET_SIZE оператора больше 1). Этот аргумент устанавливает SQL_DESC_OCTET_LENGTH рекордное поле APD. Если приложение определяет несколько значений, *BufferLength* используется для определения местоположения значений в массиве*ParameterValuePtr,* как по входной, так и по выходу. Для параметров ввода/вывода и вывода используется для определения того, следует ли усеивать данные о символах и двоичных C на выходе:  
  
-   Для данных персонажа C, если количество байтов, доступных для возврата, \*больше или равно *BufferLength,* данные в *ParameterValuePtr* усечены до *BufferLength* меньше длины символа с нулевым прекращением и сведены на нет водителем.  
  
-   Для двоичных c данных, если количество байтов, доступных \*для возврата, больше, чем *BufferLength*, данные в *ParameterValuePtr* усечены до *байтов BufferLength.*  
  
 Для всех других типов данных C аргумент *BufferLength* игнорируется. Длина \*буфера *ParameterValuePtr* (если это один элемент) или длина \*элемента в массиве *ParameterValuePtr* (если приложение вызывает **S'LSetStmtAttr** с аргументом *атрибута* SQL_ATTR_PARAMSET_SIZE указать несколько значений для каждого параметра) считается длиной типа данных C.  
  
 Для потокового вывода или streamed ввода / выходных параметров аргумент *BufferLength* игнорируется, потому что длина буфера указана в **S'LGetData.**  
  
> [!NOTE]  
>  Когда приложение ODBC 1.0 вызывает **S'LSetParam** в ODBC 3. *x* драйвер, менеджер драйвера преобразует это в вызов в **S'LBindParameter,** в котором аргумент *BufferLength* всегда SQL_SETPARAM_VALUE_MAX. Потому что менеджер драйвера возвращает ошибку, если ODBC 3. *приложение x* устанавливает *BufferLength* для SQL_SETPARAM_VALUE_MAX, ODBC 3. *x* драйвер может использовать это, чтобы определить, когда он вызывается приложением ODBC 1.0.  
  
> [!NOTE]  
>  В **S'LSetParam**, способ, в котором приложение определяет длину буфера*ParameterValuePtr,* так что водитель может вернуть символ или двоичные данные, и то, каким образом приложение посылает массив символов или бинарных параметров значения для водителя, определяются драйвером.  
  
## <a name="strlen_or_indptr-argument"></a>StrLen_or_IndPtr Аргумент

 Аргумент *StrLen_or_IndPtr* указывает на буфер, который, когда называется **S'LExecute** или **S'LExecDirect,** содержит один из следующих. (Этот аргумент устанавливает SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR поля записи указателей параметров приложения.)  
  
-   Длина значения параметра, хранящегося в*параметреValuePtr*. Это игнорируется, за исключением символов или двоичных данных C.  
  
-   SQL_NTS. Значение параметра является нулевой строкой.  
  
-   SQL_NULL_DATA. Значение параметра NULL.  
  
-   SQL_DEFAULT_PARAM. Процедура заключается в использовании значения параметра по умолчанию вместо значения, извлеченного из приложения. Это значение допустимо только в процедуре, называемой каноническим синтаксисом ODBC, и только в том случае, если аргумент *InputOutputType* SQL_PARAM_INPUT, SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_INPUT_OUTPUT_STREAM. Когда \* *StrLen_or_IndPtr* SQL_DEFAULT_PARAM, *ValueType,* *ParameterTypeType,* *ColumnSize,* *DecimalDigits,* *BufferLength*и *ParameterValuePtr* аргументы игнорируются для входнаих параметров и используются только для определения значения параметра вывода для параметров ввода/вывода.  
  
-   Результат SQL_LEN_DATA_AT_EXEC *(длина)* макроса. Данные по параметру будут отправлены с **помощью S'LPutData**. Если аргумент *ParameterTypeType* — это SQL_LONGVARBINARY, SQL_LONGVARCHAR или длинный тип данных, касающийся конкретного источника данных, и водитель возвращает "Y" для SQL_NEED_LONG_DATA_LEN типа информации в **S'LGetInfo,** *длина* — это количество байтов данных, которые будут отправлены для параметра; в противном случае *длина* должна быть ненегативной и игнорируется. Для получения дополнительной информации смотрите в этом разделе "Проходя значения параметра".  
  
     Например, указать, что 10 000 байт данных будут отправлены с **помощью S'LPutData** в одном или нескольких вызовах, по SQL_LONGVARCHAR параметру наборы приложений*StrLen_or_IndPtr* до SQL_LEN_DATA_AT_EXEC (10000).  
  
-   SQL_DATA_AT_EXEC. Данные по параметру будут отправлены с **помощью S'LPutData**. Это значение используется приложениями ODBC 1.0 при вызове ODBC 3. *x* драйверов. Для получения дополнительной информации смотрите в этом разделе "Проходя значения параметра".  
  
 Если *StrLen_or_IndPtr* является нулевой указателем, драйвер предполагает, что все значения ввода параметров не являются NULL и что символ и двоичные данные непрекращаются. Если *InputOutputType* SQL_PARAM_OUTPUT или SQL_PARAM_OUTPUT_STREAM и *ParameterValuePtr* и *StrLen_or_IndPtr* являются указателями нуля, драйвер отбрасывает выходное значение.  
  
> [!NOTE]  
>  Разработчикам приложений настоятельно рекомендуется указывать указатель нуля для *StrLen_or_IndPtr,* когда тип данных параметра SQL_C_BINARY. Чтобы водитель не усечен SQL_C_BINARY данных, *StrLen_or_IndPtr* должны содержать указатель на допустимое значение длины.  
  
 Если аргумент *InputOutputType* SQL_PARAM_INPUT_OUTPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, *StrLen_or_IndPtr* указывает на буфер, в котором водитель возвращается SQL_NULL_DATA, количество байтов, доступных для возврата в \* *ParameterValuePtr* (за исключением нулевого завершения байт данных о символах), или SQL_NO_TOTAL (если количество байтов, доступных для возврата, не может быть определено). Если процедура возвращает один или несколько наборов результатов, буфер*StrLen_or_IndPtr* не гарантируется установлением до тех пор, пока не будут извлечены все результаты.  
  
 Если значение в атрибуте SQL_ATTR_PARAMSET_SIZE оператора превышает 1, *StrLen_or_IndPtr* указывает на массив значений S'LLEN. Это может быть любое из значений, перечисленных ранее в этом разделе, и обрабатываются с помощью одной выписки по S'L.  
  
## <a name="passing-parameter-values"></a>Прохождение параметров значения

 Приложение может передавать значение параметра либо \*в буфере *ParameterValuePtr,* либо с одним или более вызовами на **S'LPutData.** Параметры, данные которых передаются с **помощью s'LPutData,** известны как параметры *данных по исполнению.* Они обычно используются для передачи данных для SQL_LONGVARBINARY и SQL_LONGVARCHAR параметров, и могут быть смешаны с другими параметрами.  
  
 Чтобы пройти значения параметров, приложение выполняет следующую последовательность шагов:  
  
1.  Вызовы **S'LBindParameter** для каждого параметра связывают буферы для значения параметра *(аргумент ParameterValuePtr)* и длины/индикатора *(StrLen_or_IndPtr* аргумент). Для параметров data-at-execution *ParameterValuePtr* представляет собой определяемое приложениезначение, такое как число параметров или указатель к данным. Значение будет возвращено позже и может быть использовано для определения параметра.  
  
2.  Место значений для входных и входных/выходных параметров в \* *ParameterValuePtr* и*StrLen_or_IndPtr* буферов:  
  
    -   Для нормальных параметров приложение помещает значение \*параметра в буфер *ParameterValuePtr* и длину этого значения в буфер*StrLen_or_IndPtr.* Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/setting-parameter-values.md)  
  
    -   Для параметров выполнения данных приложение помещает результат SQL_LEN_DATA_AT_EXEC *(длина)* макроса (при вызове драйвера ODBC 2.0) в буфер*StrLen_or_IndPtr.*  
  
3.  Для выполнения оператора **S'LExecute** или S'LExecDirect вызывает s'LExecute или **S'LExecDirect.**  
  
    -   При отсутствии параметров выполнения данных процесс завершен.  
  
    -   При наличии каких-либо параметров выполнения данных функция возвращается SQL_NEED_DATA.  
  
4.  Вызывает **S'LParamData** для получения значения, определяемого приложением, указанного в аргументе *ParameterValuePtr* **для** первого параметра данных по исполнению, который будет обработан. **S'LParamData** возвращает SQL_NEED_DATA.  
  
    > [!NOTE]  
    >  Несмотря на то, что параметры данных по исполнению напоминают столбцы данных по исполнению, значение, возвращенное **S'LParamData,** отличается для каждого из них. Параметры «данные по исполнению» — это параметры, в которых данные будут отправлены с **помощью S'LPutData,** когда выписка будет выполнена с **помощью S'LExecDirect** или **S'LExecute.** Они связаны с **S'LBindParameter**. Значение, возвращенное **S'LParamData,** является указательным значением, передаваемым в аргумент **ЕЗлБандерпараст** в аргументе *ParameterValuePtr.* Столбцы «Данные по исполнению» — это столбцы в строке, для которых данные будут отправлены с **помощью S'LPutData** при обновлении или добавлении строки с **помощью S'LBulkOperations** или обновления с **помощью S'LSetPos.** Они связаны с **S'LBindCol**. Значение, возвращенное **S'LParamData,** является адресом строки в буфере*TargetValuePtr* (установленном вызовом в **S'LBindCol),** который обрабатывается.  
  
5.  Для отправки данных по параметру, для отправки данных по параметру, **вынаправляется один** или несколько раз. Требуется более одного вызова, если значение \*данных больше буфера *ParameterValuePtr,* указанного в **S'LPutData;** несколько вызовов на **S'LPutData** по тому же параметру допускаются только при отправке данных персонажа C в столбец с типом данных, двоичным или исходным источником данных, или при отправке бинарных данных C в столбец с типом данных, двоичных или исходных данных.  
  
6.  Снова вызывает **S'LParamData,** чтобы сигнализировать о том, что все данные отправлены по параметру.  
  
    -   При наличии большего числа параметров,как выполнение данных, **s'LParamData** возвращает SQL_NEED_DATA и определенное значение приложения для следующего параметра данных по исполнению, которое будет обработано. Приложение повторяет шаги 4 и 5.  
  
    -   Если параметров «данные по исполнению» больше нет, процесс завершен. Если выписка была успешно выполнена, **sLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; если выполнение не удалось, он возвращает SQL_ERROR. На этом **этапе, S'LParamData** может вернуть любой S'Lstate, которые могут быть возвращены функцией, которая используется для выполнения оператора **(S'LExecDirect** или **S'LExecute**).  
  
         Значения вывода для любых входных/выходных или выходных параметров доступны в \* *параметре ParameterValuePtr* и*StrLen_or_IndPtr* буферах после того, как приложение извлекает все наборы результатов, генерируемые выпиской.  
  
 Вызов **S'LExecute** или **S'LExecDirect** помещает заявление в SQL_NEED_DATA состоянии. На этом этапе приложение может вызывать только **S'LCancel,** **S'LGetDiagField**, **S'LGetDiagRec**, **S'LGetФункции**, **S'LParamData**, или **S'LPutData** с заявлением или *ручкой соединения,* связанной с заявлением. Если он вызывает любую другую функцию с заявлением или соединением, связанным с выпиской, функция возвращает S'LSTATE HY010 (ошибка последовательности функции). Выписка оставляет SQL_NEED_DATA состояние, когда **S'LParamData** или **S'LPutData** возвращает ошибку, **S'LParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, или заявление отменяется.  
  
 Если приложение вызывает **S'LCancel,** в то время как водителю по-прежнему нужны данные для параметров выполнения данных, драйвер отменяет выполнение оператора; затем приложение может снова вызвать **s'LExecute** или **S'LExecDirect.**  
  
## <a name="retrieving-streamed-output-parameters"></a>Извлечение параметров потокового вывода

 Когда приложение устанавливает *InputOutputType* на SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, значение параметра вывода должно быть извлечено одним или несколько вызовами в **S'LGetData.** Когда драйвер имеет потоковое значение параметра вывода, чтобы вернуться в приложение, он вернется SQL_PARAM_DATA_AVAILABLE в ответ на вызов к следующим функциям: **S'LMoreResults**, **S'LExecute**, и **S'LExecDirect**. Приложение вызывает **S'LParamData,** чтобы определить, какой параметр имеется.  
  
 Для получения дополнительной информации о SQL_PARAM_DATA_AVAILABLE [Retrieving Output Parameters Using SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)и streamed параметрах вывода см.  
  
## <a name="using-arrays-of-parameters"></a>Использование массивов параметров

 Когда приложение готовит заявление с параметрами и проходит в массиве параметров, есть два различных способа, которые это может быть выполнено. Один из способов заключается в том, чтобы драйвер полагался на возможности обработки массивов задней части, и в этом случае все утверждение с массивом параметров рассматривается как одна атомная единица. Oracle является примером источника данных, который поддерживает возможности обработки массивов. Еще один способ реализации этой функции заключается в том, чтобы драйвер генерирует пакет инструкций по S'L, по одному оператору S-L для каждого набора параметров в массиве параметров, и выполняет пакет. Массивы параметров не могут быть использованы с **обновлением, где CURRENT OF** оператора.  
  
 При обработке массива параметров могут быть доступны отдельные наборы/ряды результатов (по одному для каждого набора параметров) или количество наборов/рядов в результате может быть свернуто в один. Вариант SQL_PARAM_ARRAY_ROW_COUNTS в **S'LGetInfo** указывает, доступны ли количество строк для каждого набора параметров (SQL_PARC_BATCH) или доступно только одно количество строк (SQL_PARC_NO_BATCH).  
  
 Вариант SQL_PARAM_ARRAY_SELECTS в **S'LGetInfo** указывает, доступен ли набор результатов для каждого набора параметров (SQL_PAS_BATCH) или доступен только один набор результатов (SQL_PAS_NO_BATCH). Если драйвер не допускает выполнение оператора, генерирующего результат, с помощью массива параметров, SQL_PARAM_ARRAY_SELECTS возвращает SQL_PAS_NO_SELECT.  
  
 Для получения более подробной информации, [см.](../../../odbc/reference/syntax/sqlgetinfo-function.md)  
  
 Для поддержки массивов параметров в SQL_ATTR_PARAMSET_SIZE атрибута оператора устанавливается определение количества значений для каждого параметра. Если поле больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR поля APD должны указывать на массивы. Кардинальность каждого массива равна значению SQL_ATTR_PARAMSET_SIZE.  
  
 Поле SQL_DESC_ROWS_PROCESSED_PTR APD указывает на буфер, содержащий количество обработанных параметров, включая наборы ошибок. При обработке каждого набора параметров драйвер сохраняет новое значение в буфере. Номер не будет возвращен, если это нулевая указка. При использовании массивов параметров значение, на SQL_DESC_ROWS_PROCESSED_PTR поле APD, заполняется, даже если SQL_ERROR возвращается функцией настройки. При возврате SQL_NEED_DATA значение, на которое указывает SQL_DESC_ROWS_PROCESSED_PTR поле APD, устанавливается набором параметров, которые обрабатываются.  
  
 Что происходит, когда массив параметров связан и **ОБНОВЛЕНИЕ, где current of** statement выполняется, определяется драйвером.  
  
## <a name="column-wise-parameter-binding"></a>Колонка-Мудрый параметр Связывание

 В связке с характерю столбцов приложение связывает отдельные параметры и массивы длины/индикатора с каждым параметром.  
  
 Для использования связывания с характерю столбцов приложение сначала устанавливает атрибут SQL_ATTR_PARAM_BIND_TYPE оператора на SQL_PARAM_BIND_BY_COLUMN. (Это по умолчанию.) Для того чтобы каждый столбец был связан, приложение выполняет следующие действия:  
  
1.  Выделяет массив буфера параметра.  
  
2.  Выделяет массив буферов длины/индикатора.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно дескрипторы, когда используется связывание с характерю столбца, для данных длины и индикатора можно использовать отдельные массивы.  
  
3.  Вызывает **S'LBindParameter** со следующими аргументами:  
  
    -   *ValueType* — это тип C одного элемента в массиве буфера параметра.  
  
    -   *ParameterTypeType* — это тип параметра.  
  
    -   *ParameterValuePtr* — это адрес параметра буферного массива.  
  
    -   *BufferLength* — это размер одного элемента в массиве буфера параметра. Аргумент *BufferLength* игнорируется, когда данные имеют фиксированную длину данных.  
  
    -   *StrLen_or_IndPtr* является адрес массива длины/индикатора.  
  
 Более подробную информацию о том, как используется эта информация, смотрите в разделе "Аргумент ПаратерВалепетр" в разделе "Комментарии". Для получения дополнительной информации о столбцовой связи параметров [см.](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md)  
  
## <a name="row-wise-parameter-binding"></a>Строка-Мудрый параметр Связывание

 В связке с рядом приложение определяет структуру, содержащую параметры и буферы длины/индикатора для каждого параметра, который должен быть связан.  
  
 Для использования связывания с рядом приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения одного набора параметров (включая как параметр, так и буферы длины/индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно дескрипторы при использовании связывания, для данных о длине и индикаторе можно использовать отдельные поля.  
  
2.  Устанавливает атрибут SQL_ATTR_PARAM_BIND_TYPE оператора к размеру структуры, содержащей один набор параметров, или к размеру экземпляра буфера, в который будут связаны параметры. Длина должна включать пространство для всех связанных параметров и любую обивку структуры или буфера, чтобы убедиться, что, когда адрес связанного параметра приравнируется с заданной длиной, результат укажет на начало одного и того же параметра в следующем ряду. При использовании *оператора sizeof* в ANSI C такое поведение гарантируется.  
  
3.  Вызывает **S'LBindParameter** со следующими аргументами для каждого параметра, который будет связан:  
  
    -   *ValueType* — это тип параметра, который должен быть привязан к столбцю.  
  
    -   *ParameterTypeType* — это тип параметра.  
  
    -   *ParameterValuePtr* — это адрес элемента буфера параметра в элементе первого массива.  
  
    -   *BufferLength* — это размер параметра буфера.  
  
    -   *StrLen_or_IndPtr* является адресом участника длины/индикатора, который должен быть связан.  
  
 Подробнее о том, как используется эта информация, читайте в материале *«Аргумент параметрValueValuePtr»* позже в этом разделе. Для получения дополнительной информации о строке-мудрый связывания параметров, [см.](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md)  
  
## <a name="error-information"></a>Сведения об ошибке

 Если драйвер не реализует параметры как пакеты (SQL_PARAM_ARRAY_ROW_COUNTS вариант равен SQL_PARC_NO_BATCH), ошибки обрабатываются так, как если бы одна выписка была выполнена. Если драйвер реализует параметры как пакеты, приложение может использовать поле заголовка SQL_DESC_ARRAY_STATUS_PTR IPD, чтобы определить, какой параметр оператора S'L или какой параметр в массиве параметров вызвал **s'LExecDirect** или **S'LExecute,** чтобы вернуть ошибку. Это поле содержит информацию о состоянии для каждой строки значений параметров. Если поле указывает на ошибку, поля в структуре диагностических данных будут указывать строку и номер параметра параметра, который не удался. Количество элементов в массиве будет определяться полем заголовка SQL_DESC_ARRAY_SIZE в APD, которое может быть установлено атрибутом SQL_ATTR_PARAMSET_SIZE оператора.  
  
> [!NOTE]  
>  Поле заголовка SQL_DESC_ARRAY_STATUS_PTR в APD используется для игнорирования параметров. Для получения дополнительной информации об игнорировании параметров, см.  
  
 Когда SQL_ERROR возвращается **s'LExecute** или **S'LExecDirect,** элементы массива, на которые указывает SQL_DESC_ARRAY_STATUS_PTR поле в IPD, будут содержать SQL_PARAM_ERROR, SQL_PARAM_SUCCESS, SQL_PARAM_SUCCESS_WITH_INFO, SQL_PARAM_UNUSED или SQL_PARAM_DIAG_UNAVAILABLE.  
  
 Для каждого элемента в этом массиве структура диагностических данных содержит одну или несколько записей о состоянии. В SQL_DIAG_ROW_NUMBER поле структуры указывается рядовое число значений параметра, вызвавшего ошибку. Если можно определить конкретный параметр в ряду параметров, которые вызвали ошибку, номер параметра будет введен в поле SQL_DIAG_COLUMN_NUMBER.  
  
 SQL_PARAM_UNUSED вводится, когда параметр не был использован, потому что ошибка произошла в предыдущем параметре, который заставил **S'LExecute** или **S'LExecDirect** прервать. Например, если есть 50 параметров и произошла ошибка при выполнении сорокового набора параметров, которые привели к прекращению **s'LExecute** или **S'LExecDirect,** то SQL_PARAM_UNUSED вводится в массив состояния для параметров 41 на 50.  
  
 SQL_PARAM_DIAG_UNAVAILABLE вводится, когда драйвер рассматривает массивы параметров как монолитную единицу, поэтому он не генерирует данный индивидуальный уровень параметра информации об ошибке.  
  
 Некоторые ошибки в обработке одного набора параметров приводят к остановке обработки последующих наборов параметров в массиве. Другие ошибки не влияют на обработку последующих параметров. Какие ошибки прекратят обработку, определяется драйвером. Если обработка не остановлена, все параметры в массиве обрабатываются, SQL_SUCCESS_WITH_INFO возвращается в результате ошибки, а буфер, определяемый SQL_ATTR_PARAMS_PROCESSED_PTR, устанавливается на общее количество обработанных наборов параметров (как определено атрибутом SQL_ATTR_PARAMSET_SIZE оператора), который включает наборы ошибок.  
  
> [!CAUTION]  
>  Поведение ODBC при возникновении ошибки в обработке массива параметров отличается в ODBC 3. *x,* чем это было в ODBC 2. *x*. В ODBC 2. *x,* функция вернулась SQL_ERROR и обработка прекратилась. Буфер, на который указывает *аргумент pirow* **от S'LParamOptions,** содержал номер строки ошибки. В ODBC 3. *x,* функция возвращается SQL_SUCCESS_WITH_INFO и обработка может либо прекратиться, либо продолжиться. Если он продолжается, буфер, указанный SQL_ATTR_PARAMS_PROCESSED_PTR, будет установлен на значение всех обработанных параметров, включая те, которые привели к ошибке. Это изменение в поведении может вызвать проблемы для существующих приложений.  
  
 Когда **s'LExecute** или **S'LExecDirect** возвращается до завершения обработки всех наборов параметров в массиве параметров, например, при возврате SQL_ERROR или SQL_NEED_DATA, массив статуса содержит статусы для тех параметров, которые уже обработаны. Расположение, на которое указывает SQL_DESC_ROWS_PROCESSED_PTR поле в IPD, содержит номер строки в массиве параметров, что вызвало SQL_ERROR или SQL_NEED_DATA код ошибки. При отправке массива параметров в выписку SELECT определяется наличие значений массива статуса; они могут быть доступны после выполнения оператора или получения наборов результатов.  
  
## <a name="ignoring-a-set-of-parameters"></a>Игнорирование набора параметров

 Поле SQL_DESC_ARRAY_STATUS_PTR APD (в установленном атрибутом SQL_ATTR_PARAM_STATUS_PTR оператора) может быть использовано для указания на то, что набор связанных параметров в выписке S'L следует игнорировать. Чтобы поручить водителю игнорировать один или несколько наборов параметров во время выполнения, приложение должно следовать следующим шагам:  
  
1.  Позвоните **в S'LSetDescField,** чтобы установить поле заголовка SQL_DESC_ARRAY_STATUS_PTR APD, чтобы указать на массив значений S'LUSMALLINT для содержащей информацию о состоянии. Это поле также может быть установлено, позвонив по **s'LSetStmtAttr** с *атрибутом* SQL_ATTR_PARAM_OPERATION_PTR, что позволяет приложению установить поле без получения дескриптора ручкой.  
  
2.  Установите каждый элемент массива, определяемый SQL_DESC_ARRAY_STATUS_PTR поле APD, на одно из двух значений:  
  
    -   SQL_PARAM_IGNORE, чтобы указать, что строка исключена из выполнения оператора.  
  
    -   SQL_PARAM_PROCEED, чтобы указать, что строка включена в выполнение оператора.  
  
3.  Для выполнения подготовленного заявления позвоните по **телефону s'LExecDirect** или **S'LExecute.**  
  
 Следующие правила применяются к массиву, определяемому SQL_DESC_ARRAY_STATUS_PTR полеapли APD:  
  
-   Указатель установлен на нуле в ней по умолчанию.  
  
-   Если указатель недействителен, используются все наборы параметров, как если бы все элементы были установлены на SQL_ROW_PROCEED.  
  
-   Установка элемента на SQL_PARAM_PROCEED не гарантирует, что операция будет использовать этот определенный набор параметров.  
  
-   SQL_PARAM_PROCEED определяется как 0 в файле заголовка.  
  
 Приложение может установить поле SQL_DESC_ARRAY_STATUS_PTR в APD, чтобы указать на тот же массив, на который указывает SQL_DESC_ARRAY_STATUS_PTR поле в IRD. Это полезно при связывании параметров для строки данных. Параметры могут быть проигнорированы в зависимости от состояния данных строки. В дополнение к SQL_PARAM_IGNORE, следующие коды приводят к игнорированию параметра в выписке по S'L: SQL_ROW_DELETED, SQL_ROW_UPDATED и SQL_ROW_ERROR. В дополнение к SQL_PARAM_PROCEED, следующие коды приводят к продолжению оператора S'L: SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO и SQL_ROW_ADDED.  
  
## <a name="rebinding-parameters"></a>Параметры перезакрепления

 Приложение может выполнить одну из двух операций для изменения привязки:  
  
-   Позвоните **в S'LBindParameter,** чтобы указать новую привязку для уже связанного столбца. Водитель перезаписывает старую переплетовую с новой.  
  
-   Укажите смещение, которое должно быть добавлено к буферному адресу, указанному связывающим вызовом на **S'LBindParameter.** Для получения дополнительной информации смотрите следующий раздел "Перезагрузка с смещениями".  
  
## <a name="rebinding-with-offsets"></a>Перезавязка с смещениями

 Повторяя параметры особенно полезно, когда приложение имеет настройку буферной зоны, которая может содержать много параметров, но вызов в **S'LExecDirect** или **S'LExecute** использует лишь некоторые из параметров. Оставшееся пространство в буферной зоне может быть использовано для следующего набора параметров путем изменения существующего связывания смещением.  
  
 Поле заголовка SQL_DESC_BIND_OFFSET_PTR в APD указывает на привязку смещения. Если поле не является нулевым, драйвер ссылается на указатель, и, если ни одно из значений в SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR полях является нулевым указателем, добавляет дессылку значения к этим полям в записях дескриптора во время выполнения. Новые значения указателя используются при выполнении инструкций S'L. Смещение остается действительным после повторного пересвязывания. Поскольку SQL_DESC_BIND_OFFSET_PTR является указателем на смещение, а не на само смещение, приложение может изменять смещение напрямую, без вызова [S'LSetDesccField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или [S'LSetDesccRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md) для изменения поля дескриптора. Указатель установлен на нуле в ней по умолчанию. Поле SQL_DESC_BIND_OFFSET_PTR ARD может быть установлено путем звонка в [S'LSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или звонка в [S'LSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)с *SQL_ATTR_PARAM_BIND_OFFSET_PTR.*  
  
 Привязка всегда добавляется непосредственно к значениям в SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR полях. Если смещение изменено на другое значение, новое значение по-прежнему добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется к сумме стоимости поля и любым более ранним смещениям.  
  
## <a name="descriptors"></a>Дескрипторы

 Как параметр связан определяется полями APD и IPDs. Аргументы в **S'LBindParameter** используются для установки этих полей дескриптора. Поля также могут быть установлены функциями **S'LSetDescField,** хотя **S'LBindParameter** является более эффективным в использовании, потому что приложение не должно получить ручку дескриптора для вызова **S'LBindParameter.**  
  
> [!CAUTION]  
>  Вызов **S'LBindParameter** для одного оператора может повлиять на другие операторы. Это происходит, когда ARD, связанный с оператором, явно выделяется и также связан с другими операторами. Поскольку **S'LBindParameter** изменяет поля APD, изменения применяются ко всем утверждениям, с которыми связан этот дескриптор. Если это не является обязательным поведением, приложение должно отделить этот дескриптор от других инструкций, прежде чем он вызывает **S'LBindParameter**.  
  
 Концептуально, **S'LBindParameter** выполняет следующие шаги последовательно:  
  
1.  Вызывает [S'LGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) для того чтобы получить ручку APD.  
  
2.  Вызывает [S'LGetDescField,](../../../odbc/reference/syntax/sqlgetdescfield-function.md) чтобы получить поле SQL_DESC_COUNT APD, и если значение аргумента *ColumnNumber* превышает значение SQL_DESC_COUNT, звонит **sLSetDescField,** чтобы увеличить значение SQL_DESC_COUNT к *ColumnNumber.*  
  
3.  Вызывает несколько раз [вызовов sLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) для присвоения значений следующим полям APD:  
  
    -   Устанавливает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE к значению *ValueType,* за исключением того, что, если *ValueType* является одним из кратких идентификаторов подтипа даты или интервала, он устанавливает SQL_DESC_TYPE SQL_DATETIME или SQL_INTERVAL, соответственно, устанавливает SQL_DESC_CONCISE_TYPE к краткому идентификатору и устанавливает SQL_DESC_DATETIME_INTERVAL_CODE соответствующего времени даты или подкода интервала.  
  
    -   Устанавливает поле SQL_DESC_OCTET_LENGTH значение *BufferLength.*  
  
    -   Устанавливает поле SQL_DESC_DATA_PTR к значению *ParameterValue.*  
  
    -   Устанавливает поле SQL_DESC_OCTET_LENGTH_PTR значение *StrLen_or_Ind.*  
  
    -   Устанавливает SQL_DESC_INDICATOR_PTR поле также к значению *StrLen_or_Ind.*  
  
     Параметр *StrLen_or_Ind* определяет как информацию индикатора, так и длину значения параметра.  
  
4.  Вызывает [S'LGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) для того чтобы получить ручку IPD.  
  
5.  Вызывает [S'LGetDescField,](../../../odbc/reference/syntax/sqlgetdescfield-function.md) чтобы получить SQL_DESC_COUNT поле IPD, и если значение аргумента *ColumnNumber* превышает значение SQL_DESC_COUNT, звонит **s'LSetDescField,** чтобы увеличить значение SQL_DESC_COUNT к *ColumnNumber.*  
  
6.  Вызывает несколько раз [вызовов sLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) для присвоения значений следующим полям IPD:  
  
    -   Устанавливает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE к значению *ParameterTypeType,* за исключением того, что если *ParameterType* является одним из кратких идентификаторов подтипа даты или интервала, он устанавливает SQL_DESC_TYPE SQL_DATETIME или SQL_INTERVAL, соответственно, устанавливает SQL_DESC_CONCISE_TYPE к краткому идентификатору и устанавливает SQL_DESC_DATETIME_INTERVAL_CODE соответствующему времени даты или подкоду интервала.  
  
    -   Устанавливает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION и SQL_DESC_DATETIME_INTERVAL_PRECISION, в соответствии с *параметромType*.  
  
    -   Устанавливает SQL_DESC_SCALE к значению *десятичных дигидов.*  
  
 При сбой вызова **в S'LBindParameter** не будет определено содержимое полей дескриптора, которые он установил бы в APD, а SQL_DESC_COUNT поле APD остается неизменным. Кроме того, не определены SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_TYPE поля соответствующего учета в ИПД, а SQL_DESC_COUNT поле ИПД остается неизменным.  
  
## <a name="conversion-of-calls-to-and-from-sqlsetparam"></a>Преобразование вызовов в и из S'LSetParam

 Когда приложение ODBC 1.0 вызывает **S'LSetParam** в ODBC 3. *x* драйвер, ODBC 3. *менеджер* драйвера отображает вызов, как показано в следующей таблице.  
  
|Звоните по приложению ODBC 1.0|Звоните в ODBC 3. *x* драйвер|  
|----------------------------------|-------------------------------|  
|СЗлСетПарам (Заявление, ParameterNumber, ValueType, ParameterTypeType, LengthPrecision, ParameterScale, ParameterValuePtr, StrLen_or_IndPtr);|S'LBindParameter (Заявление, ParameterNumber, SQL_PARAM_INPUT_OUTPUT, ValueType, ParameterTypeType, *ColumnSize*, *ДесятичныеDigits*, ParameterValuePtr, SQL_SETPARAM_VALUE_MAX, StrLen_or_IndPtr);|  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение готовит заявление s'L для вставки данных в таблицу ORDERS. По каждому параметру в заявлении приложение вызывает **S'LBindParameter,** чтобы указать тип данных ODBC C и тип данных s'L параметра, а также привязать буфер к каждому параметру. Для каждого ряда данных приложение присваивает значения данных каждому параметру и вызывает **S'LExecute** для выполнения оператора.  
  
 Следующий пример предполагает, что у вас есть источник данных ODBC на вашем компьютере под названием Northwind, который связан с базой данных Northwind.  
  
 Для получения более дополнительных примеров [SQLProcedures Function](../../../odbc/reference/syntax/sqlprocedures-function.md)кода, [SQLPutData Function](../../../odbc/reference/syntax/sqlputdata-function.md) [SQLSetPos Function](../../../odbc/reference/syntax/sqlsetpos-function.md)см. [SQLBulkOperations Function](../../../odbc/reference/syntax/sqlbulkoperations-function.md)  
  
```cpp
// SQLBindParameter_Function.cpp  
// compile with: ODBC32.lib  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
#define EMPLOYEE_ID_LEN 10  
  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLSMALLINT sCustID;  
  
SQLCHAR szEmployeeID[EMPLOYEE_ID_LEN];  
SQL_DATE_STRUCT dsOrderDate;  
SQLINTEGER cbCustID = 0, cbOrderDate = 0, cbEmployeeID = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, EMPLOYEE_ID_LEN, 0, szEmployeeID, 0, &cbEmployeeID);  
   retcode = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_SSHORT, SQL_INTEGER, 0, 0, &sCustID, 0, &cbCustID);  
   retcode = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TIMESTAMP, sizeof(dsOrderDate), 0, &dsOrderDate, 0, &cbOrderDate);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"INSERT INTO Orders(CustomerID, EmployeeID, OrderDate) VALUES (?, ?, ?)", SQL_NTS);  
  
   strcpy_s((char*)szEmployeeID, _countof(szEmployeeID), "BERGS");  
   sCustID = 5;  
   dsOrderDate.year = 2006;  
   dsOrderDate.month = 3;  
   dsOrderDate.day = 17;  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="code-example"></a>Пример кода

 В следующем примере приложение выполняет процедуру хранения сервера S'L с использованием названного параметра.  
  
```cpp
// SQLBindParameter_Function_2.cpp  
// compile with: ODBC32.lib  
// sample assumes the following stored procedure:  
// use northwind  
// DROP PROCEDURE SQLBindParameter  
// GO  
//   
// CREATE PROCEDURE SQLBindParameter @quote int  
// AS  
// delete from orders where OrderID >= @quote  
// GO  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
SQLHDESC hIpd = NULL;  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLCHAR szQuote[50] = "100084";  
SQLINTEGER cbValue = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"{call SQLBindParameter(?)}", SQL_NTS);  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 50, 0, szQuote, 0, &cbValue);  
   retcode = SQLGetStmtAttr(hstmt, SQL_ATTR_IMP_PARAM_DESC, &hIpd, 0, 0);  
   retcode = SQLSetDescField(hIpd, 1, SQL_DESC_NAME, "@quote", SQL_NTS);  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возвращение информации о параметре в заявлении|[Функция SQLDescribeParam](../../../odbc/reference/syntax/sqldescribeparam-function.md)|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Освобождение буферов параметров на отчете|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращение ряда параметров оператора|[SQLNumParams, функция](../../../odbc/reference/syntax/sqlnumparams-function.md)|  
|Возвращение следующего параметра для отправки данных для|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Определение нескольких значений параметров|[Функция SQLParamOptions](../../../odbc/reference/syntax/sqlparamoptions-function.md)|  
|Отправка данных параметров во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
  
## <a name="see-also"></a>См. также:

 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
