---
title: Функция SQLBindParameter | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLBindParameter
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLBindParameter
helpviewer_keywords:
- SQLBindParameter function [ODBC]
ms.assetid: 38349d4b-be03-46f9-9d6a-e50dd144e225
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 13f4c879f94118a2e2302a2032991e85551be0f7
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "65538129"
---
# <a name="sqlbindparameter-function"></a>Функция SQLBindParameter

**Соответствие стандартам**  
 Представленные версии: ODBC 2.0 стандартов соответствия: интерфейс ODBC  
  
 **Сводка**  
 **SQLBindParameter** привязывает буфера к маркеру параметра в инструкции SQL. **SQLBindParameter** поддерживает привязку к типу данных Юникода C, даже если основной драйвер не поддерживает данные в Юникоде.  
  
> [!NOTE]  
>  Эта функция заменяет функцию ODBC 1.0 **SQLSetParam**. Дополнительные сведения см. в разделе «Примечания».  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp
  
SQLRETURN SQLBindParameter(  
      SQLHSTMT        StatementHandle,  
      SQLUSMALLINT    ParameterNumber,  
      SQLSMALLINT     InputOutputType,  
      SQLSMALLINT     ValueType,  
      SQLSMALLINT     ParameterType,  
      SQLULEN         ColumnSize,  
      SQLSMALLINT     DecimalDigits,  
      SQLPOINTER      ParameterValuePtr,  
      SQLLEN          BufferLength,  
      SQLLEN *        StrLen_or_IndPtr);  
```
  
## <a name="arguments"></a>Аргументы

 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *ParameterNumber*  
 [Вход] Параметр с номером, упорядоченные последовательно в порядке возрастания параметра, начиная с 1.  
  
 *InputOutputType*  
 [Вход] Тип параметра. Дополнительные сведения см. в разделе "*InputOutputType* аргумент» в «Комментарии».  
  
 *ValueType*  
 [Вход] Тип данных C параметра. Дополнительные сведения см. в разделе "*ValueType* аргумент» в «Комментарии».  
  
 *ParameterType*  
 [Вход] Тип данных параметра SQL. Дополнительные сведения см. в разделе "*ParameterType* аргумент» в «Комментарии».  
  
 *ColumnSize*  
 [Вход] Размер столбца и выражения соответствующего маркера параметра. Дополнительные сведения см. в разделе "*ColumnSize* аргумент» в «Комментарии».  
  
 Если приложение выполняется в 64-разрядной операционной системе Windows, см. в разделе [сведения о ODBC 64-разрядном](../../../odbc/reference/odbc-64-bit-information.md).  
  
 *DecimalDigits*  
 [Вход] Десятичные цифры из столбца и выражения соответствующего маркера параметра. Дополнительные сведения о размер столбца, см. в разделе [размер столбца, десятичных разрядов, длительность октета передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).  
  
 *ParameterValuePtr*  
 [Отложенные входные данные] Указатель на буфер для данных параметра. Дополнительные сведения см. в разделе "*ParameterValuePtr* аргумент» в «Комментарии».  
  
 *BufferLength*  
 [Вход/выход] Длина *ParameterValuePtr* буфера в байтах. Дополнительные сведения см. в разделе "*BufferLength* аргумент» в «Комментарии».  
  
 См. в разделе [сведения о ODBC 64-разрядном](../../../odbc/reference/odbc-64-bit-information.md), если приложение выполняется в 64-разрядной операционной системе.  
  
 *StrLen_or_IndPtr*  
 [Отложенные входные данные] Указатель на буфер для параметра длины. Дополнительные сведения см. в разделе "*StrLen_or_IndPtr* аргумент» в «Комментарии».  
  
## <a name="returns"></a>Возвращает

 Значение SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика

 Когда **SQLBindParameter** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые при помощи **SQLBindParameter** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  

|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Тип данных, определенный *ValueType* аргумент невозможно преобразовать в тип данных, определяемый *ParameterType* аргумент. Обратите внимание, что эта ошибка может возвращаться **SQLExecDirect**, **SQLExecute**, или **SQLPutData** во время выполнения, а не по **SQLBindParameter**.|  
|07009|Недопустимый индекс дескриптора|(DM) значение, указанное для аргумента *ParameterNumber* был меньше, чем 1.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в **MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимая для поддержки выполнения или завершения функции.|  
|HY003|Недопустимый тип буфера приложения|Значение, указанное в аргументе *ValueType* не допустимый тип данных C или SQL_C_DEFAULT.|  
|HY004|Недопустимый тип данных SQL|Значение, указанное для аргумента *ParameterType* был не является допустимым идентификатором типа данных ODBC SQL, и не поддерживаемых драйвером идентификатор типа данных специфические для драйвера SQL.|  
|HY009|Недопустимое значение аргумента|(DM) аргумент *ParameterValuePtr* был пустым указателем, аргумент *StrLen_or_IndPtr* был пустым указателем, а аргумент *InputOutputType* не SQL_PARAM_ ВЫХОДНЫЕ ДАННЫЕ.<br /><br /> SQL_PARAM_OUTPUT (DM), где аргумент *ParameterValuePtr* был пустым указателем, тип C был char или двоичных данных или BufferLength (*cbValueMax*) был больше 0.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLBindParameter** был вызван.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY021|Несовместимые сведения дескриптора|Сведения о дескрипторе, проверяется в ходе проверки согласованности не согласован. (См. в разделе «Проверки согласованности» **SQLSetDescField**.)<br /><br /> Значение, указанное для аргумента *DecimalDigits* находился вне диапазона значений, поддерживаемых источником данных для столбца типа данных SQL, указанный с *ParameterType* аргумент.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение в *BufferLength* меньше 0. (См. в описании поля SQL_DESC_DATA_PTR в **SQLSetDescField**.)|  
|HY104|Недопустимое значение точности или масштаба|Значение, указанное для аргумента *ColumnSize* или *DecimalDigits* находился вне диапазона значений, поддерживаемых источником данных для столбца типа данных SQL, указанный с  *ParameterType* аргумент.|  
|HY105|Недопустимый тип параметра|(DM) значение, указанное для аргумента *InputOutputType* был недопустимым. (См. в разделе «Комментарии».)|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяемое сочетание значение, указанное для аргумента *ValueType* и специфические для драйвера значение, указанное для аргумента *ParameterType*.<br /><br /> Значение, указанное для аргумента *ParameterType* был допустимым идентификатором типа данных ODBC SQL, используемая версия ODBC, поддерживаемых драйвером, но не поддерживается драйвером или источником данных.<br /><br /> Драйвер поддерживает только ODBC 2. *x* и аргумент *ValueType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и все типы данных интервала C, перечисленных в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) в приложение г Типы данных.<br /><br /> Драйвер поддерживает только версии ODBC до выпуска версии 3.50, а аргумент *ValueType* был SQL_C_GUID.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии

 Приложение вызывает **SQLBindParameter** для привязки каждого маркера параметра в инструкции SQL. Привязки остаются в силе, пока приложение не вызовет **SQLBindParameter** снова вызывает **SQLFreeStmt** с SQL_RESET_PARAMS параметр, то есть вызовы **SQLSetDescField** для поле заголовка SQL_DESC_COUNT дескрипторе параметра приложения, равным 0.  
  
 Дополнительные сведения о параметрах см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md). Дополнительные сведения о типах данных параметров и маркеров параметров см. в разделе [типы данных параметров](../../../odbc/reference/appendixes/parameter-data-types.md) и [маркеры параметров](../../../odbc/reference/appendixes/parameter-markers.md) в приложение в: Грамматика SQL.  
  
## <a name="parameternumber-argument"></a>Аргумент ParameterNumber  
 Если *ParameterNumber* в вызове **SQLBindParameter** больше, чем значение SQL_DESC_COUNT, **SQLSetDescField** вызывается, чтобы увеличить значение SQL_DESC_ ОТСЧЕТ до *ParameterNumber*.  
  
## <a name="inputoutputtype-argument"></a>Аргумент InputOutputType  
 *InputOutputType* аргумент задает тип параметра. Этот аргумент задает поле SQL_DESC_PARAMETER_TYPE в IPD. Все параметры в инструкциях SQL, которые не вызывают процедуры, такие как **вставить** инструкции, являются *входной ** параметры*. Параметров в вызовах процедуры могут быть введены, ввода вывода или выходных параметров. (Приложение вызывает **SQLProcedureColumns** для определения типа параметра в вызове процедуры; параметры, тип которого не удается определить предполагается, что входные параметры.)  
  
 *InputOutputType* аргумент является одним из следующих значений:  
  
-   SQL_PARAM_INPUT. Параметр помечает параметр в инструкции SQL, который не вызывает процедуру, такие как **вставить** инструкции или он помечает входного параметра в процедуре. Например, параметры в **INSERT INTO VALUES сотрудника (?,?,?)**  являются входными параметрами, тогда как параметры в **{вызовите AddEmp (?,?,?)}**  может быть, но не обязательно, входные параметры.  
  
     При выполнении инструкции, драйвер отправляет данные для параметра источника данных. \* *ParameterValuePtr* буфер должен содержать допустимое входное значение или **StrLen_or_IndPtr* буфер должен содержать значение SQL_NULL_DATA, значение SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT Функции _EXEC макрос.  
  
     Если приложение не может определить тип параметра в вызове процедуры, то он устанавливает *InputOutputType* для SQL_PARAM_INPUT; Если источник данных возвращает значение для параметра, драйвер отбрасывает его.  
  
-   SQL_PARAM_INPUT_OUTPUT. Параметр отмечает входной/выходной параметр в процедуре. Например, параметр в **{вызвать GetEmpDept(?)}**  является параметром ввода вывода, который принимает имя сотрудника и возвращает имя сотрудника отдела.  
  
     При выполнении инструкции, драйвер отправляет данные для параметра источника данных. \* *ParameterValuePtr* буфер должен содержать допустимое входное значение или \* *StrLen_or_IndPtr* буфер должен содержать значение SQL_NULL_DATA, значение SQL_DATA_AT_EXEC или результат макрос SQL_LEN_DATA_AT_EXEC. После выполнения инструкции, драйвер возвращает данные для параметра приложения; Если источник данных не возвращает значение для параметра ввода вывода, драйвер задает **StrLen_or_IndPtr* буфера на SQL_NULL_DATA.  
  
    > [!NOTE]  
    >  Если приложение ODBC 1.0 вызывает **SQLSetParam** в драйвере ODBC 2.0 диспетчера драйверов преобразует в вызов **SQLBindParameter** в котором *InputOutputType* аргумент имеет значение SQL_PARAM_INPUT_OUTPUT.  
  
-   SQL_PARAM_OUTPUT. Параметр отмечает возвращаемое значение в процедуру или выходного параметра в процедуре. в любом случае они известны как *выходных параметров*. Например, параметр в **{? = вызовите GetNextEmpID}** является выходным параметром, который возвращает следующий идентификатор сотрудника.  
  
     После выполнения инструкции, драйвер возвращает данные для параметра в приложение, если не *ParameterValuePtr* и *StrLen_or_IndPtr* аргументы являются оба указателя null, в этом случае драйвер отбрасывает выходное значение. Если источник данных не возвращает значение выходного параметра, драйвер задает **StrLen_or_IndPtr* буфера на SQL_NULL_DATA.  
  
-   SQL_PARAM_INPUT_OUTPUT_STREAM. Указывает, что следует выполнить потоковую передачу входной/выходной параметр. **SQLGetData** можно считывать значения параметров в частях. *BufferLength* игнорируется, так как длина буфера будет определяться при вызове **SQLGetData**. Значение *StrLen_or_IndPtr* буфер должен содержать значение SQL_NULL_DATA, SQL_DEFAULT_PARAM, значение SQL_DATA_AT_EXEC или результат макроса SQL_LEN_DATA_AT_EXEC. Параметр должен быть привязан как параметр данных во время выполнения (DAE) во входных данных, если он будет передан в выходных данных. *ParameterValuePtr* может быть любым значением ненулевой указатель, который будет возвращаться **SQLParamData** как пользовательский маркер, значение которого был передан с *ParameterValuePtr* для как входные, так и выходные данные. Дополнительные сведения см. в разделе [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_PARAM_OUTPUT_STREAM. Совпадает со значением SQL_PARAM_INPUT_OUTPUT_STREAM для выходного параметра. **StrLen_or_IndPtr* игнорируется во входных данных.  
  
 В следующей таблице перечислены различные сочетания *InputOutputType* и **StrLen_or_IndPtr*:  
  
|*InputOutputType*|**StrLen_or_IndPtr*|Результат|Обратите внимание на ParameterValuePtr|  
|-----------------------|----------------------------|-------------|---------------------------------|  
|SQL_PARAM_INPUT|Значение SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввода в части|*ParameterValuePtr* может быть любым значением указатель, который будет возвращаться **SQLParamData** как пользовательский маркер, значение которого был передан с *ParameterValuePtr*.|  
|SQL_PARAM_INPUT|Не SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввод привязанным буфера|*ParameterValuePtr* — это адрес входного буфера.|  
|SQL_PARAM_OUTPUT|Игнорируется во входных данных.|Выходной буфер привязки|*ParameterValuePtr* — это адрес выходного буфера.|  
|SQL_PARAM_OUTPUT_STREAM|Игнорируется во входных данных.|Потоковые выходные данные|*ParameterValuePtr* может быть любым значением указатель, который будет возвращаться посредством **SQLParamData** как пользовательский маркер, значение которого был передан с *ParameterValuePtr*.|  
|SQL_PARAM_INPUT_OUTPUT|Значение SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввода в части и связанного буфера выходных данных|*ParameterValuePtr* — это адрес выходного буфера, который также будет возвращаться посредством **SQLParamData** как пользовательский маркер, значение которого был передан с *ParameterValuePtr*.|  
|SQL_PARAM_INPUT_OUTPUT|Не SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввод привязанным буфера и выходного буфера привязанного|*ParameterValuePtr* — это адрес Общий буфер ввода вывода.|
|SQL_PARAM_INPUT_OUTPUT_STREAM|Значение SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввода в части и потокового вывода|*ParameterValuePtr* может быть любой указатель отличное от null значение, которое будет возвращено функцией **SQLParamData** как пользовательский маркер, значение которого был передан с *ParameterValuePtr* для обоих входных данных и выходные данные.|  
  
> [!NOTE]  
>  Драйвер необходимо решить, какие типы SQL разрешены, если приложение привязывает выходного или параметр ввода вывода, как передавать их потоком. Диспетчер драйверов не будет формировать ошибку для недопустимого типа SQL.  
  
## <a name="valuetype-argument"></a>Аргумент ValueType

 *ValueType* аргумент указывает тип данных C параметра. Этот аргумент задает поля SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE дескрипторе параметра приложения. Это должно быть одно из значений в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) части приложение г Типы данных.  
  
 Если *ValueType* аргумент является одним из типов данных интервала, поле SQL_DESC_TYPE *ParameterNumber* запись о дескрипторе параметра приложения имеет значение SQL_INTERVAL, становится равным поле SQL_DESC_CONCISE_TYPE в APD Тип данных краткий интервал, а поле SQL_DESC_DATETIME_INTERVAL_CODE *ParameterNumber* записи присваивается дополнительный код для типа данных через определенный интервал времени. (См. в разделе [приложение г. Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).) По умолчанию интервала, (2) и точности секунд интервал по умолчанию (6), как задано в полях SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION в дескрипторе параметра приложения, соответственно, используются для данных. Если либо точность по умолчанию не подходит, приложение должно явно задать поля дескриптора с помощью вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Если *ValueType* аргумент является одним из типов данных даты и времени, поле SQL_DESC_TYPE *ParameterNumber* запись о дескрипторе параметра приложения имеет значение SQL_DATETIME, поле SQL_DESC_CONCISE_TYPE *ParameterNumber* запись APD присваивается тип данных даты и краткого времени C, а поле SQL_DESC_DATETIME_INTERVAL_CODE *ParameterNumber* записи присваивается дополнительный код для определенной даты и времени Тип данных. (См. в разделе [приложение г. Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)  
  
 Если *ValueType* аргумент имеет тип данных SQL_C_NUMERIC, точность по умолчанию (который является определяемым драйвером) и масштаб по умолчанию (0), как задано в полях SQL_DESC_PRECISION и SQL_DESC_SCALE в дескрипторе параметра приложения, используются для данных. Если по умолчанию точности или масштаба не подходит, приложение должно явно задать поля дескриптора с помощью вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 SQL_C_DEFAULT указывает, что значение параметра передаваться от тип данных C по умолчанию для указанного типа данных SQL с *ParameterType*.  
  
 Можно также указать расширенного типа данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 Дополнительные сведения см. в разделе [по умолчанию типы данных C](../../../odbc/reference/appendixes/default-c-data-types.md), [преобразование данных из C в типы данных SQL](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md), и [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложение г Типы данных.  
  
## <a name="parametertype-argument"></a>Аргумент ParameterType

 Это должно быть одно из значений, перечисленных в [типы данных SQL](../../../odbc/reference/appendixes/sql-data-types.md) части приложение г Типы данных, или он должен иметь значение специфические для драйвера. Этот аргумент задает поля SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE IPD.  
  
 Если *ParameterType* аргумент является один из идентификаторов даты и времени, поле SQL_DESC_TYPE IPD присваивается SQL_DATETIME, поле SQL_DESC_CONCISE_TYPE в IPD присваивается тип данных SQL краткими datetime и SQL_DESC_ Поле DATETIME_INTERVAL_CODE будет присвоено значение дополнительного кода соответствующие даты и времени.  
  
 Если *ParameterType* — один из идентификаторов интервал, поле SQL_DESC_TYPE IPD присвоено SQL_INTERVAL, поле SQL_DESC_CONCISE_TYPE в IPD присвоено краткими тип интервала данных SQL, а SQL_DESC_DATETIME_ Поле INTERVAL_CODE IPD присваивается дополнительным соответствующий промежуток времени. Поле SQL_DESC_DATETIME_INTERVAL_PRECISION IPD присваивается начальные точности интервала, а поле SQL_DESC_PRECISION присваивается точность секунд интервал, если применимо. Если значение по умолчанию SQL_DESC_DATETIME_INTERVAL_PRECISION или SQL_DESC_PRECISION не подходит, чтобы приложение должно явно задать его, вызвав **SQLSetDescField**. Дополнительные сведения о любом из этих полей см. в разделе [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md).  
  
 Если *ValueType* аргумент имеет тип данных SQL_NUMERIC, точность по умолчанию (который является определяемым драйвером) и масштаб по умолчанию (0), как задано в полях SQL_DESC_PRECISION и SQL_DESC_SCALE в IPD, используются для данных. Если по умолчанию точности или масштаба не подходит, приложение должно явно задать поля дескриптора с помощью вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Сведения о том, как данные преобразуются, см. в разделе [преобразование данных из C в типы данных SQL](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md) и [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложение г Типы данных.  
  
## <a name="columnsize-argument"></a>Аргумент ColumnSize

 *ColumnSize* аргумент указывает размер столбца или выражение, соответствующее к маркеру параметра, длину данных, или оба. Этот аргумент задает различные поля IPD, в зависимости от типа данных SQL ( *ParameterType* аргумент). Следующие правила применяются к данному сопоставлению.  
  
-   Если *ParameterType* SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY, или один из краткого даты-времени или интервал типы данных SQL, поле SQL_DESC_LENGTH IPD присваивается значение  *ColumnSize*. (Дополнительные сведения см. в разделе [размер столбца, десятичных разрядов, длительность октета передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) разделе в приложение г Типы данных).  
  
-   Если *ParameterType* SQL_DECIMAL, SQL_NUMERIC, SQL_FLOAT, SQL_REAL или SQL_DOUBLE, поле SQL_DESC_PRECISION в IPD присваивается значение *ColumnSize*.  
  
-   Для других типов данных *ColumnSize* аргумент учитывается.  
  
 Дополнительные сведения см. в разделе «Передача значения параметра» и значение SQL_DATA_AT_EXEC в "*StrLen_or_IndPtr* аргумент.»  
  
## <a name="decimaldigits-argument"></a>Аргумент DecimalDigits

 Если *ParameterType* SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP, SQL_INTERVAL_SECOND, SQL_INTERVAL_DAY_TO_SECOND, SQL_INTERVAL_HOUR_TO_SECOND или SQL_INTERVAL_MINUTE_TO_SECOND, задать поле SQL_DESC_PRECISION в IPD Чтобы *DecimalDigits*. Если *ParameterType* SQL_NUMERIC или SQL_DECIMAL, поле SQL_DESC_SCALE в IPD присваивается *DecimalDigits*. Для всех других типов данных *DecimalDigits* аргумент учитывается.  
  
## <a name="parametervalueptr-argument"></a>Аргумент ParameterValuePtr

 *ParameterValuePtr* аргумент указывает на буфер, если **SQLExecute** или **SQLExecDirect** вызывается, содержит фактические данные для параметра. Данные должны быть в форме, заданной в параметре *ValueType* аргумент. Этот аргумент задает поле SQL_DESC_DATA_PTR в APD. Приложение может задать *ParameterValuePtr* аргумент является пустым указателем, при условии  *\*StrLen_or_IndPtr* SQL_NULL_DATA, или значение SQL_DATA_AT_EXEC. (Это относится только к входных или входных и выходных параметров.)  
  
 Если \* *StrLen_or_IndPtr* является результатом значение SQL_LEN_DATA_AT_EXEC (*длина*) макрос или значение SQL_DATA_AT_EXEC, затем *ParameterValuePtr* — значение указателя, определяемые приложением, который связан с параметром. Он возвращается в приложение через **SQLParamData**. Например *ParameterValuePtr* может быть маркер ненулевое значение, например номер параметра, указатель на данные или указатель на структуру, используемой приложением для привязки входных параметров. Тем не менее, обратите внимание, что если параметр является параметром ввода вывода, *ParameterValuePtr* должен быть указателем на буфер, где будет храниться выходное значение. Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, приложение может использовать значение, на которые указывают вместе с атрибутом инструкции SQL_ATTR_PARAMS_PROCESSED_PTR *ParameterValuePtr* аргумент. Например *ParameterValuePtr* может указывать на массив значений, и приложение может использовать значение, на которые указывают SQL_ATTR_PARAMS_PROCESSED_PTR для получения правильного значения из массива. Дополнительные сведения см. в разделе «Передача значения параметров» далее в этом разделе.  
  
 Если *InputOutputType* аргументом является SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, *ParameterValuePtr* указывает на буфер, в котором драйвер возвращает выходное значение. Если процедура возвращает один или несколько результирующих наборов, \* *ParameterValuePtr* буфера, не обязательно задать пока не будут обработаны все количество наборов и строк результатов. Если буфер не задано до завершения обработки, выходные параметры и возвращаемые значения будут недоступны до **SQLMoreResults** не вернет значение SQL_NO_DATA. Вызов **SQLCloseCursor** или **SQLFreeStmt** с параметром SQL_CLOSE приведут эти значения будут отброшены.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, *ParameterValuePtr* указывает на массив. Одну инструкцию SQL обрабатывает полный массив входных значений для входного или входного выходного параметра и возвращает массив выходных значений для ввода вывода или выходной параметр.  
  
## <a name="bufferlength-argument"></a>Аргумент BufferLength

 Для символьных и двоичных данных C *BufferLength* аргумент задает длину \* *ParameterValuePtr* буфера (если он является одиночным элементом) или длина элемента в \* *ParameterValuePtr* массив (если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1). Этот аргумент задает поле записи SQL_DESC_OCTET_LENGTH в APD. Если приложение указывает несколько значений, *BufferLength* позволяет определить расположение значений в **ParameterValuePtr* массива, на входе и на выходе. Для ввода вывода и выходные параметры он используется для определения необходимости выполнить усечение символьных и двоичных данных C на выходе:  
  
-   Для символьных C данных, если количество байтов, доступных для возврата больше или равно *BufferLength*, данные в \* *ParameterValuePtr* усекается до  *BufferLength* меньше длина символа завершения null и заканчивается нулевым байтом драйвером.  
  
-   Для двоичных данных C, если количество байтов, доступных для возврата превышает *BufferLength*, данные в \* *ParameterValuePtr* усекается до *BufferLength*байт.  
  
 Для всех других типов данных C *BufferLength* аргумент учитывается. Длина \* *ParameterValuePtr* буфера (если он является одиночным элементом) или длина элемента в \* *ParameterValuePtr* массив (если приложение вызывает  **SQLSetStmtAttr** с *атрибут* аргумент SQL_ATTR_PARAMSET_SIZE для указания нескольких значений для каждого параметра) предполагается, что длина типа данных C.  
  
 Для потокового вывода или потоковых входных и выходных параметров *BufferLength* аргумент учитывается, так как длина буфера задается в **SQLGetData**.  
  
> [!NOTE]  
>  Если приложение ODBC 1.0 вызывает **SQLSetParam** в ODBC 3. *x* драйвера, диспетчер драйверов преобразует в вызов **SQLBindParameter** в котором *BufferLength* аргумент — всегда SQL_SETPARAM_VALUE_MAX. Поскольку диспетчер драйверов возвращает ошибку, если ODBC 3. *x* приложение задает *BufferLength* для SQL_SETPARAM_VALUE_MAX ODBC 3. *x* драйвер можно использовать для определения того, если он вызывается приложением ODBC 1.0.  
  
> [!NOTE]  
>  В **SQLSetParam**, способом, в которой приложение указывает длину **ParameterValuePtr* буфера, чтобы драйвер может возвращать символ или двоичные данные и способом, в которой приложение отправляет Массив символов или двоичного параметра значений для драйвера, драйвер определяются пользователем.  
  
## <a name="strlenorindptr-argument"></a>Аргумент StrLen_or_IndPtr

 *StrLen_or_IndPtr* аргумент указывает на буфер, если **SQLExecute** или **SQLExecDirect** вызывается, содержит одно из следующих. (Этот аргумент задает поля записи SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR указателей параметров приложения).  
  
-   Длина значения параметра, хранящегося в **ParameterValuePtr*. Этот параметр игнорируется за исключением символьных или двоичных данных C.  
  
-   SQL_NTS. Значение параметра является строка, завершающаяся символом null.  
  
-   SQL_NULL_DATA. Значение параметра равно NULL.  
  
-   ЗНАЧЕНИЕ SQL_DEFAULT_PARAM. Процедура — Чтобы использовать значение по умолчанию параметра, а не значение, извлеченное из приложения. Это значение является допустимым только в процедуру с именем в канонического синтаксиса ODBC, а затем только если *InputOutputType* аргумент является SQL_PARAM_INPUT, SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_INPUT_OUTPUT_STREAM. Когда \* *StrLen_or_IndPtr* является SQL_DEFAULT_PARAM *ValueType*, *ParameterType*, *ColumnSize*,  *DecimalDigits*, *BufferLength*, и *ParameterValuePtr* аргументы игнорируются для входных параметров и используются только для того, чтобы определить значение параметра выходных данных для входных данных / выходные параметры.  
  
-   Результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос. Данные для параметра будут отправлены с **SQLPutData**. Если *ParameterType* аргументом является SQL_LONGVARBINARY, SQL_LONGVARCHAR или long, тип данных зависящие от источника данных, а драйвер возвращает «Y» для типа данных SQL_NEED_LONG_DATA_LEN в **SQLGetInfo**, *длина* — количество байтов данных, отправляемых для параметра; в противном случае *длина* должно быть неотрицательное значение и учитывается. Дополнительные сведения см. в разделе «Передача параметра значений» далее в этом разделе.  
  
     Например, чтобы указать, что 10 000 байтов данных, будут отправлены с **SQLPutData** в один или несколько вызовов, для параметра SQL_LONGVARCHAR, задает приложение **StrLen_or_IndPtr* SQL_LEN_DATA_AT_EXEC) 10000).  
  
-   SQL_DATA_AT_EXEC. Данные для параметра будут отправлены с **SQLPutData**. Это значение используется приложениями ODBC 1.0 в том случае, когда вызывают ODBC 3. *x* драйверы. Дополнительные сведения см. в разделе «Передача параметра значений» далее в этом разделе.  
  
 Если *StrLen_or_IndPtr* является указателем null, драйвер предполагает, что все значения входных параметров не равны NULL и что символьных и двоичных данных заканчивается нулевым байтом. Если *InputOutputType* SQL_PARAM_OUTPUT или SQL_PARAM_OUTPUT_STREAM и *ParameterValuePtr* и *StrLen_or_IndPtr* являются оба пустыми указателями, драйвер отбрасывает Выходное значение.  
  
> [!NOTE]  
>  Разработчикам приложений не рекомендуется указывать указатель null для *StrLen_or_IndPtr* Если тип данных параметра — SQL_C_BINARY. Чтобы убедиться в том, что драйвер не удаляет данные SQL_C_BINARY, неожиданно *StrLen_or_IndPtr* должен содержать указатель на значение допустимую длину.  
  
 Если *InputOutputType* аргумент является SQL_PARAM_INPUT_OUTPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, *StrLen_or_IndPtr* указывает на буфер, в котором драйвер возвращает значение SQL_NULL_DATA, количество байтов, доступных для возврата в \* *ParameterValuePtr* (исключая конечное значение null байт символьных данных), или SQL_NO_TOTAL (если число доступных для байтов return не может быть определено). Если процедура возвращает один или несколько результирующих наборов, **StrLen_or_IndPtr* буфера, не обязательно задать, нужно определить все результаты будут выбраны.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, *StrLen_or_IndPtr* указывает на массив значений SQLLEN. Они может быть любым из значений, перечисленных ранее в этом разделе и обрабатываются с помощью одной инструкции SQL.  
  
## <a name="passing-parameter-values"></a>Передача значений параметров

 Приложение может передавать значения для параметра, либо в \* *ParameterValuePtr* буфера или с помощью одного или нескольких вызовов к **SQLPutData**. Параметры, данные которого передается с **SQLPutData** известны как *данных во время выполнения* параметров. Они обычно используются для отправки данных SQL_LONGVARBINARY и SQL_LONGVARCHAR параметров, а также могут сочетаться с другими параметрами.  
  
 Для передачи значений параметров, приложение выполняет следующие действия:  
  
1.  Вызовы **SQLBindParameter** для каждого параметра для привязки буферы для этого параметра значение (*ParameterValuePtr* аргумент) и длины и индикатора (*StrLen_or_IndPtr* аргумент). Для параметров данных времени выполнения *ParameterValuePtr* значение указателя, определяемые приложением, например номер параметра или указатель на данные. Значение будет возвращено более поздней версии и может использоваться для идентификации параметра.  
  
2.  Помещает значения для параметров ввода и ввода вывода в \* *ParameterValuePtr* и **StrLen_or_IndPtr* буферов:  
  
    -   Для обычных параметров так, приложение размещает значение параметра в \* *ParameterValuePtr* буфера и длину этого значения в **StrLen_or_IndPtr* буфера. Дополнительные сведения см. в разделе [значения параметров параметр](../../../odbc/reference/develop-app/setting-parameter-values.md).  
  
    -   Для параметров данных времени выполнения, приложение помещает результат значение SQL_LEN_DATA_AT_EXEC (*длина*) (при вызове драйвером ODBC 2.0) в макрос **StrLen_or_IndPtr* буфера.  
  
3.  Вызовы **SQLExecute** или **SQLExecDirect** для выполнения инструкции SQL.  
  
    -   Если нет параметров данных времени выполнения, процесс будет завершен.  
  
    -   При наличии параметров данных времени выполнения, функция возвращает значение SQL_NEED_DATA.  
  
4.  Вызовы **SQLParamData** извлекаемого определяемое приложением значение, указанное в *ParameterValuePtr* аргумент **SQLBindParameter** для первого параметр данных времени выполнения для обработки. **SQLParamData** возвращает SQL_NEED_DATA.  
  
    > [!NOTE]  
    >  Несмотря на то, что параметры данных времени выполнения напоминают столбцов данных времени выполнения, значение, возвращаемое функцией **SQLParamData** отличается для каждого. Параметры данных во время выполнения являются параметрами в инструкции SQL, для которого данные будут отправлены с **SQLPutData** при выполнении инструкции с **SQLExecDirect** или **SQLExecute**. Они связаны с **SQLBindParameter**. Значение, возвращенное **SQLParamData** передается значение указателя **SQLBindParameter** в *ParameterValuePtr* аргумент. Столбцы данных во время выполнения являются столбцами в наборе строк, для которого данные будут отправлены с **SQLPutData** когда строка обновляется или добавлены с классом **SQLBulkOperations** или обновлено с помощью **SQLSetPos**. Они связаны с **SQLBindCol**. Значение, возвращенное **SQLParamData** — это адрес строки в **TargetValuePtr* буфера (задать с помощью вызова **SQLBindCol**), который обрабатывается.  
  
5.  Вызовы **SQLPutData** один или несколько раз для отправки данных для параметра. Более чем один вызов является обязательным, если значение больше, чем \* *ParameterValuePtr* буфера, указанного в **SQLPutData**; несколько вызовов **SQLPutData**для одного параметра допускаются только в том случае, при отправке данных символа C к столбцу с типом данных зависящие от источника символьных, двоичных или данных, или при отправке двоичных данных C для столбца с символом, двоичных данных, или тип данных зависящие от источника данных.  
  
6.  Вызовы **SQLParamData** еще раз, чтобы сообщить, что все данные отправлены в параметре.  
  
    -   Если несколько параметров данных времени выполнения, **SQLParamData** возвращает SQL_NEED_DATA и определяемое приложением значение для следующего параметра данных времени выполнения для обработки. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет параметров данных времени выполнения, процесс будет завершен. Если инструкция была выполнена успешно, **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; Если выполнение завершилось сбоем, возвращается значение SQL_ERROR. На этом этапе **SQLParamData** может возвращать любой SQLSTATE, которые могут быть возвращены с помощью функции, который используется для выполнения инструкции (**SQLExecDirect** или **SQLExecute**).  
  
         Выходные значения для параметров ввода вывода или выходной доступны в \* *ParameterValuePtr* и **StrLen_or_IndPtr* помещает в буфер после приложение извлекает все результирующие наборы сформированное инструкцией.  
  
 Вызов **SQLExecute** или **SQLExecDirect** помещает инструкцию в состоянии SQL_NEED_DATA. На этом этапе приложение может вызвать только **SQLCancel**, **SQLGetDiagField**, **SQLGetDiagRec**, **SQLGetFunctions**, **SQLParamData**, или **SQLPutData** с инструкцией или *дескриптора соединения* связанные с инструкцией. Если он вызывает любой другой функции с инструкцией или соединения, связанного с инструкцией, функция возвращает параметром SQLSTATE HY010 (функционировать ошибка последовательности). Оставляет инструкции, SQL_NEED_DATA состояние, когда **SQLParamData** или **SQLPutData** возвращает ошибку, **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, или Инструкция отменяется.  
  
 Если приложение вызывает **SQLCancel** пока драйвер по-прежнему нужны данные для параметров данных времени выполнения, драйвер отменяет выполнение инструкции; приложение может затем вызвать **SQLExecute** или  **SQLExecDirect** еще раз.  
  
## <a name="retrieving-streamed-output-parameters"></a>Получение потоковых выходных параметров

 Когда приложение задает *InputOutputType* SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, необходимо извлечь значение параметра выходных данных с одного или нескольких вызовов к **SQLGetData**. Если драйвер имеет значение параметра потоковые выходные данные, чтобы вернуться в приложение, он возвращает SQL_PARAM_DATA_AVAILABLE в ответ на вызов к следующим функциям: **SQLMoreResults**, **SQLExecute**, и **SQLExecDirect**. Приложение вызывает **SQLParamData** для определения того, какое значение параметра доступно.  
  
 Дополнительные сведения о SQL_PARAM_DATA_AVAILABLE и потоковых выходных параметров, см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="using-arrays-of-parameters"></a>Использование массивов параметров

 Когда приложение выполняет подготовку инструкции с маркерами параметров и передает в массив параметров, существует два разных способа, который может выполняться. Один из способов — для драйвера полагаться на возможности серверной части, в котором регистр всей инструкции с массивом параметров обрабатывается как неделимым единицам обработки массивов. Oracle является примером источника данных, которая поддерживает возможности обработки массива. Другой способ реализовать эту функцию, — для создания пакета инструкций SQL, одну инструкцию SQL для каждого набора параметров в массиве параметров и выполнения пакета драйвера. Массивы параметров не может использоваться с **UPDATE WHERE CURRENT OF** инструкции.  
  
 При обработке массив параметров, количество отдельных результатов наборов и строк (по одному для каждого набора параметров) могут быть доступны, или количество наборов/строк результатов можно быть сведены в один. В диалоговом окне SQL_PARAM_ARRAY_ROW_COUNTS **SQLGetInfo** указывает количество строк для каждого набора параметров (SQL_PARC_BATCH) доступны ли счетчик только одну строку — доступны (SQL_PARC_NO_BATCH).  
  
 В диалоговом окне SQL_PARAM_ARRAY_SELECTS **SQLGetInfo** указывает ли результирующий набор доступен для каждого набора параметров (SQL_PAS_BATCH) или только один результирующий набор доступных (SQL_PAS_NO_BATCH). Если драйвер не поддерживает инструкцию для выполнения с помощью массива параметров, создания набора результат, SQL_PARAM_ARRAY_SELECTS возвращает SQL_PAS_NO_SELECT.  
  
 Дополнительные сведения см. в разделе [SQLGetInfo, функция](../../../odbc/reference/syntax/sqlgetinfo-function.md).  
  
 Чтобы обеспечить поддержку массивов параметров, атрибут инструкции SQL_ATTR_PARAMSET_SIZE присваивается указать количество значений для каждого параметра. Если поле является больше 1, поля SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR в APD должен указывать на массивы. Количество элементов каждого массива равно значению SQL_ATTR_PARAMSET_SIZE.  
  
 Поле SQL_DESC_ROWS_PROCESSED_PTR APD указывает на буфер, содержащий число наборов параметров, которые будут обработаны, включая наборы ошибки. Как обрабатывается каждый набор параметров, драйвер сохраняет новое значение в буфере. Номер не будет возвращаться, если это является пустым указателем. При использовании массивов параметров значение, на которые указывает поле SQL_DESC_ROWS_PROCESSED_PTR APD заполняется в том случае, даже если возвращается значение SQL_ERROR с помощью параметра функции. Если возвращается значение SQL_NEED_DATA, набор параметров, которые обрабатываются присваивается значение, на которые указывает поле SQL_DESC_ROWS_PROCESSED_PTR дескрипторе параметра приложения.  
  
 Что происходит при привязке массив параметров и **UPDATE WHERE CURRENT OF** выполняется инструкция является, определяемым драйвером.  
  
## <a name="column-wise-parameter-binding"></a>Привязки параметра на уровне столбца

 В привязку по столбцам, приложение связывает отдельный параметр и массивы длины и индикатора для каждого параметра.  
  
 Чтобы использовать привязку по столбцам, приложение сначала устанавливается атрибут инструкции SQL_ATTR_PARAM_BIND_TYPE в значение SQL_PARAM_BIND_BY_COLUMN. (Это значение по умолчанию). Для каждого столбца необходимо привязать приложение выполняет следующие действия:  
  
1.  Выделяет буфер массива параметров.  
  
2.  Выделяет массив буферов длины и индикатора.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда используется привязка на уровне столбцов, отдельных массива можно использовать для данных, длины и индикатора.  
  
3.  Вызовы **SQLBindParameter** со следующими аргументами:  
  
    -   *ValueType* является типом C из одного элемента в массиве параметров буфера.  
  
    -   *ParameterType* SQL тип параметра.  
  
    -   *ParameterValuePtr* — это адрес буфера массива параметров.  
  
    -   *BufferLength* — это размер из одного элемента в массиве параметров буфера. *BufferLength* аргумент учитывается, когда данные фиксированной длины данных.  
  
    -   *StrLen_or_IndPtr* — это адрес массива длины и индикатора.  
  
 Дополнительные сведения о том, как эти сведения используются см. в разделе «ParameterValuePtr аргумента» в «Комментарии», далее в этом разделе. Дополнительные сведения о привязке на уровне столбца параметров, см. в разделе [массивы параметров привязки](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).  
  
## <a name="row-wise-parameter-binding"></a>Построчная привязка параметров

 В привязку на уровне строки, приложение определяет структуру, содержащую буферы параметра и длины и индикатора для каждого параметра для привязки.  
  
 Чтобы использовать привязку на уровне строки, приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения один набор параметров (включая буферы параметра и длины и индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда используется привязка на уровне строки, можно использовать отдельные поля для данных, длины и индикатора.  
  
2.  Задает атрибут инструкции SQL_ATTR_PARAM_BIND_TYPE размер структуры, которая содержит один набор параметров или размер буфера, в который будет привязан параметры экземпляра. Длина должна включать пробел для всех привязанных параметров и все заполнения структуры или буфера, чтобы убедиться в том, что при адрес привязанного параметра увеличивается с указанным значением длины, результат будет указывать в начале этого параметра в Следующая строка. При использовании *sizeof* оператор в ANSI C, такое поведение гарантируется.  
  
3.  Вызовы **SQLBindParameter** со следующими аргументами для каждого параметра для привязки:  
  
    -   *ValueType* тип члена буфера параметр для привязки к столбцу.  
  
    -   *ParameterType* SQL тип параметра.  
  
    -   *ParameterValuePtr* — это адрес элемента буфера параметр для первого элемента массива.  
  
    -   *BufferLength* равно размеру члена параметр буфера.  
  
    -   *StrLen_or_IndPtr* — это адрес члена длины и индикатора, который требуется привязать.  
  
 Дополнительные сведения о том, как эти сведения используются, см. в разделе "*ParameterValuePtr* аргумент,» далее в этом разделе. Дополнительные сведения о Построчная привязка параметров, см. в разделе [массивы параметров привязки](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).  
  
## <a name="error-information"></a>Сведения об ошибке

 Если драйвер не реализует массивы параметров как пакеты (параметр SQL_PARAM_ARRAY_ROW_COUNTS равен SQL_PARC_NO_BATCH), ситуации, обрабатываются так, как если бы были выполнены в одной инструкции. Если драйвер реализует массивы параметров как пакеты, приложение может использовать поле заголовка SQL_DESC_ARRAY_STATUS_PTR IPD, чтобы определить, какой параметр инструкции SQL или вызвал какой параметр в массив параметров  **SQLExecDirect** или **SQLExecute** будут возвращать ошибку. Это поле содержит сведения о состоянии для каждой строки значений параметров. Если поле указывает, что произошла ошибка, поля в структуре данных диагностики о номер строки и параметрах параметра, который не удалось. Число элементов в массиве будет определяться поле заголовка SQL_DESC_ARRAY_SIZE в дескрипторе параметра приложения, который можно задать с помощью атрибута инструкции SQL_ATTR_PARAMSET_SIZE.  
  
> [!NOTE]  
>  Поле заголовка SQL_DESC_ARRAY_STATUS_PTR в дескрипторе параметра приложения используется к игнорированию параметров. Дополнительные сведения о пропуске параметров см. в разделе следующем разделе «Пропускается набор параметров».  
  
 Когда **SQLExecute** или **SQLExecDirect** возвращает значение SQL_ERROR, элементы массива, на которые указывает поле SQL_DESC_ARRAY_STATUS_PTR в IPD будет содержать SQL_ SQL_PARAM_ERROR SQL_PARAM_SUCCESS, PARAM_SUCCESS_WITH_INFO SQL_PARAM_UNUSED и SQL_PARAM_DIAG_UNAVAILABLE.  
  
 Для каждого элемента в этом массиве структура диагностических данных содержит одну или несколько записей о состоянии. Поле SQL_DIAG_ROW_NUMBER структуры указывает номер строки, значения параметров, вызвавшие ошибку. Если это возможно, для определения конкретного параметра в строке параметров, вызвавшие ошибку, параметр с номером будет указываться в поле SQL_DIAG_COLUMN_NUMBER.  
  
 SQL_PARAM_UNUSED вводится в том случае, когда параметр не используется из-за ошибки в более ранних параметр, который принудительно **SQLExecute** или **SQLExecDirect** прерывание. Например, при наличии 50 параметров и произошла ошибка при выполнении fortieth набор параметров, которые вызвали **SQLExecute** или **SQLExecDirect** прерывание, а затем SQL_PARAM_UNUSED вводится в Массив состояний параметров 41 до 50.  
  
 SQL_PARAM_DIAG_UNAVAILABLE вводится в том случае, когда драйвер считает массивов параметров монолитных единицу измерения, поэтому он не формирует этот уровень отдельных параметров сведений об ошибках.  
  
 Некоторые ошибки при обработке единого набора параметров вызвать обработки последующих наборов параметров в массиве для остановки. Другие ошибки, не влияют на обработку последующие параметры. Какие ошибки остановит обработку, определяемым драйвером. Если обработка не прекращается, обрабатываются все параметры в массиве, из-за ошибки возвращается SQL_SUCCESS_WITH_INFO и имеет значение буфера, заданного sql_attr_params_processed_ptr возвращает общее количество наборов параметров обработки (согласно определению Атрибут инструкции SQL_ATTR_PARAMSET_SIZE), который включает в себя ошибки набора.  
  
> [!CAUTION]  
>  Поведение ODBC при возникновении ошибки при обработке массив параметров отличается в ODBC 3. *x* чем в ODBC 2. *x*. В ODBC 2. *x*, функция вернула значение SQL_ERROR и обработки перестали. Буфер, на которые указывают *pirow* аргумент **SQLParamOptions** содержится номер строки ошибки. В ODBC 3. *x*, функция возвращает SQL_SUCCESS_WITH_INFO и обработки мая либо остановки или продолжения работы. Если он продолжает буфера, SQL_ATTR_PARAMS_PROCESSED_PTR заданного будет присвоено значение всех обработанных параметров, включая те, которые привело к ошибке. Это изменение в поведении может нарушить работу существующих приложений.  
  
 Когда **SQLExecute** или **SQLExecDirect** возвращает до завершения обработки всех наборов параметров в массиве параметров, например, если возвращается значение SQL_ERROR или значение SQL_NEED_DATA, этот массив содержит состояния для этих параметров, которые уже были обработаны. Расположение, на которые указывает поле SQL_DESC_ROWS_PROCESSED_PTR в IPD содержит номер строки в массиве параметров, в результате ошибки SQL_ERROR или SQL_NEED_DATA. При отправке массив параметров для инструкции SELECT, доступность массив значений состояния, определяемые драйвером; они могут быть доступны, после выполнения инструкции или как результат, выбранные наборы.  
  
## <a name="ignoring-a-set-of-parameters"></a>Пропуск набора параметров

 Поле SQL_DESC_ARRAY_STATUS_PTR APD (задаваемое при помощи атрибута инструкции SQL_ATTR_PARAM_STATUS_PTR) можно использовать для указания, что набор связанных параметров в инструкции SQL следует игнорировать. Чтобы направить драйвера, чтобы пропустить один или несколько наборов параметров во время выполнения, приложение должно выполните следующие действия.  
  
1.  Вызовите **SQLSetDescField** задать поле заголовка SQL_DESC_ARRAY_STATUS_PTR APD, чтобы он указывал на массив значений SQLUSMALLINT должен содержать сведения о состоянии. Это поле можно также задать, вызвав **SQLSetStmtAttr** с *атрибут* из SQL_ATTR_PARAM_OPERATION_PTR, что позволяет приложению задать поле без получения дескриптора.  
  
2.  Значение каждого элемента массива определяется поле SQL_DESC_ARRAY_STATUS_PTR APD одно из двух значений:  
  
    -   SQL_PARAM_IGNORE, чтобы указать, что строка исключается из выполнения инструкции.  
  
    -   SQL_PARAM_PROCEED, чтобы указать, что строка включается при выполнении инструкции.  
  
3.  Вызовите **SQLExecDirect** или **SQLExecute** Чтобы выполнить подготовленную инструкцию.  
  
 Массив, определяется поле SQL_DESC_ARRAY_STATUS_PTR дескрипторе параметра приложения, применяются следующие правила:  
  
-   Указатель устанавливается в значение null по умолчанию.  
  
-   Если указатель имеет значение null, используются все наборы параметров, как если все элементы были значение SQL_ROW_PROCEED.  
  
-   Задание элемента для SQL_PARAM_PROCEED не гарантирует, что операция будет использовать этот определенный набор параметров.  
  
-   SQL_PARAM_PROCEED определен как 0 в файле заголовка.  
  
 Приложение может задать SQL_DESC_ARRAY_STATUS_PTR поля в дескрипторе параметра приложения, чтобы она указывала один и тот же массив как, на которую указывает по полю SQL_DESC_ARRAY_STATUS_PTR в IRD. Это полезно при привязке параметров к данным строки. Параметры можно игнорировать, затем по состоянию строки данных. Кроме SQL_PARAM_IGNORE следующие коды вызвать параметра в инструкции SQL, чтобы игнорировать: Значение SQL_ROW_DELETED, SQL_ROW_UPDATED и SQL_ROW_ERROR. В дополнение к SQL_PARAM_PROCEED следующие коды вызвать инструкцию SQL продолжить. SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO, and SQL_ROW_ADDED.  
  
## <a name="rebinding-parameters"></a>Повторная привязка параметров

 Приложение может выполнять две операции, чтобы изменить привязки.  
  
-   Вызовите **SQLBindParameter** для указания новой привязки для столбца, который уже привязан. Драйвер перезаписывает старую привязку на новую.  
  
-   Указать смещение для добавления адрес буфера, который был указан при вызове привязки **SQLBindParameter**. Дополнительные сведения см. следующий раздел, «Перепривязки со смещениями.»  
  
## <a name="rebinding-with-offsets"></a>Повторная привязка с отступами

 Повторная привязка параметров особенно полезен, когда приложение удерживает настройки области буфера, которая может содержать много параметров, но вызов **SQLExecDirect** или **SQLExecute** используется только несколько параметров. Оставшегося пространства в буферной области можно использовать для следующего набора параметров, изменяя существующую привязку в качестве смещения.  
  
 Поле заголовка SQL_DESC_BIND_OFFSET_PTR в дескрипторе параметра приложения указывает на смещение привязки. Если поле не равно null, драйвер разыменовывает указатель и, если ни одно из значений в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR является пустым указателем, добавляет разыменованное значение для этих полей дескриптора записи во время выполнения. Новые значения указателя используются при выполнении инструкций SQL. Смещение остается действующим после повторной привязки. Так как SQL_DESC_BIND_OFFSET_PTR — это указатель на смещение, а не сам смещение, приложения можно изменить смещение напрямую, без вызова [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md) для Измените поле дескриптора. Указатель устанавливается в значение null по умолчанию. Поле SQL_DESC_BIND_OFFSET_PTR Отменить задаются путем вызова [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или путем вызова [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)с *fAttribute* из SQL_ATTR_PARAM_BIND_ OFFSET_PTR.  
  
 Смещение привязки всегда добавляется непосредственно значений в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется с другим значением, новое значение по-прежнему добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется к сумме значение поля и любые более ранние смещения.  
  
## <a name="descriptors"></a>Дескрипторы

 Как параметр привязан определяется по полям APDs и поставщики IDP. Аргументы в **SQLBindParameter** , используются для задания этих поля дескриптора. Также можно задать поля **SQLSetDescField** функции, несмотря на то что **SQLBindParameter** более эффективен, поскольку приложение не имеет для получения дескриптора для вызова **SQLBindParameter**.  
  
> [!CAUTION]  
>  Вызов **SQLBindParameter** для одной инструкции может повлиять на другие инструкции. Это происходит при явном выделении Отменить, связанные с инструкцией и также связан с другими инструкциями. Так как **SQLBindParameter** изменяет те поля из дескрипторе параметра приложения, изменения применяются ко всем операторам, с которыми связан данный дескриптор. Если это не требуемое поведение, приложение должно отменить связь этот дескриптор из других инструкций, перед вызовом **SQLBindParameter**.  
  
 По существу **SQLBindParameter** выполняет следующие шаги в последовательности:  
  
1.  Вызовы [SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) получить дескриптор APD.  
  
2.  Вызовы [SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md) для получения поля SQL_DESC_COUNT APD и, если значение *ColumnNumber* аргумента превышает значение свойства SQL_DESC_COUNT, вызовы **SQLSetDescField**для увеличения значения SQL_DESC_COUNT для *ColumnNumber*.  
  
3.  Вызовы [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) несколько раз, чтобы присвоить значения следующих полей свойства дескрипторе параметра приложения:  
  
    -   Задает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE значению *ValueType*, за исключением того, что если *ValueType* является одним из краткого идентификаторов подтипа даты-времени или интервал, он задает SQL_DESC_TYPE SQL_ DATETIME или SQL_INTERVAL, соответственно, задается SQL_DESC_CONCISE_TYPE краткими идентификатору, а SQL_DESC_DATETIME_INTERVAL_CODE соответствующей даты и времени или интервал дополнительный код.  
  
    -   Задает значение для поля SQL_DESC_OCTET_LENGTH *BufferLength*.  
  
    -   Задает значение для поля SQL_DESC_DATA_PTR *ParameterValue*.  
  
    -   Задает значение для поля SQL_DESC_OCTET_LENGTH_PTR *StrLen_or_Ind*.  
  
    -   Задает поле SQL_DESC_INDICATOR_PTR также значению *StrLen_or_Ind*.  
  
     *StrLen_or_Ind* указывает индикатор сведений и длина значения параметра.  
  
4.  Вызовы [SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) получить дескриптор IPD.  
  
5.  Вызовы [SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md) для получения IPD SQL_DESC_COUNT поля и, если значение *ColumnNumber* аргумента превышает значение свойства SQL_DESC_COUNT, вызовы **SQLSetDescField**для увеличения значения SQL_DESC_COUNT для *ColumnNumber*.  
  
6.  Вызовы [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) несколько раз, чтобы присвоить значения следующих полей свойства IPD:  
  
    -   Устанавливает значение SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE *ParameterType*, за исключением того, что если *ParameterType* является одним краткими идентификаторов подтипа даты-времени или интервал, он задает SQL_DESC_TYPE Чтобы SQL_DATETIME или SQL_INTERVAL соответственно, задает SQL_DESC_CONCISE_TYPE краткого идентификатора и наборы SQL_DESC_DATETIME_INTERVAL_CODE соответствующей даты и времени или интервал дополнительный код.  
  
    -   Задает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION и SQL_DESC_DATETIME_INTERVAL_PRECISION, в зависимости от *ParameterType*.  
  
    -   Задает SQL_DESC_SCALE значению *DecimalDigits*.  
  
 Если вызов **SQLBindParameter** завершается ошибкой, содержимое поля дескриптора, которые он будет установлен в дескрипторе параметра приложения не определены, и поле SQL_DESC_COUNT дескрипторе параметра приложения не изменяется. Кроме того не определены поля SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_TYPE соответствующую запись в IPD и поле SQL_DESC_COUNT IPD не меняется.  
  
## <a name="conversion-of-calls-to-and-from-sqlsetparam"></a>Преобразование вызовов в и из SQLSetParam

 Если приложение ODBC 1.0 вызывает **SQLSetParam** в ODBC 3. *x* драйвера ODBC 3. *x* диспетчера драйверов сопоставляет вызов, как показано в следующей таблице.  
  
|Вызовите приложением ODBC 1.0|Вызов ODBC 3. *x* драйвера|  
|----------------------------------|-------------------------------|  
|SQLSetParam (StatementHandle, ParameterNumber, ValueType, ParameterType, LengthPrecision, ParameterScale, ParameterValuePtr, StrLen_or_IndPtr);|SQLBindParameter (StatementHandle, ParameterNumber, SQL_PARAM_INPUT_OUTPUT, ValueType, ParameterType, *ColumnSize*, *DecimalDigits*, ParameterValuePtr, SQL_SETPARAM_VALUE_MAX,      StrLen_or_IndPtr);|  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение подготавливает инструкцию SQL для вставки данных в таблице ORDERS. Для каждого параметра в инструкции, приложение вызывает **SQLBindParameter** для указания типа данных ODBC C и параметра типа данных SQL и чтобы привязать буфер для каждого параметра. Для каждой строки данных, приложение назначает значения данных для каждого параметра и вызовы **SQLExecute** для выполнения инструкции.  
  
 Приведенный ниже предполагается, что источник данных ODBC на компьютере с именем Northwind, которая связана с базой данных "Борей".  
  
 Дополнительные примеры кода, см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [функция SQLProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md), [SQLPutData, функция](../../../odbc/reference/syntax/sqlputdata-function.md), и [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
```cpp
// SQLBindParameter_Function.cpp  
// compile with: ODBC32.lib  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
#define EMPLOYEE_ID_LEN 10  
  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLSMALLINT sCustID;  
  
SQLCHAR szEmployeeID[EMPLOYEE_ID_LEN];  
SQL_DATE_STRUCT dsOrderDate;  
SQLINTEGER cbCustID = 0, cbOrderDate = 0, cbEmployeeID = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, EMPLOYEE_ID_LEN, 0, szEmployeeID, 0, &cbEmployeeID);  
   retcode = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_SSHORT, SQL_INTEGER, 0, 0, &sCustID, 0, &cbCustID);  
   retcode = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TIMESTAMP, sizeof(dsOrderDate), 0, &dsOrderDate, 0, &cbOrderDate);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"INSERT INTO Orders(CustomerID, EmployeeID, OrderDate) VALUES (?, ?, ?)", SQL_NTS);  
  
   strcpy_s((char*)szEmployeeID, _countof(szEmployeeID), "BERGS");  
   sCustID = 5;  
   dsOrderDate.year = 2006;  
   dsOrderDate.month = 3;  
   dsOrderDate.day = 17;  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="code-example"></a>Пример кода

 В следующем примере приложение выполняет хранимую процедуру SQL Server с помощью именованного параметра.  
  
```cpp
// SQLBindParameter_Function_2.cpp  
// compile with: ODBC32.lib  
// sample assumes the following stored procedure:  
// use northwind  
// DROP PROCEDURE SQLBindParameter  
// GO  
//   
// CREATE PROCEDURE SQLBindParameter @quote int  
// AS  
// delete from orders where OrderID >= @quote  
// GO  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
SQLHDESC hIpd = NULL;  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLCHAR szQuote[50] = "100084";  
SQLINTEGER cbValue = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"{call SQLBindParameter(?)}", SQL_NTS);  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 50, 0, szQuote, 0, &cbValue);  
   retcode = SQLGetStmtAttr(hstmt, SQL_ATTR_IMP_PARAM_DESC, &hIpd, 0, 0);  
   retcode = SQLSetDescField(hIpd, 1, SQL_DESC_NAME, "@quote", SQL_NTS);  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возвращение сведений о параметре в операторе|[Функция SQLDescribeParam](../../../odbc/reference/syntax/sqldescribeparam-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнении подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Освобождение буферов параметра для инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращает число параметров инструкции|[Функция SQLNumParams](../../../odbc/reference/syntax/sqlnumparams-function.md)|  
|Возвращает следующий параметр для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Указание нескольких значений параметра|[Функция SQLParamOptions](../../../odbc/reference/syntax/sqlparamoptions-function.md)|  
|Отправка данных параметра во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
  
## <a name="see-also"></a>См. также

 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
