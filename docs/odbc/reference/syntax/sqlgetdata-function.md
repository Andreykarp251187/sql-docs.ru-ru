---
title: Функция S'LGetData (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetData
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetData
helpviewer_keywords:
- SQLGetData function [ODBC]
ms.assetid: e3c1356a-5db7-4186-85fd-8b74633317e8
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ac11505b8e47dae8df53af27c64a7ee6372b3f28
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285510"
---
# <a name="sqlgetdata-function"></a>Функция SQLGetData
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **SLGetData** получает данные для одного столбца в наборе результатов или для одного параметра после возвращения **s'LParamData** SQL_PARAM_DATA_AVAILABLE. Его можно вызвать несколько раз для извлечения данных переменной длины по частям.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetData(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   Col_or_Param_Num,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_IndPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *Col_or_Param_Num*  
 (Вход) Для извлечения данных столбца это число столбца, для которого можно вернуть данные. Столбцы набора результатов пронумероированы в увеличении порядка столбца, начиная с 1. Столбец закладки — столбец номер 0; это может быть указано только в том случае, если включены закладки.  
  
 Для извлечения данных параметра, это ординатал параметра, который начинается с 1.  
  
 *Targettype*  
 (Вход) Идентификатор типа C-типа данных буфера*TargetValuePtr.* Список действительных типов данных C и идентификаторов типа см. раздел [C Data Types](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: Типы данных.  
  
 Если *TargetType* SQL_ARD_TYPE, водитель использует идентификатор типа, указанный в SQL_DESC_CONCISE_TYPE поле ARD. Если *TargetType* SQL_APD_TYPE, **s'LGetData** будет использовать тот же тип данных C, который был указан в **S'LBindParameter**. В противном случае тип данных C, указанный в **S'LGetData,** переопределяет тип данных C, указанный в **S'LBindParameter.** Если это SQL_C_DEFAULT, драйвер выбирает тип данных C по умолчанию на основе типа данных s-L источника.  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *TargetValuePtr*  
 (Выход) Указатель на буфер, в котором можно вернуть данные.  
  
 *TargetValuePtr* не может быть NULL.  
  
 *BufferLength*  
 (Вход) Длина буфера*TargetValuePtr* в байтах.  
  
 Драйвер использует *BufferLength,* чтобы избежать записи мимо конца буфера \* *TargetValuePtr* при возвращении данных переменной длины, таких как символ или двоичные данные. Обратите внимание, что драйвер подсчитывает символ \*нулевого прекращения при возврате данных о символах в *TargetValuePtr.* *Таким образом, *TargetValuePtr* должен содержать место для символа с нулевым прекращением, иначе водитель усечен инее данных.  
  
 Когда драйвер возвращает данные с фиксированной длиной, такие как целый ряд или структура даты, драйвер игнорирует *BufferLength* и предполагает, что буфер достаточно велик, чтобы держать данные. Поэтому для приложения важно выделить достаточно большой буфер для данных с фиксированной длиной, иначе драйвер напишет мимо конца буфера.  
  
 **SLGetData** возвращает S'LSTATE HY090 (Недействительная длина строки или буфера), когда *BufferLength* меньше 0, но не тогда, когда *BufferLength* 0.  
  
 *StrLen_or_IndPtr*  
 (Выход) Указатель на буфер, в котором можно вернуть значение длины или индикатора. Если это нулевая указка, значение длины или индикатора не возвращается. Это возвращает ошибку, когда полученные данные являются NULL.  
  
 **SLGetData** может вернуть следующие значения в буфере длины/индикатора:  
  
-   Длина данных, доступных для возврата  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Для получения дополнительной информации в этой теме можно [просмотреть значение длины/индикатора](../../../odbc/reference/develop-app/using-length-and-indicator-values.md) и "Комментарии".  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LGetData** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_STMT и *ручки* *обработки заявлений.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LGetData,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Не все данные для указанного столбца, *Col_or_Param_Num,* могут быть извлечены в одном вызове к функции. SQL_NO_TOTAL или длина данных, оставшихся в указанном столбце до текущего вызова **в S'LGetData,** возвращается в \* *StrLen_or_IndPtr.* (Функция возвращает SQL_SUCCESS_WITH_INFO.)<br /><br /> Для получения дополнительной информации об использовании нескольких вызовов в **S'LGetData** для одного столбца см.|  
|01S07|Фракционная усечение|Данные, возвращенные для одного или нескольких столбцов, были усечены. Для численных типов данных дробная часть числа была усечена. Для типов времени, меток времени и интервалов данных, содержащих временной компонент, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|Значение данных столбца в наборе результатов не может быть преобразовано в тип данных C, указанный аргументом *TargetType.*|  
|07009|Недействительный индекс дескриптора|Значение, указанное для аргумента *Col_or_Param_Num,* составляло 0, а атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен в SQL_UB_OFF.<br /><br /> Значение, указанное для аргумента *Col_or_Param_Num,* превышало количество столбцов в наборе результатов.<br /><br /> *Значение Col_or_Param_Num* не было равно ординатору доступного параметра.<br /><br /> (DM) Указанная колонка была связана. Это описание не распространяется на драйверы, которые возвращают SQL_GD_BOUND битную маску для SQL_GETDATA_EXTENSIONS опции в **S'LGetInfo.**<br /><br /> (DM) Число указанного столбца было меньше или равно числу наивысшего столбца. Это описание не распространяется на драйверы, которые возвращают SQL_GD_ANY_COLUMN битную маску для SQL_GETDATA_EXTENSIONS опции в **S'LGetInfo.**<br /><br /> (DM) Приложение уже вызвало **S'LGetData** для текущей строки; число столбцов, указанное в текущем вызове, меньше, чем число столбцов, указанное в предыдущем вызове; и водитель не возвращает SQL_GD_ANY_ORDER битную маску для SQL_GETDATA_EXTENSIONS варианта в **S'LGetInfo**.<br /><br /> (DM) Аргумент *TargetType* был SQL_ARD_TYPE, и *запись Col_or_Param_Num* дескриптора в ARD не удалось проверки согласованности.<br /><br /> (DM) Аргумент *TargetType* был SQL_ARD_TYPE, и значение в SQL_DESC_COUNT области ARD было *меньше,* чем Col_or_Param_Num аргумент.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|22002|Переменная переменная индикатора требуется, но не поставляется|*StrLen_or_IndPtr* был нулевой указатель и NULL данные были извлечены.|  
|22003|Числовое значение вне диапазона|Возвращение численного значения (в качестве численного или строки) для столбца привело бы к тому, что вся (в отличие от дробной) часть числа была бы усечена.<br /><br /> Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-d-data-types.md)|  
|22007|Недействительный формат дата-времени|Столбец символов в наборе результатов был привязан к дате C, времени или структуре метки времени, а значение в столбце было недействительным датой, временем или меткой времени, соответственно. Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-d-data-types.md)|  
|22012|Разделение на ноль|Было возвращено значение из арифметического выражения, приведшивое к разделению на ноль.|  
|22015|Переполниние поля интервала|Назначение от точного числа или интервала типа S'L к типу интервала C привело к потере значительных цифр в ведущем поле.<br /><br /> При возврате данных в тип интервала C не было представлено значение типа S'L в типе интервала C.|  
|22018|Недействительное значение символов для спецификации литья|Столбец символа в наборе результатов был возвращен в буфер символа C, а столбец содержал символ, для которого не было представления в наборе символов буфера.<br /><br /> Тип C был точным или приблизительным числом, временем даты или типом данных интервала; тип столбца s'L был типом данных символов; и значение в колонке не было действительным буквальным типа C.|  
|24 000|Недопустимое состояние курсора|(DM) Функция была вызвана без предварительного вызова **S'LFetch** или **S'LFetchScroll** для размещения курсора на строке требуемых данных.<br /><br /> (DM) *StatementHandle* находился в выполненном состоянии, но ни один набор результатов не был связан с *statementHandle*.<br /><br /> Курсор был открыт на *StatementHandle,* и был вызван **S'LFetch** или **S'LFetchScroll,** но курсор был расположен до начала набора результатов или после окончания набора результатов.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в *буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003|Тип программы вне диапазона|(DM) Аргумент *TargetType* не был допустимым типом данных, SQL_C_DEFAULT, SQL_ARD_TYPE (в случае извлечения данных столбца) или SQL_APD_TYPE (в случае извлечения данных параметра).<br /><br /> (DM) Аргумент *Col_or_Param_Num* был 0, и аргумент *TargetType* не был SQL_C_BOOKMARK для закладки с фиксированной длиной или SQL_C_VARBOOKMARK для закладки переменной длины.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*, а затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle* из другого потока в многопоточном приложении, а затем функция была вызвана снова на *StatementHandle*.|  
|HY009|Недействительное использование нулевой указатель|(DM) Аргумент *TargetValuePtr* был нулевой указатель.|  
|HY010|Ошибка последовательности функций|(DM) Указанное *statementHandle* не находилось в выполненном состоянии. Функция была вызвана без предварительного вызова **s'LExecDirect**, **S'LExecute** или функции каталога.<br /><br /> (DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LGetData.**<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) *StatementHandle* находился в выполненном состоянии, но ни один набор результатов не был связан с *statementHandle*.<br /><br /> Вместо sLParamData был возвращен звонок в **S'LExeceute**, **S'LExecDirect**или **S'LMoreResults,** SQL_PARAM_DATA_AVAILABLE, но вместо **S'LParamData**был вызван **звонок.**|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение, указанное для *аргумента BufferLength* было меньше, чем 0.<br /><br /> Значение, указанное для аргумента *BufferLength* было меньше, чем 4, *Col_or_Param_Num* аргумент был установлен на 0, и драйвер омование драйвером ODBC 2 *.x.*|  
|HY109|Положение недействительного курсора|Курсор был расположен (по **S'LSetPos**, **S'LFetch**, **S'LFetchScroll**, или **S'LBulkOperations**) на строке, которая была удалена или не может быть извлечена.<br /><br /> Курсор был курсором только вперед, и размер гребли был больше, чем один.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает использование **S'LGetData** с несколькими строками в **S'LFetchScroll.** Это описание не распространяется на драйверы, которые возвращают SQL_GD_BLOCK битную маску для SQL_GETDATA_EXTENSIONS опции в **S'LGetInfo**.<br /><br /> Драйвер или источник данных не поддерживает преобразование, указанное комбинацией аргумента *TargetType* и типа данных в соответствующем столбце. Эта ошибка применяется только в том случае, если тип данных столбца был отображен в типе данных, специфичном для драйвера.<br /><br /> Драйвер поддерживает только ODBC 2 *.x*, и аргумент *TargetType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любой из типов данных интервала C, перечисленных в [типах данных C](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: Типы данных.<br /><br /> Драйвер поддерживает версии ODBC только до 3.50, и аргумент *TargetType* был SQL_C_GUID.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, соответствующий *statementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **S'LGetData** возвращает данные в указанном столбце. **SLGetData** можно вызвать только после того, как одна или несколько строк были извлечены из результата, установленного **S'LFetch,** **S'LFetchScroll**, или **S'LExtendedFetch**. Если данные с переменной длиной слишком велики, чтобы их можно было вернуть в один вызов в **S'LGetData** (из-за ограничения в приложении), **S'LGetData** может получить их по частям. Можно связать некоторые столбцы в строке и вызвать **S'LGetData** для других, хотя это подпадает под некоторые ограничения. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/getting-long-data.md)  
  
 Для получения информации об использовании **S'LGetData** с streamed параметрами вывода, [см.](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)  
  
## <a name="using-sqlgetdata"></a>Использование S'LGetData  
 Если драйвер не поддерживает расширения в **S'LGetData,** функция может возвращать данные только для несвязанных столбцов с числом, превышающее число последних связанных столбцов. Кроме того, в пределах ряда данных значение *Col_or_Param_Num* аргумента в каждом вызове на **S'LGetData** должно быть больше или равно значению *Col_or_Param_Num* в предыдущем вызове; т.е. данные должны быть извлечены в порядке увеличения количества столбцов. Наконец, если расширения не поддерживаются, **S'LGetData** не может быть вызван, если размер строки превышает 1.  
  
 Водители могут расслабить любое из этих ограничений. Чтобы определить, какие ограничения ослабляет водитель, приложение вызывает **s'LGetInfo** с любым из следующих вариантов SQL_GETDATA_EXTENSIONS:  
  
-   SQL_GD_OUTPUT_PARAMS **s-LGetData** можно вызвать для возврата значений параметра вывода. Дополнительные сведения см. в разделе [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_GD_ANY_COLUMN. Если эта опция будет возвращена, можно вызвать **любой** несвязанный столбец, в том числе до последнего столбца.  
  
-   SQL_GD_ANY_ORDER. Если эта опция будет возвращена, **s-LGetData** может быть вызван для несвязанных столбцов в любом порядке.  
  
-   SQL_GD_BLOCK. Если эта опция возвращается **sLGetInfo** для SQL_GETDATA_EXTENSIONS InfoType, то драйвер поддерживает вызовы в **S'LGetData,** когда размер набора строк превышает 1, и приложение может вызвать **S'LSetPos** с SQL_POSITION опцией для размещения курсора на правильной строке, прежде чем вызывать **S'LGetData.**  
  
-   SQL_GD_BOUND. Если эта опция будет возвращена, можно будет вызвать **«S'LGetData»** для связанных столбцов, а также для несвязанных столбцов.  
  
 Есть два исключения из этих ограничений и способность водителя, чтобы расслабить их. Во-первых, **sLGetData** никогда не следует вызывать для форвардного курсора, когда размер рядов больше 1. Во-вторых, если драйвер поддерживает закладки, он должен всегда поддерживать возможность вызова **S'LGetData** для столбца 0, даже если он не позволяет приложениям вызывать **S'LGetData** для других столбцов до последнего связанного столбца. (Когда приложение работает с драйвером ODBC 2 *.x,* **S'LGetData** успешно вернет закладку, когда она называется с *Col_or_Param_Num* равняется 0 после звонка *fOption* в **S'LFetch**, потому что **S'LFetch** отображается на карте *.x* ODBC 3 **SQLGetStmtOption** *.x* Driver Manager к **S'LExtendedFetch** с *помощью FetchOrientation* SQL_FETCH_NEXT, а **S'LGetData** с SQL_GET_BOOKMARK *Col_or_Param_Num*  
  
 **SLGetData** не может быть использован для получения закладки для строки, просто вставленной по телефону **s'LBulkOperations** с SQL_ADD опцией, потому что курсор не расположен на строке. Приложение может получить закладку для такой строки, связав столбец 0, прежде чем вызывать **S'LBulkOperations** с SQL_ADD, и в этом случае **S'LBulkOperations** возвращает закладку в связанном буфере. **Затем** можно вызвать SQL_FETCH_BOOKMARK для перестановки курсора на этом ряду.  
  
 Если аргумент *TargetType* представляет собой тип данных интервала, то для данных используются точность интервала интервала по умолчанию (2) и точность секунд интервала по умолчанию (6), установленные в SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION полях ARD, соответственно. Если аргумент *TargetType* является SQL_C_NUMERIC типом данных, для данных используется точность (определенная драйвером) и шкала по умолчанию (0), установленная в SQL_DESC_PRECISION и SQL_DESC_SCALE полях ARD. Если какая-либо точность или масштаб по умолчанию не подходит, приложение должно четко установить соответствующее поле дескриптора по вызову в **S'LSetDescfield** или **S'LSetDescRec.** Он может установить поле SQL_DESC_CONCISE_TYPE для SQL_C_NUMERIC и вызова **S'LGetData** с аргументом *TargetType* SQL_ARD_TYPE, что приведет к использованию значений точности и масштаба в полях дескриптора.  
  
> [!NOTE]
>  В ODBC 2 *.x*приложения, установленные *TargetType* для \*SQL_C_DATE, SQL_C_TIME или SQL_C_TIMESTAMP, указывают, что *TargetValuePtr* — это структура даты, времени или метки времени. В ODBC 3 *.x*приложения устанавливают *TargetType* для SQL_C_TYPE_DATE, SQL_C_TYPE_TIME или SQL_C_TYPE_TIMESTAMP. Менеджер драйвера делает соответствующие отображения, если это необходимо, на основе приложения и версии драйвера.  
  
## <a name="retrieving-variable-length-data-in-parts"></a>Получение данных переменной длины по частям  
 **Для** извлечения данных из столбца, содержащего данные переменной длины по частям, т.е. когда идентификатор типа данных в столбце SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_WCHAR, SQL_WVARCHAR, SQL_WLONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY или идентификатор для конкретного драйвера для типа переменной длины.  
  
 Для извлечения данных из столбца по частям приложение вызывает **s'LGetData** несколько раз подряд для одного и того же столбца. При каждом **вызове, S'LGetData** возвращает следующую часть данных. Это до приложения, чтобы собрать части, заботясь, чтобы удалить нулевой прекращения символ из промежуточных частей данных символов. Если для термина «термин» выделено больше данных или выделено достаточное количество буфера, **то s'LGetData** возвращается SQL_SUCCESS_WITH_INFO и S'LSTATE 01004 (данные усечены). При возврате последней части **данных, s'LGetData** возвращается SQL_SUCCESS. Ни SQL_NO_TOTAL ни ноль не могут быть возвращены на последнем действительном вызове для извлечения данных из столбца, поскольку приложение не сможет узнать, сколько данных в буфере приложения является действительным. Если после этого вызвана **S'LGetData,** она возвращаетSQL_NO_DATA. Для получения дополнительной информации, см.  
  
 Закладки переменной длины могут быть возвращены по частям **по s'LGetData**. Как и в случае с другими данными, призыв к **S'LGetData** вернуть закладки переменной длины по частям вернет S'Lstate 01004 (струнные данные, правые усеченные) и SQL_SUCCESS_WITH_INFO, когда будет больше данных, которые будут возвращены. Это отличается от того, когда закладка с переменной длиной усечена вызовом в **S'LFetch** или **S'LFetchScroll**, который возвращает SQL_ERROR и S'LSTATE 22001 (струнные данные, право усеченные).  
  
 **Для** возврата данных фиксированной длины по частям нельзя использовать данные с фиксированной длиной. Если **s'LGetData** вызывается более одного раза подряд для столбца, содержащего данные с фиксированной длиной, он возвращает SQL_NO_DATA для всех вызовов после первого.  
  
## <a name="retrieving-streamed-output-parameters"></a>Извлечение параметров потокового вывода  
 Если драйвер поддерживает streamed параметры вывода, приложение может вызывать **S'LGetData** с небольшим буфером много раз, чтобы получить большое значение параметра. Для получения дополнительной информации о потоковом параметре вывода [см.](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)  
  
## <a name="retrieving-data-with-sqlgetdata"></a>Получение данных с помощью S'LGetData  
 Для возврата данных для указанного столбца **компания S'LGetData** выполняет следующую последовательность шагов:  
  
1.  Возвращает SQL_NO_DATA, если он уже вернул все данные для столбца.  
  
2.  Устанавливает \* *StrLen_or_IndPtr* для SQL_NULL_DATA, если данные являются NULL. Если данные являются NULL, а *StrLen_or_IndPtr* был нулевой указателем, **S'LGetData** возвращает S'LSTATE 22002 (индикатор переменной требуется, но не поставляется).  
  
     Если данные для столбца не являются НУИЛ, **S'LGetData** переходит к шагу 3.  
  
3.  Если атрибут SQL_ATTR_MAX_LENGTH оператора установлен на ненулевое значение, если столбец содержит символ или двоичные данные, и если **ранее** не был вызван в столбец, данные усечены до SQL_ATTR_MAX_LENGTH байтов.  
  
    > [!NOTE]  
    >  Атрибут SQL_ATTR_MAX_LENGTH оператора предназначен для снижения сетевого трафика. Обычно он реализуется источником данных, который усечения данных, прежде чем вернуть его по всей сети. Драйверы и источники данных не обязаны поддерживать его. Таким образом, чтобы гарантировать, что данные усечены до определенного размера, приложение должно выделить буфер такого размера и указать размер в аргументе *BufferLength.*  
  
4.  Преобразует данные в тип, указанный в *TargetType.* Данные получают точность и масштаб по умолчанию для этого типа данных. Если *TargetType* является SQL_ARD_TYPE, используется тип данных в SQL_DESC_CONCISE_TYPE поле ARD. Если *TargetType* является SQL_ARD_TYPE, данные получают точность и масштаб в SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION и SQL_DESC_SCALE полях ARD, в зависимости от типа данных в SQL_DESC_CONCISE_TYPE поле. Если какая-либо точность или масштаб по умолчанию не подходит, приложение должно четко установить соответствующее поле дескриптора по вызову в **S'LSetDescfield** или **S'LSetDescRec.**  
  
5.  Если данные были преобразованы в тип данных с переменной длиной, например, в символ или двоичную, **S'LGetData** проверяет, превышает ли длина данных *BufferLength.* Если длина данных символов (включая символ нулевого прекращения) превышает *BufferLength,* **S'LGetData** усечения данных *в BufferLength* меньше длины символа с нулевым прекращением. Затем он сводит на нет данные. Если длина двоичных данных превышает длину буфера данных, **S'LGetData** укоротит их до байтов *BufferLength.*  
  
     Если поставляемый буфер данных слишком мал, чтобы удерживать символ нулевого прекращения, **s'LGetData** возвращается SQL_SUCCESS_WITH_INFO и S'Lstate 01004.  
  
     **S'LGetData** никогда не усечения данных, преобразованных в типы данных с фиксированной длиной; он всегда предполагает, что длина*TargetValuePtr* — это размер типа данных.  
  
6.  Размещает конвертированные (и, возможно, \*усеченные) данные в *TargetValuePtr.* Обратите внимание, что **S'LGetData** не может вернуть данные из строки.  
  
7.  Помещает длину данных \*в *StrLen_or_IndPtr*. Если *StrLen_or_IndPtr* был нулевой указатель, **S'LGetData** не возвращает длину.  
  
    -   Для символов или двоичных данных, это длина данных после преобразования и до усечения из-за *BufferLength*. Если драйвер не может определить длину данных после преобразования, как это иногда бывает с длинными данными, он возвращает SQL_SUCCESS_WITH_INFO и устанавливает длину, чтобы SQL_NO_TOTAL. (Последний вызов на **s'LGetData** должен всегда возвращать длину данных, а не ноль или SQL_NO_TOTAL.) Если данные были усечены из-за атрибута SQL_ATTR_MAX_LENGTH оператора, значение этого атрибута - в отличие от фактической длины - помещается в \* *StrLen_or_IndPtr*. Это связано с тем, что этот атрибут предназначен для усечения данных на сервере до преобразования, поэтому у драйвера нет возможности выяснить, какова фактическая длина. Когда **S'LGetData** вызывается несколько раз подряд для одного и того же столбца, это длина данных, доступных в начале текущего вызова; то есть, длина уменьшается с каждым последующим вызовом.  
  
    -   Для всех остальных типов данных это длина данных после преобразования; то есть, это размер типа, к которому были преобразованы данные.  
  
8.  Если данные усечены без потери значимости во время преобразования (например, реальное число 1.234 усечено при преобразовании в целый 1) или потому, что *BufferLength* слишком мал (например, строка "abcdef" помещается в 4-байт буфер), **S'LGetData** возвращает S'LSTATE 01004 (данные усеченные) и SQL_SUCCESS_WITH_INFO. Если данные усечены без потери значимости из-за атрибута SQL_ATTR_MAX_LENGTH оператора, **s'LGetData** возвращается SQL_SUCCESS и не возвращает S'LSTATE 01004 (данные усечены).  
  
 Содержимое буфера связанных данных (если **S'LGetData** вызвано на связанный столбец) и буфер длины/индикатора не определены, если **S'LGetData** не возвращаетSQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Последовательные вызовы на **S'LGetData** будут извлекать данные из последнего запрошенного столбца; предварительные смещения становятся недействительными. Например, при выполнении следующей последовательности:  
  
```cpp  
SQLGetData(icol=n), SQLGetData(icol=m), SQLGetData(icol=n)  
```  
  
 второй вызов на s'LGetData (icol'n) получает данные из начала столбца n. Любое смещение данных из-за более ранних вызовов в **s'LGetData** для столбца больше не действует.  
  
## <a name="descriptors-and-sqlgetdata"></a>Дескрипторы и S'LGetData  
 **СЗЛГетДата** не взаимодействует напрямую с полями дескриптора.  
  
 Если *TargetType* является SQL_ARD_TYPE, используется тип данных в SQL_DESC_CONCISE_TYPE поле ARD. Если *TargetType* является SQL_ARD_TYPE или SQL_C_DEFAULT, данные получают точность и масштаб в SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION и SQL_DESC_SCALE полях ARD, в зависимости от типа данных в SQL_DESC_CONCISE_TYPE поле.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет заявление **SELECT,** чтобы вернуть набор идентификаторов результатов, имен и телефонных номеров, отсортированных по имени, идентификатору и номеру телефона. Для каждого ряда данных он вызывает **S'LFetch,** чтобы расположить курсор на следующий ряд. Для получения полученных данных он вызывает **s-LGetData;** буферы для данных и возвращенное количество байтов указаны в вызове на **S'LGetData.** Наконец, он печатает имя каждого сотрудника, id и номер телефона.  
  
```cpp  
#define NAME_LEN 50  
#define PHONE_LEN 50  
  
SQLCHAR      szName[NAME_LEN], szPhone[PHONE_LEN];  
SQLINTEGER   sCustID, cbName, cbAge, cbBirthday;  
SQLRETURN    retcode;  
SQLHSTMT     hstmt;  
  
retcode = SQLExecDirect(hstmt,  
   "SELECT CUSTID, NAME, PHONE FROM CUSTOMERS ORDER BY 2, 1, 3",  
   SQL_NTS);  
  
if (retcode == SQL_SUCCESS) {  
   while (TRUE) {  
      retcode = SQLFetch(hstmt);  
      if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO) {  
         show_error();  
      }  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO){  
  
         /* Get data for columns 1, 2, and 3 */  
  
         SQLGetData(hstmt, 1, SQL_C_ULONG, &sCustID, 0, &cbCustID);  
         SQLGetData(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &cbName);  
         SQLGetData(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN,  
            &cbPhone);  
  
         /* Print the row of data */  
  
         fprintf(out, "%-5d %-*s %*s", sCustID, NAME_LEN-1, szName,   
            PHONE_LEN-1, szPhone);  
      } else {  
         break;  
      }  
   }  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Назначение хранилища для столбца в наборе результатов|[SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение оптовых операций, не связанных с положением курсора блока|[СЗЛБалКОперации](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки оператора|[SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение оператора S'L|[SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Получение блока данных или прокрутка набора результатов|[SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одного ряда данных или блок данных в направлении только вперед|[SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Отправка данных параметров во время выполнения|[SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Позиционирование курсора, обновление данных в строке или обновление или удаляние данных в строке|[функция SQLSetPos;](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
