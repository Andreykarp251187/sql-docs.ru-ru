---
title: Функция SQLGetData | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetData
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetData
helpviewer_keywords:
- SQLGetData function [ODBC]
ms.assetid: e3c1356a-5db7-4186-85fd-8b74633317e8
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 1b42339c74102b86fe08c84b15da3266a1040dfd
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63258963"
---
# <a name="sqlgetdata-function"></a>Функция SQLGetData
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLGetData** извлекает данные для одного столбца в результирующем наборе, или для единственного параметра после **SQLParamData** возвращает SQL_PARAM_DATA_AVAILABLE. Его можно вызывать несколько раз для получения данных переменной длины по частям.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLGetData(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   Col_or_Param_Num,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_IndPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *Col_or_Param_Num*  
 [Вход] Для Получение данных столбца, это номер столбца, для которого возвращаются данные. Столбцы результирующего набора, нумеруются в порядке возрастания столбца, начиная с 1. Столбец закладок является столбцом номер 0; Это может быть указан только, включены ли закладки.  
  
 Для получения данных параметра, это порядковый номер параметра, который начинается с 1.  
  
 *TargetType*  
 [Вход] Идентификатор типа для типа данных C **TargetValuePtr* буфера. Список допустимых типов данных C и идентификаторы типов, см. в разделе [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) разделе в приложение г Типы данных.  
  
 Если *TargetType* является SQL_ARD_TYPE, то драйвер использует идентификатор типа, указанного в поле SQL_DESC_CONCISE_TYPE Отменить. Если *TargetType* является SQL_APD_TYPE, **SQLGetData** будет использовать тот же тип данных C, который был указан в **SQLBindParameter**. В противном случае тип данных C, указанный в **SQLGetData** переопределяет тип данных C, указанный в **SQLBindParameter**. Если SQL_C_DEFAULT, драйвер выбирает тип данных C по умолчанию, в зависимости от типа источника данных SQL.  
  
 Можно также указать расширенного типа данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *TargetValuePtr*  
 [Выход] Указатель на буфер, в котором для возвращения данных.  
  
 *TargetValuePtr* не может иметь значение NULL.  
  
 *BufferLength*  
 [Вход] Длина **TargetValuePtr* буфера в байтах.  
  
 Драйвер использует *BufferLength* во избежание записи за пределами \* *TargetValuePtr* буфера при возврате данных переменной длины, например символьных или двоичных данных. Обратите внимание на то, что драйвер подсчитывает знак завершения null при возврате символьных данных к \* *TargetValuePtr*. **TargetValuePtr* таким образом может содержать место для символа завершения null, или драйвер будет выполнять усечение данных.  
  
 Когда драйвер возвращает данных фиксированной длины, например целое число или структура даты, драйвер пропускает *BufferLength* и предполагает, что буфер недостаточно велик для хранения данных. Поэтому важно для приложения, чтобы выделить достаточно большой буфер для данных фиксированной длины или драйвер будет записывать после конца буфера.  
  
 **SQLGetData** возвращает SQLSTATE HY090 (Недопустимая длина строки или буфера) при *BufferLength* является меньше 0 но не в том случае, когда *BufferLength* равно 0.  
  
 *StrLen_or_IndPtr*  
 [Выход] Указатель на буфер, в которую будет возвращено значение длины или индикатора. Если это является указателем null, возвращается значение не длину или признак. Возвращается ошибка при извлечении данных имеет значение NULL.  
  
 **SQLGetData** может возвращать следующие значения в буфер длины/индикатора:  
  
-   Длина данных, доступных для возврата  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Дополнительные сведения см. в разделе [использование значений длины и индикатора](../../../odbc/reference/develop-app/using-length-and-indicator-values.md) и «Комментарии» в этом разделе.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLGetData** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, можно получить путем вызова связанного значения SQLSTATE **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLGetData** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение данных строки справа|Не все данные для указанного столбца, *Col_or_Param_Num*, может быть получен за один вызов функции. SQL_NO_TOTAL или длину данных, оставшихся в указанном столбце перед текущим вызовом к **SQLGetData** возвращается в \* *StrLen_or_IndPtr*. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).<br /><br /> Дополнительные сведения об использовании нескольких вызовов **SQLGetData** для одного столбца, см. в разделе «Примечания».|  
|01S07|Частичное усечение|Данные, возвращаемые для одного или нескольких столбцов были усечены. Для числовых типов данных был усечен, дробная часть числа. Для времени, timestamp и интервальных типов данных, содержащего компонент времени десятичная часть времени были усечены.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе невозможно преобразовать в тип данных C, заданной аргументом *TargetType*.|  
|07009|Недопустимый индекс дескриптора|Значение, указанное для аргумента *Col_or_Param_Num* было равно 0, и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_OFF.<br /><br /> Значение, указанное для аргумента *Col_or_Param_Num* поданных единиц превысил количество столбцов в результирующем наборе.<br /><br /> *Col_or_Param_Num* значение не равно порядковый номер параметра, который доступен.<br /><br /> (DM) указанного столбца был привязан. Это описание не применяется к драйверы, которые возвращают параметр SQL_GETDATA_EXTENSIONS в битовой маске SQL_GD_BOUND **SQLGetInfo**.<br /><br /> (DM) указанного столбца было меньше или равно количеству наивысший связанного столбца. Это описание не применяется к драйверы, которые возвращают параметр SQL_GETDATA_EXTENSIONS в битовой маске SQL_GD_ANY_COLUMN **SQLGetInfo**.<br /><br /> (DM) приложение уже вызван **SQLGetData** для текущей строки; номер столбца, указанного в текущем вызове был меньше, чем номер столбца, указанного в предыдущем вызове; и драйвер не возвращает SQL_ Битовая маска GD_ANY_ORDER параметр SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) *TargetType* аргумент был SQL_ARD_TYPE и *Col_or_Param_Num* запись дескриптора в Отменить не удалось выполнить проверку согласованности.<br /><br /> (DM) *TargetType* аргумент был SQL_ARD_TYPE, и значение в поле SQL_DESC_COUNT Отменить было меньше, чем *Col_or_Param_Num* аргумент.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22002|Переменная индикатора требуется, но не указано|*StrLen_or_IndPtr* был пустым указателем и получения данных значение NULL.|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение (в виде строк или чисел) для столбца вызвало бы всего (в отличие от долей) часть усекаемое число.<br /><br /> Дополнительные сведения см. в разделе [приложение г Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе была привязана к C даты, времени или структура отметки времени, а значение в столбце было при обнаружении неверной даты, времени или timestamp, соответственно. Дополнительные сведения см. в разделе [приложение г Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22012|Деление на ноль|Было возвращено значение из арифметическое выражение, которое привело к деления на ноль.|  
|22015|Переполнение поля интервала|Назначение на основе точное числовое значение или интервал тип SQL тип интервала C привело к потере значащих разрядов в начале поля.<br /><br /> При возврате данных тип интервала C, возникла не представление значения типа SQL в тип интервала C.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе было возвращено в буфер символов C, а столбец содержится символ, для которого отсутствует представление, отсутствует в наборе символов из буфера.<br /><br /> Тип C был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.|  
|24000|Недопустимое состояние курсора|(DM), что функция была вызвана без предварительного вызова функции **SQLFetch** или **SQLFetchScroll** для позиционирования курсора в строке данных обязательно.<br /><br /> (DM) *StatementHandle* была выполненного состоянии, но результирующий набор не связан с *StatementHandle*.<br /><br /> Курсор был открыт на *StatementHandle* и **SQLFetch** или **SQLFetchScroll** бы вызывалась, но курсор был установлен перед началом результирующего набора или после конец результирующего набора.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в *MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003|Тип программы вне допустимого диапазона|(DM) аргумент *TargetType* не допустимый тип данных, SQL_C_DEFAULT, SQL_ARD_TYPE (в случае получение данных столбца) или SQL_APD_TYPE (в случае получения данных параметра).<br /><br /> (DM) аргумент *Col_or_Param_Num* было 0, а аргумент *TargetType* не SQL_C_BOOKMARK для закладки фиксированной длины или SQL_C_VARBOOKMARK для закладки переменной длины.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения, а затем функция был снова вызван на *StatementHandle*.|  
|HY009|Недопустимое использование пустого указателя|(DM) аргумент *TargetValuePtr* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) указанного *StatementHandle* не находился в состоянии выполненного. Функция был вызван без предварительного вызова функции **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLGetData** была вызвана функция.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) *StatementHandle* была выполненного состоянии, но результирующий набор не связан с *StatementHandle*.<br /><br /> Вызов **SQLExeceute**, **SQLExecDirect**, или **SQLMoreResults** возвращается SQL_PARAM_DATA_AVAILABLE, но **SQLGetData** был вызван , а не **SQLParamData**.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное для аргумента *BufferLength* меньше 0.<br /><br /> Значение, указанное для аргумента *BufferLength* был меньше, чем 4 *Col_or_Param_Num* аргумент присвоено значение 0, а драйвер был ODBC 2 *.x* драйвера.|  
|HY109|Недопустимое положение курсора.|Курсор был установлен (по **SQLSetPos**, **SQLFetch**, **SQLFetchScroll**, или **SQLBulkOperations**) в строке, которое было удалено или не удалось извлечь.<br /><br /> Однопроходный курсор находился курсор и размер набора строк было больше единицы.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает использование **SQLGetData** с несколькими строками в **SQLFetchScroll**. Это описание не применяется к драйверы, которые возвращают параметр SQL_GETDATA_EXTENSIONS в битовой маске SQL_GD_BLOCK **SQLGetInfo**.<br /><br /> Драйвер или источник данных не поддерживает преобразование, определяемое сочетание *TargetType* аргументом и типом данных SQL соответствующего столбца. Данная ошибка относится только в том случае, если тип данных SQL столбца был сопоставлен с типом данных специфические для драйвера SQL.<br /><br /> Драйвер поддерживает только ODBC 2 *.x*и аргумент *TargetType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любой из типов данных интервала C, перечисленных в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) в приложение г Типы данных.<br /><br /> Драйвер поддерживает только версии ODBC до выпуска версии 3.50, а аргумент *TargetType* был SQL_C_GUID.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, соответствующий *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **SQLGetData** возвращает данные в указанном столбце. **SQLGetData** может быть вызван только после выбранных один или несколько строк из результирующего набора по **SQLFetch**, **SQLFetchScroll**, или **SQLExtendedFetch**. Если данные переменной длины слишком велико, возвращаемых за один вызов к **SQLGetData** (из-за ограничений в приложение), **SQLGetData** его можно получить в частях. Можно привязать некоторые столбцы в строке и вызвать **SQLGetData** для других пользователей, несмотря на то, что это накладываются некоторые ограничения. Дополнительные сведения см. в разделе [получения длинных данных](../../../odbc/reference/develop-app/getting-long-data.md).  
  
 Дополнительные сведения об использовании **SQLGetData** с потоковых выходных параметров, см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="using-sqlgetdata"></a>С помощью метода SQLGetData  
 Если драйвер не поддерживает расширения **SQLGetData**, функция может возвращать только данные для несвязанных столбцов с номером больше последнего связанного столбца. Кроме того, в строке данных, значение *Col_or_Param_Num* аргумента в каждый вызов **SQLGetData** должно быть больше или равно значению *Col_or_Param_Num*в предыдущем вызове; то есть необходимо получить данные по возрастанию номера столбца. Наконец, если расширения не поддерживаются, **SQLGetData** не может вызываться, если размер набора строк больше, чем 1.  
  
 Драйверы могут опускать эти ограничения. Чтобы определить, какие ограничения, снижает драйвером, приложение вызывает **SQLGetInfo** с любым из следующих вариантов SQL_GETDATA_EXTENSIONS:  
  
-   SQL_GD_OUTPUT_PARAMS = **SQLGetData** может вызываться для возврата значения выходных параметров. Дополнительные сведения см. в разделе [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_GD_ANY_COLUMN. Если этот параметр возвращается, **SQLGetData** может вызываться для любой несвязанного столбца, в том числе до последнего связанного столбца.  
  
-   SQL_GD_ANY_ORDER. Если этот параметр возвращается, **SQLGetData** может вызываться для несвязанных столбцов в любом порядке.  
  
-   SQL_GD_BLOCK. Если этот параметр возвращается **SQLGetInfo** для SQL_GETDATA_EXTENSIONS InfoType, драйвер поддерживает вызовы **SQLGetData** когда размер набора строк больше, чем 1, и приложение может вызвать **SQLSetPos** с параметром SQL_POSITION для позиционирования курсора в строке правильный перед вызовом **SQLGetData.**  
  
-   SQL_GD_BOUND. Если этот параметр возвращается, **SQLGetData** может вызываться для привязанных столбцов, а также для несвязанных столбцов.  
  
 Существует два исключения из этих ограничений, а также возможность опускать их драйвера. Во-первых, **SQLGetData** никогда не должна вызываться для однонаправленного курсора, если размер набора строк больше 1. Во-вторых, если драйвер поддерживает закладки, он всегда должен поддерживать возможность вызова **SQLGetData** для столбца 0, даже если он не позволяет приложениям вызывать **SQLGetData** для других столбцов перед последней привязанного столбца. (Если приложение работа с ODBC 2 *.x* драйвера, **SQLGetData** успешно вернет закладки при вызове с *Col_or_Param_Num* равно 0, после вызова **SQLFetch**, так как **SQLFetch** сопоставлен с ODBC 3 *.x* диспетчера драйверов для **SQLExtendedFetch** с  *FetchOrientation* для SQL_FETCH_NEXT, и **SQLGetData** с *Col_or_Param_Num* 0 сопоставляется с ODBC 3 *.x* диспетчера драйверов для **SQLGetStmtOption** с *fOption* из SQL_GET_BOOKMARK.)  
  
 **SQLGetData** не может использоваться для получения закладка для строки, только что добавили, вызвав **SQLBulkOperations** с параметром sql_add, так как курсор не располагается в строке. Приложения можно получить закладки для такую строку, привязка столбца 0 до вызова метода **SQLBulkOperations** с SQL_ADD, в противном случае **SQLBulkOperations** возвращает закладки в буфере привязки. **SQLFetchScroll** затем может быть вызван с sql_fetch_bookmark аргумента можно переместить курсор в этой строке.  
  
 Если *TargetType* аргумент имеет тип данных интервал, точность начальные интервал по умолчанию (2) и точность секунд интервал по умолчанию (6), как задано в поля SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION Отменить, соответственно, используются для данных. Если *TargetType* аргумент имеет тип данных SQL_C_NUMERIC, точность по умолчанию (определенное драйвером) и по умолчанию масштаб (0), как задано в поля SQL_DESC_PRECISION и SQL_DESC_SCALE Отменить, используются для данных. Если любой по умолчанию точность или масштаб не подходит, приложение должно явным образом задать поле соответствующий дескриптор путем вызова **SQLSetDescField** или **SQLSetDescRec**. Его можно задать поле SQL_DESC_CONCISE_TYPE SQL_C_NUMERIC с последующим вызовом **SQLGetData** с *TargetType* аргумент SQL_ARD_TYPE, что вызовет точность и масштаб значения в поля дескриптора для использования.  
  
> [!NOTE]
>  В ODBC 2 *.x*, набора приложений *TargetType* SQL_C_DATE, SQL_C_TIME или SQL_C_TIMESTAMP, чтобы указать, что \* *TargetValuePtr* является датой, time, или Структура отметки времени. В ODBC 3 *.x*, набора приложений *TargetType* SQL_C_TYPE_DATE, SQL_C_TYPE_TIME или SQL_C_TYPE_TIMESTAMP. Диспетчер драйверов делает соответствующих сопоставлений при необходимости в зависимости от версии приложений и драйверов.  
  
## <a name="retrieving-variable-length-data-in-parts"></a>Извлечение данных переменной длины в частях  
 **SQLGetData** может использоваться для получения данных из столбца, который содержит данные переменной длины в части — то есть, в том случае, когда идентификатор типа данных SQL столбца SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_WCHAR, SQL_WVARCHAR, SQL_ WLONGVARCHAR SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY и идентификатор драйвера для типов переменной длины.  
  
 Для получения данных из столбца в части, приложение вызывает **SQLGetData** несколько раз подряд этого же столбца. При каждом вызове **SQLGetData** возвращает следующей части данных. Это приложение должно воссоздать частей, в этом не забудьте удалить символ завершения null из промежуточных частей символьных данных. Если есть дополнительные данные для возврата или не был выделен достаточный буфер для завершающего символа **SQLGetData** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004 (данных). Если он возвращает последнюю часть данных, **SQLGetData** возвращает значение SQL_SUCCESS. SQL_NO_TOTAL ни нуля может быть возвращено при последнем вызове допустимым для получения данных из столбца, так как приложение будет иметь нет способа узнать, какой объем данных в буфере приложения является допустимым. Если **SQLGetData** вызывается после этого он возвращает значение SQL_NO_DATA. Дополнительные сведения см. в разделе следующем разделе «Получение данных с помощью SQLGetData».  
  
 Закладки переменной длины могут быть возвращены в элементы, указывая **SQLGetData**. Как и в случае с другими данными, вызов **SQLGetData** для возврата закладки переменной длины в части вернет SQLSTATE 01004 (строковые данные, усечение справа) и значение SQL_SUCCESS_WITH_INFO, если данных должны быть возвращены. Это отличается от случая при усечении закладка переменной длины с помощью вызова **SQLFetch** или **SQLFetchScroll**, который возвращает значение SQL_ERROR и SQLSTATE 22001 (строковые данные, усечение справа).  
  
 **SQLGetData** не может использоваться для возврата данных фиксированной длины по частям. Если **SQLGetData** — вызывается несколько раз подряд для столбца, содержащего данные фиксированной длины, будет возвращено SQL_NO_DATA для всех вызовов после первого.  
  
## <a name="retrieving-streamed-output-parameters"></a>Получение потоковых выходных параметров  
 Если драйвер поддерживает потоковых выходных параметров, приложение может вызвать **SQLGetData** с маленькой буфера многократно для получения значения параметра большого объема. Дополнительные сведения о потоковых выходной параметр, см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="retrieving-data-with-sqlgetdata"></a>Извлечение данных с SQLGetData  
 Для возврата данных для указанного столбца, **SQLGetData** выполняет следующую последовательность шагов:  
  
1.  Возвращает значение SQL_NO_DATA, если он уже возвращается все данные для столбца.  
  
2.  Наборы \* *StrLen_or_IndPtr* в значение SQL_NULL_DATA, если данные имеют значение NULL. Если данные имеют значение NULL и *StrLen_or_IndPtr* был пустым указателем, **SQLGetData** возвращает SQLSTATE 22002 (переменная индикатора требуется, но не указано).  
  
     Если данные для столбца не равно NULL, **SQLGetData** переходит к шагу 3.  
  
3.  Если атрибут инструкции sql_attr_max_length параметра задано ненулевое значение, если столбец содержит символьных или двоичных данных и в том случае, если **SQLGetData** ранее не был вызван для этого столбца, данные будут усечены sql_attr_max_length параметра байты.  
  
    > [!NOTE]  
    >  Атрибут инструкции sql_attr_max_length параметра предназначена для снижения сетевого трафика. Она обычно реализуется в источнике данных, который производит усечение данных перед его возвратом по сети. Драйверы и источники данных не требуются для его поддержки. Таким образом, чтобы гарантировать, что данные будут усечены до определенного размера, приложение должно выделить буфер указанного размера и укажите размер в *BufferLength* аргумент.  
  
4.  Преобразует данные к типу, указанному в *TargetType*. Для этого типа данных данные задано по умолчанию точности и масштаба. Если *TargetType* является SQL_ARD_TYPE данных используется тип в поле SQL_DESC_CONCISE_TYPE Отменить. Если *TargetType* не SQL_ARD_TYPE, данных содержится в SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION, точность и масштаб и поля SQL_DESC_SCALE Отменить, в зависимости от данных SQL_DESC_CONCISE _Тип поле. Если любой по умолчанию точность или масштаб не подходит, приложение должно явным образом задать поле соответствующий дескриптор путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
5.  Если данные преобразованы в тип данных переменной длины, например символьный или двоичный файл, **SQLGetData** проверяет, превышает ли длина данных *BufferLength*. Если длина символьных данных (включая символ завершения null) превышает *BufferLength*, **SQLGetData** усекает данные *BufferLength* меньше длины символа завершения null. Он затем заканчиваются значением null данные. Если длина двоичных данных превышает длину буфера данных, **SQLGetData** усекает его *BufferLength* байт.  
  
     Если буфер данных слишком мал для размещения символа завершения null, **SQLGetData** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004.  
  
     **SQLGetData** никогда не усекает данные преобразовать типы данных фиксированной длины; всегда предполагает, что длина **TargetValuePtr* — это размер типа данных.  
  
6.  Помещает данные преобразованный (и возможно усеченный) в \* *TargetValuePtr*. Обратите внимание, что **SQLGetData** не может возвращать данные из строки.  
  
7.  Помещает на длину данных в \* *StrLen_or_IndPtr*. Если *StrLen_or_IndPtr* был пустым указателем, **SQLGetData** не возвращает длину.  
  
    -   Для символьных или двоичных данных, это длина данных после преобразования и перед усечением из-за *BufferLength*. Если драйвер не может определить длину данных после преобразования, что иногда происходит при использовании длинных данных, он возвращает значение SQL_SUCCESS_WITH_INFO и устанавливает длину SQL_NO_TOTAL. (Последнего вызова **SQLGetData** должны всегда возвращать длину данных, а не нуль или SQL_NO_TOTAL.) Если данные были усечены из-за атрибута инструкции sql_attr_max_length параметра, значение этого атрибута — в отличие от фактическая длина - помещается в \* *StrLen_or_IndPtr*. Это потому, что этот атрибут предназначен для усечения данных на сервере до преобразования, поэтому драйвер не имеет возможности выяснить, какая фактическая длина. Когда **SQLGetData** является вызывать несколько раз подряд, для того же столбца, это длина данных, доступных в начале текущего вызова; то есть длина уменьшается при каждом последующем вызове.  
  
    -   Для всех других типов данных это длина данных после преобразования; он является размер типа, к которому данные преобразованы.  
  
8.  Если данные будут усечены при выполнении преобразования без потери значимости (например, вещественное число 1,234 усекается при преобразовании в целочисленное значение 1) или из-за *BufferLength* слишком мал (например, строка «abcdef» помещается в буфере 4-байтовое) **SQLGetData** возвращает SQLSTATE 01004 (данных) и SQL_SUCCESS_WITH_INFO. Если данные усекаются без потери значимости, из-за атрибута инструкции значения SQL_ATTR_MAX_LENGTH, **SQLGetData** возвращает значение SQL_SUCCESS и не возвращает SQLSTATE 01004 (данных).  
  
 Содержимое буфера привязанного к данным (если **SQLGetData** вызывается для связанного столбца) и буфер длины/индикатора определены, если **SQLGetData** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Последовательные вызовы **SQLGetData** извлечет данные из последнего столбца запрошено; предыдущие смещения становятся недействительными. Например, когда выполняется следующая последовательность:  
  
```  
SQLGetData(icol=n), SQLGetData(icol=m), SQLGetData(icol=n)  
```  
  
 Второй вызов SQLGetData(icol=n) извлекает данные из начала n столбца. Смещения в данных, из-за предыдущих вызовов **SQLGetData** для столбца больше не является допустимым.  
  
## <a name="descriptors-and-sqlgetdata"></a>Дескрипторы и SQLGetData  
 **SQLGetData** не взаимодействует напрямую с полями дескриптора.  
  
 Если *TargetType* является SQL_ARD_TYPE данных используется тип в поле SQL_DESC_CONCISE_TYPE Отменить. Если *TargetType* SQL_ARD_TYPE или SQL_C_DEFAULT, данные приведены точность и масштаб в SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION, и введите поля SQL_DESC_SCALE Отменить, в зависимости от данных в поле SQL_DESC_CONCISE_TYPE.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет **ВЫБЕРИТЕ** инструкция возвращает результирующий набор клиента идентификаторы, имена, и телефонных номеров, отсортированных по имени, идентификатор и номер телефона. Для каждой строки данных, он вызывает **SQLFetch** для позиционирования курсора на следующую строку. Он вызывает **SQLGetData** для извлечения данных выборки; буферы данных и возвращенное число байтов, указаны в вызове **SQLGetData**. Наконец он выводит имя каждого сотрудника, идентификатор и номер телефона.  
  
```  
#define NAME_LEN 50  
#define PHONE_LEN 50  
  
SQLCHAR      szName[NAME_LEN], szPhone[PHONE_LEN];  
SQLINTEGER   sCustID, cbName, cbAge, cbBirthday;  
SQLRETURN    retcode;  
SQLHSTMT     hstmt;  
  
retcode = SQLExecDirect(hstmt,  
   "SELECT CUSTID, NAME, PHONE FROM CUSTOMERS ORDER BY 2, 1, 3",  
   SQL_NTS);  
  
if (retcode == SQL_SUCCESS) {  
   while (TRUE) {  
      retcode = SQLFetch(hstmt);  
      if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO) {  
         show_error();  
      }  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO){  
  
         /* Get data for columns 1, 2, and 3 */  
  
         SQLGetData(hstmt, 1, SQL_C_ULONG, &sCustID, 0, &cbCustID);  
         SQLGetData(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &cbName);  
         SQLGetData(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN,  
            &cbPhone);  
  
         /* Print the row of data */  
  
         fprintf(out, "%-5d %-*s %*s", sCustID, NAME_LEN-1, szName,   
            PHONE_LEN-1, szPhone);  
      } else {  
         break;  
      }  
   }  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Назначение хранилища для столбца в результирующем наборе|[SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнения массовых операций, которые не связаны с позицией курсора блока|[SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработка инструкций|[SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение инструкции SQL|[SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнении подготовленной инструкции SQL|[SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Блока данных или прокрутке результирующего набора|[SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Выборка одной строки данных или блока данных в направлении только вперед|[SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Отправка данных параметра во время выполнения|[SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Позиционирование курсора, обновление данных в наборе строк или удаления данных в наборе строк|[SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
