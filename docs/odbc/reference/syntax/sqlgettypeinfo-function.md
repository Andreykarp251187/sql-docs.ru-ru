---
title: Функция S'LGetTypeInfo (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetTypeInfo
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetTypeInfo
helpviewer_keywords:
- SQLGetTypeInfo function [ODBC]
ms.assetid: bdedb044-8924-4ca4-85f3-8b37578e0257
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 47273c75a005f11b33e9929977b57607b36898de
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81303265"
---
# <a name="sqlgettypeinfo-function"></a>Функция SQLGetTypeInfo
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **SLGetTypeInfo** возвращает информацию о типах данных, поддерживаемых источником данных. Водитель возвращает информацию в виде набора результатов S'L. Типы данных предназначены для использования в заявлениях языка определения данных (DDL).  
  
> [!IMPORTANT]  
>  Приложения должны использовать имена типов, возвращенные в TYPE_NAME столбца результатов **s'LGetTypeInfo,** установленных в заявлениях **ALTER TABLE** и **CREATE TABLE.** **В** DATA_TYPE столбец может вернуть несколько строк с одинаковым значением.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetTypeInfo(  
     SQLHSTMT      StatementHandle,  
     SQLSMALLINT   DataType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора для набора результатов.  
  
 *DataType*  
 (Вход) Тип данных S'L. Это должно быть одно из значений в разделе [Типы данных в](../../../odbc/reference/appendixes/sql-data-types.md) приложении D: Типы данных, или тип данных, специфичный для драйверов. SQL_ALL_TYPES указывает, что информация обо всех типах данных должна быть возвращена.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **sLGetTypeInfo** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону s'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_STMT и *ручки* *обработки заявлений.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **s'LGetTypeInfo,** и разъясняются каждые из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Изменение значения опциона|Определенный атрибут оператора был недействительным из-за условий выполнения работы, поэтому аналогичное значение было временно заменено. (Позвоните **в S'LGetStmtAttr,** чтобы определить временно замещенное значение.) Значение замены допустимо для *StatementHandle* до тех пор, пока курсор не будет закрыт. Атрибуты оператора, которые могут быть изменены: SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_KEYSET_SIZE, SQL_ATTR_MAX_LENGTH, SQL_ATTR_MAX_ROWS, SQL_ATTR_QUERY_TIMEOUT и SQL_ATTR_SIMULATE_CURSOR. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|Курсор был открыт на *statementHandle,* и **s'LFetch** или **S'LFetchScroll** был вызван. Эта ошибка возвращается менеджером-драйвером, если **S'LFetch** или **S'LFetchScroll** не вернулись SQL_NO_DATA, и возвращается драйвером, если **S'LFetch** или **S'LFetchScroll** вернулся SQL_NO_DATA.<br /><br /> Набор результатов был открыт на *statementHandle,* но **S'LFetch** или **S'LFetchScroll** не были вызваны.|  
|40001|Сбой сериализации|Транзакция была отката из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY004|Недействительный тип данных S'L|Значение, указанное для аргумента *DataType,* не является ни действительным идентификатором типа данных ODBC S'L, ни идентификатором типа данных, поддерживаемым драйвером.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*, затем функция была вызвана и, прежде чем она завершила выполнение, **S'LCancel** или **S'LКансортхенд** был вызван на *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и до завершения выполнения **s'LCancel** или **S'LКансортхлик** был вызван в *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась при вызове функции **S'LGetTypeInfo.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Комбинация текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE оператора не была поддержана драйвером или источником данных.<br /><br /> Атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_VARIABLE, а атрибут SQL_ATTR_CURSOR_TYPE оператора был установлен на тип курсора, для которого водитель не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается с **помощью S'LSetStmtAttr,** SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, соответствующий *statementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **SLGetTypeInfo** возвращает результаты в качестве стандартного набора результатов, заказанный DATA_TYPE а затем по тому, насколько близко карты типа данных к соответствующему типу данных ODBC S'L. Типы данных, определяемые источником данных, имеют приоритет над типами данных, определяемых пользователем. Следовательно, порядок сортировки не обязательно соответствует, но может быть обобщен как DATA_TYPE сначала, а затем TYPE_NAME, как восходящие. Например, предположим, что источник данных определил типы данных INTEGER и COUNTER, где COUNTER является автоматическим увеличением, и что также определен тип данных, определяемый пользователем. Они будут возвращены в порядке INTEGER, WHOLENUM и COUNTER, потому что карты WHOLENUM, близкие к типу данных ODBC S'L, SQL_INTEGER, в то время как автоматический приращение типа данных, даже при поддержке источника данных, не отображается близко к типу данных ODBC S'L. Для получения информации о том, как эта информация может быть использована, [см.](../../../odbc/reference/develop-app/ddl-statements.md)  
  
 Если аргумент *DataType* определяет тип данных, который действителен для версии ODBC, поддерживаемой драйвером, но не поддерживается драйвером, то он возвращает пустой набор результатов.  
  
> [!NOTE]  
>  Для получения дополнительной информации об общем использовании, аргументах и возвращенных данных функций каталога ODBC [см.](../../../odbc/reference/develop-app/catalog-functions.md)  
  
 Следующие столбцы были переименованы в ODBC 3. *x*. Изменения имени столбца не влияют на обратную совместимость, поскольку приложения связываются с номером столбца.  
  
|Колонка ODBC 2.0|ODBC 3. *x* колонка|  
|---------------------|-----------------------|  
|PRECISION|COLUMN_SIZE|  
|MONEY|FIXED_PREC_SCALE|  
|AUTO_INCREMENT|AUTO_UNIQUE_VALUE|  
  
 Следующие столбцы были добавлены к набору результатов, возвращенных **S'LGetTypeInfo** для ODBC 3. *x*:  
  
-   SQL_DATA_TYPE  
  
-   INTERVAL_PRECISION  
  
-   SQL_DATETIME_SUB  
  
-   NUM_PREC_RADIX  
  
 В следующей таблице перечислены столбцы в наборе результатов. Дополнительные столбцы за столбец 19 (INTERVAL_PRECISION) могут быть определены драйвером. Приложение должно получить доступ к столбику, в зависимости от драйвера, отсчитывая от конца набора результатов, а не указывая явное обыдающееся положение. Для получения дополнительной информации смотрите [данные, возвращенные функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
> [!NOTE]  
>  **Возможно, не** все типы данных могут быть возвращены. Например, драйвер может не возвращать типы данных, определяемых пользователем. Приложения могут использовать любой допустимый тип данных, независимо от того, возвращается ли они **компанией S'LGetTypeInfo.** Типы данных, возвращенные **s'LGetTypeInfo,** поддерживаются источником данных. Они предназначены для использования в заявлениях языка определения данных (DDL). Драйверы могут возвращать данные, установленные в результате, используя типы данных, помимо типов, возвращенных **S'LGetTypeInfo.** При создании набора результатов для функции каталога драйвер может использовать тип данных, не поддерживаемый источником данных.  
  
|Имя столбца|Столбец<br /><br /> number|Тип данных|Комментарии|  
|-----------------|-----------------------|---------------|--------------|  
|TYPE_NAME (ODBC 2.0)|1|Варчар не NULL|Имя типа данных, зависящих от источников данных; например, "CHAR()", "VARCHAR()", "MONEY", "LONG VARBINARY", или "CHAR ( ) ДЛЯ BIT DATA". Приложения должны использовать это имя в заявлениях **CREATE TABLE** и **ALTER TABLE.**|  
|DATA_TYPE (ODBC 2.0)|2|Smallint, не NULL|Тип данных S'L. Это может быть тип данных ODBC S'L или тип данных, специфичный для драйверов, с помощью s-L. Для типов данных дат или интервалов этот столбец возвращает краткий тип данных (например, SQL_TYPE_TIME или SQL_INTERVAL_YEAR_TO_MONTH). В приложении D: Типы данных ODBC S'L [можно](../../../odbc/reference/appendixes/sql-data-types.md) ознакомиться с перечном списке действительных типов данных ODBC S'L. Для получения информации о типах данных, специфичных для драйверов, просмотрите документацию водителя.|  
|COLUMN_SIZE (ODBC 2.0)|3|Целое число|Максимальный размер столбца, который сервер поддерживает для этого типа данных. Для числовых данных это максимальная точность. Для строковых данных это длина символов. Для типов данных дат это длина символов представления строки (при условии максимально допустимой точности компонента дробных секунд). NULL возвращается для типов данных, где размер столбца неприменим. Для типов интервальных данных это число символов в представлении символов интервала буквального (определяемое точностью интервала; [см. Длина типа данных Интервала](../../../odbc/reference/appendixes/interval-data-type-length.md) в приложении D: Типы данных).<br /><br /> Для получения дополнительной информации о размере столбца [в](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) приложении D: Типы данных см.|  
|LITERAL_PREFIX (ODBC 2.0)|4|Varchar|Персонаж или символы, используемые для префикса буквального; например, единый знак котировок (') для типов данных символов или 0x для бинарных типов данных; NULL возвращается для типов данных, где буквальная приставка неприменима.|  
|LITERAL_SUFFIX (ODBC 2.0)|5|Varchar|Персонаж или символы, используемые для прекращения буквального; например, единый знак котировок (') для типов данных символов; NULL возвращается для типов данных, где буквальный суффикс не применим.|  
|CREATE_PARAMS (ODBC 2.0)|6|Varchar|Список ключевых слов, разделенных запятыми, соответствующий каждому параметру, который приложение может указать в скобках при использовании имени, возвращенного в поле TYPE_NAME. Ключевые слова в списке могут быть любым из следующих: длина, точность или масштаб. Они отображаются в порядке, который требует их использования синтаксиса. Например, CREATE_PARAMS DECIMAL будет "точной,масштабной"; CREATE_PARAMS для VARCHAR будет равна "длине". NULL возвращается, если нет параметров для определения типа данных; например, ИНТЕГЕР.<br /><br /> Водитель поставляет CREATE_PARAMS текст на языке страны/региона, где он используется.|  
|НЕОБЫДАНЫЙ (ODBC 2.0)|7|Smallint, не NULL|Принимает ли тип данных значение NULL:<br /><br /> SQL_NO_NULLS, если тип данных не принимает значения NULL.<br /><br /> SQL_NULLABLE, если тип данных принимает значения NULL.<br /><br /> SQL_NULLABLE_UNKNOWN если не известно, принимает ли столбец значения NULL.|  
|CASE_SENSITIVE (ODBC 2.0)|8|Smallint, не NULL|Является ли тип данных персонажа чувствительным к случаям в сопоставлениях и сравнениях:<br /><br /> SQL_TRUE, если тип данных является типом данных символов и является чувствительным к случаям.<br /><br /> SQL_FALSE, если тип данных не является типом данных символов или не является чувствительным к случаям.|  
|ПОИСК (ODBC 2.0)|9|Smallint, не NULL|Как тип данных используется в пункте **WHERE:**<br /><br /> SQL_PRED_NONE, если столбец не может быть использован в пункте **WHERE.** (Это то же самое, что и SQL_UNSEARCHABLE значение в ODBC 2. *x*.)<br /><br /> SQL_PRED_CHAR, если столбец может быть использован в пункте **WHERE,** но только с предикатом **LIKE.** (Это то же самое, что и SQL_LIKE_ONLY значение в ODBC 2. *x*.)<br /><br /> SQL_PRED_BASIC, если столбец может быть использован в пункте **WHERE** со всеми операторами сравнения, за исключением **LIKE** (сравнение, количественное сравнение, **BETWEEN**, **ОТЛИЧИЕ**, **В**, **MATCH**, и **УНИКУЕ).** (Это то же самое, что и SQL_ALL_EXCEPT_LIKE значение в ODBC 2. *x*.)<br /><br /> SQL_SEARCHABLE если столбец может быть использован в пункте **WHERE** с любым оператором сравнения.|  
|UNSIGNED_ATTRIBUTE (ODBC 2.0)|10|Smallint|Является ли тип данных неподписанным:<br /><br /> SQL_TRUE, если тип данных не подписан.<br /><br /> SQL_FALSE, если тип данных подписан.<br /><br /> NULL возвращается, если атрибут не применим к типу данных или тип данных не является числовым.|  
|FIXED_PREC_SCALE (ODBC 2.0)|11|Smallint, не NULL|Имеет ли тип данных предопределено фиксированная точность и масштаб (которые специфичны для исходных данных), например тип данных денег:<br /><br /> SQL_TRUE если он имеет предопределенную фиксированную точность и масштаб.<br /><br /> SQL_FALSE, если он не имеет заданной фиксированной точности и масштаба.|  
|AUTO_UNIQUE_VALUE (ODBC 2.0)|12|Smallint|Является ли тип данных аутоинкремированием:<br /><br /> SQL_TRUE, если тип данных является аутоинкремированием.<br /><br /> SQL_FALSE, если тип данных не является аутоинкремированием.<br /><br /> NULL возвращается, если атрибут не применим к типу данных или тип данных не является числовым.<br /><br /> Приложение может вставить значения в столбец, имеющий этот атрибут, но обычно не может обновлять значения в столбце.<br /><br /> Когда вставка сделана в столбец автоматического приращения, уникальное значение вставляется в столбец во время вставки. Приращение не определено, но является источником данных. Приложение не должно предполагать, что столбец автоматического приращения начинается в какой-либо конкретной точке или приращения какой-либо конкретной стоимости.|  
|LOCAL_TYPE_NAME (ODBC 2.0)|13|Varchar|Локализованная версия имени типа данных, которое зависит от источника данных. Если локализованное имя не поддерживается источником данных, возвращается значение NULL. Это имя предназначено только для отображения, например, в диалоговых коробках.|  
|MINIMUM_SCALE (ODBC 2.0)|14|Smallint|Минимальная шкала типа данных на источнике данных. Если тип данных имеет фиксированный масштаб, это значение содержится и в столбце MINIMUM_SCALE, и в столбце MAXIMUM_SCALE. Например, столбец SQL_TYPE_TIMESTAMP может иметь фиксированную шкалу для дробных секунд. Для типов данных, к которым понятие масштаба не применимо, возвращается значение NULL. Для получения дополнительной информации в приложении D: Типы данных [см.](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)|  
|MAXIMUM_SCALE (ODBC 2.0)|15|Smallint|Максимальная шкала типа данных на источнике данных. Для типов данных, к которым понятие масштаба не применимо, возвращается значение NULL. Если максимальная шкала не определена отдельно в источнике данных, а определяется как максимальная точность, этот столбец содержит то же значение, что и COLUMN_SIZE столбец. Для получения дополнительной информации в приложении D: Типы данных [см.](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)|  
|SQL_DATA_TYPE (ODBC 3.0)|16|Smallint НЕ NULL|Значение типа данных S'L, как он появляется в SQL_DESC_TYPE поле дескриптора. Этот столбец совпадает с DATA_TYPE столбец, за исключением типов данных интервала и даты.<br /><br /> Для типов данных интервала и даты поле SQL_DATA_TYPE в наборе результатов будет возвращаться SQL_INTERVAL или SQL_DATETIME, а поле SQL_DATETIME_SUB возвращает подкод для конкретного типа данных интервала или даты. [(См. Приложение D: Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)|  
|SQL_DATETIME_SUB (ODBC 3.0)|17|Smallint|Когда значение SQL_DATA_TYPE SQL_DATETIME или SQL_INTERVAL, этот столбец содержит подкод времени даты/интервала. Для типов данных, помимо времени и интервала, это поле является NULL.<br /><br /> Для типов данных интервала или даты поле SQL_DATA_TYPE в наборе результатов будет возвращаться SQL_INTERVAL или SQL_DATETIME, а поле SQL_DATETIME_SUB возвращает подкод для конкретного типа данных интервала или даты. [(См. Приложение D: Типы данных](../../../odbc/reference/appendixes/appendix-d-data-types.md).)|  
|NUM_PREC_RADIX (ODBC 3.0)|18|Целое число|Если тип данных является приблизительной числовой, этот столбец содержит значение 2, чтобы указать, что COLUMN_SIZE определяет количество битов. Для точных численных типов этот столбец содержит значение 10, чтобы указать, что COLUMN_SIZE указывает ряд десятичных цифр. В противном случае этот столбец содержит значение NULL.|  
|INTERVAL_PRECISION (ODBC 3.0)|19|Smallint|Если тип данных представляет собой тип интервальных данных, то этот столбец содержит значение точности, ведущей интервала. (См. [Точность типа данных Интервала](../../../odbc/reference/appendixes/interval-data-type-precision.md) в приложении D: Типы данных.) В противном случае эта колонка является NULL.|  
  
 Информация об атрибутах может применяться к типам данных или к определенным столбикам в наборе результатов. **S'LGetTypeInfo** возвращает информацию об атрибутах, связанных с типами данных; В наборе результатов **S'LColAttribute** возвращает информацию об атрибутах, связанных с столбцов.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение информации о столбце в наборе результатов|[Функция SQLColAttribute](../../../odbc/reference/syntax/sqlcolattribute-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одной строки или блока данных в направлении только вперед|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Возвращение информации о драйвере или источнике данных|[SQLGetInfo, функция](../../../odbc/reference/syntax/sqlgetinfo-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
