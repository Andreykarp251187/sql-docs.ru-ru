---
title: Функция S'LGetDiagRec (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetDiagRec
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetDiagRec
helpviewer_keywords:
- SQLGetDiagRec function [ODBC]
ms.assetid: ebdbac93-3d68-438f-8416-ef1f08e04269
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 39069526e254903509ddfef00b7bd4844f3d9e10
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285384"
---
# <a name="sqlgetdiagrec-function"></a>Функция SQLGetDiagRec
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **S'LGetDiagRec** возвращает текущие значения нескольких полей диагностической записи, содержащей информацию об ошибках, предупреждении и статусе. В отличие от **S'LGetDiagField**, который возвращает одно диагностическое поле за вызов, **S'LGetDiagRec** возвращает несколько часто используемых полей диагностической записи, в том числе S'LSTATE, родной код ошибки, и текст диагностического сообщения.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetDiagRec(  
     SQLSMALLINT     HandleType,  
     SQLHANDLE       Handle,  
     SQLSMALLINT     RecNumber,  
     SQLCHAR *       SQLState,  
     SQLINTEGER *    NativeErrorPtr,  
     SQLCHAR *       MessageText,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   TextLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 (Вход) Идентификатор типа ручки, описывающий тип ручки, для которой требуется диагностика. Должна быть одной из следующих:  
  
-   SQL_HANDLE_DBC  
  
-   SQL_HANDLE_DBC_INFO_TOKEN  
  
-   SQL_HANDLE_DESC  
  
-   SQL_HANDLE_ENV  
  
-   SQL_HANDLE_STMT  
  
 SQL_HANDLE_DBC_INFO_TOKEN ручка используется только менеджером водителя и водителем. Приложения не должны использовать этот тип рукоятки. Для получения дополнительной информации о SQL_HANDLE_DBC_INFO_TOKEN [см.](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md)  
  
 *Дескриптор*  
 (Вход) Ручка для структуры диагностических данных, типа, указанного *HandleType*. Если *HandleType* SQL_HANDLE_ENV, *ручка* может быть как общей, так и необщей обработкой среды.  
  
 *RecNumber*  
 (Вход) Отоснажает запись состояния, из которой приложение ищет информацию. Записи о состоянии пронумероированы с 1.  
  
 *Sqlstate*  
 (Выход) Указатель на буфер, в котором можно вернуть код с пятью символами S'LSTATE (и прекращать NULL) для диагностической записи *RecNumber.* Первые два символа указывают класс; следующие три указывают на подкласс. Эта информация содержится в диагностической области SQL_DIAG_SQLSTATE. Для получения более подробной информации ознакомьтесь с [см.](../../../odbc/reference/develop-app/sqlstates.md)  
  
 *NativeErrorPtr*  
 (Выход) Указатель на буфер, в котором можно вернуть исходный код ошибки, специфичный для источника данных. Эта информация содержится в SQL_DIAG_NATIVE диагностической области.  
  
 *MessageText*  
 (Выход) Указатель на буфер, в котором можно вернуть строку текста диагностического сообщения. Эта информация содержится в SQL_DIAG_MESSAGE_TEXT диагностической области. Для формата строки [см.](../../../odbc/reference/develop-app/diagnostic-messages.md)  
  
 Если *MessageText* является NULL, *TextLengthPtr* по-прежнему возвращает общее количество символов (за исключением символа с нулевым прекращением для данных символов), доступных для возврата в буфере, на который указывает *MessageText.*  
  
 *BufferLength*  
 (Вход) Длина буфера*MessageText* в символах. Максимальная длина текста диагностического сообщения отсутствует.  
  
 *TextLengthPtr*  
 (Выход) Указатель на буфер, в котором можно вернуть общее количество символов (за исключением количества символов, необходимых для символа с нулевым прекращением), доступного для возврата в * \*MessageText.* Если количество символов, доступных для возврата, больше, чем *BufferLength,* текст диагностического сообщения в * \*MessageText* усечен до *BufferLength* минус длина символа с нулевым прекращением.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 **S'LGetDiagRec** не публикует для себя диагностические записи. Он использует следующие значения возврата, чтобы сообщить о результатах собственного исполнения:  
  
-   SQL_SUCCESS: Функция успешно вернула диагностическую информацию.  
  
-   SQL_SUCCESS_WITH_INFO: \*Буфер *MessageText* был слишком мал, чтобы удерживать запрошенное диагностическое сообщение. Диагностические записи не были созданы. Чтобы определить, что усечение произошло, приложение должно сравнить *BufferLength* с фактическим числом байтов доступны, который написан на*StringLengthPtr*.  
  
-   SQL_INVALID_HANDLE: Ручка, указанная *HandleType* и *Handle,* не является действительной ручкой.  
  
-   SQL_ERROR: Произошло одно из следующих:  
  
    -   *RecNumber* был отрицательным или 0.  
  
    -   *BufferLength* был меньше нуля.  
  
    -   При использовании асинхронного уведомления асинхронная операция на рукоятке не была завершена.  
  
-   SQL_NO_DATA: *RecNumber* был больше, чем количество диагностических записей, которые существовали для ручки, указанной в *ручке.* Функция также возвращает SQL_NO_DATA для любого положительного *RecNumber,* если нет диагностических записей для *Ручка*.  
  
## <a name="comments"></a>Комментарии  
 Приложение обычно вызывает **S'LGetDiagRec,** когда предыдущий вызов функции ODBC вернулся SQL_ERROR или SQL_SUCCESS_WITH_INFO. Однако, поскольку любая функция ODBC может размещать нулевые или более диагностические записи каждый раз, когда она называется, приложение может вызвать **S'LGetDiagRec** после любого вызова функции ODBC. Приложение может несколько раз вызывать **s'LGetDiagRec,** чтобы вернуть некоторые или все записи в структуре диагностических данных. ODBC не накладывает ограничений на количество диагностических записей, которые могут храниться в любой момент времени.  
  
 **СЗЛГетДиагРене** не может использоваться для возврата полей из заголовка структуры диагностических данных. (Аргумент *RecNumber* должен быть больше, чем 0.) Для этого приложение должно позвонить по **телефону s'LGetDiagField.**  
  
 **СЗЛГетДиагРе** получает только диагностическую информацию, связанную с ручкой, указанную в аргументе *Ручки.* Если приложение вызывает другую функцию ODBC, за исключением **S'LGetDiagRec**, **S'LGetDiagField**, или **S'LError**, любая диагностическая информация из предыдущих вызовов на той же ручке теряется.  
  
 Приложение может сканировать все диагностические записи, зацикливая, прибавляя *RecNumber,* до тех пор, пока **s'LGetDiagRec** возвращается SQL_SUCCESS. Вызовы на **S'LGetDiagRec** неразрушают для заголовков и полей записи. Приложение может снова позвонить в **S'LGetDiagRec** позже, чтобы получить поле из записи, пока никакая другая функция, кроме **S'LGetDiagRec**, **S'LGetDiagField**, или **S'LError**, была вызвана в промежуточный период. Приложение также может получить количество общего числа диагностических записей, доступных, позвонив в **S'LGetDiagField,** чтобы получить значение SQL_DIAG_NUMBER поля, а затем позвонив в **S'LGetDiagRec,** что много раз.  
  
 Для описания полей структуры диагностических данных, [см.](../../../odbc/reference/syntax/sqlgetdiagfield-function.md) Для получения более подробной информации, [см.](../../../odbc/reference/develop-app/using-sqlgetdiagrec-and-sqlgetdiagfield.md) [Implementing SQLGetDiagRec and SQLGetDiagField](../../../odbc/reference/develop-app/implementing-sqlgetdiagrec-and-sqlgetdiagfield.md)  
  
 Вызов API, отличный от того, который выполняется асинхронно, будет генерировать HY010 "Ошибка последовательности функций". Однако запись ошибки не может быть получена до завершения асинхронной операции.  
  
## <a name="handletype-argument"></a>Аргумент HandleType  
 Каждый тип ручки может иметь диагностическую информацию, связанную с ним. Аргумент *HandleType* обозначает тип ручки аргумента *Ручка.*  
  
 Некоторые поля заголовка и записи не могут быть возвращены для обработки среды, соединения, оператора и дескриптора. Те ручки, для которых поле не применимо, указаны в разделах "Заголовки полей" и "Record Fields" в [разделе S'LGetDiagField.](../../../odbc/reference/syntax/sqlgetdiagfield-function.md)  
  
 Вызов на **sLGetDiagRec** вернется SQL_INVALID_HANDLE, если *HandleType* SQL_HANDLE_SENV, что означает общую ручку среды. Однако, если *HandleType* SQL_HANDLE_ENV, *ручка* может быть как общей, так и необщей обработкой среды.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Получение поля диагностической записи или поля диагностического заголовка|[Функция SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Образец программы ODBC](../../../odbc/reference/sample-odbc-program.md)
