---
title: Функция S'LGetDiagField (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetDiagField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetDiagField
helpviewer_keywords:
- SQLGetDiagField function [ODBC]
ms.assetid: 1dbc4398-97a8-4585-bb77-1f7ea75e24c4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a26319868a4b94b895da73d39b284f612fe35889
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285434"
---
# <a name="sqlgetdiagfield-function"></a>Функция SQLGetDiagField

**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **S'LGetDiagField** возвращает текущее значение поля записи структуры диагностических данных (связанных с указанной ручкой), содержащего информацию об ошибках, предупреждении и статусе.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp

SQLRETURN SQLGetDiagField(  
     SQLSMALLINT     HandleType,  
     SQLHANDLE       Handle,  
     SQLSMALLINT     RecNumber,  
     SQLSMALLINT     DiagIdentifier,  
     SQLPOINTER      DiagInfoPtr,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   StringLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 (Вход) Идентификатор типа ручки, описывающий тип ручки, для которой требуется диагностика. Должна быть одной из следующих:  
  
-   SQL_HANDLE_DBC  
  
-   SQL_HANDLE_DBC_INFO_TOKEN  
  
-   SQL_HANDLE_DESC  
  
-   SQL_HANDLE_ENV  
  
-   SQL_HANDLE_STMT  
  
 SQL_HANDLE_DBC_INFO_TOKEN ручка используется только менеджером водителя и водителем. Приложения не должны использовать этот тип рукоятки. Для получения дополнительной информации о SQL_HANDLE_DBC_INFO_TOKEN [см.](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md)  
  
 *Дескриптор*  
 (Вход) Ручка для структуры диагностических данных, типа, указанного *HandleType*. Если *HandleType* SQL_HANDLE_ENV, *ручка* может быть как общей, так и необщей обработкой среды.  
  
 *RecNumber*  
 (Вход) Отоснажает запись состояния, из которой приложение ищет информацию. Записи о состоянии пронумероированы с 1. Если аргумент *DiagIdentifier* указывает на какое-либо поле заголовка диагностики, *RecNumber* игнорируется. Если нет, то она должна быть больше, чем 0.  
  
 *ДиагИктификатор*  
 (Вход) Указывает поле диагностики, значение которой должно быть возвращено. Подробнее об этом читайте в материале*журнала* "Аргументы недели" "Комментарии".  
  
 *ДиагИнфоПтр*  
 (Выход) Указатель на буфер, в котором можно вернуть диагностическую информацию. Тип данных зависит от значения *DiagIdentifier.* Если *DiagInfoPtr* является целым типом, приложения должны использовать буфер S'LULEN и инициализировать значение до 0, прежде чем вызывать эту функцию, так как некоторые драйверы могут писать только нижний 32-битный или 16-битный буфер и оставить бит более высокого порядка без изменений.  
  
 Если *DiagInfoPtr* является NULL, *StringLengthPtr* по-прежнему возвращает общее количество байтов (за исключением символа нулевого прекращения для данных о персонажах), доступного для возврата в буфере, на который указывает *DiagInfoPtr.*  
  
 *BufferLength*  
 (Вход) Если *DiagIdentifier* является диагностикой, определяемой ODBC, а *DiagInfoPtr* указывает на \*строку символов или бинарный буфер, этот аргумент должен быть длиной *DiagInfoPtr.* Если *DiagIdentifier* является полем, \*определяемым ODBC, а *DiagInfoPtr* — это ряд, *то BufferLength* игнорируется. Если значение в * \*DiagInfoPtr* является строкой Unicode (при вызове **S'LGetDiagFieldW),** аргумент *BufferLength* должен быть четным числом.  
  
 Если *DiagIdentifier* является полем, определяемым драйвером, приложение указывает на характер поля менеджеру драйвера, установив аргумент *BufferLength.* *BufferLength* может иметь следующие значения:  
  
-   Если *DiagInfoPtr* является указателем на строку персонажа, *BufferLength* — это длина строки или SQL_NTS.  
  
-   Если *DiagInfoPtr* является указателем на двоичный буфер, приложение помещает результат SQL_LEN_BINARY_ATTR *(длина)* макроса в *BufferLength*. Это ставит отрицательное значение в *BufferLength*.  
  
-   Если *DiagInfoPtr* является указателем на значение, кроме строки символов или двоичной строки, *BufferLength* должен иметь значение SQL_IS_POINTER.  
  
-   Если * \*DiagInfoPtr* содержит тип данных с фиксированной длиной, *BufferLength* SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT или SQL_IS_USMALLINT, если это необходимо.  
  
 *СтрунныйДлинПтр*  
 (Выход) Указатель на буфер, в котором можно вернуть общее количество байтов (за исключением количества байтов, необходимых для символа нулевого прекращения), доступного для возврата в \* *DiagInfoPtr*для данных о символах. Если количество байтов, доступных для возврата, больше или \*равно *BufferLength,* текст в *DiagInfoPtr* усечен до *BufferLength* минус длина персонажа с нулевым прекращением.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_NO_DATA.  
  
## <a name="diagnostics"></a>Диагностика  
 **Компания S'LGetDiagField** не публикует для себя диагностические записи. Он использует следующие значения возврата, чтобы сообщить о результатах собственного исполнения:  
  
-   SQL_SUCCESS: Функция успешно вернула диагностическую информацию.  
  
-   SQL_SUCCESS_WITH_INFO: \* *DiagInfoPtr* был слишком мал, чтобы держать запрашиваемый диагностический пол. Таким образом, данные в диагностической области были усечены. Чтобы определить, что усечение произошло, приложение должно сравнить *BufferLength* с фактическим числом байтов доступны, который написан на*StringLengthPtr*.  
  
-   SQL_INVALID_HANDLE: Ручка, указанная *HandleType* и *Handle,* не является действительной ручкой.  
  
-   SQL_ERROR: Произошло одно из следующих:  
  
    -   Аргумент *DiagIdentifier* не был одним из действительных значений.  
  
    -   *Аргумент DiagIdentifier* был SQL_DIAG_CURSOR_ROW_COUNT, SQL_DIAG_DYNAMIC_FUNCTION, SQL_DIAG_DYNAMIC_FUNCTION_CODE или SQL_DIAG_ROW_COUNT, но *ручка* не была ручкой оператора. (Менеджер драйвера возвращает эту диагностику.)  
  
    -   *Аргумент RecNumber* был отрицательным или 0, когда *DiagIdentifier* указал поле из диагностической записи. *RecNumber* игнорируется для полей заголовка.  
  
    -   Запрошенное значение было строкой символов, а *BufferLength* был меньше нуля.  
  
    -   При использовании асинхронного уведомления асинхронная операция на рукоятке не была завершена.  
  
-   SQL_NO_DATA: *RecNumber* был больше, чем количество диагностических записей, которые существовали для ручки, указанной в *ручке.* Функция также возвращает SQL_NO_DATA для любого положительного *RecNumber,* если нет диагностических записей для *Ручка*.  
  
## <a name="comments"></a>Комментарии  
 Приложение, как правило, вызывает **S'LGetDiagField** для достижения одной из трех целей:  
  
1.  Получение конкретной информации об ошибках или предупреждении при возврате вызова функции SQL_ERROR или SQL_SUCCESS_WITH_INFO (или SQL_NEED_DATA для функции **S'LBrowseConnect).**  
  
2.  Определить количество строк в источнике данных, которые были затронуты при вставке, удалении или обновлении, с помощью вызова на **s'LExecDirect,** **S'LBulkOperations**, или **S'LSetPos** (из поля заголовка SQL_DIAG_ROW_COUNT), или определить количество строк, которые существуют в текущем открытом курсоре, если водитель может предоставить эту информацию (из поля заголовка SQL_DIAG_CURSOR_ROW_COUNT). **SQLExecute**  
  
3.  Определить, какая функция была выполнена по вызову в **S'LExecDirect** или **S'LExecute** (из SQL_DIAG_DYNAMIC_FUNCTION и SQL_DIAG_DYNAMIC_FUNCTION_CODE поля заголовка).  
  
 Любая функция ODBC может размещать нулевые или более диагностические записи каждый раз, когда она называется, так что приложение может вызвать **S'LGetDiagField** после любого вызова функции ODBC. Количество диагностических записей, которые могут храниться в любой момент времени, не ограничено. **СЗЛГЕТДиагФилд** получает только диагностическую информацию, связанную с структурой диагностических данных, указанной в аргументе *«Ручка».* Если приложение вызывает функцию ODBC, за исключением **функции ,LGetDiagField** или **S'LGetDiagRec,** любая диагностическая информация от предыдущего вызова с той же ручкой теряется.  
  
 Приложение может сканировать все диагностические записи путем приращения *RecNumber,* до тех пор, пока **s'LGetDiagField** возвращается SQL_SUCCESS. Количество записей о состоянии указывается в поле заголовка SQL_DIAG_NUMBER. Вызовы на **S'LGetDiagField** неразрушают для заголовков и полей записи. Приложение может снова вызвать **S'LGetDiagField** позже, чтобы получить поле из записи, до тех пор, пока функция, кроме диагностических функций, не была вызвана в промежуточный период, который будет размещать записи на той же ручке.  
  
 Приложение может позвонить в **S'LGetDiagField,** чтобы вернуть любое диагностическое поле в любое время, за исключением SQL_DIAG_CURSOR_ROW_COUNT или SQL_DIAG_ROW_COUNT, которые вернут SQL_ERROR если *ручка* не является ручкой оператора. Если какое-либо другое диагностическое поле не определено, вызов на **S'LGetDiagField** вернется SQL_SUCCESS (при условии, что не будет обнаружено никакой другой диагностики) и неопределенное значение возвращается для поля.  
  
 Для получения более подробной информации, [см.](../../../odbc/reference/develop-app/using-sqlgetdiagrec-and-sqlgetdiagfield.md) [Implementing SQLGetDiagRec and SQLGetDiagField](../../../odbc/reference/develop-app/implementing-sqlgetdiagrec-and-sqlgetdiagfield.md)  
  
 Вызов API, отличный от того, который выполняется асинхронно, будет генерировать HY010 "Ошибка последовательности функций". Однако запись ошибки не может быть получена до завершения асинхронной операции.  
  
## <a name="handletype-argument"></a>Аргумент HandleType  
 Каждый тип ручки может иметь диагностическую информацию, связанную с ним. Аргумент *HandleType* указывает тип ручки *ручки.*  
  
 Некоторые поля заголовка и записи не могут быть возвращены для обработки среды, соединения, оператора и дескриптора. Те ручки, для которых поле не применимо, указаны в следующих разделах "Заголовки" и "Record Fields".  
  
 Если *HandleType* SQL_HANDLE_ENV, *ручка* может быть как общей, так и необщей обработкой среды.  
  
 Никакие диагностические поля заголовка для драйвера не должны быть связаны с ручкой среды.  
  
 Единственными диагностическими полями заголовка, которые определяются для дескриптора, являются SQL_DIAG_NUMBER и SQL_DIAG_RETURNCODE.  
  
## <a name="diagidentifier-argument"></a>Аргумент диагиотитатора  
 Этот аргумент указывает на идентификатор поля, требуемого из структуры диагностических данных. Если *RecNumber* больше или равен 1, данные в полевых условиях описывают диагностическую информацию, возвращенную функцией. Если *RecNumber* равен 0, поле находится в заголовке структуры диагностических данных и, следовательно, содержит данные, относящиеся к вызову функции, который вернул диагностическую информацию, а не к конкретной информации.  
  
 Драйверы могут определять поля заголовка и записи в структуре диагностических данных.  
  
 Приложение ODBC 3 *.x,* работая с драйвером ODBC 2 *.x,* сможет вызывать **S'LGetDiagField** только с *аргументом DiagIdentifier* SQL_DIAG_CLASS_ORIGIN, SQL_DIAG_CLASS_SUBCLASS_ORIGIN, SQL_DIAG_CONNECTION_NAME, SQL_DIAG_MESSAGE_TEXT, SQL_DIAG_NATIVE, SQL_DIAG_NUMBER, SQL_DIAG_RETURNCODE, SQL_DIAG_SERVER_NAME или SQL_DIAG_SQLSTATE. Все остальные диагностические поля вернутся SQL_ERROR.  
  
## <a name="header-fields"></a>Заголовок поля  
 Поля заголовка, перечисленные в следующей таблице, могут быть включены в аргумент *DiagIdentifier.*  
  
|ДиагИктификатор|Возвращаемый тип|Результаты|  
|--------------------|-----------------|-------------|  
|SQL_DIAG_CURSOR_ROW_COUNT|КСЛЛЕН|Это поле содержит количество строк в курсоре. Его семантика зависит от типов информации **s'LGetInfo** SQL_DYNAMIC_CURSOR_ATTRIBUTES2, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2, SQL_KEYSET_CURSOR_ATTRIBUTES2 и SQL_STATIC_CURSOR_ATTRIBUTES2, которые указывают, какие строки доступны для каждого типа курсора (в SQL_CA2_CRC_EXACT и SQL_CA2_CRC_APPROXIMATE битах).<br /><br /> Содержимое этого поля определяется только для ручек оператора и только после того, как были вызваны **S'LLExecute,** **S'LExecDirect**, или **S'LMoreResults.** Вызов **S'LGetDiagField** с *DiagIdentifier* SQL_DIAG_CURSOR_ROW_COUNT на других, чем ручка оператора вернется SQL_ERROR.|  
|SQL_DIAG_DYNAMIC_FUNCTION|СЗЛЧАР|Это строка, описывающая оператора S'L, выполняемый основной функцией. (См. "Значения полей динамической функциональности", позже в этом разделе, для конкретных значений.) Содержимое этого поля определяется только для ручек оператора и только после звонка в **S'L'LExecute,** **S'LExecDirect**, или **S'LMoreResults**. Вызов **S'LGetDiagField** с *DiagIdentifier* SQL_DIAG_DYNAMIC_FUNCTION на других, чем ручка оператора вернется SQL_ERROR. Значение этого поля не определено до вызова в **S'L'LExecute** или **S'LExecDirect.**|  
|SQL_DIAG_DYNAMIC_FUNCTION_CODE|SQLINTEGER|Это числовой код, описывающий оператора S'L, выполненное основной функцией. (См. "Значения динамических полей функций", позже в этом разделе, для конкретного значения.) Содержимое этого поля определяется только для ручек оператора и только после звонка в **S'L'LExecute,** **S'LExecDirect**, или **S'LMoreResults**. Вызов **S'LGetDiagField** с *диагИтутером* SQL_DIAG_DYNAMIC_FUNCTION_CODE на других, чем ручка оператора, вернется SQL_ERROR. Значение этого поля не определено до вызова в **S'L'LExecute** или **S'LExecDirect.**|  
|SQL_DIAG_NUMBER|SQLINTEGER|Количество записей о состоянии, доступных для указанной ручки.|  
|SQL_DIAG_RETURNCODE|СЗЛРЕВЕ|Код возврата, возвращенный функцией. Список кодов возврата [см.](../../../odbc/reference/develop-app/return-codes-odbc.md) Водитель не должен реализовывать SQL_DIAG_RETURNCODE; она всегда реализуется менеджером драйвера. Если функция еще не была вызвана на *рукоятке,* SQL_SUCCESS будет возвращен для SQL_DIAG_RETURNCODE.|  
|SQL_DIAG_ROW_COUNT|КСЛЛЕН|Количество строк, затронутых вставкой, удалением или обновлением, выполняемых **S'LLExecute,** **S'LExecDirect,** **S'LBulkOperations**или **S'LSetPos.** Он определяется драйвером после выполнения *спецификации курсора.* Содержимое этого поля определяется только для ручек оператора. Вызов **S'LGetDiagField** с *помощью DiagIdentifier* SQL_DIAG_ROW_COUNT на другой, чем ручка оператора, вернется SQL_ERROR. Данные в этой области также возвращаются в аргумент *RowCountPtr* **s'LRowCount**. Данные в этом поле сбрасываются после каждого вызова недиагностической функции, в то время как количество строк, возвращенное **S'LRowCount,** остается неизменным до тех пор, пока заявление не будет восстановлено в подготовленном или выделенном состоянии.|  
  
## <a name="record-fields"></a>Поле записи  
 Поля записей, перечисленные в следующей таблице, могут быть включены в аргумент *DiagIdentifier.*  
  
|ДиагИктификатор|Возвращаемый тип|Результаты|  
|--------------------|-----------------|-------------|  
|SQL_DIAG_CLASS_ORIGIN|СЗЛЧАР|Строка, отодевательная к документу, определяющая классовую часть значения S'LSTATE в этой записи. Его ценность составляет "ISO 9075" для всех S'LSTATEs, определяемых интерфейсом уровня вызова Open Group и ISO. Для ODBC-специфических S'LSTATEs (все те, чей класс S'LSTATE является "IM"), его значение составляет "ODBC 3.0".|  
|SQL_DIAG_COLUMN_NUMBER|SQLINTEGER|Если SQL_DIAG_ROW_NUMBER поле является действительным номером строки в строке или набором параметров, это поле содержит значение, представляющее номер столбца в наборе результатов или номер параметра в наборе параметров. Номера столбцов, установленных в результате, всегда начинаются с 1; если эта запись состояния относится к столбце закладки, поле может быть нулевым. Номера параметров начинаются с 1. Он имеет значение SQL_NO_COLUMN_NUMBER, если запись состояния не связана с номером столбца или номером параметра. Если драйвер не может определить номер столбца или номер параметра, с которым связана эта запись, это поле имеет значение SQL_COLUMN_NUMBER_UNKNOWN.<br /><br /> Содержимое этого поля определяется только для ручек оператора.|  
|SQL_DIAG_CONNECTION_NAME|СЗЛЧАР|Строка, указываюав имя соединения, к которое относится диагностическая запись. Это поле определяется драйверами. Для диагностических структур данных, связанных с обработкой среды, и для диагностики, не связанных с какой-либо связью, это поле представляет собой строку нулевой длины.|  
|SQL_DIAG_MESSAGE_TEXT|СЗЛЧАР|Информационное сообщение об ошибке или предупреждении. Это поле отформатировано, как описано в [Диагностических сообщениях.](../../../odbc/reference/develop-app/diagnostic-messages.md) Максимальная длина текста диагностического сообщения отсутствует.|  
|SQL_DIAG_NATIVE|SQLINTEGER|Код исходной ошибки драйвера/источника данных. Если нет родного кода ошибки, драйвер возвращает 0.|  
|SQL_DIAG_ROW_NUMBER|КСЛЛЕН|Это поле содержит строку в строке или номер параметра в наборе параметров, с которым связана запись состояния. Строки и номера параметров начинаются с 1. Это поле имеет значение SQL_NO_ROW_NUMBER, если эта запись состояния не связана с номером строки или номером параметра. Если драйвер не может определить номер строки или номер параметра, с которым связана эта запись, это поле имеет значение SQL_ROW_NUMBER_UNKNOWN.<br /><br /> Содержимое этого поля определяется только для ручек оператора.|  
|SQL_DIAG_SERVER_NAME|СЗЛЧАР|Строка, указываюана на имя сервера, к которое относится диагностическая запись. Это то же самое, что и значение, возвращенное для вызова в **S'LGetInfo** с SQL_DATA_SOURCE_NAME опцией. Для диагностических структур данных, связанных с обработкой среды, и для диагностики, не связанных с каким-либо сервером, это поле представляет собой строку нулевой длины.|  
|SQL_DIAG_SQLSTATE|СЗЛЧАР|Диагностический код с пятью символами S'LSTATE. Для получения более подробной информации ознакомьтесь с [см.](../../../odbc/reference/develop-app/sqlstates.md)|  
|SQL_DIAG_SUBCLASS_ORIGIN|СЗЛЧАР|Строка с тем же форматом и действительными значениями, что и SQL_DIAG_CLASS_ORIGIN, которая определяет определяющую часть подклассовой части кода S'Lstate. Специфический ODBC S'LSTATES, для которого возвращается "ODBC 3.0", включает в себя следующее:<br /><br /> 01S00, 01S01, 01S02, 01S06, 01S07, 07S01, 08S01, 21S01, 21S02, 25S01, 25S02, 25S03, 42S01, 42S02, 42S11, 42S11, 42S222, HY095, HY099 HY100, HY101, HY105, HY107, HY109, HY110, HY111, HYT00, IM001, IM002, IM003, IM004, IM005, IM006, IM007, IM008, IM01.|  
  
## <a name="values-of-the-dynamic-function-fields"></a>Значения динамических полей функций  
 В следующей таблице описываются значения SQL_DIAG_DYNAMIC_FUNCTION и SQL_DIAG_DYNAMIC_FUNCTION_CODE, которые применяются к каждому типу выписки s'L, выполняемой по вызову в **S'LExecute** или **S'LExecDirect.** Драйвер может добавить значения, определяемые драйверами, к перечисленным.  
  
|Инструкция SQL<br /><br /> Выполнен|Значение параметра <br /><br /> SQL_DIAG_DYNAMIC_FUNCTION|Значение параметра <br /><br /> SQL_DIAG_DYNAMIC_FUNCTION_CODE|  
|--------------------------------|-----------------------------------------------|-----------------------------------------------------|  
|*альтер-домен-заявление*|"ALTER DOMAIN"|SQL_DIAG_ALTER_DOMAIN|  
|*альтер-таблица-заявление*|"ИЗМЕНЕННЫЙ СТОЛ"|SQL_DIAG_ALTER_TABLE|  
|*утверждение-определение*|"СОЗДАТЬ УТВЕРЖДЕНИЕ"|SQL_DIAG_CREATE_ASSERTION|  
|*определение характера*|"СОЗДАТЬ НАБОР СИМВОЛОВ"|SQL_DIAG_CREATE_CHARACTER_SET|  
|*сопоставление-определение*|"СОЗДАТЬ КОЛЛАГАЦИЮ"|SQL_DIAG_CREATE_COLLATION|  
|*домен-определение*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|
|*создать-индекс-заявление*|"СОЗДАТЬ ИНДЕКС"|SQL_DIAG_CREATE_INDEX|  
|*создать таблицу-заявление*|"СОЗДАТЬ ТАБЛИЦУ"|SQL_DIAG_CREATE_TABLE|  
|*создание-вид-заявление*|"CREATE VIEW"|SQL_DIAG_CREATE_VIEW|  
|*курсор-спецификация*|"СЕСТЕР КУРСОР"|SQL_DIAG_SELECT_CURSOR|  
|*удалить-заявление позиционируется*|"DYNAMIC DELETE CURSOR"|SQL_DIAG_DYNAMIC_DELETE_CURSOR|  
|*удаление-заявление-поиск*|"УДАЛИТЬ ГДЕ"|SQL_DIAG_DELETE_WHERE|  
|*падение-утверждение-заявление*|"УТВЕРЖДЕНИЕ КАПЛИ"|SQL_DIAG_DROP_ASSERTION|  
|*падение-символ-набор-stmt*|"НАБОР СИМВОЛОВ КАПЛИ"|SQL_DIAG_DROP_CHARACTER_SET|  
|*заявление о сбросе*|"КАПЛЯ КОЛЛАЦИЯ"|SQL_DIAG_DROP_COLLATION|  
|*падение-домен-заявление*|"DROP DOMAIN"|SQL_DIAG_DROP_DOMAIN|  
|*падение-индекс-заявление*|"ИНДЕКС ПАДЕНИЯ"|SQL_DIAG_DROP_INDEX|  
|*дроп-схема-заявление*|"ДРОД ШАМА"|SQL_DIAG_DROP_SCHEMA|  
|*выпадающий стол-заявление*|"ПАДЕНИЕ ТАБЛИЦЫ"|SQL_DIAG_DROP_TABLE|  
|*падение-перевод-заявление*|"КАПЛЯ ПЕРЕВОД"|SQL_DIAG_DROP_TRANSLATION|  
|*заявление о падении*|"ВИД ПАДЕНИЯ"|SQL_DIAG_DROP_VIEW|  
|*грантоутверждение*|"ГРАНТ"|SQL_DIAG_GRANT|
|*вставить-заявление*|"ВСТАВКА"|SQL_DIAG_INSERT|  
|*Расширение ПРОЦЕДУРЫ ODBC*|"ЗВОНОК"|SQL_DIAG_ КАЛЛИ|  
|*аннулирование-заявление*|"ОТОЗВАТЬ"|SQL_DIAG_REVOKE|  
|*схема-определение*|"CREATE SCHEMA"|SQL_DIAG_CREATE_SCHEMA|  
|*перевод-определение*|"СОЗДАТЬ ПЕРЕВОД"|SQL_DIAG_CREATE_TRANSLATION|  
|*обновление-заявление позиционируется*|"DYNAMIC UPDATE CURSOR"|SQL_DIAG_DYNAMIC_UPDATE_CURSOR|  
|*обновление-выписка-поиск*|"ОБНОВЛЕНИЕ, ГДЕ"|SQL_DIAG_UPDATE_WHERE|  
|Неизвестно|*пустая строка*|SQL_DIAG_UNKNOWN_STATEMENT|  

<!--
These two malformed table rows were fixed by educated GUESS only.
Each pair starts with the original flawed row.
Flawed because treated as only two cells by HTML render,
and because missing info anyway.
Also, these flawed rows lacked '|' as their first nonWhitespace character (although markdown technically allows this omission, unfortunately).
Arguably the following SQL.H file shows the sequence of the flawed rows in the table was suboptimal also.

ftp://www.fpc.org/fpc32/VS6Disk1/VC98/INCLUDE/SQL.H

GeneMi , 2019/01/19
- - - - - - - - - - - - - -

n-definition*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|  

|*domain-definition*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|

-statement*|"GRANT"|SQL_DIAG_GRANT|  

|*grant-statement*|"GRANT"|SQL_DIAG_GRANT|

-->

## <a name="sequence-of-status-records"></a>Последовательность записей состояния

 Записи состояния позиционируются в последовательности в зависимости от числа строк и типа диагностики. Менеджер драйвера определяет окончательный порядок возврата записей статуса, которые он генерирует. Водитель определяет окончательный порядок, в котором возвращается записи статуса, которые он генерирует.  
  
 Если диагностические записи публикуются как менеджером водителя, так и водителем, менеджер драйвера несет ответственность за их заказ.  
  
 При наличии двух или более записей состояния последовательность записей определяется сначала номером строки. Следующие правила применяются к определению последовательности диагностических записей по строке:  
  
-   Записи, не соответствующие ни одной строке, появляются перед записями, которые соответствуют определенному ряду, поскольку SQL_NO_ROW_NUMBER определяется как -1.  
  
-   Записи, для которых число строк неизвестно, появляются перед всеми другими записями, потому что SQL_ROW_NUMBER_UNKNOWN определяется как -2.  
  
-   Для всех записей, относящихся к определенным строкам, записи сортируются по значению в поле SQL_DIAG_ROW_NUMBER. Перечислены все ошибки и предупреждения о первом ряду, а затем все ошибки и предупреждения следующего ряда и так далее.  
  
> [!NOTE]
>  OdBC 3 *.x* Driver Manager не задает записи статуса в диагностической очереди, если S'LSTATE 01S01 (Ошибка в строке) возвращается водителем ODBC 2 **SQLExtendedFetch***.x* или если S'LSTATE 01S01 (ошибка в строке) возвращается водителем ODBC 3 *.x,* когда **s'LExtendedFetch** называется или **slSetPos** вызывается на курсор, который был передан.  
  
 В каждой строке, или для всех тех записей, которые не соответствуют строке или для которых номер строки неизвестен, или для всех тех записей с номером строки, равным SQL_NO_ROW_NUMBER, первая запись, перечисленная определяется с помощью набора правил сортировки. После первой записи порядок других записей, влияющих на строку, не определен. Приложение не может предположить, что ошибки предшествуют предупреждениям после первой записи. Приложения должны сканировать полную структуру диагностических данных, чтобы получить полную информацию о неудачном вызове к функции.  
  
 Для определения первой записи в строке используются следующие правила. Рекорд с самым высоким рангом является первым рекордом. Источник записи (менеджер драйвера, водитель, шлюз и так далее) не учитывается при составлении рейтинговых записей.  
  
-   **Ошибки** Записи статуса, описывающие ошибки, имеют наивысший ранг. Для сортировки ошибок применяются следующие правила:  
  
    -   Записи, указывающие на сбой транзакции или возможный сбой транзакции, обозначают все остальные записи.  
  
    -   Если две или более записей описывают одно и то же условие ошибки, то S'LSTATEs, определяемые спецификацией ClI Открытой группы (классы 03 через H') оползти ODBC- и драйвер-определяемые S'LSTATEs.  
  
-   **Значения данных, определяемые реализацией, нет** Записи статуса, описывающие значения данных, определяемые драйверами No Data (класс 02), имеют второй по величине ранг.  
  
-   **Предупреждения** Записи состояния, описывающие предупреждения (класс 01), имеют самый низкий ранг. Если две или более записей описывают одно и то же состояние предупреждения, то предупреждение S'LSTATEs, определяемое спецификацией Open Group CLI, перехиваёт ODBC-определенные и определяемые драйверами S'LSTATEs.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Получение нескольких полей структуры диагностических данных|[Функция SQLGetDiagRec](sqlgetdiagrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
