---
title: Функция SQLGetDiagField | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetDiagField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetDiagField
helpviewer_keywords:
- SQLGetDiagField function [ODBC]
ms.assetid: 1dbc4398-97a8-4585-bb77-1f7ea75e24c4
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 620ccce9a035139482b2d9b4630bb2242f720af8
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68103779"
---
# <a name="sqlgetdiagfield-function"></a>Функция SQLGetDiagField

**Соответствие стандартам**  
 Представленные версии: ODBC 3.0 стандартов соответствия: ISO-92  
  
 **Сводка**  
 **SQLGetDiagField** возвращает текущее значение поля записи структуры диагностических данных (связанные с указанным дескриптором), содержащий сведения об ошибках, предупреждения и состоянии.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp

SQLRETURN SQLGetDiagField(  
     SQLSMALLINT     HandleType,  
     SQLHANDLE       Handle,  
     SQLSMALLINT     RecNumber,  
     SQLSMALLINT     DiagIdentifier,  
     SQLPOINTER      DiagInfoPtr,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   StringLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 [Вход] Идентификатор типа дескриптора, описывающий тип маркера, для которого требуются диагностики. Должна быть одной из следующих:  
  
-   SQL_HANDLE_DBC  
  
-   SQL_HANDLE_DBC_INFO_TOKEN  
  
-   SQL_HANDLE_DESC  
  
-   SQL_HANDLE_ENV  
  
-   ЗНАЧЕНИЕ SQL_HANDLE_STMT  
  
 Дескриптор SQL_HANDLE_DBC_INFO_TOKEN используется только для диспетчера драйверов и драйверов. Приложения не должны использовать этот тип дескриптора. Дополнительные сведения о SQL_HANDLE_DBC_INFO_TOKEN, см. в разделе [драйвера ODBC с поддержкой пула подключений разработка](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md).  
  
 *Дескриптор*  
 [Вход] Дескриптор для структуры диагностических данных, тип, указанный *HandleType*. Если *HandleType* является SQL_HANDLE_ENV, *обрабатывать* можно использовать общий или дескриптор среды с монопольным доступом.  
  
 *RecNumber*  
 [Вход] Указывает запись состояния, из которого приложение ищет сведения. Записи состояния нумеруются от 1. Если *DiagIdentifier* аргумент указывает любое поле заголовка диагностики, *RecNumber* учитывается. В противном случае он должен быть больше 0.  
  
 *DiagIdentifier*  
 [Вход] Указывает поле, значение которого равно возвращается диагностики. Дополнительные сведения см. в разделе "*DiagIdentifier* аргумент» раздела «Примечания».  
  
 *DiagInfoPtr*  
 [Выход] Указатель на буфер, в которую будет возвращен диагностические сведения. Тип данных зависит от значения *DiagIdentifier*. Если *DiagInfoPtr* имеет целочисленный тип, приложения должны использовать буфер SQLULEN и инициализации, значение 0, перед вызовом этой функции, как некоторые драйверы могут только записи в нижнем 32-разрядной или 16-разрядное буфера и оставьте более высокого порядка бит без изменений.  
  
 Если *DiagInfoPtr* имеет значение NULL, *StringLengthPtr* по-прежнему возвращает общее число байтов (за исключением символа конечное значение null для символьных данных) для возврата в буфере, на которые указывают  *DiagInfoPtr*.  
  
 *BufferLength*  
 [Вход] Если *DiagIdentifier* является диагностики, определенных для ODBC и *DiagInfoPtr* указывает на строку символов или двоичный буфер, данный аргумент должен иметь длину \* *DiagInfoPtr* . Если *DiagIdentifier* представляет собой поле, определенных для ODBC и \* *DiagInfoPtr* должно быть целым числом, *BufferLength* учитывается. Если значение в  *\*DiagInfoPtr* строка в Юникоде (при вызове **SQLGetDiagFieldW**), *BufferLength* аргумент должен быть четным числом.  
  
 Если *DiagIdentifier* является полем, определяемым драйвером, приложение указывает характер поле для диспетчера драйверов, задав *BufferLength* аргумент. *BufferLength* может иметь следующие значения:  
  
-   Если *DiagInfoPtr* — это указатель на строку символов *BufferLength* длина строки или SQL_NTS.  
  
-   Если *DiagInfoPtr* является результатом SQL_LEN_BINARY_ATTR указатель бинарный буфер местах приложения (*длина*) в макрос *BufferLength*. Это размещает отрицательное значение в *BufferLength*.  
  
-   Если *DiagInfoPtr* — это указатель на значение, отличное от символьной строки или двоичная строка *BufferLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если  *\*DiagInfoPtr* содержит тип данных фиксированной длины, *BufferLength* является SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT или SQL_IS_USMALLINT, соответствующим образом.  
  
 *StringLengthPtr*  
 [Выход] Указатель на буфер, в которую будет возвращено общее число байтов (за исключением число байтов, необходимых для символа завершения null) для возврата в \* *DiagInfoPtr*, для символьных данных. Если количество байтов, доступных для возврата больше или равно *BufferLength*, текст в \* *DiagInfoPtr* усекается до *BufferLength* минус Длина символа завершения null.  
  
## <a name="returns"></a>Возвращает  
 Значение SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR, SQL_INVALID_HANDLE или значение SQL_NO_DATA.  
  
## <a name="diagnostics"></a>Диагностика  
 **SQLGetDiagField** не размещайте диагностические записи для себя. Сообщить о результате свое выполнение является он использует следующие возвращаемые значения:  
  
-   ЗНАЧЕНИЕ SQL_SUCCESS, УКАЗЫВАЯ: Функция успешно возвращено диагностические сведения.  
  
-   SQL_SUCCESS_WITH_INFO: \**DiagInfoPtr* слишком мал для хранения запрошенного диагностические поля. Таким образом данные в поле диагностики были усечены. Чтобы определить, что возникло усечение, приложение необходимо сравнить *BufferLength* фактическое число доступных байтов, которые написаны для **StringLengthPtr*.  
  
-   SQL_INVALID_HANDLE: Указывает дескриптор *HandleType* и *обрабатывать* не является допустимым дескриптором.  
  
-   ЗНАЧЕНИЕ SQL_ERROR: Одной из следующих причин:  
  
    -   *DiagIdentifier* аргумент не является одним из допустимых значений.  
  
    -   *DiagIdentifier* аргумент был SQL_DIAG_CURSOR_ROW_COUNT, SQL_DIAG_DYNAMIC_FUNCTION, SQL_DIAG_DYNAMIC_FUNCTION_CODE или SQL_DIAG_ROW_COUNT, но *обрабатывать* не дескриптор инструкции. (The Driver Manager возвращает это диагностики.)  
  
    -   *RecNumber* аргумент был отрицательным или 0 при *DiagIdentifier* указано поле из создается запись диагностики. *RecNumber* учитывается для поля заголовка.  
  
    -   Значение, заданное был строку символов и *BufferLength* меньше нуля.  
  
    -   Если вы используете асинхронное уведомление, асинхронные операции для дескриптора не завершена.  
  
-   ЗНАЧЕНИЕ SQL_NO_DATA: *RecNumber* поданных единиц превысил количество диагностических записей, которые существовали для дескриптор, указанный в *обработки.* Функция также возвращает значение SQL_NO_DATA для любой положительных *RecNumber* Если нет диагностических записей для *обрабатывать*.  
  
## <a name="comments"></a>Комментарии  
 Приложение обычно вызывает **SQLGetDiagField** для выполнения одной из трех целей:  
  
1.  Для получения определенной ошибки или предупреждения, когда вызов функции возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO (или SQL_NEED_DATA для **SQLBrowseConnect** функции).  
  
2.  Чтобы определить количество строк в источнике данных, которые были затронуты при insert, delete или операции обновления были выполнены с помощью вызова **SQLExecute**, **SQLExecDirect**,  **SQLBulkOperations**, или **SQLSetPos** (из SQL_DIAG_ROW_COUNT поле заголовка), или требуется определить число строк, которые существуют в текущем открытого курсора, если драйвер может предоставлять эти сведения (из Поле заголовка SQL_DIAG_CURSOR_ROW_COUNT).  
  
3.  Чтобы определить, какая функция была выполнена с помощью вызова **SQLExecDirect** или **SQLExecute** (из поля заголовка SQL_DIAG_DYNAMIC_FUNCTION и SQL_DIAG_DYNAMIC_FUNCTION_CODE).  
  
 Любая функция ODBC можно разместить ноль или более записей диагностики каждый раз, что он вызывается, поэтому приложение может вызвать **SQLGetDiagField** после любого вызова функции ODBC. Нет ограничений на количество диагностических записей, которые могут храниться в любой момент времени. **SQLGetDiagField** получает диагностические сведения, наиболее недавно связанные с этой структурой диагностических данных, указанный в *обрабатывать* аргумент. Если приложение вызывает функцию ODBC, отличных от **SQLGetDiagField** или **SQLGetDiagRec**, теряются все диагностические сведения из предыдущего вызова с тем же дескриптором.  
  
 Приложение может проверять все диагностические записи путем увеличения *RecNumber*, при условии, что **SQLGetDiagField** возвращает значение SQL_SUCCESS. Число записей состояния указывается в поле заголовка SQL_DIAG_NUMBER. Вызовы **SQLGetDiagField** были неразрушающими полях заголовка и записи. Приложение может вызвать **SQLGetDiagField** еще раз позже — для извлечения полей из записи, до тех пор, пока функция, отличная от функции диагностики не был вызван до этого времени, который выполнил бы команду post записи на том же дескрипторе.  
  
 Приложение может вызвать **SQLGetDiagField** возвратить любой диагностическое поле в любое время, за исключением SQL_DIAG_CURSOR_ROW_COUNT или SQL_DIAG_ROW_COUNT, который вернет значение SQL_ERROR, если *обрабатывать* не Дескриптор инструкции. Если диагностическое поле не определен, вызов **SQLGetDiagField** вернет значение SQL_SUCCESS, (при условии других Диагностика не обнаруживается) и возвращается неопределенное значение для поля.  
  
 Дополнительные сведения см. в разделе [использование SQLGetDiagRec и SQLGetDiagField](../../../odbc/reference/develop-app/using-sqlgetdiagrec-and-sqlgetdiagfield.md) и [реализация SQLGetDiagRec и SQLGetDiagField](../../../odbc/reference/develop-app/implementing-sqlgetdiagrec-and-sqlgetdiagfield.md).  
  
 Вызов API-Интерфейс, отличный от того, который выполняется асинхронно создаст HY010 «Function ошибка последовательности». Тем не менее не удалось получить запись об ошибке, до завершения асинхронной операции.  
  
## <a name="handletype-argument"></a>Аргумент HandleType  
 Каждый тип дескриптора может иметь диагностические сведения, связанные с ней. *HandleType* аргумент указывает тип дескриптора *обрабатывать*.  
  
 Некоторые поля заголовка и записи, нельзя вернуть для среды, подключения, инструкции и дескриптора дескрипторов. Эти дескрипторы, для которых поле неприменимо, отображаются в разделах «заголовок» и «Запись поля», следующих.  
  
 Если *HandleType* является SQL_HANDLE_ENV, *обрабатывать* может быть дескриптор общий или отменен общий доступ к среде.  
  
 Нет заголовка специфические для драйвера диагностические поля должны быть связаны с дескриптор среды.  
  
 Поля заголовков только для диагностики, которые определены для дескриптора: SQL_DIAG_NUMBER и SQL_DIAG_RETURNCODE.  
  
## <a name="diagidentifier-argument"></a>Аргумент DiagIdentifier  
 Этот аргумент указывает идентификатор поля, необходимые в структуре диагностических данных. Если *RecNumber* больше или равно 1, данные в поле Описание диагностических сведений, возвращаемых функцией. Если *RecNumber* равно 0, поле в заголовке структуры диагностических данных и поэтому содержит данные, относящиеся к вызов функции, которые вернули диагностических сведений, не можно получить сведения.  
  
 Драйверы можно определить заголовок специфические для драйвера и поля записей в структуре диагностических данных.  
  
 ODBC 3 *.x* приложение, которое работает с ODBC 2 *.x* драйвер будет иметь возможность вызывать **SQLGetDiagField** только с *DiagIdentifier* Аргумент SQL_DIAG_CLASS_ORIGIN SQL_DIAG_CLASS_SUBCLASS_ORIGIN, SQL_DIAG_CONNECTION_NAME, SQL_DIAG_MESSAGE_TEXT, SQL_DIAG_NATIVE, SQL_DIAG_NUMBER, SQL_DIAG_RETURNCODE, SQL_DIAG_SERVER_NAME и SQL_DIAG_SQLSTATE. Все диагностические поля вернет значение SQL_ERROR.  
  
## <a name="header-fields"></a>Поля заголовка  
 Поля заголовка, перечисленные в следующей таблице, которые могут быть включены в *DiagIdentifier* аргумент.  
  
|DiagIdentifier|Возвращаемый тип|Возвращает|  
|--------------------|-----------------|-------------|  
|SQL_DIAG_CURSOR_ROW_COUNT|SQLLEN|Это поле содержит число строк в курсоре. Его семантика зависит от **SQLGetInfo** типы сведений SQL_DYNAMIC_CURSOR_ATTRIBUTES2, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2, SQL_KEYSET_CURSOR_ATTRIBUTES2 и SQL_STATIC_CURSOR_ATTRIBUTES2, которые указывают, что количество строк, доступны для каждого типа курсора (в битах SQL_CA2_CRC_EXACT и SQL_CA2_CRC_APPROXIMATE).<br /><br /> Содержимое этого поля определяется только для дескрипторов инструкций и только после того, как **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван. Вызов **SQLGetDiagField** с *DiagIdentifier* из SQL_DIAG_CURSOR_ROW_COUNT на отличный от инструкцию дескриптор вернет значение SQL_ERROR.|  
|SQL_DIAG_DYNAMIC_FUNCTION|SQLCHAR *|Это строка, описывающая инструкцию SQL, выполнение базовой функции. (См. в разделе «Значения поля динамических функций» далее в этом разделе описано, по определенным значениям.) Содержимое этого поля определяется только для дескрипторов инструкций и только после вызова **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults**. Вызов **SQLGetDiagField** с *DiagIdentifier* из SQL_DIAG_DYNAMIC_FUNCTION на отличный от инструкцию дескриптор вернет значение SQL_ERROR. Значение этого поля не определено до вызова **SQLExecute** или **SQLExecDirect**.|  
|SQL_DIAG_DYNAMIC_FUNCTION_CODE|SQLINTEGER|Это числовой код, который описывает инструкцию SQL, которая была выполнена с помощью базовой функции. (См. в разделе «Значения из динамических функция поля,» далее в этом разделе описано, для конкретного значения.) Содержимое этого поля определяется только для дескрипторов инструкций и только после вызова **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults**. Вызов **SQLGetDiagField** с *DiagIdentifier* из SQL_DIAG_DYNAMIC_FUNCTION_CODE на отличный от инструкцию дескриптор вернет значение SQL_ERROR. Значение этого поля не определено до вызова **SQLExecute** или **SQLExecDirect**.|  
|SQL_DIAG_NUMBER|SQLINTEGER|Число записей состояния, доступные для указанного дескриптора.|  
|SQL_DIAG_RETURNCODE|SQLRETURN|Код возврата, возвращенный функцией. Список кодов возврата, см. в разделе [коды возврата](../../../odbc/reference/develop-app/return-codes-odbc.md). Драйвер должен реализовывать SQL_DIAG_RETURNCODE; она всегда реализуется диспетчером драйверов. Если ни одна из функций еще был вызван на *обработки*, возвращается значение SQL_SUCCESS, указывая для SQL_DIAG_RETURNCODE.|  
|SQL_DIAG_ROW_COUNT|SQLLEN|Количество строк, затронутых вставки, удаления или обновления, выполненного **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos**. Это, определяемым драйвером после *спецификацией курсора* был выполнен. Содержимое этого поля определяются только для дескриптора инструкции. Вызов **SQLGetDiagField** с *DiagIdentifier* из SQL_DIAG_ROW_COUNT на отличный от инструкцию дескриптор вернет значение SQL_ERROR. Данные в это поле также возвращается в *RowCountPtr* аргумент **SQLRowCount**. Данные в это поле сбрасывается после каждого вызова функций nondiagnostic, тогда как возвращаемый число строк **SQLRowCount** остается неизменным, пока инструкция снова установить значение подготовленного или выделенное состояние.|  
  
## <a name="record-fields"></a>Запись поля  
 Запись поля, перечисленные в следующей таблице, которые могут быть включены в *DiagIdentifier* аргумент.  
  
|DiagIdentifier|Возвращаемый тип|Возвращает|  
|--------------------|-----------------|-------------|  
|SQL_DIAG_CLASS_ORIGIN|SQLCHAR *|Строковое значение, указывающее документ, который определяет класс часть значение SQLSTATE в этой записи. Его значение равно «ISO 9075» для всех SQLSTATE определяется Open Group и интерфейс уровня вызова ISO. Для конкретного ODBC SQLSTATE (их все, классом SQLSTATE которых является «Обмена мгновенными Сообщениями»), его значение равно «ODBC 3.0".|  
|SQL_DIAG_COLUMN_NUMBER|SQLINTEGER|Если поле SQL_DIAG_ROW_NUMBER является числом допустимую строку в набор строк или набор параметров, это поле содержит значение, представляющее номер столбца в результирующем наборе, или параметр с номером в набор параметров. Столбец чисел всегда начинаются с 1; результирующего набора Если эта запись состояния относится столбца закладки, поле может равняться нулю. Параметр номера начинаются с 1. Он имеет значение SQL_NO_COLUMN_NUMBER, если запись состояния не связан номер столбца или параметра с номером. Если драйвер не может определить номер столбца или параметр с номером, с которой связана эта запись, это поле имеет значение SQL_COLUMN_NUMBER_UNKNOWN.<br /><br /> Содержимое этого поля определяются только для дескриптора инструкции.|  
|SQL_DIAG_CONNECTION_NAME|SQLCHAR *|Строка, указывающая имя подключения, к которому относится диагностической записью. Это поле доступно, определяемым драйвером. Для структур диагностических данных, связанной с дескриптором среды и средства диагностики, которые не связаны с любого подключения это поле является строкой нулевой длины.|  
|SQL_DIAG_MESSAGE_TEXT|SQLCHAR *|Информационное сообщение в случае ошибки или предупреждения. Это поле имеет формат, как описано в разделе [диагностические сообщения](../../../odbc/reference/develop-app/diagnostic-messages.md). Нет без ограничения длины текста диагностическое сообщение.|  
|SQL_DIAG_NATIVE|SQLINTEGER|Зависящие от источника собственной ошибки код в виде данных или драйвера. Если нет собственное значение кода ошибки, драйвер возвращает 0.|  
|SQL_DIAG_ROW_NUMBER|SQLLEN|Это поле содержит номер строки в наборе строк или параметр с номером в набор параметров, с которыми связана запись состояния. Номера строк и номера параметров начинается с 1. Это поле имеет значение SQL_NO_ROW_NUMBER, если эта запись состояния не связан с номером строки или параметр с номером. Если драйвер не может определить количество строк или параметр с номером, с которой связана эта запись, это поле имеет значение SQL_ROW_NUMBER_UNKNOWN.<br /><br /> Содержимое этого поля определяются только для дескриптора инструкции.|  
|SQL_DIAG_SERVER_NAME|SQLCHAR *|Строка, указывающая имя сервера, к которому относится диагностической записью. Он совпадает со значением значение, возвращаемое для вызова **SQLGetInfo** с параметром SQL_DATA_SOURCE_NAME. Для структур диагностических данных, связанной с дескриптором среды и средства диагностики, которые не связаны с любого сервера это поле является строкой нулевой длины.|  
|SQL_DIAG_SQLSTATE|SQLCHAR *|Диагностический код SQLSTATE пяти символов. Дополнительные сведения см. в разделе [SQLSTATE](../../../odbc/reference/develop-app/sqlstates.md).|  
|SQL_DIAG_SUBCLASS_ORIGIN|SQLCHAR *|Строка с тем же формат и допустимые значения как SQL_DIAG_CLASS_ORIGIN, обозначающее определение часть подкласс часть код SQLSTATE. Следующие SQLSTATES конкретного ODBC, для которых возвращается «ODBC 3.0».<br /><br /> 01S00 01S01, 01S02, 01S06, 01S07, 07S01, 08S01 21S01, 21S02, 25S01, 25S02, 25S03, 42S01, 42S02, 42S11, 42S12, 42S21, 42S22, HY095, HY097, HY098, HY099, HY100, HY101, HY105, HY107, HY109, HY110, HY111, HYT00, HYT01, IM001, IM002, IM003, IM004, IM005, IM006, IM007, IM008, IM010, IM011, IM012.|  
  
## <a name="values-of-the-dynamic-function-fields"></a>Значения полей динамической функции  
 В следующей таблице описаны значения SQL_DIAG_DYNAMIC_FUNCTION и SQL_DIAG_DYNAMIC_FUNCTION_CODE, которые применяются к каждому типу инструкцией SQL, выполненной с помощью вызова **SQLExecute** или **SQLExecDirect**. Драйвер можно добавить значения, определяемые драйвером перечисленных.  
  
|Инструкция SQL<br /><br /> Выполняется|Значение<br /><br /> SQL_DIAG_DYNAMIC_FUNCTION|Значение<br /><br /> SQL_DIAG_DYNAMIC_FUNCTION_CODE|  
|--------------------------------|-----------------------------------------------|-----------------------------------------------------|  
|*домена инструкции ALTER*|«ALTER ДОМЕН»|SQL_DIAG_ALTER_DOMAIN|  
|*Таблица инструкции ALTER*|«ALTER TABLE»|SQL_DIAG_ALTER_TABLE|  
|*Определение утверждения*|«СОЗДАНИЕ УТВЕРЖДЕНИЕ»|SQL_DIAG_CREATE_ASSERTION|  
|*определения для набора символов*|«СОЗДАТЬ НАБОР СИМВОЛОВ»|SQL_DIAG_CREATE_CHARACTER_SET|  
|*Определение параметров сортировки*|«СОЗДАНИЕ ПАРАМЕТРОВ СОРТИРОВКИ»|SQL_DIAG_CREATE_COLLATION|  
|*Определение domainn*|«СОЗДАНИЕ ДОМЕНА»|SQL_DIAG_CREATE_DOMAIN|
|*Индекс инструкция CREATE*|«СОЗДАНИЕ ИНДЕКСА»|SQL_DIAG_CREATE_INDEX|  
|*— Инструкция CREATE table*|«СОЗДАНИЕ ТАБЛИЦЫ»|SQL_DIAG_CREATE_TABLE|  
|*представление инструкция CREATE*|«СОЗДАНИЕ ПРЕДСТАВЛЕНИЯ»|SQL_DIAG_CREATE_VIEW|  
|*спецификацией курсора.*|«SELECT КУРСОРА»|SQL_DIAG_SELECT_CURSOR|  
|*положение инструкции DELETE*|«DELETE ДИНАМИЧЕСКИЙ КУРСОР»|SQL_DIAG_DYNAMIC_DELETE_CURSOR|  
|*Поиск DELETE оператор*|«УДАЛИТЬ WHERE»|SQL_DIAG_DELETE_WHERE|  
|*инструкцию DROP утверждения*|«DROP УТВЕРЖДЕНИЕ»|SQL_DIAG_DROP_ASSERTION|  
|*drop-character-set-stmt*|«СИМВОЛ DROP SET»|SQL_DIAG_DROP_CHARACTER_SET|  
|*инструкцию DROP — параметры сортировки*|«СБРОСА ПАРАМЕТРОВ СОРТИРОВКИ»|SQL_DIAG_DROP_COLLATION|  
|*инструкцию DROP домена*|«DROP ДОМЕН»|SQL_DIAG_DROP_DOMAIN|  
|*drop-index-statement*|«DROP INDEX»|SQL_DIAG_DROP_INDEX|  
|*инструкцию DROP схемы*|«DROP SCHEMA»|SQL_DIAG_DROP_SCHEMA|  
|*инструкцию DROP таблица*|«DROP TABLE»|SQL_DIAG_DROP_TABLE|  
|*инструкцию DROP перевода*|«DROP ПЕРЕВОДА»|SQL_DIAG_DROP_TRANSLATION|  
|*инструкцию DROP представление*|«DROP VIEW»|SQL_DIAG_DROP_VIEW|  
|*grantstatement*|«ПРЕДОСТАВЛЕНИЕ»|SQL_DIAG_GRANT|
|*инструкции INSERT*|«ВСТАВИТЬ»|SQL_DIAG_INSERT|  
|*ODBC-процедуры extension*|«CALL»|ВЫЗОВ SQL_DIAG_|  
|*Инструкция REVOKE*|«ОТОЗВАТЬ»|SQL_DIAG_REVOKE|  
|*Определение схемы*|«СОЗДАТЬ СХЕМУ»|SQL_DIAG_CREATE_SCHEMA|  
|*определения перевода*|«СОЗДАТЬ ПЕРЕВОД»|SQL_DIAG_CREATE_TRANSLATION|  
|*позиционировано инструкции Update*|«ДИНАМИЧЕСКОЕ ОБНОВЛЕНИЕ КУРСОРА»|SQL_DIAG_DYNAMIC_UPDATE_CURSOR|  
|*Поиск обновления оператор*|«ИЗМЕНЕНИЕ МЕСТА, ГДЕ»|SQL_DIAG_UPDATE_WHERE|  
|Неизвестно|*пустая строка*|SQL_DIAG_UNKNOWN_STATEMENT|  

<!--
These two malformed table rows were fixed by educated GUESS only.
Each pair starts with the original flawed row.
Flawed because treated as only two cells by HTML render,
and because missing info anyway.
Also, these flawed rows lacked '|' as their first nonWhitespace character (although markdown technically allows this omission, unfortunately).
Arguably the following SQL.H file shows the sequence of the flawed rows in the table was suboptimal also.

ftp://www.fpc.org/fpc32/VS6Disk1/VC98/INCLUDE/SQL.H

GeneMi , 2019/01/19
- - - - - - - - - - - - - -

n-definition*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|  

|*domain-definition*|"CREATE DOMAIN"|SQL_DIAG_CREATE_DOMAIN|

-statement*|"GRANT"|SQL_DIAG_GRANT|  

|*grant-statement*|"GRANT"|SQL_DIAG_GRANT|

-->

## <a name="sequence-of-status-records"></a>Последовательность записей состояния

 Состояние записи располагаются в последовательности на основе номера строки и тип диагностики. Диспетчер драйверов определяет конечного порядка, в которую будет возвращен записи состояния, которые она создает. Драйвер определяет конечного порядка, в которую будет возвращен записи состояния, которые она создает.  
  
 Если диагностические записи учитываются, диспетчер драйверов и драйвер, диспетчер драйверов несет ответственность за их упорядочивание.  
  
 При наличии двух или более записей состояния, последовательность записей сначала определяется по номеру строки. Для определения последовательности диагностических записей по строкам применяются следующие правила:  
  
-   Записи, которые не соответствуют любой строке отображаются перед записями, которые соответствуют определенной строке, поскольку SQL_NO_ROW_NUMBER определяется как значение -1.  
  
-   Записи, для которых имеет неизвестный номер строки отображаются перед все остальные записи, так как SQL_ROW_NUMBER_UNKNOWN определяется как -2.  
  
-   Для всех записей, относящихся к определенной строки записи сортируются по значению в поле SQL_DIAG_ROW_NUMBER. Все ошибки и предупреждения из первой строки, затронутой перечислены, а затем все ошибки и предупреждения следующей строк затронутых и т. д.  
  
> [!NOTE]
>  ODBC 3 *.x* диспетчер драйверов не упорядочивает записи состояния в диагностики очереди Если SQLSTATE 01S01 (ошибка в строке) возвращается ODBC 2 *.x* драйвера или, если SQLSTATE 01S01 (ошибка в строке), возвращенный ODBC 3 *.x* драйвера при **SQLExtendedFetch** вызывается или **SQLSetPos** вызывается в курсоре, который позиционирует с **SQLExtendedFetch** .  
  
 В каждой строке, а также для тех записей, которые не соответствуют строке или для которого Неизвестный номер строки или для всех этих записей с номером строки, равное SQL_NO_ROW_NUMBER первой записи в списке определяется с помощью набора правил сортировки. После первой записи не определен порядок записей, влияющие на строку. Приложения нельзя предполагать, что ошибки предшествовать предупреждения после первой записи. Приложения должны сканировать структуре полный диагностических данных, информацию о неудачной вызов функции.  
  
 Следующие правила используются для определения первой записи в пределах строки. Запись с наивысшим рангом является первой записью. Источник записи (диспетчера драйверов, драйвер, шлюза и т. д.) не считается когда ранжирование записей.  
  
-   **Ошибки** записи состояния, которые описывают ошибки имеют наивысший ранг. Для сортировки ошибок применяются следующие правила:  
  
    -   Записи, которые указывают на сбой транзакции или возможных транзакций сбоя outrank все остальные записи.  
  
    -   Если две или более записей описать то же условие ошибки, SQLSTATE, определенных в спецификации Open CLI группы (классы 03 через ГЦ) outrank SQLSTATE, определяемые ODBC и драйвером.  
  
-   **Значения данных нет определенной реализацией** записи состояния, которые описывают значения определенное драйвером нет данных (класс 02) имеют второй наивысшим рангом.  
  
-   **Предупреждения** записи состояния, описывающих предупреждения (класс 01) имеют низкий ранг. Если две или более записей описывают то же условие предупреждение, предупреждение SQLSTATE, определенных в спецификации Open CLI группы outrank SQLSTATE, определенных для ODBC и определяемые драйвером.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Получение нескольких полей структуры диагностических данных|[Функция SQLGetDiagRec](sqlgetdiagrec-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
