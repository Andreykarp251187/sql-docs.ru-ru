---
title: SQLBindCol, функция | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLBindCol
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLBindCol
helpviewer_keywords:
- SQLBindCol function [ODBC]
ms.assetid: 41a37655-84cd-423f-9daa-e0b47b88dc54
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 17b907be3e2641fe1dcbbb8fbd96586132e054ca
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "65538066"
---
# <a name="sqlbindcol-function"></a>SQLBindCol, функция
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLBindCol** привязывает буферы данных приложений столбцы в результирующем наборе.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLBindCol(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   ColumnNumber,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_Ind);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *ColumnNumber*  
 [Вход] Число результирующих набора столбцов для привязки. Столбцы нумеруются в порядке возрастания столбца, начиная с 0, где столбец 0 — столбец закладки. Если не используются закладки — то есть атрибут инструкции SQL_ATTR_USE_BOOKMARKS присваивается SQL_UB_OFF - номера столбцов начинаются с 1.  
  
 *TargetType*  
 [Вход] Идентификатор типа данных C \* *TargetValuePtr* буфера. При извлечении данных из источника данных с помощью **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, или **SQLSetPos**, драйвер преобразует данные для этого типа; При отправке данных в источник данных с помощью **SQLBulkOperations** или **SQLSetPos**, драйвер преобразует данные из этого типа. Список допустимых типов данных C и идентификаторы типов, см. в разделе [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) разделе в приложение г Типы данных.  
  
 Если *TargetType* аргумент имеет тип данных интервал, точность начальные интервал по умолчанию (2) и точность секунд интервал по умолчанию (6), как задано в поля SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION Отменить, соответственно, используются для данных. Если *TargetType* аргумент SQL_C_NUMERIC, точность по умолчанию (определенное драйвером) и по умолчанию масштаб (0), как задано в поля SQL_DESC_PRECISION и SQL_DESC_SCALE Отменить, используются для данных. Если любой по умолчанию точность или масштаб не подходит, приложение должно явным образом задать поле соответствующий дескриптор путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Можно также указать расширенного типа данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *TargetValuePtr*  
 [Отложенное вход/выход] Указатель на буфер данных для привязки к столбцу. **SQLFetch** и **SQLFetchScroll** возвращать данные в этот буфер. **SQLBulkOperations** возвращает данные в этом буфера, когда *операции* является SQL_FETCH_BY_BOOKMARK; он извлекает данные из этого буфера, когда *операции* SQL_ADD или SQL_UPDATE_BY_BOOKMARK. **SQLSetPos** возвращает данные в этом буфера, когда *операции* является SQL_REFRESH; он извлекает данные из этого буфера, когда *операции* является SQL_UPDATE.  
  
 Если *TargetValuePtr* является указателем null, драйвер отменяет привязку буфер данных для столбца. Приложения можно отменить привязку всех столбцов путем вызова **SQLFreeStmt** с параметром SQL_UNBIND. Приложения можно отменить привязку буфер данных для столбца, но по-прежнему буфер длины/индикатора привязанного столбца, если *TargetValuePtr* аргумента в вызове **SQLBindCol** является указателем null, но *StrLen_or_IndPtr* аргумент является допустимым значением.  
  
 *BufferLength*  
 [Вход] Длина **TargetValuePtr* буфера в байтах.  
  
 Драйвер использует *BufferLength* во избежание записи за пределами \* *TargetValuePtr* буфера при возвращении данных переменной длины, например символьных или двоичных данных. Обратите внимание на то, что драйвер считает знак завершения null, если он возвращает символьные данные для \* *TargetValuePtr*. **TargetValuePtr* таким образом может содержать места для знака завершения null или драйвер будет выполнять усечение данных.  
  
 Когда драйвер возвращает данных фиксированной длины, например целое число или структура даты, драйвер пропускает *BufferLength* и предполагает, что буфер недостаточно велик для хранения данных. Поэтому очень важно для приложения, чтобы выделить достаточно большой буфер для данных фиксированной длины или драйвер будет записывать после конца буфера.  
  
 **SQLBindCol** возвращает SQLSTATE HY090 (Недопустимая длина строки или буфера) при *BufferLength* является меньше 0 но не в том случае, когда *BufferLength* равно 0. Тем не менее если *TargetType* Указывает символьный тип, не устанавливайте приложения *BufferLength* 0, поскольку драйверов, совместимых с ISO CLI возвращают SQLSTATE HY090 (Недопустимая длина строки или буфера) в том, что регистр.  
  
 *StrLen_or_IndPtr*  
 [Отложенное вход/выход] Указатель на буфер длины/индикатора для привязки к столбцу. **SQLFetch** и **SQLFetchScroll** возвращают значение в этом буфере. **SQLBulkOperations** извлекает значение из данного буфера, когда *операции* SQL_ADD, SQL_UPDATE_BY_BOOKMARK или SQL_DELETE_BY_BOOKMARK. **SQLBulkOperations** возвращает значение в этом буфер при *операции* является SQL_FETCH_BY_BOOKMARK. **SQLSetPos** возвращает значение в этом буфер при *операции* является SQL_REFRESH; он извлекает значение из данного буфера, когда *операции* является SQL_UPDATE.  
  
 **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, и **SQLSetPos** может возвращать следующие значения в буфер длины/индикатора:  
  
-   Длина данных, доступных для возврата  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Приложение можно поместить следующие значения в буфер длины/индикатора для использования с **SQLBulkOperations** или **SQLSetPos**:  
  
-   Длина отправляемых данных  
  
-   SQL_NTS  
  
-   SQL_NULL_DATA  
  
-   SQL_DATA_AT_EXEC  
  
-   Результат SQL_LEN_DATA_AT_EXEC макроса  
  
-   SQL_COLUMN_IGNORE  
  
 Если буфера индикатора и буфер длины отдельных буферах, буфера индикатора может возвращать только SQL_NULL_DATA, тогда как длина буфера может возвращать другие значения.  
  
 Дополнительные сведения см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md), [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md), и [использование значений длины и индикатора](../../../odbc/reference/develop-app/using-length-and-indicator-values.md).  
  
 Если *StrLen_or_IndPtr* является пустым указателем, ни длины ни индикатор используется. Это ошибка при выборке данных и данных имеет значение NULL.  
  
 См. в разделе [сведения о ODBC 64-разрядном](../../../odbc/reference/odbc-64-bit-information.md), если приложение выполняется в 64-разрядной операционной системе.  
  
## <a name="returns"></a>Возвращает  
 Значение SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLBindCol** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые при помощи **SQLBindCol** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|(DM) *ColumnNumber* аргумент было равно 0 и *TargetType* аргумент не SQL_C_BOOKMARK или SQL_C_VARBOOKMARK.|  
|07009|Недопустимый индекс дескриптора|Значение, указанное для аргумента *ColumnNumber* превышено максимальное число столбцов в результирующем наборе.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимая для поддержки выполнения или завершения функции.|  
|HY003|Недопустимый тип буфера приложения|Аргумент *TargetType* был SQL_C_DEFAULT ни допустимый тип данных.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLBindCol** был вызван.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное для аргумента *BufferLength* меньше 0.<br /><br /> (DM) драйвер был ODBC 2. *x* драйвера, *ColumnNumber* аргумент имеет значение 0, а значение, указанное для аргумента *BufferLength* не равно 4.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяемое сочетание *TargetType* аргумента и типу данных специфические для драйвера SQL соответствующего столбца.<br /><br /> Аргумент *ColumnNumber* было равно 0, и драйвер не поддерживает закладки.<br /><br /> Драйвер поддерживает только ODBC 2. *x* и аргумент *TargetType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любой из типов данных интервала C, перечисленных в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) в приложение г Типы данных.<br /><br /> Драйвер поддерживает только версии ODBC до выпуска версии 3.50, а аргумент *TargetType* был SQL_C_GUID.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 **SQLBindCol** используется для связи, или *привязать,* столбцов в результате значение буферов данных и буфер длины/индикатора в приложении. Когда приложение вызывает **SQLFetch**, **SQLFetchScroll**, или **SQLSetPos** для выборки данных, драйвер возвращает данные для привязанных столбцов в указанной буферов; Дополнительные сведения см. в разделе [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md). Когда приложение вызывает **SQLBulkOperations** для обновления или вставки строки или **SQLSetPos** попытка обновить строку, драйвер получает данные для привязанных столбцов из указанного буферов; Дополнительные сведения , см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md) или [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md). Дополнительные сведения о привязке см. в разделе [извлечение результатов (базовые)](../../../odbc/reference/develop-app/retrieving-results-basic.md).  
  
 Обратите внимание, что столбцы не нужно быть привязаны для получения данных из них. Приложение также может вызвать **SQLGetData** для получения данных из столбцов. Несмотря на то, что можно привязать некоторые столбцы в строке и вызвать **SQLGetData** для других пользователей, это накладываются некоторые ограничения. Дополнительные сведения см. в разделе [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md).  
  
## <a name="binding-unbinding-and-rebinding-columns"></a>Привязка, Отмена привязки и повторная привязка столбцов  
 Столбец можно привязать, несвязанных или повторно привязаны в любое время, даже в том случае, если данные были получены из результирующего набора. Создать привязку вступает в силу в следующий раз вызывается функция, которая использует привязки. Предположим, например, приложение связывает столбцы в результирующем наборе и вызывает метод **SQLFetch**. Драйвер возвращает данные в привязанных буферах. Теперь предположим, что приложение привязывает столбцы к другому набору буферов. Драйвер не помещать данные для только что извлеченные строки в новой присоединенной буферах. Вместо этого оно ждет **SQLFetch** вызывается снова и помещает данные для следующей строки в новой присоединенной буферах.  
  
> [!NOTE]  
>  Атрибут инструкции SQL_ATTR_USE_BOOKMARKS всегда должны устанавливаться перед привязкой 0 столбца для столбца. Это не является обязательным, но настоятельно рекомендуется.  
  
## <a name="binding-columns"></a>Привязка столбцов  
 Чтобы привязать столбец, приложение вызывает **SQLBindCol** и передает номер столбца, тип, адрес и длину буфера данных и адрес буфера длины и индикатора. Сведения о том, как используются эти адреса см. в разделе «Адреса буферов,» далее в этом разделе. Дополнительные сведения о столбцах привязки см. в разделе [использование SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md).  
  
 Использование этих буферов откладывается; то есть приложение выполняет привязку их в **SQLBindCol** , но драйвер получает к ним доступ из других функций — а именно **SQLBulkOperations**, **SQLFetch**,  **SQLFetchScroll**, или **SQLSetPos**. Приложения должны убедиться, что указатели, указанные в **SQLBindCol** остаются действительными до тех пор, пока привязка остается в силе. Если приложение, позволяющее эти указатели недействительными — к примеру, он освобождает буфер -, а затем вызывает функцию, ожидающую их был допустимым, последствия не определены. Дополнительные сведения см. в разделе [отложенного буферы](../../../odbc/reference/develop-app/deferred-buffers.md).  
  
 Привязка остается в силе до заменяется новой привязки, отменяется привязка столбца или инструкция освобождается.  
  
## <a name="unbinding-columns"></a>Удаление привязки столбцов  
 Чтобы отменить привязку одного столбца, приложение вызывает **SQLBindCol** с *ColumnNumber* задан номер этого столбца и *TargetValuePtr* значение является пустым указателем. Если *ColumnNumber* ссылается на столбец, не связанного с данными, **SQLBindCol** по-прежнему возвращает значение SQL_SUCCESS.  
  
 Чтобы отменить привязку всех столбцов, приложение вызывает **SQLFreeStmt** с *fOption* значение SQL_UNBIND. Также это можно сделать, задав поле SQL_DESC_COUNT Отменить до нуля.  
  
## <a name="rebinding-columns"></a>Идет повторная привязка столбцов  
 Приложение может выполнять две операции, чтобы изменить привязки.  
  
-   Вызовите **SQLBindCol** для указания новой привязки для столбца, который уже привязан. Драйвер перезаписывает старую привязку на новую.  
  
-   Указать смещение для добавления адрес буфера, который был указан при вызове привязки **SQLBindCol**. Дополнительные сведения см. следующий раздел, «Смещения привязки».  
  
## <a name="binding-offsets"></a>Привязка смещения  
 Смещение привязки является значение, которое добавляется к адресам буферов данных и длины и индикатора (как указано в *TargetValuePtr* и *StrLen_or_IndPtr* аргумента), прежде чем они, отменяются. При использовании смещения привязки — это «шаблон» расположение буферы приложения и приложения можно переместить «шаблон» к различным областям памяти, изменение смещения. Так как же смещение добавляется в каждый адрес в каждой привязке, относительные смещения между буферами для различных столбцов должны совпадать в пределах каждого набора буферов. Это всегда имеет значение true, если используется привязка на уровне строки; приложения должны тщательно компоновать свои буферы, этому свойству значение true, если используется привязка на уровне столбцов.  
  
 С помощью смещения привязки в основном имеет тот же эффект, что повторная привязка столбца путем вызова **SQLBindCol**. Разница в том, новый вызов **SQLBindCol** указывает новые адреса для буфера данных и буфер длины/индикатора, тогда как использование смещение привязки не приводит к изменению адреса, но просто добавляет смещение к ним. Приложение может задать новое смещение, каждый раз, когда ему, и это смещение всегда добавляется изначально связанные адреса. В частности Если смещение задано значение 0, или если атрибут инструкции присваивается указатель null, драйвер использует изначально связанные адреса.  
  
 Чтобы указать смещение привязки, приложение устанавливает атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR адрес буфера SQLINTEGER. Прежде чем приложение вызывает функцию, которая использует привязки, он помещает смещение в байтах в этом буфере. Чтобы определить адрес буфера для использования, драйвер добавляет смещение к адресу в привязке. Сумма адрес и смещение должно быть допустимым адресом, но не быть допустимый адрес, к которому добавляется смещение. Дополнительные сведения о том, как используются смещения привязки см. в разделе «Адреса буферов,» далее в этом разделе.  
  
## <a name="binding-arrays"></a>Привязка массивов  
 Если размер набора строк (значение атрибута SQL_ATTR_ROW_ARRAY_SIZE инструкции) больше, чем 1, приложение связывает массивы буферов вместо одного буферов. Дополнительные сведения см. в разделе [блочные курсоры](../../../odbc/reference/develop-app/block-cursors.md).  
  
 Приложение можно связать массивы двумя способами:  
  
-   Привязать массив для каждого столбца. Это называется *привязка на уровне столбцов* так как каждая структура данных (array) содержит данные для одного столбца.  
  
-   Определите структуру для хранения данных для всей строки и привязать массив этих структур. Это называется *привязку на уровне строки* поскольку каждая структура данных содержит данные для одной строки.  
  
 Каждый массив буферов должен иметь по крайней мере столько же элементов, что размер набора строк.  
  
> [!NOTE]  
>  Приложения необходимо убедиться, что выравнивание является допустимым. Дополнительные сведения о рекомендациях по выравниванию, см. в разделе [выравнивание](../../../odbc/reference/develop-app/alignment.md).  
  
## <a name="column-wise-binding"></a>Привязка на уровне столбца  
 В привязку по столбцам, приложение связывает разделить данные и массивы длины и индикатора для каждого столбца.  
  
 Чтобы использовать привязку по столбцам, приложение сначала устанавливается атрибут инструкции SQL_ATTR_ROW_BIND_TYPE значение sql_bind_bind_by_column. (Это значение по умолчанию). Для каждого столбца необходимо привязать приложение выполняет следующие действия:  
  
1.  Выделяет массиву буфера данных.  
  
2.  Выделяет массив буферов длины и индикатора.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда используется привязка на уровне столбцов, отдельных массива можно использовать для данных, длины и индикатора.  
  
3.  Вызовы **SQLBindCol** со следующими аргументами:  
  
    -   *TargetType* тип из одного элемента в массиве буфера данных.  
  
    -   *TargetValuePtr* — это адрес массива буфера данных.  
  
    -   *BufferLength* — это размер из одного элемента в массиве буфера данных. *BufferLength* аргумент учитывается, когда данные фиксированной длины данных.  
  
    -   *StrLen_or_IndPtr* — это адрес массива длины и индикатора.  
  
 Дополнительные сведения о том, как эти сведения используются см. в разделе «Адреса буферов,» далее в этом разделе. Дополнительные сведения о привязки на уровне столбца, см. в разделе [привязки на уровне столбца](../../../odbc/reference/develop-app/column-wise-binding.md).  
  
## <a name="row-wise-binding"></a>Привязка на уровне строки  
 В привязку на уровне строки, приложение определяет структуру, содержащую буферов данных и длины и индикатора для каждого столбца, для привязки.  
  
 Чтобы использовать привязку на уровне строки, приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения одну строку данных (включая буферов данных и длины и индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда используется привязка на уровне строки, можно использовать отдельные поля для данных, длины и индикатора.  
  
2.  Задает атрибут инструкции SQL_ATTR_ROW_BIND_TYPE размер структуры, которая содержит одну строку данных или размер экземпляра буфера, в который будет привязан столбцов результатов. Длина должна включать пробел для всех связанных столбцов и все заполнения структуры или буфера, чтобы убедиться в том, результат адрес связанного столбца увеличивается с указанным значением длины, будет указывать на начало того же столбца в следующей строке. При использовании *sizeof* оператор в ANSI C, такое поведение гарантируется.  
  
3.  Вызовы **SQLBindCol** со следующими аргументами для каждого столбца, для привязки:  
  
    -   *TargetType* является типом элемента буфера данных, привязанное к столбцу.  
  
    -   *TargetValuePtr* — это адрес члена данных буфера в первом элементе массива.  
  
    -   *BufferLength* — это размер элемента буфера данных.  
  
    -   *StrLen_or_IndPtr* — это адрес члена длины и индикатора, который требуется привязать.  
  
 Дополнительные сведения о том, как эти сведения используются см. в разделе «Адреса буферов,» далее в этом разделе. Дополнительные сведения о привязки на уровне столбца, см. в разделе [привязки на уровне строки](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="buffer-addresses"></a>Адреса буферов  
 *Буфера адрес* — это фактический адрес буфера данных или длины и индикатора. Драйвер вычисляет адрес буфера, непосредственно перед записываются в буферах (такие как время во время извлечения). Оно вычисляется с помощью следующей формулы, которая использует адреса, указанные в *TargetValuePtr* и *StrLen_or_IndPtr* аргументов, смещение привязки и номер строки:  
  
 *Привязан адрес* + *привязки смещение* + ((*номером строки* - 1) x *размер элемента*)  
  
 где формулы переменные определяются, как описано в следующей таблице.  
  
|Переменная|Описание|  
|--------------|-----------------|  
|*Привязан адрес*|Буфер данных, то указывается адрес с *TargetValuePtr* аргумента в **SQLBindCol**.<br /><br /> Буфер длины/индикатора, то указывается адрес с *StrLen_or_IndPtr* аргумента в **SQLBindCol**. Дополнительные сведения см. в разделе «Примечания» в разделе «Дескрипторы и SQLBindCol».<br /><br /> Если привязан адрес равен 0, значение данных не возвращается, даже если адрес, как вычисляется в указанной выше формуле не равно нулю.|  
|*Смещение привязки*|Если используется привязка на уровне строки, по адресу значение, заданное атрибутом SQL_ATTR_ROW_BIND_OFFSET_PTR инструкции.<br /><br /> Если используется привязка на уровне столбцов или если значение атрибута инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR является пустым указателем, *смещение привязки* равно 0.|  
|*Номер строки*|Отсчитываемый от единицы номер строки в наборе строк. Для выборки одной строки, которые используются по умолчанию, это 1.|  
|*Размер элемента*|Размер элемента в массиве привязанных.<br /><br /> Если используется привязка на уровне столбцов, это **sizeof(SQLINTEGER)** буфер длины/индикатора. Для буферов данных, это значение *BufferLength* аргумента в **SQLBindCol** Если тип данных переменной длины и размер типа данных, если тип данных имеет фиксированную длину.<br /><br /> Если используется привязка на уровне строки, это значение атрибута инструкции SQL_ATTR_ROW_BIND_TYPE для буферов данных и длины и индикатора.|  
  
## <a name="descriptors-and-sqlbindcol"></a>Дескрипторы и SQLBindCol  
 В следующих разделах описываются как **SQLBindCol** взаимодействует с дескрипторами.  
  
> [!CAUTION]  
>  Вызов **SQLBindCol** для одной инструкции может повлиять на другие инструкции. Это происходит при явном выделении Отменить, связанные с инструкцией и также связан с другими инструкциями. Так как **SQLBindCol** изменяет дескриптор, изменения применяются ко всем операторам, с которыми связан данный дескриптор. Если это не требуемое поведение, приложение должно отменить связь этот дескриптор из других инструкций, перед вызовом **SQLBindCol**.  
  
## <a name="argument-mappings"></a>Аргумент сопоставления  
 По существу **SQLBindCol** выполняет следующие шаги в последовательности:  
  
1.  Вызовы **SQLGetStmtAttr** получить дескриптор Отменить.  
  
2.  Вызовы **SQLGetDescField** для получения поля SQL_DESC_COUNT этим дескриптором и, если значение в *ColumnNumber* аргумента превышает значение свойства SQL_DESC_COUNT, вызовы **SQLSetDescField**  для увеличения значения SQL_DESC_COUNT для *ColumnNumber*.  
  
3.  Вызовы **SQLSetDescField** несколько раз, чтобы присвоить значения следующих полей свойства Отменить:  
  
    -   Задает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE значению *TargetType*, за исключением того, что если *TargetType* является одним из краткого идентификаторов подтипа даты-времени или интервал, он задает SQL_DESC_TYPE SQL_ DATETIME или SQL_INTERVAL, соответственно; Задает SQL_DESC_CONCISE_TYPE для краткого идентификатора; и наборы SQL_DESC_DATETIME_INTERVAL_CODE соответствующей даты и времени или интервал дополнительный код.  
  
    -   Задает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_DATETIME_INTERVAL_PRECISION, в зависимости от *TargetType*.  
  
    -   Задает значение для поля SQL_DESC_OCTET_LENGTH *BufferLength*.  
  
    -   Задает значение для поля SQL_DESC_DATA_PTR *TargetValue*.  
  
    -   Задает значение для поля SQL_DESC_INDICATOR_PTR *StrLen_or_Ind*. (См. следующий абзац).  
  
    -   Задает значение для поля SQL_DESC_OCTET_LENGTH_PTR *StrLen_or_Ind*. (См. следующий абзац).  
  
 Переменная, *StrLen_or_Ind* на которое ссылается аргумент используется для индикатора и длины данных. Если fetch встретится значение null для столбца, он сохраняет значение SQL_NULL_DATA в этой переменной; в противном случае она сохраняет длину данных в этой переменной. Передача пустой указатель как *StrLen_or_Ind* отслеживает операции выборки возвращали длину данных, но делает fetch ошибкой, если он встретится значение null и не может возвращать значение SQL_NULL_DATA.  
  
 Если вызов **SQLBindCol** завершается с ошибкой, содержимое поля дескриптора, он будет установлен в Отменить не определены, и значение поля SQL_DESC_COUNT Отменить остается неизменным.  
  
## <a name="implicit-resetting-of-count-field"></a>Неявные сброса поле СЧЕТЧИКА  
 **SQLBindCol** присваивается значение SQL_DESC_COUNT *ColumnNumber* аргумента только в том случае, если это увеличит значение SQL_DESC_COUNT. Если значение в *TargetValuePtr* аргумент является указателем null и значение в *ColumnNumber* аргумент равен SQL_DESC_COUNT (то есть при отмене привязки самым высоким привязанного столбца), затем SQL_DESC_ ЧИСЛО присваивается номер наивысший оставшиеся привязанного столбца.  
  
## <a name="cautions-regarding-sqldefault"></a>Предостережения относительно SQL_DEFAULT  
 Для извлечения данных столбца успешно, приложение должно определить, правильно длину и начальную точку данных в буфере приложения. Если приложение указывает явным *TargetType*, неправильных представлений приложения легко выявлялись. Тем не менее, если приложение указывает *TargetType* из SQL_DEFAULT, **SQLBindCol** могут применяться к столбцу в другой тип данных из назначенного приложением, либо из изменений метаданные или путем применения кода к другому столбцу. В этом случае приложение может не всегда определить начала или длину данных, извлеченных столбцов. Это может привести к недокументированных данных ошибок или нарушений памяти.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет **ВЫБЕРИТЕ** оператором в таблицу клиентов, чтобы вернуть результирующий набор, клиента, идентификаторы, имена и номера телефонов, отсортированных по имени. Затем он вызывает **SQLBindCol** для привязки столбцов данных в локальном буферы. Наконец, приложение извлекает каждой строки данных с помощью **SQLFetch** и выводит имя каждого клиента, идентификатор и номер телефона.  
  
 Дополнительные примеры кода, см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [функция SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md), [функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md), и [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
```cpp  
// SQLBindCol_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <stdio.h>  
  
#define UNICODE  
#include <sqlext.h>  
  
#define NAME_LEN 50  
#define PHONE_LEN 20  
  
void show_error() {  
   printf("error\n");  
}  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt = 0;  
   SQLRETURN retcode;  
   SQLWCHAR szName[NAME_LEN], szPhone[PHONE_LEN], sCustID[NAME_LEN];  
   SQLLEN cbName = 0, cbCustID = 0, cbPhone = 0;  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);  
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLWCHAR*) L"NorthWind", SQL_NTS, (SQLWCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {   
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               retcode = SQLExecDirect(hstmt, (SQLWCHAR *) L"SELECT CustomerID, ContactName, Phone FROM CUSTOMERS ORDER BY 2, 1, 3", SQL_NTS);  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
  
                  // Bind columns 1, 2, and 3  
                  retcode = SQLBindCol(hstmt, 1, SQL_C_CHAR, &sCustID, 100, &cbCustID);  
                  retcode = SQLBindCol(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &cbName);  
                  retcode = SQLBindCol(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN, &cbPhone);   
  
                  // Fetch and print each row of data. On an error, display a message and exit.  
                  for (i ; ; i++) {  
                     retcode = SQLFetch(hstmt);  
                     if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO)  
                        show_error();  
                     if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
                        wprintf(L"%d: %S %S %S\n", i + 1, sCustID, szName, szPhone);  
                     else  
                        break;  
                  }  
               }  
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLCancel(hstmt);  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
 Обратите внимание, [образец программы ODBC](../../../odbc/reference/sample-odbc-program.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Освобождение буферах столбцов на инструкцию|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Получение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
