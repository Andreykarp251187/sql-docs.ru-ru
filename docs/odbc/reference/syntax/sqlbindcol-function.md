---
title: Функция S'LBindCol (англ. Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLBindCol
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLBindCol
helpviewer_keywords:
- SQLBindCol function [ODBC]
ms.assetid: 41a37655-84cd-423f-9daa-e0b47b88dc54
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 90bb1c1aa4dbfa2614f689faa47eb0c41a6cecd6
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81298744"
---
# <a name="sqlbindcol-function"></a>SQLBindCol, функция
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **S'LBindCol** связывает буферы данных приложений с столбцов в наборе результатов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLBindCol(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   ColumnNumber,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_Ind);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *ColumnNumber*  
 (Вход) Количество набора столбца для связывания. Столбцы пронумероваются в увеличиваемом порядке столбца, начиная с 0, где столбец 0 является столбцом закладки. Если закладки не используются, т.е. атрибут SQL_ATTR_USE_BOOKMARKS оператора установлен на SQL_UB_OFF, то цифры столбцов начинаются с 1.  
  
 *Targettype*  
 (Вход) Идентификатор типа данных \*C буфера *TargetValuePtr.* При извлечении данных из источника данных с **помощью S'LFetch,** **S'LFetchScroll,** **S'LBulkOperations**или **S'LSetPos**, драйвер преобразует данные в этот тип; при отправке данных в исходный исход данных с **помощью S'LBulkOperations** или **S'LSetPos,** драйвер преобразует данные этого типа. Список действительных типов данных C и идентификаторов типа см. раздел [C Data Types](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: Типы данных.  
  
 Если аргумент *TargetType* представляет собой тип данных интервала, то для данных используются точность интервала интервала по умолчанию (2) и точность секунд интервала по умолчанию (6), установленные в SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION полях ARD, соответственно. Если аргумент *TargetType* является SQL_C_NUMERIC, для данных используется точность (определенная драйвером) и шкала по умолчанию (0), установленная в SQL_DESC_PRECISION и SQL_DESC_SCALE полях ARD. Если какая-либо точность или масштаб по умолчанию не подходит, приложение должно четко установить соответствующее поле дескриптора по вызову в **S'LSetDescfield** или **S'LSetDescRec.**  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения о типах данных см. в разделе [Типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *TargetValuePtr*  
 (Отложенный вход/выход) Указатель на буфер данных для привязки к столбецу. В этом буфере данные возвращаются ими с помощью **sLFetch** и **S'LFetchScroll.** **S'LBulkOperations** возвращает данные в этом буфере, когда *операция* SQL_FETCH_BY_BOOKMARK; он извлекает данные из этого буфера, когда *операция* SQL_ADD или SQL_UPDATE_BY_BOOKMARK. **SLSetPos** возвращает данные в этом буфере, когда *операция* SQL_REFRESH; он извлекает данные из этого буфера при SQL_UPDATE *операции.*  
  
 Если *TargetValuePtr* является нулевой указкой, драйвер отменяет буфер данных для столбца. Приложение может развенчание всех столбцов, позвонив в **SQL_UNBIND** опцию. Приложение может отменить буфер данных для столбца, но все еще имеет буфер длины/индикатора, привязанный к столбце, если аргумент *TargetValuePtr* в вызове **к S'LBindCol** является нулевым указателем, но *аргумент StrLen_or_IndPtr* является допустимым значением.  
  
 *BufferLength*  
 (Вход) Длина \*буфера *TargetValuePtr* в байтах.  
  
 Драйвер использует *BufferLength,* чтобы избежать записи мимо конца \*буфера *TargetValuePtr,* когда он возвращает данные переменной длины, такие как символ или двоичные данные. Обратите внимание, что драйвер подсчитывает символ \*нулевого прекращения, когда возвращает данные о символах *в TargetValuePtr.* \*Таким *образом, TargetValuePtr* должен содержать место для символа с нулевым прекращением, иначе водитель усечен инес данные.  
  
 Когда драйвер возвращает данные с фиксированной длиной, такие как целый ряд или структура даты, драйвер игнорирует *BufferLength* и предполагает, что буфер достаточно велик, чтобы держать данные. Поэтому для приложения важно выделить достаточно большой буфер для данных с фиксированной длиной, иначе драйвер напишет мимо конца буфера.  
  
 **S'LBindCol** возвращает S'LSTATE HY090 (Недействительная длина строки или буфера), когда *BufferLength* меньше 0, но не тогда, когда *BufferLength* 0. Однако, если *TargetType* указывает тип символов, приложение не должно установить *BufferLength* до 0, потому что драйверы, совместимые с ISO CLI, возвращают S'LSTATE HY090 (недействительная длина строки или длины буфера) в этом случае.  
  
 *StrLen_or_IndPtr*  
 (Отложенный вход/выход) Указатель на буфер длины/индикатора для привязки к столбецу. **S'LFetch** и **S'LFetchScroll** возвращают значение в этом буфере. **S'LBulkOperations** извлекает значение из этого буфера, когда *операция* находится SQL_ADD, SQL_UPDATE_BY_BOOKMARK или SQL_DELETE_BY_BOOKMARK. При SQL_FETCH_BY_BOOKMARK *операции* в этом буфере **s'LBulkOperations** возвращает значение. **SLSetPos** возвращает значение в этом буфере, когда *операция* SQL_REFRESH; он извлекает значение из этого буфера, когда *операция* SQL_UPDATE.  
  
 **S'LFetch**, **S'LFetchScroll**, **S'LBulkOperations**, и **S'LSetPos** может вернуть следующие значения в буфере длины /индикатора:  
  
-   Длина данных, доступных для возврата  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Приложение может поместить следующие значения в буфер длины/индикатора для использования с **помощью S'LBulkOperations** или **S'LSetPos:**  
  
-   Длина отправляемых данных  
  
-   SQL_NTS  
  
-   SQL_NULL_DATA  
  
-   SQL_DATA_AT_EXEC  
  
-   Результат SQL_LEN_DATA_AT_EXEC макроса  
  
-   SQL_COLUMN_IGNORE  
  
 Если буфер индикатора и буфер длины являются отдельными буферами, буфер индикатора может вернуться только SQL_NULL_DATA, в то время как буфер длины может вернуть все другие значения.  
  
 Для получения более подробной [информации,](../../../odbc/reference/develop-app/using-length-and-indicator-values.md) [SQLFetch Function](../../../odbc/reference/syntax/sqlfetch-function.md)см. [SQLSetPos Function](../../../odbc/reference/syntax/sqlsetpos-function.md) [SQLBulkOperations Function](../../../odbc/reference/syntax/sqlbulkoperations-function.md)  
  
 Если *StrLen_or_IndPtr* является нулевой указатель, не длина или значение индикатора не используется. Это ошибка при извлечении данных, а данные являются NULL.  
  
 Смотрите [информацию ODBC 64-Bit,](../../../odbc/reference/odbc-64-bit-information.md)если ваше приложение будет работать на 64-битной операционной системе.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LBindCol** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью HandleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LBindCol,** и приведены в контексте этой функции. нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|(DM) Аргумент *ColumnNumber* был 0, и *аргумент TargetType* не был SQL_C_BOOKMARK или SQL_C_VARBOOKMARK.|  
|07009|Недействительный индекс дескриптора|Значение, указанное для аргумента *ColumnNumber,* превысило максимальное количество столбцов в наборе результатов.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003|Недействительный тип буфера приложения|Аргумент *TargetType* не был ни действительным типом данных, ни SQL_C_DEFAULT.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда был вызван **S'LBindCol.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Асинхронно выполнение функции был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение, указанное для аргумента *BufferLength* было меньше, чем 0.<br /><br /> (DM) Водитель был ODBC 2. *x* драйвер, аргумент *ColumnNumber* был установлен на 0, а значение, указанное для аргумента *BufferLength,* не было равно 4.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает преобразование, указанное комбинацией аргумента *TargetType* и типом данных соответствующего столбца для конкретного драйвера S'L.<br /><br /> Аргумент *ColumnNumber* был 0 и водитель не поддерживает закладки.<br /><br /> Водитель поддерживает только ODBC 2. *x* и аргумент *TargetType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любой из типов данных интервала C, перечисленных в [типах данных C](../../../odbc/reference/appendixes/c-data-types.md) в приложении D: Типы данных.<br /><br /> Драйвер поддерживает версии ODBC только до 3.50, и аргумент *TargetType* был SQL_C_GUID.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Для ассоциированного или *связывания* столбцов в наборе результатов используется **s'LBindCol** и буферах длины/индикатора в приложении. Когда приложение вызывает **s'LFetch,** **S'LFetchScroll**, или **S'LSetPos** для получения данных, водитель возвращает данные для связанных столбцов в указанных буферах; Для получения более подробной информации, [см.](../../../odbc/reference/syntax/sqlfetch-function.md) Когда приложение вызывает **S'LBulkOperations** для обновления или вставки строки или **S'LSetPos** для обновления строки, драйвер извлекает данные для связанных столбцов из указанных буферов; Для получения более подробной информации, [SQLSetPos Function](../../../odbc/reference/syntax/sqlsetpos-function.md)см. [SQLBulkOperations Function](../../../odbc/reference/syntax/sqlbulkoperations-function.md) Для получения дополнительной информации о [привязке](../../../odbc/reference/develop-app/retrieving-results-basic.md)см.  
  
 Обратите внимание, что столбцы не должны быть обязаны получать данные из них. Для извлечения данных из столбцов приложение также может вызывать **s'LGetData.** Несмотря на то, что некоторые столбцы можно связать подряд и вызвать **s'LGetData** для других, на это распространяются некоторые ограничения. Для получения более подробной информации, [см.](../../../odbc/reference/syntax/sqlgetdata-function.md)  
  
## <a name="binding-unbinding-and-rebinding-columns"></a>Связывание, несвязные и переобязательные столбцы  
 Столбец может быть связан, не связан или отскок в любое время, даже после того, как данные были извлечены из набора результатов. Новая привязка вступает в силу в следующий раз, когда вызывается функция, использующая привязки. Например, предположим, что приложение связывает столбцы в наборе результатов и вызывает **S'LFetch.** Водитель возвращает данные в связанных буферах. Теперь предположим, что приложение связывает столбцы с другим набором буферов. Драйвер не размещает данные для только что извлеченного ряда в недавно связанных буферах. Вместо этого он ждет, пока **s'LFetch** будет снова вызываться, а затем помещает данные для следующего ряда в недавно связанные буферы.  
  
> [!NOTE]  
>  Атрибут оператора SQL_ATTR_USE_BOOKMARKS всегда должен быть установлен перед привязкой столбца к столбце 0. Это не требуется, но настоятельно рекомендуется.  
  
## <a name="binding-columns"></a>Привязка столбцов  
 Чтобы связать столбец, приложение вызывает **s'LBindCol** и передает номер столбца, тип, адрес и длину буфера данных, а также адрес буфера длины/индикатора. Подробнее о том, как используются эти адреса, можно узнать в этом разделе "Buffer Addresses". Для получения дополнительной информации о связывающих столбцах [см.](../../../odbc/reference/develop-app/using-sqlbindcol.md)  
  
 Использование этих буферов откладывается; то есть, приложение связывает их в **S'LBindCol,** но водитель получает к ним доступ с помощью других функций, а именно, **S'LBulkOperations**, **S'LFetch**, **S'LFetchScroll**, или **S'LSetPos**. Приложение обязано обеспечить, чтобы указатели, указанные в **S'LBindCol,** оставались в силе до тех пор, пока привязка остается в силе. Если приложение позволяет этим указателям стать недействительными - например, оно освобождает буфер , а затем вызывает функцию, которая ожидает, что они будут действительными, последствия не определены. Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/deferred-buffers.md)  
  
 Привязка остается в силе до тех пор, пока она не будет заменена новой привязкой, столбец не связан или заявление освобождается.  
  
## <a name="unbinding-columns"></a>Необязательные столбцы  
 Чтобы отвязать один столбец, приложение вызывает **S'LBindCol** с *columnNumber,* установленным на номер этого столбца, и *TargetValuePtr,* установленным на нулевую указку. Если *ColumnNumber* относится к несвязанной колонке, **S'LBindCol** по-прежнему возвращается SQL_SUCCESS.  
  
 Чтобы развязать все столбцы, приложение вызывает **S'LFreeStmt** с *fOption* набор для SQL_UNBIND. Это также может быть достигнуто путем установки SQL_DESC_COUNT области ARD к нулю.  
  
## <a name="rebinding-columns"></a>Пересвязывание столбцов  
 Приложение может выполнить одну из двух операций для изменения привязки:  
  
-   Позвоните **в S'LBindCol,** чтобы указать новую привязку для уже связанного столбца. Водитель перезаписывает старую переплетовую с новой.  
  
-   Укажите смещение, которое будет добавлено к буферному адресу, указанному связывающим вызовом на **S'LBindCol.** Для получения дополнительной информации смотрите следующий раздел "Связывание смещений".  
  
## <a name="binding-offsets"></a>Связывание смещений  
 Привязка смещения — это значение, которое добавляется к адресам буферов данных и длины/индикатора (как указано в *TargetValuePtr* и *StrLen_or_IndPtr* аргументе) до того, как они будут раз: При использовании смещений привязки являются «шаблоном» того, как выкладываются буферы приложения, и приложение может переместить этот «шаблон» в различные области памяти, изменив смещение. Поскольку к каждому адресу в каждом связующих связях добавляется одно и то же смещение, относительные смещения между буферами для разных столбцов должны быть одинаковыми в каждом наборе буферов. Это всегда верно, когда используется связывание по гребню; приложение должно тщательно выложить свои буферы, чтобы это было правдой, когда используется связывание с характерю столбца.  
  
 Использование привязки смещения имеет в основном тот же эффект, как и пересвязание столбца, позвонив по **s'LBindCol.** Разница заключается в том, что новый вызов в **S'LBindCol** определяет новые адреса для буфера данных и буфера длины/индикатора, в то время как использование привязки смещения не меняет адреса, а просто добавляет к ним смещение. Приложение может указать новое смещение, когда захочет, и это смещение всегда добавляется к первоначально связанным адресам. В частности, если смещение настроено до 0 или если атрибут оператора установлен на нулевой указатель, драйвер использует первоначально связанные адреса.  
  
 Чтобы указать привязку смещения, приложение устанавливает атрибут SQL_ATTR_ROW_BIND_OFFSET_PTR оператора на адрес буфера S'LINTEGER. Перед тем, как приложение вызывает функцию, использующую привязки, оно помещает компенстизируемые байты в этот буфер. Чтобы определить адрес буфера для использования, драйвер добавляет смещение к адресу в привязке. Сумма адреса и смещения должны быть действительным адресом, но адрес, к которому добавляется смещение, не должен быть действительным. Для получения дополнительной информации о том, как используются обязательные смещения, см.  
  
## <a name="binding-arrays"></a>Связывание массивов  
 Если размер строки (значение атрибута SQL_ATTR_ROW_ARRAY_SIZE оператора) превышает 1, приложение связывает массивы буферов вместо отдельных буферов. Для получения дополнительной [информации](../../../odbc/reference/develop-app/block-cursors.md)см.  
  
 Приложение может связывать массивы двумя способами:  
  
-   Привязать массив к каждой колонке. Это называется *связующим кругом,* поскольку каждая структура данных (массив) содержит данные для одного столбца.  
  
-   Определите структуру для хранения данных для целого ряда и связывайте массив этих структур. Это называется *связующим связующим связующим связующим с рядом,* поскольку каждая структура данных содержит данные для одной строки.  
  
 Каждый массив буферов должен иметь по крайней мере столько же элементов, сколько размер набора строк.  
  
> [!NOTE]  
>  Приложение должно убедиться, что выравнивание действительно. Для получения дополнительной информации [Alignment](../../../odbc/reference/develop-app/alignment.md)о соображениях выравнивания см.  
  
## <a name="column-wise-binding"></a>Привязка на уровне столбца  
 В связке с колонкой приложение связывает отдельные данные и массивы длины/индикатора с каждым столбцом.  
  
 Для использования связывания с характерю столбцов приложение сначала устанавливает атрибут SQL_ATTR_ROW_BIND_TYPE оператора на SQL_BIND_BY_COLUMN. (Это по умолчанию.) Для того чтобы каждый столбец был связан, приложение выполняет следующие действия:  
  
1.  Выделяет массив буфера данных.  
  
2.  Выделяет массив буферов длины/индикатора.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно дескрипторы, когда используется связывание с характерю столбца, для данных длины и индикатора можно использовать отдельные массивы.  
  
3.  Вызывает **S'LBindCol** со следующими аргументами:  
  
    -   *TargetType* — это тип одного элемента в массиве буфера данных.  
  
    -   *TargetValuePtr* — это адрес массива буфера данных.  
  
    -   *BufferLength* — это размер одного элемента в массиве буфера данных. Аргумент *BufferLength* игнорируется, когда данные имеют фиксированную длину данных.  
  
    -   *StrLen_or_IndPtr* является адрес массива длины/индикатора.  
  
 Для получения дополнительной информации о том, как эта информация используется, см. Для получения дополнительной информации о [Column-Wise Binding](../../../odbc/reference/develop-app/column-wise-binding.md)столбцовой связи см.  
  
## <a name="row-wise-binding"></a>Привязка на уровне строки  
 В связке с рядом приложение определяет структуру, содержащую данные и буферы длины/индикатора для каждого столбца.  
  
 Для использования связывания с рядом приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения одного ряда данных (включая как данные, так и буферы длины/индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно дескрипторы при использовании связывания, для данных о длине и индикаторе можно использовать отдельные поля.  
  
2.  Устанавливает атрибут SQL_ATTR_ROW_BIND_TYPE оператора к размеру структуры, содержащей одну строку данных, или к размеру экземпляра буфера, в который будут привязаны столбцы результатов. Длина должна включать пространство для всех связанных столбцов и любую обивку структуры или буфера, чтобы убедиться, что, когда адрес связанного столбца приравнсирован с указанной длиной, результат укажет на начало одной и той же колонки в следующем ряду. При использовании *оператора sizeof* в ANSI C такое поведение гарантируется.  
  
3.  Вызывает **S'LBindCol** со следующими аргументами для каждого столбца, чтобы быть связанным:  
  
    -   *TargetType* — это тип члена буфера данных, который должен быть привязан к столбцю.  
  
    -   *TargetValuePtr* — это адрес члена буфера данных в элементе первого массива.  
  
    -   *BufferLength* — это размер члена буфера данных.  
  
    -   *StrLen_or_IndPtr* является адресом участника длины/индикатора, который должен быть связан.  
  
 Для получения дополнительной информации о том, как эта информация используется, см. Для получения дополнительной информации о [Row-Wise Binding](../../../odbc/reference/develop-app/row-wise-binding.md)столбцовой связи см.  
  
## <a name="buffer-addresses"></a>Баффер Адреса  
 Адрес *буфера* — это фактический адрес данных или буфер длины/индикатора. Водитель вычисляет адрес буфера непосредственно перед его записи в буферы (например, во время получения времени). Он рассчитывается по следующей формуле, которая использует адреса, указанные в *TargetValuePtr* и *StrLen_or_IndPtr* аргументы, привязка смещения, и номер строки:  
  
 *Связанный адрес* + *Связывание Offset* ((Номер*строки* - 1) x Размер *элемента)*  
  
 где переменные формулы определяются как описано в следующей таблице.  
  
|Переменная|Описание|  
|--------------|-----------------|  
|*Связанный адрес*|Для буферов данных адрес, указанный в аргументе *TargetValuePtr,* в **S'LBindCol**.<br /><br /> Для буферов длины/индикатора адрес, указанный *с аргументом StrLen_or_IndPtr* в **S'LBindCol**. Для получения дополнительной информации, см. "Дополнительные комментарии" в разделе "Дескрипторы и S'LBindCol".<br /><br /> Если связанный адрес 0, значение данных не возвращается, даже если адрес, рассчитанный предыдущей формулой, является ненулевым.|  
|*Связывание Offset*|При использовании привязки с рядом значение, хранящееся в адресе, указанном в SQL_ATTR_ROW_BIND_OFFSET_PTR атрибута оператора.<br /><br /> Если используется связывание с характерю столбца или если значение атрибута SQL_ATTR_ROW_BIND_OFFSET_PTR оператора является нулевой указкой, *связывающее смещение* составляет 0.|  
|*Row Number*|1-основанное число строки в строке. Для однорядных извлечений, которые по умолчанию, это 1.|  
|*Размер элемента*|Размер элемента в связанном массиве.<br /><br /> Если используется связывание с характерю столбца, то это **размер (S'LINTEGER)** для буферов длины/индикатора. Для буферов данных это значение аргумента *BufferLength* в **S'LBindCol,** если тип данных является переменной длиной, и размер типа данных, если тип данных является фиксированной длиной.<br /><br /> Если используется связывание с рядом, это значение атрибута SQL_ATTR_ROW_BIND_TYPE оператора как для данных, так и для буферов длины/индикатора.|  
  
## <a name="descriptors-and-sqlbindcol"></a>Дескрипторы и S'LBindCol  
 В следующих разделах описывается, как **s'LBindCol** взаимодействует с дескрипторами.  
  
> [!CAUTION]  
>  Вызов **S'LBindCol** для одного оператора может повлиять на другие операторы. Это происходит, когда ARD, связанный с оператором, явно выделяется и также связан с другими операторами. Поскольку **S'LBindCol** изменяет дескриптор, изменения применяются ко всем утверждениям, с которыми связан этот дескриптор. Если это не является обязательным поведением, приложение должно отделить этот дескриптор от других инструкций, прежде чем он вызывает **S'LBindCol**.  
  
## <a name="argument-mappings"></a>Аргумент Картирование  
 Концептуально, **S'LBindCol** выполняет следующие шаги последовательно:  
  
1.  Вызывает **S'LGetStmtAttr** для того чтобы получить ручку ARD.  
  
2.  Вызывает **S'LGetDescField,** чтобы получить SQL_DESC_COUNT поле этого дескриптора, и если значение в аргументе *ColumnNumber* превышает значение SQL_DESC_COUNT, звонит **s'LSetDescField,** чтобы увеличить значение SQL_DESC_COUNT *к ColumnNumber.*  
  
3.  Вызывает несколько раз **вызовов sLSetDescField** для присвоения значений следующим полям ARD:  
  
    -   Устанавливает SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE к значению *TargetType,* за исключением того, что если *TargetType* является одним из кратких идентификаторов подтипа даты или интервала, он устанавливает SQL_DESC_TYPE SQL_DATETIME или SQL_INTERVAL, соответственно; устанавливает SQL_DESC_CONCISE_TYPE к краткому идентификатору; и устанавливает SQL_DESC_DATETIME_INTERVAL_CODE в соответствующий подкод даты или интервал.  
  
    -   Устанавливает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_DATETIME_INTERVAL_PRECISION, если они подходят для *TargetType.*  
  
    -   Устанавливает поле SQL_DESC_OCTET_LENGTH значение *BufferLength.*  
  
    -   Устанавливает поле SQL_DESC_DATA_PTR к значению *TargetValue.*  
  
    -   Устанавливает поле SQL_DESC_INDICATOR_PTR значение *StrLen_or_Ind.* (См. следующий абзац.)  
  
    -   Устанавливает поле SQL_DESC_OCTET_LENGTH_PTR значение *StrLen_or_Ind.* (См. следующий абзац.)  
  
 Переменная, на которую ссылается *StrLen_or_Ind* аргумент, используется как для информации о индикаторах, так и в длине. Если извлечение встречаетнуло нулевое значение для столбца, он хранит SQL_NULL_DATA в этой переменной; в противном случае он хранит длину данных в этой переменной. Передача нулевой *указатель,* как StrLen_or_Ind держит получить операции от возвращения длины данных, но делает получить неудачу, если он сталкивается с нулевая стоимость и не имеет возможности вернуть SQL_NULL_DATA.  
  
 Если вызов **на S'LBindCol** не удается, содержание полей дескриптора, которые он установил бы в ARD, не определено, а значение SQL_DESC_COUNT поля ARD остается неизменным.  
  
## <a name="implicit-resetting-of-count-field"></a>Неявная перезагрузка поля COUNT  
 **S'LBindCol** устанавливает SQL_DESC_COUNT к значению аргумента *ColumnNumber* только тогда, когда это увеличит значение SQL_DESC_COUNT. Если значение в аргументе *TargetValuePtr* является нулевой указателем, а значение в аргументе *ColumnNumber* равно SQL_DESC_COUNT (т.е. при несвязивании столбца наивысшей границы), то SQL_DESC_COUNT устанавливается на число наивысшего оставшегося столбца.  
  
## <a name="cautions-regarding-sql_default"></a>Предостережения относительно SQL_DEFAULT  
 Чтобы успешно получить данные столбца, приложение должно правильно определить длину и отправную точку данных в буфере приложения. Когда приложение указывает явный *TargetType,* заблуждения приложения легко обнаруживаются. Однако, когда приложение указывает *TargetType* SQL_DEFAULT, **S'LBindCol** может быть применен к столбце другого типа данных, от того, который предназначен приложением, либо от изменений в метаданных, либо путем применения кода к другому столбцюлю. В этом случае приложение не всегда может определить начало или длину извлеченных данных столбца. Это может привести к несообщаемым ошибкам данных или нарушениям памяти.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет выписку **SELECT** на столе Клиентов, чтобы вернуть набор идентиверий клиентов, имен и телефонных номеров, отсортированных по имени. Затем он вызывает **S'LBindCol,** чтобы связать столбцы данных с локальными буферами. Наконец, приложение получает каждый ряд данных с **помощью S'LFetch** и печатает имя, идентификатор и номер телефона каждого клиента.  
  
 Для получения более поздних примеров [SQLColumns Function](../../../odbc/reference/syntax/sqlcolumns-function.md)кода, [SQLSetPos Function](../../../odbc/reference/syntax/sqlsetpos-function.md)см. [SQLFetchScroll Function](../../../odbc/reference/syntax/sqlfetchscroll-function.md) [SQLBulkOperations Function](../../../odbc/reference/syntax/sqlbulkoperations-function.md)  
  
```cpp  
// SQLBindCol_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <stdio.h>  
  
#define UNICODE  
#include <sqlext.h>  
  
#define NAME_LEN 50  
#define PHONE_LEN 60
  
void show_error() {  
   printf("error\n");  
}  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt = 0;  
   SQLRETURN retcode;  
   SQLWCHAR szName[NAME_LEN], szPhone[PHONE_LEN], sCustID[NAME_LEN];  
   SQLLEN cbName = 0, cbCustID = 0, cbPhone = 0;  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);  
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLWCHAR*) L"NorthWind", SQL_NTS, (SQLWCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {   
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               retcode = SQLExecDirect(hstmt, (SQLWCHAR *) L"SELECT CustomerID, ContactName, Phone FROM CUSTOMERS ORDER BY 2, 1, 3", SQL_NTS);  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
  
                  // Bind columns 1, 2, and 3  
                  retcode = SQLBindCol(hstmt, 1, SQL_C_WCHAR, &sCustID, 100, &cbCustID);  
                  retcode = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szName, NAME_LEN, &cbName);  
                  retcode = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szPhone, PHONE_LEN, &cbPhone);   
  
                  // Fetch and print each row of data. On an error, display a message and exit.  
                  for (int i=0 ; ; i++) {  
                     retcode = SQLFetch(hstmt);  
                     if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO)  
                        show_error();  
                     if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
                     {
                        //replace wprintf with printf
                        //%S with %ls
                        //warning C4477: 'wprintf' : format string '%S' requires an argument of type 'char *'
                        //but variadic argument 2 has type 'SQLWCHAR *'
                        //wprintf(L"%d: %S %S %S\n", i + 1, sCustID, szName, szPhone);  
                        printf("%d: %ls %ls %ls\n", i + 1, sCustID, szName, szPhone);  
                    }    
                     else  
                        break;  
                  }  
               }  
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLCancel(hstmt);  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
 Также [см.](../../../odbc/reference/sample-odbc-program.md)  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возвращение информации о столбце в наборе результатов|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение нескольких строк данных|[Функция S'LFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Освобождение буферов столбца на отчете|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Получение части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращение числа столбцов набора результатов|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
