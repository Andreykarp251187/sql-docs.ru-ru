---
title: Функция S'LSetDescfield (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetDescField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetDescField
helpviewer_keywords:
- SQLSetDescField function [ODBC]
ms.assetid: 8c544388-fe9d-4f94-a0ac-fa0b9c9c88a5
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 122d4b26d1d75811d4a8e252378ce8f81ca2c66b
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81299554"
---
# <a name="sqlsetdescfield-function"></a>Функция SQLSetDescField

**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **SLSetDescField** устанавливает значение одного поля дескриптора.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
SQLRETURN SQLSetDescField(  
     SQLHDESC      DescriptorHandle,  
     SQLSMALLINT   RecNumber,  
     SQLSMALLINT   FieldIdentifier,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    BufferLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *DescriptorHandle*  
 (Вход) Ручка дескриптора.  
  
 *RecNumber*  
 (Вход) Указывает запись дескриптора, содержащую поле, которое приложение стремится установить. Записи дескриптора пронумероированы от 0, при этом запись закладки является рекордным номером. Аргумент *RecNumber* игнорируется для полей заголовка.  
  
 *FieldIdentifier*  
 (Вход) Указывает поле дескриптора, значение которого должно быть установлено. Подробнее об этом читайте в разделе "Аргументы полевых*идентификатора".*  
  
 *ValuePtr*  
 (Вход) Указатель на буфер, содержащий информацию о дескрипторе, или значение рядов. Тип данных зависит от значения *FieldIdentifier.* Если *ValuePtr* является целым значением, то он может рассматриваться как 8 байтов (S'LLEN), 4 байта (S'SLINTEGER) или 2 байта (S'LSMALLINT), в зависимости от значения аргумента *FieldIdentifier.*  
  
 *BufferLength*  
 (Вход) Если *FieldIdentifier* является полем, определяемым ODBC, а *ValuePtr* указывает на строку символов или бинарный буфер, этот аргумент должен быть длиной*valuePtr.* Для данных строки символов этот аргумент должен содержать количество байтов в строке.  
  
 Если *FieldIdentifier* является полем, определяемым ODBC, а *ValuePtr* — неопределенным, *то BufferLength* игнорируется.  
  
 Если *FieldIdentifier* является полем, определяемым драйвером, приложение указывает на характер поля менеджеру драйвера, установив аргумент *BufferLength.* *BufferLength* может иметь следующие значения:  
  
-   Если *ValuePtr* является указателем на строку персонажа, то *BufferLength* — это длина строки или SQL_NTS.  
  
-   Если *ValuePtr* является указателем на двоичный буфер, то приложение помещает результат SQL_LEN_BINARY_ATTR *(длина)* макроса в *BufferLength.* Это ставит отрицательное значение в *BufferLength*.  
  
-   Если *ValuePtr* является указателем на значение, кроме строки символов или двоичной строки, то *BufferLength* должен иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение с фиксированной длиной, то *BufferLength* — это либо SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT, либо SQL_IS_USMALLINT по мере необходимости.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LSetDesccField** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE может быть получено, позвонив по **телефону S'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_DESC и *ручки* *DescriptorHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LSetDescField,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Изменение значения опциона|Драйвер не поддерживал значение, указанное в * \*ValuePtr* (если *ValuePtr* был указателем) или значение в *ValuePtr* (если *ValuePtr* был значением integer), или * \*ValuePtr* был недействительным из-за условий выполнения, поэтому драйвер заменил аналогичное значение. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07009|Недействительный индекс дескриптора|Аргумент *FieldIdentifier* был рекордным полем, аргумент *RecNumber* — 0, а аргумент *DescriptorHandle* — к ручке IPD.<br /><br /> Аргумент *RecNumber* был меньше, чем 0, и *аргумент DescriptorHandle* сослался на ARD или APD.<br /><br /> Аргумент *RecNumber* был больше, чем максимальное количество столбцов или параметров, которые может поддерживать источник данных, а аргумент *DescriptorHandle,* относящееся к APD или ARD.<br /><br /> (DM) Аргумент *FieldIdentifier* был SQL_DESC_COUNT, а * \*аргумент ValuePtr* был меньше 0.<br /><br /> Аргумент *RecNumber* был равен 0, а аргумент *DescriptorHandle* сослался на косвенно выделенный APD. (Эта ошибка не возникает с явно выделенным дескриптором приложения, поскольку неизвестно, является ли явно выделенный дескриптор приложения APD или ARD до времени выполнения.)|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|22001|Строковые данные, правые усеченные|Аргумент *FieldIdentifier* был SQL_DESC_NAME, а аргумент *BufferLength* был значением больше, чем SQL_MAX_IDENTIFIER_LEN.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) *DescriptorHandle* был связан с *statementHandle,* для которого была вызвана асинхронно исполнительная функция (не эта) и все еще исполнялась, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle,* с которым *DescriptorHandle* был связан и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *DescriptorHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LSetDescField.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для одной из дескрипторов оператора, связанных с *DescriptorHandle* и возвращенных SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY016|Не удается изменить дескриптор строки реализации|Аргумент *DescriptorHandle* был связан с IRD, и аргумент *FieldIdentifier* не был SQL_DESC_ARRAY_STATUS_PTR или SQL_DESC_ROWS_PROCESSED_PTR.|  
|HY021|Несогласованная информация о дескрипторе|SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE поля не образуют допустимого типа ODBC S-L или действительного типа S'L, конкретного драйвера (для IPD) или действительного типа ODBC C (для APD или ARD).<br /><br /> Информация о дескрипторах, проверенная во время проверки согласованности, не соответствовала. (См. "Проверка согласованности" в **S'LSetDescRec**.)|  
|HY090|Недействительная длина строки или буфера|(DM) * \*ValuePtr* является строкой символов, и *BufferLength* был меньше нуля, но не был равен SQL_NTS.<br /><br /> (DM) Драйвер был драйвером ODBC 2 *.x,* дескриптор был ARD, аргумент *ColumnNumber* был установлен на 0, а значение, указанное для аргумента *BufferLength,* не было равно 4.|  
|HY091|Идентификатор полей недействительных дескрипторов|Значение, указанное для аргумента *FieldIdentifier,* не является полем, определяемым ODBC, и не является значением, определяемым реализацией.<br /><br /> Аргумент *FieldIdentifier* был недействительным для аргумента *DescriptorHandle.*<br /><br /> Аргумент *FieldIdentifier* был только для чтения, ОДБК-определенных полей.|  
|HY092|Недействительный идентификатор атрибута/опциона|Значение в * \*ValuePtr* не было действительным для аргумента *FieldIdentifier.*<br /><br /> Аргумент *FieldIdentifier* был SQL_DESC_UNNAMED, и *ValuePtr* был SQL_NAMED.|  
|HY105|Недействительный тип параметра|(DM) Значение, указанное для поля SQL_DESC_PARAMETER_TYPE, является недействительным. (Для получения дополнительной информации, см.*InputOutputType* **SQLBindParameter**|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/what-s-new-in-odbc-3-8.md)|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *DescriptorHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение может вызвать **S'LSetDescField,** чтобы установить любое поле дескриптора по одному. Один звонок в **S'LSetDescField** устанавливает одно поле в одном дескрипторе. Эта функция может быть вызвана для установки любого поля в любом типе дескриптора, при условии, что поле может быть установлено. (См. таблицу позже в этом разделе.)  
  
> [!NOTE]  
>  Если вызов в **S'LSetDescField** не удается, содержание записи дескриптора, идентифицированной аргументом *RecNumber,* не определено.  
  
 Другие функции можно вызвать для установки нескольких полей дескриптора с одним вызовом функции. Функция **S'LSetDescRec** устанавливает различные поля, влияющие на тип данных и буфер, связанные с столбцом или параметром (SQL_DESC_TYPE, SQL_DESC_DATETIME_INTERVAL_CODE, SQL_DESC_OCTET_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE, SQL_DESC_DATA_PTR, SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR поля). **Для** выполнения полной спецификации для привязки столбца или параметра **можно** использовать полную спецификацию для привязки столбца или параметра. Эти функции устанавливают определенную группу полей дескриптора с одним вызовом функции.  
  
 Можно вызвать **sLSetDescField** для изменения обязательных буферов, добавив смещение в указатели связывания (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR или SQL_DESC_OCTET_LENGTH_PTR). Это изменяет обязательные буферы, не вызывая **S'LBindCol** или **S'LBindParameter**, что позволяет приложению изменять SQL_DESC_DATA_PTR без изменения других полей, таких как SQL_DESC_DATA_TYPE.  
  
 Если приложение вызывает **S'LSetDesccField,** чтобы установить любое поле, кроме SQL_DESC_COUNT или отложенных полей SQL_DESC_DATA_PTR, SQL_DESC_OCTET_LENGTH_PTR или SQL_DESC_INDICATOR_PTR, запись становится несвязанной.  
  
 Поля заголовка дескриптора устанавливаются по телефону **S'LSetDescField** с соответствующим *полем.* Многие поля заголовка также являются атрибутами оператора, поэтому они также могут быть установлены путем вызова в **S'LSetStmtAttr.** Это позволяет приложениям устанавливать поле дескриптора без предварительного получения ручки дескриптора. Когда **sLSetDescField** вызывается для установки поля заголовка, аргумент *RecNumber* игнорируется.  
  
 *RecNumber* 0 используется для установки полей закладок.  
  
> [!NOTE]  
>  Атрибут оператора SQL_ATTR_USE_BOOKMARKS всегда должен быть установлен перед вызовом **S'LSetDesccField** для установки полей закладок. Хотя это не является обязательным, настоятельно рекомендуется.  
  
## <a name="sequence-of-setting-descriptor-fields"></a>Последовательность настройки полей дескриптора  
 При настройке полей дескриптора, позвонив по **S'LSetDescField,** приложение должно следовать определенной последовательности:  
  
1.  Приложение должно сначала установить поле SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE или SQL_DESC_DATETIME_INTERVAL_CODE.  
  
2.  После установки одного из этих полей приложение может установить атрибут типа данных, а драйвер устанавливает поля атрибута типа данных с соответствующими значениями по умолчанию для типа данных. Автоматическое по умолчанию полей атрибута типа гарантирует, что дескриптор всегда готов к использованию после того, как приложение учтет тип данных. Если приложение явно устанавливает атрибут типа данных, оно переопределяет атрибут по умолчанию.  
  
3.  После установки одного из полей, перечисленных в шаге 1, и атрибутов типа данных, приложение может установить SQL_DESC_DATA_PTR. Это подсказывает проверку согласованности полей дескриптора. Если приложение изменяет тип данных или атрибуты после установки SQL_DESC_DATA_PTR поля, драйвер устанавливает SQL_DESC_DATA_PTR на нулевую указку, не связывающую запись. Это заставляет приложение выполнять правильные шаги последовательно, прежде чем запись дескриптора может быть пригоденк.  
  
## <a name="initialization-of-descriptor-fields"></a>Инициализация полей дескриптора  
 При выделении дескриптора поля в дескрипторе могут быть инициализированы к значению по умолчанию, инициализированы без значения по умолчанию или не определены для типа дескриптора. В следующих таблицах указывается инициализация каждого поля для каждого типа дескриптора, при этом "D" указывает, что поле инициализировано по умолчанию, и "ND", указывающий на то, что поле инициализировано без дефолта. Если число отображается, значение поля по умолчанию — это число. Таблицы также указывают, читается ли поле/пишется (R/W) или только для чтения (R).  
  
 Поля IRD имеют значение по умолчанию только после того, как заявление было подготовлено или выполнено и IRD было заселено, а не при выделении ручки оператора или дескриптора. До тех пор, пока IRD не будет заселен, любая попытка получить доступ к полю IRD вернет ошибку.  
  
 Некоторые поля дескриптора определены для одного или нескольких, но не для всех типов дескрипторов (ARD и IRD, и APD и IPDs). Когда поле не определено для типа дескриптора, оно не требуется ни одной из функций, которые используют этот дескриптор.  
  
 Поля, к которым можно получить доступ по **s'LGetDescField,** не обязательно могут быть установлены **S'LSetDescField.** Поля, которые могут быть установлены **S'LSetDescField,** перечислены в следующих таблицах.  
  
 Инициализация полей заголовка изложена в следующей таблице.  
  
|Название поля заголовка|Тип|Чтение-запись|Значение по умолчанию|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_ALLOC_TYPE|SQLSMALLINT|ARD: R APD: R IRD: R IPD: R|ARD: SQL_DESC_ALLOC_AUTO для неявных или SQL_DESC_ALLOC_USER для явных<br /><br /> APD: SQL_DESC_ALLOC_AUTO для неявных или SQL_DESC_ALLOC_USER для явных<br /><br /> IRD: SQL_DESC_ALLOC_AUTO<br /><br /> IPD: SQL_DESC_ALLOC_AUTO|  
|SQL_DESC_ARRAY_SIZE|SQLULEN|ARD: R/W APD: R/W IRD: Неиспользованная IPD: Неиспользованные|ARD: «1» APD: IRD: Неиспользованные IPD: Неиспользованные|  
|SQL_DESC_ARRAY_STATUS_PTR|СЛЮМЛМИТ|ARD: R/W APD: R/W IRD: R/W IPD: R/W|ARD: Null ptr APD: Null ptr IRD: Null ptr IPD: Null ptr|  
|SQL_DESC_BIND_OFFSET_PTR|СКЛЛЕН|ARD: R/W APD: R/W IRD: Неиспользованная IPD: Неиспользованные|ARD: Null ptr APD: Null ptr IRD: Неиспользованные IPD: Неиспользованные|  
|SQL_DESC_BIND_TYPE|SQLINTEGER|ARD: R/W APD: R/W IRD: Неиспользованная IPD: Неиспользованные|ARD: SQL_BIND_BY_COLUMN<br /><br /> APD: SQL_BIND_BY_COLUMN<br /><br /> IRD: Неиспользованные<br /><br /> IPD: Неиспользованные|  
|SQL_DESC_COUNT|SQLSMALLINT|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: 0 APD: 0 IRD: D IPD: 0|  
|SQL_DESC_ROWS_PROCESSED_PTR|SQLULEN|ARD: Неиспользованные APD: Неиспользованные IRD: R / W IPD: R / W|ARD: Неиспользованные APD: Неиспользованные IRD: Null ptr IPD: Null ptr|  
  
 Эти поля определяются только тогда, когда IPD автоматически заселяется водителем. Если нет, то они не определены. Если приложение попытается установить эти поля, будет возвращена система S'LSTATE HY091 (идентификатор полей недействительных дескрипторов).  
  
 Инициализация полей записей показана в следующей таблице.  
  
|Имя поля записи|Тип|Чтение-запись|Значение по умолчанию|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_AUTO_UNIQUE_VALUE|SQLINTEGER|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_BASE_COLUMN_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_BASE_TABLE_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_CASE_SENSITIVE|SQLINTEGER|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: D|  
|SQL_DESC_CATALOG_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_CONCISE_TYPE|SQLSMALLINT|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: SQL_C_ DEFAULT APD: SQL_C_ DEFAULT IRD: D IPD: ND|  
|SQL_DESC_DATA_PTR|СЗЛПУКЕР|ARD: R/W APD: R/W IRD: Неиспользованная IPD: Неиспользованные|ARD: Null ptr APD: Null ptr IRD: Неиспользованные IPD: Неиспользованные|  
|SQL_DESC_DATETIME_INTERVAL_CODE|SQLSMALLINT|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_DATETIME_INTERVAL_PRECISION|SQLINTEGER|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_DISPLAY_SIZE|КСЛЛЕН|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_FIXED_PREC_SCALE|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: D|  
|SQL_DESC_INDICATOR_PTR|КСЛЛЕН|ARD: R/W APD: R/W IRD: Неиспользованная IPD: Неиспользованные|ARD: Null ptr APD: Null ptr IRD: Неиспользованные IPD: Неиспользованные|  
|SQL_DESC_LABEL|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_LENGTH|SQLULEN|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_LITERAL_PREFIX|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_LITERAL_SUFFIX|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_LOCAL_TYPE_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: D|  
|SQL_DESC_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R / W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_NULLABLE|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_NUM_PREC_RADIX|SQLINTEGER|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_OCTET_LENGTH|КСЛЛЕН|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_OCTET_LENGTH_PTR|КСЛЛЕН|ARD: R/W APD: R/W IRD: Неиспользованная IPD: Неиспользованные|ARD: Null ptr APD: Null ptr IRD: Неиспользованные IPD: Неиспользованные|  
|SQL_DESC_PARAMETER_TYPE|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: Неиспользованные IPD: R / W|ARD: Неиспользованные APD: Неиспользованные IRD: Неиспользованные IPD: D'SQL_PARAM_INPUT|  
|SQL_DESC_PRECISION|SQLSMALLINT|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_ROWVER|SQLSMALLINT|ARD: Неиспользованные<br /><br /> APD: Неиспользованные<br /><br /> IRD: R<br /><br /> IPD: R|ARD: Неиспользованные<br /><br /> APD: Неиспользованные<br /><br /> IRD: ND<br /><br /> IPD: ND|  
|SQL_DESC_SCALE|SQLSMALLINT|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_SCHEMA_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_SEARCHABLE|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_TABLE_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
|SQL_DESC_TYPE|SQLSMALLINT|ARD: R/W APD: R/W IRD: R IPD: R/W|ARD: SQL_C_DEFAULT APD: SQL_C_DEFAULT IRD: D IPD: ND|  
|SQL_DESC_TYPE_NAME|СЗЛЧАР|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: D|  
|SQL_DESC_UNNAMED|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R / W|ARD: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_UNSIGNED|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: R|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: D|  
|SQL_DESC_UPDATABLE|SQLSMALLINT|ARD: Неиспользованные APD: Неиспользованные IRD: R IPD: Неиспользованные|ARD: Неиспользованные APD: Неиспользованные IRD: D IPD: Неиспользованные|  
  
 Эти поля определяются только тогда, когда IPD автоматически заселяется водителем. Если нет, то они не определены. Если приложение попытается установить эти поля, будет возвращена система S'LSTATE HY091 (идентификатор полей недействительных дескрипторов).  
  
 Поле SQL_DESC_DATA_PTR в IPD может быть установлено, чтобы заставить проверку согласованности. При последующем вызове на **s'LGetDescfield** или **S'LGetDescRec**драйвер не обязан возвращать значение, которое было установлено SQL_DESC_DATA_PTR.  
  
## <a name="fieldidentifier-argument"></a>Полеики Аргумент  
 Аргумент *FieldIdentifier* указывает на поле дескриптора, который должен быть установлен. Дескриптор содержит *заголовок дескриптора,* состоящий из полей заголовка, описанных в следующем разделе, "Заголовки полей", и ноль или более *дескрипторных записей,* состоящий из полей записи, описанных в разделе после раздела "Заголовки полей".  
  
## <a name="header-fields"></a>Заголовок поля  
 Каждый дескриптор имеет заголовок, состоящий из следующих полей:  
  
 **SQL_DESC_ALLOC_TYPE (все)**  
 В этом поле заголовка для чтения только для чтения S'LSMALLSMALLINT указывается, был ли дескриптор автоматически выделен водителем или явно приложением. Приложение может получить, но не изменить это поле. Поле устанавливается для SQL_DESC_ALLOC_AUTO водителем, если дескриптор был автоматически выделен водителем. Он устанавливается для SQL_DESC_ALLOC_USER водителем, если дескриптор был явно выделен приложением.  
  
 **SQL_DESC_ARRAY_SIZE «Дескрипторы приложений»**  
 В ARD- иноугольном поле s'LULEN определяет количество строк в строке. Это число строк, которые должны быть возвращены по вызову в **S'LFetch** или **S'LFetchScroll** или для работы по вызову в **S'LBulkOperations** или **S'LSetPos.**  
  
 В APD- иайкнется это поле заголовка S'LULEN определяет количество значений для каждого параметра.  
  
 Значение этого поля по умолчанию составляет 1. Если SQL_DESC_ARRAY_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR APD или ARD указывают на массивы. Кардинальность каждого массива равна значению этого поля.  
  
 Это поле в ARD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_ROW_ARRAY_SIZE атрибутом. Это поле в APD также можно установить, позвонив по **s'LSetStmtAttr** с SQL_ATTR_PARAMSET_SIZE атрибутом.  
  
 **SQL_DESC_ARRAY_STATUS_PTR (все)**  
 Для каждого типа дескриптора, это поле заголовка S'LUSMALLINT указывает на массив значений S'LUSMALLINT. Эти массивы названы следующим образом: массив статуса строки (IRD), массив статуса параметров (IPD), массив операции строки (ARD) и массив операции параметра (APD).  
  
 В IRD это поле заголовка указывает на массив статуса строки, содержащий значения статуса после вызова в **S'LBulkOperations,** **S'LFetch,** **S'LFetchScroll**, или **S'LSetPos.** Массив имеет столько элементов, сколько рядов в строке. Приложение должно выделить массив S'LUSMALLINTs и установить это поле, чтобы указать на массив. Поле устанавливается на нулевую указку по умолчанию. Водитель заселяет массив - если поле SQL_DESC_ARRAY_STATUS_PTR не установлено на нулевую точку, и в этом случае значения статуса не генерируются и массив не заселен.  
  
> [!CAUTION]  
>  Поведение драйвера не определено, если приложение устанавливает элементы массива состояния строки, на которые указывает SQL_DESC_ARRAY_STATUS_PTR поле IRD.  
  
 Массив изначально населен вызовом в **S'LBulkOperations,** **S'LFetch,** **S'LFetchScroll**, или **S'LSetPos**. Если вызов не вернулся SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на который указывает это поле, не определено. Элементы массива могут содержать следующие значения:  
  
-   SQL_ROW_SUCCESS: Строка была успешно извлечена и не изменилась с момента последнего.  
  
-   SQL_ROW_SUCCESS_WITH_INFO: Строка была успешно извлечена и не изменилась с момента последнего. Тем не менее, предупреждение было возвращено о строке.  
  
-   SQL_ROW_ERROR: Ошибка произошла при извлечении строки.  
  
-   SQL_ROW_UPDATED: Строка была успешно извлечена и была обновлена с момента последнего извлечения. Если строка снова извлечена, ее статус SQL_ROW_SUCCESS.  
  
-   SQL_ROW_DELETED: Строка была удалена с момента последнего извлечения.  
  
-   SQL_ROW_ADDED: Строка была вставлена **s'LBulkOperations**. Если строка снова извлечена, ее статус SQL_ROW_SUCCESS.  
  
-   SQL_ROW_NOROW: строка перекрывает конец набора результатов, и не было возвращено строки, соответствующей этому элементу массива состояния строки.  
  
 Это поле в IRD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_ROW_STATUS_PTR атрибутом.  
  
 Поле SQL_DESC_ARRAY_STATUS_PTR IRD действителен только после SQL_SUCCESS или SQL_SUCCESS_WITH_INFO. Если код возврата не является одним из них, месторасположение, на который указывает SQL_DESC_ROWS_PROCESSED_PTR, не определено.  
  
 В IPD это поле заголовка указывает на массив статуса параметров, содержащий информацию о состоянии для каждого набора значений параметров после вызова в **S'LExecute** или **S'LExecDirect.** Если вызов в **S'LExecute** или **S'LExecDirect** не вернулся SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на который указывает это поле, не определено. Приложение должно выделить массив S'LUSMALLINTs и установить это поле, чтобы указать на массив. Водитель заселяет массив - если поле SQL_DESC_ARRAY_STATUS_PTR не установлено на нулевую точку, и в этом случае значения статуса не генерируются и массив не заселен. Элементы массива могут содержать следующие значения:  
  
-   SQL_PARAM_SUCCESS: Для этого набора параметров была успешно выполнена выписка по S'L.  
  
-   SQL_PARAM_SUCCESS_WITH_INFO: Заявление S'L было успешно выполнено для этого набора параметров; однако в структуре диагностических данных имеется предупреждающая информация.  
  
-   SQL_PARAM_ERROR: При обработке этого набора параметров произошла ошибка. Дополнительная информация об ошибках доступна в структуре данных диагностики.  
  
-   SQL_PARAM_UNUSED: Этот набор параметров был неиспользованным, возможно, из-за того, что некоторые предыдущие набор параметров вызвали ошибку, которая прервала дальнейшую обработку, или потому, что SQL_PARAM_IGNORE был установлен для этого набора параметров в массиве, указанном SQL_DESC_ARRAY_STATUS_PTR поле APD.  
  
-   SQL_PARAM_DIAG_UNAVAILABLE: Диагностическая информация недоступна. Примером этого является, когда драйвер рассматривает массивы параметров как монолитную единицу и поэтому не генерирует данный уровень информации об ошибках.  
  
 Это поле в IPD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_PARAM_STATUS_PTR атрибутом.  
  
 В ARD это поле заголовка указывает на массив операций строки значений, которые могут быть установлены приложением, чтобы указать, следует ли игнорировать эту строку для операций **S'LSetPos.** Элементы массива могут содержать следующие значения:  
  
-   SQL_ROW_PROCEED: Строка включена в объемную операцию с использованием **S'LSetPos.** (Эта настройка не гарантирует, что операция будет происходить на строке. Если строка имеет статус SQL_ROW_ERROR в массиве состояния iRD строки, драйвер может быть не в состоянии выполнить операцию в строке.)  
  
-   SQL_ROW_IGNORE: Строка исключается из основной операции с помощью **S'LSetPos.**  
  
 Если элементы массива не установлены, все строки включены в основную операцию. Если значение в SQL_DESC_ARRAY_STATUS_PTR поле ARD является нулевой указателем, все строки включены в объемную операцию; интерпретация такая же, как если бы указатель указал на допустимый массив, и все элементы массива были SQL_ROW_PROCEED. Если элемент в массиве установлен на SQL_ROW_IGNORE, значение в массиве состояния строки для проигнорированного строки не изменяется.  
  
 Это поле в ARD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_ROW_OPERATION_PTR атрибутом.  
  
 В APD это поле заголовка указывает на массив операций параметров значений, которые могут быть установлены приложением, чтобы указать, следует ли игнорировать этот набор параметров при вызове **S'LExecute** или **S'LExecDirect.** Элементы массива могут содержать следующие значения:  
  
-   SQL_PARAM_PROCEED: Набор параметров включен в колл **s'LExecute** или **S'LExecDirect.**  
  
-   SQL_PARAM_IGNORE: Набор параметров исключен из вызова **S'LExecute** или **S'LExecDirect.**  
  
 Если элементы массива не установлены, все наборы параметров в массиве используются в вызовах **S'LExecute** или **S'LExecDirect.** Если значение в SQL_DESC_ARRAY_STATUS_PTR поле APD является нулевой указателем, используются все наборы параметров; интерпретация такая же, как если бы указатель указал на допустимый массив, и все элементы массива были SQL_PARAM_PROCEED.  
  
 Это поле в APD также можно установить, позвонив по **s'LSetStmtAttr** с SQL_ATTR_PARAM_OPERATION_PTR атрибутом.  
  
 **SQL_DESC_BIND_OFFSET_PTR «Дескрипторы приложений»**  
 Это поле заголовка S'LLEN указывает на привязку смещения. Он установлен на нулевую указатель по умолчанию. Если это поле не является указателем на недействительных значениях, драйвер ссылается на указатель и добавляет декоранное значение к каждому из отложенных полей, которое имеет ненулевое значение в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) во время получения и использует новые значения указателя при связывании.  
  
 Привязка всегда добавляется непосредственно к значениям в SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR полях. Если смещение изменено на другое значение, новое значение по-прежнему добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется к значению поля плюс любое ранее смещение.  
  
 Это поле является *отложенным полем:* оно не используется в момент его установки, но используется в более позднее время драйвером, когда ему необходимо определить адреса буферов данных.  
  
 Это поле в ARD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_ROW_BIND_OFFSET_PTR атрибутом. Это поле в ARD также может быть установлено, позвонив в **s'LSetStmtAttr** с SQL_ATTR_PARAM_BIND_OFFSET_PTR атрибутом.  
  
 Для получения более подробной информации, см. описание связывания в области гребной связи в [S'LFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md) и [S'LBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md).  
  
 **SQL_DESC_BIND_TYPE «Дескрипторы приложений»**  
 Это поле заголовка S'LUINTEGER устанавливает обязательную ориентацию, которая будет использоваться для связывания столбцов или параметров.  
  
 В ARD-поле указывается обязательная ориентация, когда на ассоциированной ручке оператора вызывается **S'LFetchScroll** или **S'LFetch.**  
  
 Для выбора связывания столбцов для столбцов это поле настроено на SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Это поле в ARD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_ROW_BIND_TYPE *атрибутом.*  
  
 В APD это поле определяет связывающую ориентацию, которая будет использоваться для динамических параметров.  
  
 Для выбора связывания с характером столбца для параметров это поле настроено на SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Это поле в APD также может быть установлено, позвонив в **S'LSetStmtAttr** с SQL_ATTR_PARAM_BIND_TYPE *атрибутом.*  
  
 **SQL_DESC_COUNT (все)**  
 В этом поле заголовка S'LSMALLSMALLINT указан 1-й индекс самой высокой записи, содержащей данные. Когда драйвер устанавливает структуру данных для дескриптора, он должен также установить поле SQL_DESC_COUNT, чтобы показать, сколько записей является значительным. Когда приложение выделяет экземпляр этой структуры данных, оно не должно указывать, сколько записей для резервирования места для. По мере того как приложение определяет содержание записей, драйвер предпринимает все необходимые действия для обеспечения того, чтобы ручка дескриптора отсылала к структуре данных адекватного размера.  
  
 SQL_DESC_COUNT — это не подсчет всех столбцов данных, которые связаны (если поле находится в ARD) или всех параметров, которые связаны (если поле находится в APD), а число записей с самым высоким числом. Если столбец или параметр с самым высоким числом не связан, SQL_DESC_COUNT изменен на число следующего столбца или параметра с самым высоким числом. Если столбец или параметр с числом, которое меньше числа столбца с самым высоким числом, не связан (позвонив в **S'LBindCol** с аргументом *TargetValuePtr,* установленным на нулевую точку, или **S'LBindParameter** с аргументом *ParameterValuePtr,* установленным на нулевой указатель), SQL_DESC_COUNT не изменен. Если дополнительные столбцы или параметры связаны с числами, превышают данные с самым высоким числом, водитель автоматически увеличивает значение в поле SQL_DESC_COUNT. Если все столбцы не связаны, позвонив в **SQL_UNBIND** вариант, SQL_DESC_COUNT поля в ARD и IRD настроены до 0. Если **s'LFreeStmt** вызывается с SQL_RESET_PARAMS опцией, SQL_DESC_COUNT поля в APD и IPD настроены на 0.  
  
 Значение в SQL_DESC_COUNT может быть четко установлено приложением, позвонив по **s'LSetDescField.** Если значение в SQL_DESC_COUNT явно уменьшено, все записи с числами, превышающее новое значение в SQL_DESC_COUNT, эффективно удаляются. Если значение в SQL_DESC_COUNT явно установлено до 0, а поле находится в ARD, все буферы данных, за исключением связанного столбца закладок, освобождаются.  
  
 Количество записей в этой области ARD не включает в себя связанную колонку закладок. Единственный способ развязать столбец закладки — установить поле SQL_DESC_DATA_PTR на нулевую указку.  
  
 **SQL_DESC_ROWS_PROCESSED_PTR «Дескрипторы реализации»**  
 В IRD это поле \* заголовка S'LULEN указывает на буфер, содержащий количество строк, извлеченных после вызова в **S'LFetch** или **S'LFetchScroll,** или количество строк, затронутых в ходе основной операции, выполняемой вызовом в **S'LBulkOperations** или **S'LSetPos,** включая строки ошибок.  
  
 В IPD это поле заголовка S'LUINTEGER указывает на буфер, содержащий количество обработанных параметров, включая наборы ошибок. Номер не будет возвращен, если это нулевая указка.  
  
 SQL_DESC_ROWS_PROCESSED_PTR действителен только после того, как SQL_SUCCESS или SQL_SUCCESS_WITH_INFO был возвращен после звонка в **S'LFetch** или **S'LFetchScroll** (для поля IRD) или **S'LExecute,** **S'LExecDirect**, или **S'LParamData** (для поля IPD). Если вызов, заполняемый в буфере, на который указывает это поле, не возвращается SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено, если он не возвращается SQL_NO_DATA, и в этом случае значение в буфере установлено до 0.  
  
 Это поле в ARD также может быть установлено, позвонив в **s'LSetStmtAttr** с SQL_ATTR_ROWS_FETCHED_PTR атрибутом. Это поле в APD также можно установить, позвонив в **S'LSetStmtAttr** с SQL_ATTR_PARAMS_PROCESSED_PTR атрибутом.  
  
 Буфер, на который указывает это поле, выделяется приложением. Это отложенный буфер вывода, установленный драйвером. Он установлен на нулевую указатель по умолчанию.  
  
## <a name="record-fields"></a>Поле записи  
 Каждый дескриптор содержит одну или несколько записей, состоящих из полей, определяющих данные столбца или динамические параметры, в зависимости от типа дескриптора. Каждая запись представляет собой полное определение одного столбца или параметра.  
  
 **SQL_DESC_AUTO_UNIQUE_VALUE (IRDs)**  
 Это поле записи только для чтения S'LINTEGER содержит SQL_TRUE если столбец является столбцом автоматического приращения, или SQL_FALSE если столбец не является столбцом автоматического приращения. Это поле читается только для чтения, но базовый столбец автоматического приращения не обязательно читается только.  
  
 **SQL_DESC_BASE_COLUMN_NAME (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит название базовой колонки для столбца, установленного для результатов. Если имя базового столбца не существует (как в случае столбцов, которые являются выражениями), эта переменная содержит пустую строку.  
  
 **SQL_DESC_BASE_TABLE_NAME (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит базовое название таблицы для столбца набора результатов. Если имя базовой таблицы не может быть определено или не применимо, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CASE_SENSITIVE «Дескрипторы реализации»**  
 Это поле записи только для чтения S'LINTEGER содержит SQL_TRUE, если столбец или параметр рассматривается как чувствительный к случаям для сопоставления и сравнения, или SQL_FALSE, если столбец не рассматривается как чувствительный к случаям для сопоставления и сравнения или если он не характер столбец.  
  
 **SQL_DESC_CATALOG_NAME (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит каталог для базовой таблицы, содержащей столбец. Значение возврата зависит от драйвера, если столбец является выражением или если столбец является частью представления. Если источник данных не поддерживает каталоги или каталог не может быть определен, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CONCISE_TYPE (все)**  
 В этом поле заголовка S'LSMALLSMALLINT указан аклагаемый тип данных для всех типов данных, включая время даты и типы интервальных данных.  
  
 Значения в SQL_DESC_CONCISE_TYPE, SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE областях взаимозависимы. Каждый раз, когда одно из полей устанавливается, другое также должно быть установлено. SQL_DESC_CONCISE_TYPE может быть установлен озвоном в **S'LBindCol** или **S'LBindParameter**, или **S'LSetDescField**. SQL_DESC_TYPE может быть установлен по телефону в **S'LSetDescField** или **S'LSetDescRec.**  
  
 Если SQL_DESC_CONCISE_TYPE установлен на краткий тип данных, за исключением типа данных интервала или даты, поле SQL_DESC_TYPE настроено на то же значение, а поле SQL_DESC_DATETIME_INTERVAL_CODE настроено на 0.  
  
 Если SQL_DESC_CONCISE_TYPE установлен в наборе времени даты или типа данных интервала, поле SQL_DESC_TYPE устанавливается в соответствующем многословном типе (SQL_DATETIME или SQL_INTERVAL), а поле SQL_DESC_DATETIME_INTERVAL_CODE устанавливается в соответствующий подкод.  
  
 **SQL_DESC_DATA_PTR «Дескрипторы приложений и IPD»**  
 Это поле записи S'LPOINTER указывает на перемену, которая будет содержать значение параметра (для APD) или значение столбца (для ARD). Это поле является *отложенным полем.* Он не используется во время установки, но используется в более позднее время драйвером для получения данных.  
  
 Колонка, указанная SQL_DESC_DATA_PTR полеARD, не связана, если аргумент *TargetValuePtr* в вызове к **S'LBindCol** является нулевой указателем или если SQL_DESC_DATA_PTR поле в ARD устанавливается вызовом в **S'LSetDescField** или **S'LSetDescRec** к нулю указателя. Другие поля не затрагиваются, если SQL_DESC_DATA_PTR поле настроено на нулевую точку.  
  
 Если вызов на **S'LFetch** или **S'LFetchScroll,** который заполняет буфер, на который указывает это поле, не вернулся SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.  
  
 Всякий раз, когда устанавливается SQL_DESC_DATA_PTR поле APD, ARD или IPD, драйвер проверяет, что значение в поле SQL_DESC_TYPE содержит один из допустимых типов данных ODBC C или тип данных, специфичные для драйвера, и что все другие поля, влияющие на типы данных, являются последовательными. Побуждение проверки согласованности является единственным использованием SQL_DESC_DATA_PTR поле IPD. В частности, если приложение устанавливает SQL_DESC_DATA_PTR поле IPD, а затем вызывает **S'LGetDescField** на этом поле, это не обязательно возвращается значение, которое оно установило. Для получения дополнительной информации, см. [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)  
  
 **SQL_DESC_DATETIME_INTERVAL_CODE (все)**  
 Это поле записи S'LSMALLSMALLINT содержит подкод для конкретного типа данных даты или интервала, когда поле SQL_DESC_TYPE SQL_DATETIME или SQL_INTERVAL. Это относится как к типам данных S'L, так и к C. Код состоит из имени типа данных с "CODE" заменяется либо "TYPE" или "C_TYPE" (для типов дат) или "CODE" заменяется "INTERVAL" или "C_INTERVAL" (для типов интервалов).  
  
 Если SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE в дескрипторе приложения настроены на SQL_C_DEFAULT и дескриптор не связан с ручкой оператора, содержимое SQL_DESC_DATETIME_INTERVAL_CODE не определено.  
  
 Это поле может быть установлено для типов данных о дате, перечисленных в следующей таблице.  
  
|Типы дат времени|DATETIME_INTERVAL_CODE|  
|--------------------|------------------------------|  
|SQL_TYPE_DATE/SQL_C_TYPE_DATE|SQL_CODE_DATE|  
|SQL_TYPE_TIME/SQL_C_TYPE_TIME|SQL_CODE_TIME|  
|SQL_TYPE_TIMESTAMP/SQL_C_TYPE_TIMESTAMP|SQL_CODE_TIMESTAMP|  
  
 Это поле может быть установлено для типов данных интервала, перечисленных в следующей таблице.  
  
|Тип интервала|DATETIME_INTERVAL_CODE|  
|-------------------|------------------------------|  
|SQL_INTERVAL_DAY/SQL_C_INTERVAL_DAY|SQL_CODE_DAY|  
|SQL_INTERVAL_DAY_TO_HOUR/SQL_C_INTERVAL_DAY_TO_HOUR|SQL_CODE_DAY_TO_HOUR|  
|SQL_INTERVAL_DAY_TO_MINUTE/SQL_C_INTERVAL_DAY_TO_MINUTE|SQL_CODE_DAY_TO_MINUTE|  
|SQL_INTERVAL_DAY_TO_SECOND/SQL_C_INTERVAL_DAY_TO_SECOND|SQL_CODE_DAY_TO_SECOND|  
|SQL_INTERVAL_HOUR/SQL_C_INTERVAL_HOUR|SQL_CODE_HOUR|  
|SQL_INTERVAL_HOUR_TO_MINUTE/SQL_C_INTERVAL_HOUR_TO_MINUTE|SQL_CODE_HOUR_TO_MINUTE|  
|SQL_INTERVAL_HOUR_TO_SECOND/SQL_C_INTERVAL_HOUR_TO_SECOND|SQL_CODE_HOUR_TO_SECOND|  
|SQL_INTERVAL_MINUTE/SQL_C_INTERVAL_MINUTE|SQL_CODE_MINUTE|  
|SQL_INTERVAL_MINUTE_TO_SECOND/SQL_C_INTERVAL_MINUTE_TO_SECOND|SQL_CODE_MINUTE_TO_SECOND|  
|SQL_INTERVAL_MONTH/SQL_C_INTERVAL_MONTH|SQL_CODE_MONTH|  
|SQL_INTERVAL_SECOND/SQL_C_INTERVAL_SECOND|SQL_CODE_SECOND|  
|SQL_INTERVAL_YEAR/SQL_C_INTERVAL_YEAR|SQL_CODE_YEAR|  
|SQL_INTERVAL_YEAR_TO_MONTH/SQL_C_INTERVAL_YEAR_TO_MONTH|SQL_CODE_YEAR_TO_MONTH|  
  
 Для получения дополнительной информации о интервалах [Data Type Identifiers and Descriptors](../../../odbc/reference/appendixes/data-type-identifiers-and-descriptors.md)данных и этом поле см.  
  
 **SQL_DESC_DATETIME_INTERVAL_PRECISION (все)**  
 Это поле записи S'LINTEGER содержит точность интервального ведущего, если SQL_DESC_TYPE поле SQL_INTERVAL. Когда поле SQL_DESC_DATETIME_INTERVAL_CODE настроено на тип данных интервала, это поле устанавливается на точность выполнения интервала по умолчанию.  
  
 **SQL_DESC_DISPLAY_SIZE (IRDs)**  
 Это поле записи только для чтения S'LINTEGER содержит максимальное количество символов, необходимых для отображения данных из столбца.  
  
 **SQL_DESC_FIXED_PREC_SCALE «Дескрипторы реализации»**  
 Это поле записи только для чтения S'LSMALLSMALLINT установлено для SQL_TRUE, если столбец является точным числовым столбцом и имеет фиксированную точность и ненулевой масштаб, или SQL_FALSE, если столбец не является точной числовой колонкой с фиксированной точностью и масштабом.  
  
 **SQL_DESC_INDICATOR_PTR «Дескрипторы приложений»**  
 В ARD, это S'LLEN - запись поля указывает на переменную индикатора. Эта переменная содержит SQL_NULL_DATA, если значение столбца является NULL. Для APD переменная индикатора установлена для SQL_NULL_DATA для указания динамических аргументов NULL. В противном случае переменная равна нулю (если только значения в SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR не являются одинаковыми указателями).  
  
 Если SQL_DESC_INDICATOR_PTR поле в ARD является нулевой указатель, водитель не может вернуть информацию о том, является ли столбец null или нет. Если столбец является NULL, а SQL_DESC_INDICATOR_PTR является нулевой указателем, S'LSTATE 22002 (индикатор переменной требуется, но не поставляется) возвращается, когда водитель пытается заполнить буфер после вызова в **S'LFetch** или **S'LFetchScroll**. Если вызов в **S'LFetch** или **S'LFetchScroll** не вернулся SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.  
  
 Поле SQL_DESC_INDICATOR_PTR определяет, устанавливается ли поле, на SQL_DESC_OCTET_LENGTH_PTR. Если значение данных для столбца null, драйвер устанавливает переменную индикатора для SQL_NULL_DATA. Поле, на SQL_DESC_OCTET_LENGTH_PTR, не устанавливается. Если значение NULL не встречается во время извлечения, буфер, на который указывает SQL_DESC_INDICATOR_PTR, установлен до нуля, а буфер, на который указывает SQL_DESC_OCTET_LENGTH_PTR, устанавливается на длину данных.  
  
 Если SQL_DESC_INDICATOR_PTR поле в APD является нулевой указателем, приложение не может использовать эту запись дескриптора для указания аргументов NULL.  
  
 Это поле является *отложенным полем:* оно не используется в момент его установки, но используется в более позднее время драйвером для указания nullability (для ARD) или для определения необоснованности (для APDs).  
  
 **SQL_DESC_LABEL (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит метку столбца или название. Если столбец не имеет метки, эта переменная содержит имя столбца. Если столбец неназван и не помечен, эта переменная содержит пустую строку.  
  
 **SQL_DESC_LENGTH (все)**  
 Это поле записи S'LULEN является либо максимальной, либо фактической длиной строки символов в символах, либо типом двоичных данных в байтах. Это максимальная длина для типа данных с фиксированной длиной или фактическая длина для типа данных с переменной длиной. Его значение всегда исключает символ нулевого прекращения, который завершает строку символа. Для значений, тип которых SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP или один из типов интервальных данных S'L, это поле имеет длину в символах строки символа представления значения времени даты или интервала.  
  
 Значение в этой области может отличаться от значения для "длины", как это определено в ODBC 2 *.x*. Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-d-data-types.md)  
  
 **SQL_DESC_LITERAL_PREFIX (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит символ или символы, которые драйвер распознает в качестве приставки для буквального типа данных. Эта переменная содержит пустую строку для типа данных, для которой буквальная приставка не применима.  
  
 **SQL_DESC_LITERAL_SUFFIX (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит символ или символы, которые драйвер распознает в качестве суффикса для буквального этого типа данных. Эта переменная содержит пустую строку для типа данных, для которой буквальный суффикс не применим.  
  
 **SQL_DESC_LOCAL_TYPE_NAME «Дескрипторы реализации»**  
 Это поле записи только для чтения S'LCHAR содержит любое локализованное (родной язык) имя типа данных, которое может отличаться от обычного имени типа данных. Если локализованного имени нет, возвращается пустая строка. Это поле предназначено только для отображения.  
  
 **SQL_DESC_NAME «Дескрипторы реализации»**  
 Это поле записи S'LCHAR в строке дескриптор содержит псевдоним столбец, если он применяется. Если псевдоним столбец не применяется, имя столбца возвращается. В любом случае водитель устанавливает поле SQL_DESC_UNNAMED для SQL_NAMED, когда он устанавливает SQL_DESC_NAME поле. Если нет имени столбца или псевдонима столбец, водитель возвращает пустую строку в поле SQL_DESC_NAME и устанавливает поле SQL_DESC_UNNAMED для SQL_UNNAMED.  
  
 Приложение может установить SQL_DESC_NAME поле IPD к названию параметра или псевдониму, чтобы указать параметры сохраненной процедуры по имени. (Для получения дополнительной [информации см. Связывание параметров по имени (Названные параметры)](../../../odbc/reference/develop-app/binding-parameters-by-name-named-parameters.md).) Поле SQL_DESC_NAME IRD является полем только для чтения; S'LSTATE HY091 (идентификатор полей недействительных дескрипторов) будет возвращен, если приложение попытается установить его.  
  
 В IPD это поле не определено, если драйвер не поддерживает указанные параметры. Если драйвер поддерживает указанные параметры и способен описывать параметры, имя параметра возвращается в этом поле.  
  
 **SQL_DESC_NULLABLE «Дескрипторы реализации»**  
 В IRDs это поле записи только для чтения S'LSMALLSMALLINT является SQL_NULLABLE, если столбец может иметь значения NULL, SQL_NO_NULLS если столбец не имеет значения NULL, или SQL_NULLABLE_UNKNOWN, если не известно, принимает ли столбец значения NULL. Это поле относится к столбце набора результатов, а не к базовой колонке.  
  
 В IPD всегда настроена на SQL_NULLABLE, поскольку динамические параметры всегда недействительны и не могут быть установлены приложением.  
  
 **SQL_DESC_NUM_PREC_RADIX (все)**  
 Это поле S'LINTEGER содержит значение 2, если тип данных в SQL_DESC_TYPE поле является приблизительной типом численных данных, поскольку поле SQL_DESC_PRECISION содержит количество битов. Это поле содержит значение 10, если тип данных в поле SQL_DESC_TYPE является точным типом численных данных, поскольку поле SQL_DESC_PRECISION содержит количество десятичных цифр. Это поле установлено на 0 для всех типов нечислоных данных.  
  
 **SQL_DESC_OCTET_LENGTH (все)**  
 Это поле записи S'LLEN содержит длину, в байтах, строки символов или типа двоичных данных. Для символов с фиксированной длиной или бинарных типов это фактическая длина байтов. Для символов с переменной длиной или бинарных типов это максимальная длина байтов. Это значение всегда исключает место для символа нулевого прекращения для дескрипторов реализации и всегда включает пространство для символа нулевого прекращения для дескрипторов приложений. Для данных приложения это поле содержит размер буфера. Для APD это поле определяется только для параметров вывода или ввода/вывода.  
  
 **SQL_DESC_OCTET_LENGTH_PTR «Дескрипторы приложений»**  
 Это поле записи S'LLEN указывает на переменную, которая будет содержать общую длину в байтах динамического аргумента (для оценок параметров) или значения связанного столбца (для дескрипторов строки).  
  
 Для APD это значение игнорируется для всех аргументов, кроме строки символов и двоичной; если это поле указывает на SQL_NTS, динамический аргумент должен быть аннулирован. Чтобы указать, что параметр связаны между собой будет параметром данных по исполнению, приложение устанавливает это поле в соответствующей записи APD к переменной, которая во время выполнения будет содержать значение SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT_EXEC макроса. Если существует несколько таких полей, SQL_DESC_DATA_PTR может быть установлен в значение, однозначно определяющее параметр, чтобы помочь приложению определить, какой параметр запрашивается.  
  
 Если OCTET_LENGTH_PTR поле ARD является нулевой указателем, водитель не возвращает информацию о длине для столбца. Если SQL_DESC_OCTET_LENGTH_PTR поле APD является нулевой указателем, драйвер предполагает, что строки символов и двоичные значения аннулируются. (Двоичные значения не должны быть нулевыми, но должны быть предоставлены длины, чтобы избежать усечения.)  
  
 Если вызов на **S'LFetch** или **S'LFetchScroll,** который заполняет буфер, на который указывает это поле, не вернулся SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено. Это поле является *отложенным полем.* Он не используется в момент его установки, но используется в более позднее время драйвером для определения или указания длины октета данных.  
  
 **SQL_DESC_PARAMETER_TYPE (IPDs)**  
 Это поле записи S'LSMALLSMALLINT установлено для SQL_PARAM_INPUT для вхотворного параметра, SQL_PARAM_INPUT_OUTPUT для параметра ввода/вывода, SQL_PARAM_OUTPUT для параметра вывода, SQL_PARAM_INPUT_OUTPUT_STREAM для ввода/вывода потокового параметра, или SQL_PARAM_OUTPUT_STREAM для параметра потокового вывода. Он установлен на SQL_PARAM_INPUT по умолчанию.  
  
 Для IPD поле устанавливается для SQL_PARAM_INPUT по умолчанию, если IPD автоматически не засеян драйвером (атрибут SQL_ATTR_ENABLE_AUTO_IPD оператора SQL_FALSE). Приложение должно установить это поле в IPD для параметров, которые не являются входные параметры.  
  
 **SQL_DESC_PRECISION (все)**  
 Это поле записи S'LSMALLSMALLINT содержит количество цифр для точного численного типа, количество битов в мониссе (двоичная точность) для приблизительного численного типа, или числа цифр в компоненте дробных секунд для SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP или SQL_INTERVAL_SECOND типа данных. Это поле не определено для всех других типов данных.  
  
 Значение в этой области может отличаться от значения "точности", как это определено в ODBC 2 *.x*. Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-d-data-types.md)  
  
 **SQL_DESC_ROWVER «Дескрипторы реализации»**  
 В этом поле S'LSMALLINTrecord указывается, автоматически ли столбец изменяется DBMS при обновлении строки (например, столбец типа "таймштамп" в сервере S'L). Значение этого поля записи устанавливается для SQL_TRUE, если столбец является столбцом строки, и SQL_FALSE иным образом. Этот атрибут столбца аналогичен вызову **S'LSpecialColumns** с IdentifierType of SQL_ROWVER, чтобы определить, автоматически ли обновляется столбец.  
  
 **SQL_DESC_SCALE (все)**  
 Это поле записи S'LSMALLSMALLINT содержит определенную шкалу для десятичных и численных типов данных. Поле не определено для всех других типов данных.  
  
 Значение в этой области может отличаться от значения для "шкалы", как это определено в ODBC 2 *.x*. Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-d-data-types.md)  
  
 **SQL_DESC_SCHEMA_NAME (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит название схемы базовой таблицы, содержащее столбец. Значение возврата зависит от драйвера, если столбец является выражением или если столбец является частью представления. Если источник данных не поддерживает схемы или имя схемы не может быть определено, эта переменная содержит пустую строку.  
  
 **SQL_DESC_SEARCHABLE (IRDs)**  
 Это поле записи только для чтения S'LSMALLSMALLINT настроено на одно из следующих значений:  
  
-   SQL_PRED_NONE, если столбец не может быть использован в пункте **WHERE.** (Это то же самое, что SQL_UNSEARCHABLE значение в ODBC 2 *.x*.)  
  
-   SQL_PRED_CHAR, если столбец может быть использован в пункте **WHERE,** но только с предикатом **LIKE.** (Это то же самое, что и SQL_LIKE_ONLY значение в ODBC 2 *.x*.)  
  
-   SQL_PRED_BASIC, если столбец может быть использован в пункте **WHERE** со всеми операторами сравнения, за исключением **LIKE.** (Это то же самое, что и SQL_EXCEPT_LIKE значение в ODBC 2 *.x*.)  
  
-   SQL_PRED_SEARCHABLE, если столбец может быть использован в пункте **WHERE** с любым оператором сравнения.  
  
 **SQL_DESC_TABLE_NAME (IRDs)**  
 Это поле записи только для чтения S'LCHAR содержит название базовой таблицы, содержащей этот столбец. Значение возврата зависит от драйвера, если столбец является выражением или если столбец является частью представления.  
  
 **SQL_DESC_TYPE (все)**  
 В этом поле записи S'LSMALLSMALLINT указывается на краткий тип данных S'L или C для всех типов данных, за исключением дат и типов интервальных данных. Для типов данных о дате и интервалах в этом поле указывается тип подробного данных, который является SQL_DATETIME или SQL_INTERVAL.  
  
 Всякий раз, когда это поле содержит SQL_DATETIME или SQL_INTERVAL, поле SQL_DESC_DATETIME_INTERVAL_CODE должно содержать соответствующий подкод для краткого типа. Для типов данных о дате SQL_DESC_TYPE содержит SQL_DATETIME, а поле SQL_DESC_DATETIME_INTERVAL_CODE содержит подкод для конкретного типа данных о дате. Для типов интервальных данных SQL_DESC_TYPE содержит SQL_INTERVAL, а поле SQL_DESC_DATETIME_INTERVAL_CODE содержит подкод для конкретного типа данных интервала.  
  
 Значения в SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE полях взаимозависимы. Каждый раз, когда одно из полей устанавливается, другое также должно быть установлено. SQL_DESC_TYPE может быть установлен по телефону в **S'LSetDescField** или **S'LSetDescRec.** SQL_DESC_CONCISE_TYPE может быть установлен озвоном в **S'LBindCol** или **S'LBindParameter**, или **S'LSetDescField**.  
  
 Если SQL_DESC_TYPE установлен на краткий тип данных, кроме типа данных интервала или даты, поле SQL_DESC_CONCISE_TYPE настроено на то же значение, а поле SQL_DESC_DATETIME_INTERVAL_CODE настроено на 0.  
  
 Если SQL_DESC_TYPE устанавливается в многословное время даты или тип интервальных данных (SQL_DATETIME или SQL_INTERVAL) и поле SQL_DESC_DATETIME_INTERVAL_CODE устанавливается в соответствующий подкод, поле type SQL_DESC_CONCISE устанавливается в соответствующий краткий тип. Попытка установить SQL_DESC_TYPE в один из кратких типов дат или интервалов, возвращает s'LSTATE HY021 (несогласованная информация о дескрипторах).  
  
 Когда SQL_DESC_TYPE поле устанавливается вызовом в **S'LBindCol,** **S'LBindParameter**или **S'LSetDescField,** следующие поля устанавливаются на следующие значения по умолчанию, как показано в таблице ниже. Значения оставшихся полей одной и той же записи не определены.  
  
|Значение SQL_DESC_TYPE|Другие поля неявно установлены|  
|------------------------------|---------------------------------|  
|SQL_CHAR, SQL_VARCHAR, SQL_C_CHAR, SQL_C_VARCHAR|SQL_DESC_LENGTH установлен на 1. SQL_DESC_PRECISION установлен на 0.|  
|SQL_DATETIME|Когда SQL_DESC_DATETIME_INTERVAL_CODE настроена на SQL_CODE_DATE или SQL_CODE_TIME, SQL_DESC_PRECISION настроенна на 0. Когда он установлен на SQL_DESC_TIMESTAMP, SQL_DESC_PRECISION установлен до 6.|  
|SQL_DECIMAL, SQL_NUMERIC, SQL_C_NUMERIC|SQL_DESC_SCALE настроен на 0. SQL_DESC_PRECISION устанавливается на точность, определяемую реализацией для соответствующего типа данных.<br /><br /> [См. S'L к C: Число](../../../odbc/reference/appendixes/sql-to-c-numeric.md) информации о том, как вручную связать SQL_C_NUMERIC значение.|  
|SQL_FLOAT, SQL_C_FLOAT|SQL_DESC_PRECISION устанавливается на точность выполнения, определяемого по умолчанию для SQL_FLOAT.|  
|SQL_INTERVAL|Когда SQL_DESC_DATETIME_INTERVAL_CODE устанавливается на тип интервальных данных, SQL_DESC_DATETIME_INTERVAL_PRECISION устанавливается на 2 (точность, ведущую к интервалу по умолчанию). Когда интервал имеет секундный компонент, SQL_DESC_PRECISION устанавливается до 6 (точность секунд интервала по умолчанию).|  
  
 Когда приложение вызывает **S'LSetDesccField,** чтобы установить поля дескриптора, а не вызывать **S'LSetDescRec,** приложение должно сначала объявить тип данных. Когда это происходит, другие поля, указанные в предыдущей таблице, неявно устанавливаются. Если какое-либо из неявно установленных значений неприемлемо, приложение может вызвать **S'LSetDesccField** или **S'LSetDesccRec,** чтобы установить неприемлемое значение явно.  
  
 **SQL_DESC_TYPE_NAME «Дескрипторы реализации»**  
 Это поле записи только для чтения S'LCHAR содержит имя типа, зависящее от источника данных (например, "CHAR", "VARCHAR" и так далее). Если имя типа данных неизвестно, эта переменная содержит пустую строку.  
  
 **SQL_DESC_UNNAMED «Дескрипторы реализации»**  
 Это поле записи S'LSMALLINT в строке дескриптор устанавливается водителем либо SQL_NAMED или SQL_UNNAMED, когда он устанавливает поле SQL_DESC_NAME. Если поле SQL_DESC_NAME содержит псевдоним столбец или если псевдоним столбец не применяется, драйвер устанавливает поле SQL_DESC_UNNAMED для SQL_NAMED. Если приложение устанавливает поле SQL_DESC_NAME IPD на имя параметра или псевдоним, драйвер устанавливает SQL_DESC_UNNAMED поле IPD для SQL_NAMED. Если нет названия столбца или псевдонима столбец, водитель устанавливает поле SQL_DESC_UNNAMED для SQL_UNNAMED.  
  
 Приложение может установить SQL_DESC_UNNAMED поле IPD для SQL_UNNAMED. Водитель возвращает S'LSTATE HY091 (идентификатор полей недействительных дескрипторов), если приложение пытается установить SQL_DESC_UNNAMED поле IPD для SQL_NAMED. Поле SQL_DESC_UNNAMED IRD читается только для чтения; S'LSTATE HY091 (идентификатор полей недействительных дескрипторов) будет возвращен, если приложение попытается установить его.  
  
 **SQL_DESC_UNSIGNED «Дескрипторы реализации»**  
 Это поле записи только для чтения S'LLSMALLINT устанавливается для SQL_TRUE, если тип столбца не подписан или нечислимый, или SQL_FALSE, если тип столбца подписан.  
  
 **SQL_DESC_UPDATABLE (IRDs)**  
 Это поле записи только для чтения S'LSMALLSMALLINT настроено на одно из следующих значений:  
  
-   SQL_ATTR_READ_ONLY, если столбец набора результатов читается только для чтения.  
  
-   SQL_ATTR_WRITE, если столбец набора результатов читается-запись.  
  
-   SQL_ATTR_READWRITE_UNKNOWN, не известно ли столбец набора результатов updatable или нет.  
  
 SQL_DESC_UPDATABLE описывает updatability столбца в наборе результатов, а не столбец в базовой таблице. Повышается способность столбца в базовой таблице, на которой основан этот набор результатов, может отличаться от значения в этом поле. Вопрос о том, является ли столбец updatable, может основываться на типе данных, привилегиях пользователя и определении набора результата. Если неясно, является ли столбец updatable, SQL_ATTR_READWRITE_UNKNOWN должны быть возвращены.  
  
## <a name="consistency-checks"></a>Проверка согласованности  
 Проверка согласованности выполняется водителем автоматически всякий раз, когда приложение проходит в значении для SQL_DESC_DATA_PTR области ARD, APD или IPD. Если какое-либо из полей несовместимо с другими полями, **S'LSetDesccField** вернет S'LSTATE HY021 (несогласованная информация о дескрипторах). Для получения дополнительной информации, см. [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Связывание столбца|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Связывание параметра|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Получение дескриптора поля|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)
