---
title: Функция S'LGetDescfield (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetDescField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetDescField
helpviewer_keywords:
- SQLGetDescField function [ODBC]
ms.assetid: f09ff660-1e4a-4370-be85-90d4da0487d3
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 89972d7f36b436868cc8e243b03827f095b90492
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285479"
---
# <a name="sqlgetdescfield-function"></a>Функция SQLGetDescField
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 3.0: ISO 92  
  
 **Сводка**  
 **S'LGetDescField** возвращает текущую настройку или значение одного поля записи дескриптора.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetDescField(  
     SQLHDESC        DescriptorHandle,  
     SQLSMALLINT     RecNumber,  
     SQLSMALLINT     FieldIdentifier,  
     SQLPOINTER      ValuePtr,  
     SQLINTEGER      BufferLength,  
     SQLINTEGER *    StringLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *DescriptorHandle*  
 (Вход) Ручка дескриптора.  
  
 *RecNumber*  
 (Вход) Указывает запись дескриптора, с которой приложение ищет информацию. Записи дескриптора пронумероированы от 0, при этом запись закладки является рекордным номером. Если аргумент *FieldIdentifier* указывает на поле заголовка, *RecNumber* игнорируется. Если *RecNumber* меньше или равна SQL_DESC_COUNT но строка не содержит данных для столбца или параметра, вызов в **S'LGetDescField** вернет значения полей по умолчанию. (Для получения дополнительной информации, см. [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)  
  
 *FieldIdentifier*  
 (Вход) Указывает поле дескриптора, значение которого должно быть возвращено. Подробнее об этом читайте в разделе *"Аргументы по левых идентификатора"* в [разделе S'LSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md).  
  
 *ValuePtr*  
 (Выход) Указатель на буфер, в котором можно вернуть информацию о дескрипторах. Тип данных зависит от значения *FieldIdentifier.*  
  
 Если *ValuePtr* является целым типом, приложения должны использовать буфер S'LULEN и инициализировать значение до 0, прежде чем вызывать эту функцию, так как некоторые драйверы могут писать только нижний 32-битный или 16-битный буфер и оставить бит более высокого порядка без изменений.  
  
 Если *ValuePtr* является NULL, *StringLengthPtr* по-прежнему возвращает общее количество байтов (за исключением символа нулевого прекращения для данных символов), доступного для возврата в буфере, на который указывает *ValuePtr.*  
  
 *BufferLength*  
 (Вход) Если *FieldIdentifier* является полем, определяемым ODBC, а *ValuePtr* указывает на \*строку символов или бинарный буфер, этот аргумент должен быть длиной *ValuePtr.* Если *FieldIdentifier* является полем, \*определяемым ODBC, а *ValuePtr* — неопределенным, *то BufferLength* игнорируется. Если значение в * \*ValuePtr* имеет тип данных Unicode (при вызове **S'LGetDescfieldW),** аргумент *BufferLength* должен быть четным числом.  
  
 Если *FieldIdentifier* является полем, определяемым драйвером, приложение указывает на характер поля менеджеру драйвера, установив аргумент *BufferLength.* *BufferLength* может иметь следующие значения:  
  
-   Если * \*ValuePtr* является указателем на строку персонажа, то *BufferLength* — это длина строки или SQL_NTS.  
  
-   Если * \*ValuePtr* является указателем на двоичный буфер, то приложение помещает результат SQL_LEN_BINARY_ATTR *(длина)* макроса в *BufferLength.* Это ставит отрицательное значение в *BufferLength*.  
  
-   Если * \*ValuePtr* является указателем на значение, кроме строки персонажа или двоичной строки, то *BufferLength* должен иметь значение SQL_IS_POINTER.  
  
-   Если * \*ValuePtr* содержит тип данных с фиксированной длиной, то *BufferLength* — это либо SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT, либо SQL_IS_USMALLINT по мере необходимости.  
  
 *СтрунныйДлинПтр*  
 (Выход) Указатель на буфер, в котором можно вернуть общее количество байтов (за исключением количества байтов, необходимых для символа нулевого прекращения), доступного для возврата в*значение.*  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_NO_DATA или SQL_INVALID_HANDLE.  
  
 SQL_NO_DATA возвращается, если *RecNumber* больше, чем текущее количество записей дескриптора.  
  
 SQL_NO_DATA возвращается, если *DescriptorHandle* является iRD-ручкой и заявление находится в подготовленном или выполненном состоянии, но с ним не было связано открытое курсора.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LGetDesccField** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью HandleType* of SQL_HANDLE_STMT и *ручки* *обработки заявлений.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LGetDescField,** и разъясняются каждое из них в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Буфер \* *ValuePtr* не был достаточно большим, чтобы вернуть все поле дескриптора, поэтому поле было усечено. Длина непросеченного дескриптора возвращается в*строке StringLengthPtr*. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07009|Недействительный индекс дескриптора|(DM) Аргумент *RecNumber* был равен 0, атрибут SQL_ATTR_USE_BOOKMARK оператора был SQL_UB_OFF, а аргумент *DescriptorHandle* был iRD-ручкой. (Эта ошибка может быть возвращена для явно выделенного дескриптора только в том случае, если дескриптор связан с ручкой оператора.)<br /><br /> Аргумент *FieldIdentifier* был рекордным полем, аргумент *RecNumber* был 0, а аргумент *DescriptorHandle* был ручкой IPD.<br /><br /> Аргумент *RecNumber* был меньше, чем 0.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY007|Связанное заявление не подготовлено|*DescriptorHandle* был связан с *StatementHandle* как IRD, а связанная ручка оператора не была подготовлена или выполнена.|  
|HY010|Ошибка последовательности функций|(DM) *DescriptorHandle* был связан с *statementHandle,* для которого была вызвана асинхронно исполнительная функция (не эта) и все еще исполнялась, когда эта функция была вызвана.<br /><br /> (DM) *DescriptorHandle* был связан с *выпиской,* для которой **s'L'LExecute,** **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван и возвращен SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *DescriptorHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LGetDescField.**|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY021|Несогласованная информация о дескрипторе|Поля SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE не образуют допустимого типа ODBC S'L, действительного типа S'L, конкретного драйвера (для IPD) или действительного типа ODBC C (для APD или ARD).|  
|HY090|Недействительная длина строки или буфера|(DM) * \*ValuePtr* был строкой характера, и *BufferLength* был меньше нуля.|  
|HY091|Идентификатор полей недействительных дескрипторов|*FieldIdentifier* не является полем, определяемым ODBC, и не является значением, определяемым реализацией.<br /><br /> *FieldIdentifier* был неопределенным для *DescriptorHandle*.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения более подробной [SQLEndTran Function](../../../odbc/reference/syntax/sqlendtran-function.md)информации о приостановленном состоянии, см.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *DescriptorHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение может вызвать **S'LGetDescField,** чтобы вернуть значение одного поля записи дескриптора. Вызов в **S'LGetDescField** может вернуть настройку любого поля в любом типе дескриптора, включая поля заголовка, поля записи и поля закладок. Приложение может получить настройки нескольких полей в одних и тех же или разных дескрипаторах, в произвольном порядке, совершая повторные вызовы в **S'LGetDescField.** Также можно было бы вызвать полей дескриптора, определяемого драйвером, **S'LGetDescField.**  
  
 По причинам производительности приложение не должно вызывать **IRD** для IRD для выполнения оператора.  
  
 Параметры нескольких полей, описывающие имя, тип данных и данные о столбцах или параметрах, также могут быть извлечены в одном вызове на **S'LGetDescRec.** Можно вызвать **s'LGetStmtAttr,** чтобы вернуть настройку одного поля в заголовке дескриптора, который также является атрибутом оператора. **Запись** **возврата** или **SQLDescribeCol**закладки, поприщиеся по клиней, а также обменные записи или поля закладок.  
  
 Когда приложение вызывает **S'LGetDescField** для получения значения поля, которое не определено для конкретного типа дескриптора, функция возвращается SQL_SUCCESS но значение, возвращенное для поля, не определено. Например, вызов **S'LGetDesccField** для SQL_DESC_NAME или SQL_DESC_NULLABLE поля APD или ARD вернет SQL_SUCCESS но неопределенное значение для поля.  
  
 Когда приложение вызывает **S'LGetDescField** для получения значения поля, которое определено для конкретного типа дескриптора, но не имеет значения по умолчанию и еще не установлено, функция возвращается SQL_SUCCESS но значение, возвращенное для поля, не определено. Более подробную информацию о инициализации полей дескриптора и описаниях полей см. [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) Для получения дополнительной информации о [Descriptors](../../../odbc/reference/develop-app/descriptors.md)дескрипторах см.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Установка одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
