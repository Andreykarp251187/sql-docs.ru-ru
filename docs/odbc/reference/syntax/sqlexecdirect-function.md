---
title: Функция SQLExecDirect | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExecDirect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExecDirect
helpviewer_keywords:
- SQLExecDirect function [ODBC]
ms.assetid: 985fcee1-f204-425c-bdd1-deb0e7d7bbd9
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 794dc83a27d3c4882b5df4edbb4f2a645cd5ca1c
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63061512"
---
# <a name="sqlexecdirect-function"></a>Функция SQLExecDirect
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLExecDirect** выполняет отлаживаемую инструкцию, используя текущие значения переменных маркера параметра в том случае, если существует любые параметры в инструкции. **SQLExecDirect** является самым быстрым способом, чтобы отправить инструкции SQL для однократного выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLExecDirect(  
     SQLHSTMT     StatementHandle,  
     SQLCHAR *    StatementText,  
     SQLINTEGER   TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *StatementText*  
 [Вход] Инструкция SQL для выполнения.  
  
 *TextLength*  
 [Вход] Длина **StatementText* в символах.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, SQL_NO_DATA, SQL_INVALID_HANDLE, or SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLExecDirect** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, можно получить путем вызова связанного значения SQLSTATE **SQLGetDiagRec** с *HandleType* значение SQL_HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLExecDirect** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01001|Конфликт операции с курсором|\**StatementText* автономной позиционированные инструкция update или delete, и ни одной строки или более чем одной строке были обновлены или удалены. (Дополнительные сведения об обновлениях для более одной строки см. описание SQL_ATTR_SIMULATE_CURSOR *атрибут* в **SQLSetStmtAttr**.)<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01003|Функция set не поддерживает значение NULL|Аргумент *StatementText* содержатся функции набора (такие как **AVG**, **MAX**, **MIN**, и так далее), но не **COUNT**  задать функцию и аргумент значение NULL, значения были устранены до применения функции. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение данных строки справа|Строка или двоичные данные, возвращаемые для ввода вывода или выходной параметр привело к усечение непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усекаются справа. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01006|Привилегия не отменена|\**StatementText* содержится **ОТОЗВАТЬ** инструкции и пользователь не имеет заданного права. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01007|Привилегия не предоставлена|*\*StatementText* был **GRANT** инструкции и пользователь не может предоставляться заданного права.|  
|01S02|Значение параметра изменено|Атрибут указанной инструкции была Недопустимый рабочий трудностями реализации, поэтому такую же пользу за временно был заменен. (**SQLGetStmtAttr** можно вызвать для определения, что такое временно подставляемого значения.) Заменяющее значение является допустимым для *StatementHandle* до закрытия курсора, после чего атрибут инструкции возвращается к предыдущему значению. Атрибуты инструкции, которые могут быть изменены следующие:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S07|Частичное усечение|Данные, возвращаемые для ввода вывода или выходного параметра было усечено, дробная часть параметра числового типа данных было усечено или дробной части числа компонент времени, метка времени, интервалом времени или тип данных было усечено.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07002|Неправильное поле COUNT|Число параметров, указанных в **SQLBindParameter** был меньше, чем число параметров в инструкции SQL, содержащихся в \* *StatementText*.<br /><br /> **SQLBindParameter** был вызван с *ParameterValuePtr* значение является пустым указателем, *StrLen_or_IndPtr* не присвоено значение SQL_NULL_DATA, или значение SQL_DATA_AT_EXEC, и *InputOutputType*  не присвоено SQL_PARAM_OUTPUT, позволяющего число параметров в **SQLBindParameter** превышает число параметров в инструкции SQL, содержащихся в **StatementText* .|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных, определяемое *ValueType* аргумента в **SQLBindParameter** для привязанного параметра не удалось преобразовать в тип данных, определяемый *ParameterType*аргумента в **SQLBindParameter**.<br /><br /> Возвращаемое значение данных параметра, привязанный как SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT не удалось преобразовать в тип данных, определяемый *ValueType* аргумента в **SQLBindParameter**.<br /><br /> (Если значения данных для одной или нескольких строк не могут быть преобразованы, но один или несколько строк, возвращенных успешно, эта функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07007|Нарушение ограничения значения параметра|Тип параметра SQL_PARAM_INPUT_OUTPUT_STREAM используется только для параметра, который отправляет и получает данные в частях. Связанный входной буфер не допускается для этого параметра типа.<br /><br /> Эта ошибка возникает в том случае, когда тип параметра является SQL_PARAM_INPUT_OUTPUT и когда \* *StrLen_or_IndPtr* указано в **SQLBindParameter** не равным SQL_NULL_DATA, SQL_DEFAULT_ PARAM, SQL_LEN_DATA_AT_EXEC(len) или значение SQL_DATA_AT_EXEC.|  
|07S01|Недопустимое использование параметра по умолчанию|Задайте значение параметра с **SQLBindParameter**был SQL_DEFAULT_PARAM и значение по умолчанию не было соответствующего параметра.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|21S01|Список вставляемых значений не соответствует списку столбцов|\**StatementText* содержится **вставить** инструкции, а количество значений для вставки не совпали степень производной таблицы.|  
|21S02|Структура полученной таблицы не соответствует списку столбцов|\**StatementText* содержится **CREATE VIEW** инструкции, а также список столбцов с неполными (количество столбцов, указанных для представления в *идентификатор столбца* аргументы SQL Инструкция) содержит несколько имен, чем количество столбцов в производная таблица, определяется *спецификация запроса* аргумент инструкции SQL.|  
|22001|Строковые данные, усечение справа|Назначение символьное или двоичное значение в столбец завершилась усечение непустых символьные данные или двоичные данные отличное от null.|  
|22002|Переменная индикатора требуется, но не указано|Значение NULL, данные были привязаны к параметру вывода которого *StrLen_or_IndPtr* задается **SQLBindParameter** был пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|**StatementText* содержали инструкцию SQL, содержащий связанный числовой параметр или литерал, и значение вызвало целиком (в отличие от долей) часть номера будет усечен при назначении столбцу связанные таблицы.<br /><br /> Возвращает числовое значение (в виде строк или чисел) для одного или нескольких параметров ввода вывода или выходной вызвало бы всего (в отличие от долей) часть усекаемое число.|  
|22007|Формат недопустимые даты и времени|**StatementText* содержатся инструкции SQL, содержащего даты, времени или структура отметки времени, как связанных параметров, а параметр был, соответственно, при обнаружении неверной даты, времени или метки времени.<br /><br /> Является параметром ввода вывода или вывода был привязан к даты, времени или структура отметки времени C, а значение в параметре возвращаемый было, соответственно, при обнаружении неверной даты, времени или метки времени. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22008|Переполнение поля даты и времени|**StatementText* автономной инструкции SQL, содержащего выражение даты и времени, что при вычислении, привело к даты, времени или метки времени структуру, в которой был недопустимым.<br /><br /> Выражение даты и времени, рассчитанное для ввода вывода или выходной параметр привело к даты, времени или C отметку времени, был недопустимым.|  
|22012|Деление на ноль|**StatementText* содержали инструкцию SQL, который содержал арифметического выражения, вызвавшего деления на ноль.<br /><br /> Арифметическое выражение вычисляется для ввода вывода или выходной параметр привело к деления на ноль.|  
|22015|Переполнение поля интервала|*\*StatementText* содержится параметр точного числового или интервал, при преобразовании в тип данных SQL интервал, привело к потере значащих цифр.<br /><br /> *\*StatementText* содержится параметр интервала с более чем одним полем, преобразованный в числовой тип данных в столбце, имел нет представления в числовой тип данных.<br /><br /> *\*StatementText* содержащихся данных параметра, назначенный период, в тип SQL, и возникла не представление значения типа C в интервале тип SQL.<br /><br /> Назначение ввода вывода или выходной параметр, который было точное числовое значение или интервал типа SQL в тип интервала C, привело к потере значащих цифр.<br /><br /> Когда параметр ввода вывода или вывода был назначен структуру интервала C, возникла нет представления данных в структуре данных интервала.|  
|22018|Недопустимое символьное значение для спецификации приведения|*\*StatementText* содержится тип C это было точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.<br /><br /> После ввода вывода или выходного параметра было возвращено, тип SQL был точное или Приблизительное числовое, datetime или тип интервала данных; Тип C был SQL_C_CHAR; и значение в столбце не является допустимым литералом связанного типа SQL.|  
|22019|Недопустимый escape-символ|\**StatementText* содержали инструкцию SQL, который содержал **как** предиката с **ESCAPE** в **ГДЕ** предложения и длину escape Следующий **escape-** не равно 1.|  
|22025|Недопустимая escape-последовательность|\**StatementText* содержали инструкцию SQL, который содержал "**как** _значение шаблона_ **ESCAPE** _escape-символ_ "в **ГДЕ** предложение, а символ после escape-символ в значение шаблона не является одним из «%» или «_».|  
|23000|Нарушение ограничения целостности|**StatementText* содержали инструкцию SQL, который содержал параметр или литерал. Значение параметра было NULL для столбца, определенные как NOT NULL в столбце связанной таблицы, повторяющееся значение было указано для столбца, ограниченного должен содержать только уникальные значения или другое ограничение целостности было нарушено.|  
|24000|Недопустимое состояние курсора|Курсор был установлен на *StatementHandle* по **SQLFetch** или **SQLFetchScroll**. Если эта ошибка возвращается диспетчером драйверов **SQLFetch** или **SQLFetchScroll** не вернула значение SQL_NO_DATA и возвращается с помощью драйвера, если **SQLFetch** или **SQLFetchScroll** вернула значение SQL_NO_DATA.<br /><br /> Курсор был открыт, но не расположено на *StatementHandle*.<br /><br /> **StatementText* автономной позиционированные инструкция update или delete, и курсор был установлен перед началом результирующего набора или в конце результирующего набора.|  
|34000|Недопустимое имя курсора|**StatementText* автономной позиционированные инструкция update или delete, и курсор ссылается выполняемый оператор не был открыт.|  
|3D000|Недопустимое имя каталога|Имя каталога, указанное в *StatementText* был недопустимым.|  
|3F000|Недопустимое имя схемы|Имя схемы, указанное в *StatementText* был недопустимым.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|42000|Синтаксическая ошибка или нарушение доступа|\**StatementText* содержали инструкцию SQL, который не был подготавливаемых или содержит синтаксическую ошибку.<br /><br /> Пользователь не имеет разрешения на выполнение инструкции SQL, содержащихся в **StatementText*.|  
|42S01|Базовая таблица или представление уже существует|\**StatementText* содержится **CREATE TABLE** или **CREATE VIEW** инструкции и имя таблицы или представления с указанным именем уже существует.|  
|42S02|Базовая таблица или представление не найдены|\**StatementText* содержится **DROP TABLE** или **DROP VIEW** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ALTER TABLE** инструкции и указанным именем таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE VIEW** инструкции и имя таблицы или представления, имя, определенное в спецификации запроса не существует.<br /><br /> \**StatementText* содержится **CREATE INDEX** инструкции и указанным именем таблицы не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **удалить**, **вставить**, или **обновления** инструкции и указанным именем таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и таблицы, указанной в ограничении (со ссылками на таблицы не, созданный) не существует.<br /><br /> \**StatementText* содержится **CREATE SCHEMA** инструкции и указанными именем таблицы или представления, имя не существует.|  
|42S11|Индекс уже существует|\**StatementText* содержится **CREATE INDEX** инструкции и индекс с указанным именем уже существует.<br /><br /> \**StatementText* содержится **CREATE SCHEMA** инструкции и индекс с указанным именем уже существует.|  
|42S12|Индекс не найден|\**StatementText* содержится **DROP INDEX** инструкции и индекс с указанным именем не существует.|  
|42S21|Столбец уже существует|\**StatementText* содержится **ALTER TABLE** инструкции и столбец, указанный в **добавить** предложение не является уникальным, или определяет существующего столбца в базовой таблице.|  
|42S22|Столбец не найден|\**StatementText* содержится **CREATE INDEX** инструкции и один или несколько столбцов, имена, указанные в списке столбцов не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** инструкции и с определенным названием столбца не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ**, **удалить**, **вставить**, или **обновления** инструкции и с определенным названием столбца не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и столбец, указанный в ограничении (со ссылками на таблицы не, созданный) не существует.<br /><br /> \**StatementText* содержится **CREATE SCHEMA** инструкции и с определенным названием столбца не существует.|  
|44000|Нарушение параметра WITH CHECK OPTION|Аргумент *StatementText* содержится **вставить** инструкции, в просматриваемой таблице или таблице, производным от просматриваемого таблицы, который был создан путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк влияет **вставить** инструкции больше не присутствовать в просматриваемой таблице.<br /><br /> Аргумент *StatementText* содержится **обновление** инструкции, в просматриваемой таблице или таблице, производным от просматриваемого таблицы, который был создан путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк влияет **обновления** инструкции больше не присутствовать в просматриваемой таблице.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция был снова вызван для *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) **StatementText* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLExecDirect** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) аргумент *TextLength* была меньше или равно 0, но не равно SQL_NTS.<br /><br /> Задайте значение параметра с **SQLBindParameter**, был пустым указателем, а длина значения параметра не 0, SQL_NULL_DATA, значение SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Задайте значение параметра с **SQLBindParameter**, не является пустым указателем; был тип данных C SQL_C_BINARY и SQL_C_CHAR; и значение параметра длины было, но меньше 0 не SQL_NTS, SQL_NULL_DATA, в значение SQL_DATA_AT_EXEC, SQL_DEFAULT_ PARAM, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Длина значения параметра, привязанного с **SQLBindParameter** был задан в значение SQL_DATA_AT_EXEC, тип SQL был SQL_LONGVARCHAR, SQL_LONGVARBINARY, или тип данных long зависящие от источника данных; и информации, SQL_NEED_LONG_DATA_LEN Введите в **SQLGetInfo** был «Y».|  
|HY105|Недопустимый тип параметра|Значение, указанное для аргумента *InputOutputType* в **SQLBindParameter** SQL_PARAM_OUTPUT, и параметр входным параметром.|  
|HY109|Недопустимое положение курсора.|\**StatementText* автономной позиционированные инструкция update или delete, и курсор был установлен (по **SQLSetPos** или **SQLFetchScroll**) на строку, которая была удалена или не удалось извлечь.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Сочетание текущие значения атрибутов инструкции SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживается драйвером или источником данных.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE и атрибут инструкции SQL_ATTR_CURSOR_TYPE было присвоено тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Период ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLExecDirect** для отправки инструкций SQL к источнику данных. Дополнительные сведения о прямое выполнение, см. в разделе [прямое выполнение](../../../odbc/reference/develop-app/direct-execution-odbc.md). Драйвер изменяет инструкцию использовать форму SQL, используемый источником данных и затем передает его к источнику данных. В частности драйвер изменяет escape-последовательности, используемые для определения некоторых функций в SQL. Синтаксис escape-последовательностей, см. в разделе [escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).  
  
 Приложение может включать один или несколько маркеров параметров в инструкции SQL. Чтобы включить параметр маркера, приложение внедряет знак вопроса (?) в инструкцию SQL в соответствующем положении. Сведения о параметрах см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md).  
  
 Если инструкция SQL является **ВЫБЕРИТЕ** инструкции и если приложение вызвало **SQLSetCursorName** чтобы связать курсор с помощью оператора, то драйвер использует заданный курсор. В противном случае драйвер создает имя курсора.  
  
 Если источник данных находится в режиме ручной фиксации (требуется запуска явной транзакции), и транзакция уже не было инициировано, драйвер запускает транзакцию, прежде чем он отправляет инструкции SQL. Дополнительные сведения см. в разделе [режим ручной фиксации](../../../odbc/reference/develop-app/manual-commit-mode.md).  
  
 Если приложение использует **SQLExecDirect** для отправки **ЗАФИКСИРОВАТЬ** или **ОТКАТА** инструкции, она не будет с возможностью взаимодействия между СУБД. Для фиксации или отката транзакции, приложение вызывает **SQLEndTran**.  
  
 Если **SQLExecDirect** обнаруживают параметр данных во время выполнения, он возвращает SQL_NEED_DATA. Приложение отправляет данные с помощью **SQLParamData** и **SQLPutData**. См. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [отправка данных типа Long](../../../odbc/reference/develop-app/sending-long-data.md).  
  
 Если **SQLExecDirect** выполняет поисковое обновление, вставка или инструкцию delete, которая не влияет на все строки в источнике данных, вызов **SQLExecDirect** не вернет значение SQL_NO_DATA.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, а инструкция SQL содержит по крайней мере один маркер параметра, **SQLExecDirect** выполнит инструкцию SQL один раз для каждого набора значений параметров из массивы, на которые указывают *ParameterValuePointer* аргумента в вызове **SQLBindParameter**. Дополнительные сведения см. в разделе [массивы значений параметров](../../../odbc/reference/develop-app/arrays-of-parameter-values.md).  
  
 Если включены закладки и выполняется запрос, не поддерживает закладки, драйвер должен попытаться привязкой к среде, поддерживает закладки, изменив значение атрибута и возвращение SQLSTATE 01S02 (значение параметра изменено). Если атрибут не может быть изменен, драйвер должен возвращать SQLSTATE HY024 (недопустимое значение атрибута).  
  
> [!NOTE]  
>  При использовании пула подключений, приложение не должно выполнить инструкции SQL, изменяющие базу данных или контексте базы данных, такие как **используйте** _базы данных_ инструкции в SQL Server, который изменяет каталог, используемый источником данных.  
  
## <a name="code-example"></a>Пример кода  
 См. в разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md), и [образец программы ODBC](../../../odbc/reference/sample-odbc-program.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнении подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Получение нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращает имя курсора|[Функция SQLGetCursorName](../../../odbc/reference/syntax/sqlgetcursorname-function.md)|  
|Получение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает следующий параметр для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Отправка данных параметра во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Задав имя курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
|Присвоение атрибуту инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
