---
title: Функция S'LExtendedFetch (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExtendedFetch
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLExtendedFetch
helpviewer_keywords:
- SQLExtendedFetch function [ODBC]
ms.assetid: 940b5cf7-581c-4ede-8533-c67d5e9ef488
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dc832e5a20b1d3c0a1ad63b3e2a070563de2b46d
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285984"
---
# <a name="sqlextendedfetch-function"></a>Функция SQLExtendedFetch
**Соответствия**  
 Версия Введена: Соответствие стандартам ODBC 1.0: Deprecated  
  
 **Сводка**  
 **SLExtendedFetch** получает указанный набор данных из набора результатов и возвращает данные для всех связанных столбцов. Роусеты могут быть указаны в абсолютном или относительном положении или по закладке.  
  
> [!NOTE]
>  В ODBC 3 *.x,* **S'LExtendedFetch** был заменен **на S'LFetchScroll**. Приложения ODBC 3 *.x* не должны вызывать **S'LExtendedFetch;** вместо этого они должны вызвать **S'LFetchScroll**. Менеджер драйвера при работе с драйвером ODBC 2 *.x* отображает **карты S'LFetchScroll** на **S'LExtendedFetch.** Драйверы ODBC 3 *.x* должны поддерживать **S'LExtendedFetch,** если они хотят работать с приложениями ODBC 2 *.x,* которые называют это. Для получения дополнительной информации [Block Cursors, Scrollable Cursors, and Backward Compatibility](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: Driver Guidelines для обратной совместимости см.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExtendedFetch(  
      SQLHSTMT         StatementHandle,  
      SQLUSMALLINT     FetchOrientation,  
      SQLLEN           FetchOffset,  
      SQLULEN *        RowCountPtr,  
      SQLUSMALLINT *   RowStatusArray);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
 *FetchOrientation*  
 (Вход) Тип извлечения. Это то же самое, что *FetchOrientation* в **S'LFetchScroll**.  
  
 *FetchOffset*  
 (Вход) Номер строки для получения. Это то же самое, что *FetchOffset* в **S'LFetchScroll**, за одним исключением. Когда *FetchOrientation* SQL_FETCH_BOOKMARK, *FetchOffset* является фиксированной длины закладки, а не смещения от закладки. Другими словами, **S'LExtendedFetch** извлекает закладку из этого аргумента, а не атрибут SQL_ATTR_FETCH_BOOKMARK_PTR оператора. Он не поддерживает закладки с переменной длиной и не поддерживает извлечение строки в смещении (кроме 0) из закладки.  
  
 *RowCountPtr*  
 (Выход) Указатель на буфер, в котором можно вернуть количество строк, фактически извлеченных. Этот буфер используется таким же образом, как буфер, указанный атрибутом SQL_ATTR_ROWS_FETCHED_PTR оператора. Этот буфер используется только в **s'LExtendedFetch**. Он не используется **в S'LFetch** или **S'LFetchScroll**.  
  
 *РоуСтатусстрарейрей*  
 (Выход) Указатель на массив, в котором можно вернуть статус каждой строки. Этот массив используется таким же образом, как и массив, указанный атрибутом SQL_ATTR_ROW_STATUS_PTR оператора.  
  
 Однако адрес этого массива не хранится в поле SQL_DESC_STATUS_ARRAY_PTR в IRD. Кроме того, этот массив используется только **в s'LExtendedFetch** и **s'LBulkOperations** с *операцией* SQL_ADD или **S'LSetPos,** когда он называется после **S'LExtendedFetch**. Он не используется **в S'LFetch** или **S'LFetchScroll,** и он не используется **в S'LBulkOperations** или **S'LSetPos,** когда они вызваны после **S'LFetch** или **S'LFetchScroll.** Он также не используется, когда **s'LBulkOperations** с *операцией* SQL_ADD вызывается до того, как вызывается функция извлечения. Другими словами, он используется только в заявлении состояния S7. Он не используется в заявлении государств S5 или S6. Для получения дополнительной информации смотрите [Переходные процессы в приложении](../../../odbc/reference/appendixes/statement-transitions.md) B: Таблицы перехода состояния ODBC.  
  
 Приложения должны предоставить действительный указатель в аргументе *RowStatusArray;* в противном случае, поведение **S'LExtendedFetch** и поведение вызовов на **S'LBulkOperations** или **S'LSetPos** после того, как курсор был расположен **s'LExtendedFetch,** не определены.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 При возврате SQL_ERROR или SQL_SUCCESS_WITH_INFO, если **s-LExtendedFetch** возвращается, **SQLError**то, по звонку, можно получить связанное с этим значение S'LSTATE. В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LExtendedFetch,** и приведены в контексте этой функции. нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное. Если на одном столбце произошла ошибка, можно вызвать **S'LGetDiagField** с *помощью DiagIdentifier* SQL_DIAG_COLUMN_NUMBER для определения столбца, на которую была допущена ошибка; и **S'LGetDiagField** можно вызвать с *помощью DiagIdentifier* SQL_DIAG_ROW_NUMBER для определения строки, содержащей эту колонку.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Строка или двоичные данные, возвращенные для столбца, привели к усечению непустого символа или неnull двоичных данных. Если это было значение строки, то оно было правильно усечено. Если это было числовое значение, то дробная часть числа была усечена.  (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S01|Ошибка в строке|Ошибка произошла при извлечении одного или нескольких строк. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S06|Попытка получить до того, как набор результатов вернет первый ряд|Запрашиваемый ряд перекрывает начало набора результатов, когда текущая позиция была за пределами первого ряда, и либо *FetchOrientation* был SQL_PRIOR, либо *FetchOrientation* был SQL_RELATIVE с отрицательным *FetchOffset,* абсолютное значение которого было меньше или равнялась текущей SQL_ROWSET_SIZE. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Фракционная усечение|Данные, возвращенные для столбца, были усечены. Для численных типов данных дробная часть числа была усечена. Для типов времени, меток времени и интервалов данных, содержащих временной компонент, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|Значение данных не может быть преобразовано в тип данных C, указанный *TargetType* в **S'LBindCol.**|  
|07009|Недействительный индекс дескриптора|Колонка 0 была связана с **S'LBindCol**, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_OFF.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|22002|Переменная переменная индикатора требуется, но не поставляется|Данные NULL были извлечены в колонку, *StrLen_or_IndPtr* которой, установленный **S'LBindCol,** был нулевой указателем.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22003|Числовое значение вне диапазона|Возвращение численного значения (в качестве численного или строки) для одного или нескольких столбцов привело бы к тому, что вся (в отличие от дробной) часть числа была бы усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)<br /><br /> Для получения дополнительной информации в приложении D: Типы [данных см.](../../../odbc/reference/appendixes/guidelines-for-interval-and-numeric-data-types.md)|  
|22007|Недействительный формат дата-времени|Столбец символов в наборе результатов был привязан к структуре даты, времени или метки времени C, а значение в столбце было, соответственно, недействительной датой, временем или меткой времени.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22012|Разделение на ноль|Значение из арифметического выражения было возвращено, что привело к разделению на ноль.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22015|Переполниние поля интервала|Назначение от точного числа или интервала типа S'L к типу интервала C привело к потере значительных цифр в ведущем поле.<br /><br /> При извлечении данных в тип интервала C не было представлено значение типа S'L в типе интервала C.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22018|Недействительное значение символов для спецификации литья|Тип C был точным или приблизительным числом, временем даты или типом данных интервала; тип столбца s'L был типом данных символов; и значение в колонке не было действительным буквальным типа C.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|24 000|Недопустимое состояние курсора|*StatementHandle* находился в выполненном состоянии, но ни один набор результатов не был связан с *statementHandle.*|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LError** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхлик** был вызван на *StatementHandle*, а затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхливнейра** был вызван на *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LExtendedFetch.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Указанное *statementHandle* не находилось в выполненном состоянии. Функция была вызвана без предварительного вызова **S'LExecDirect**, **S'LExecute**, или функции каталога.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) **S'LExtendedFetch** был вызван для *statementHandle* после того, как **s'LFetch** или **S'LFetchScroll** был вызван и до того, как **sLFreeStmt** был вызван с SQL_CLOSE опцией.<br /><br /> (ДМ) **S'LBulkOperations** был вызван для заявления, прежде чем **S'LFetch**, **S'LFetchScroll**, или **S'LExtendedFetch** был вызван, а затем **S'LExtendedFetch** был вызван до **s'LFreeStmt** был вызван с SQL_CLOSE вариантом.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY106|Тип извне диапазона|(DM) Значение, указанное для аргумента *FetchOrientation,* было недействительным. (См. "Комментарии.")<br /><br /> Аргумент *FetchOrientation* был SQL_FETCH_BOOKMARK, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_OFF.<br /><br /> Значение опции SQL_CURSOR_TYPE оператора было SQL_CURSOR_FORWARD_ONLY, и значение аргумента *FetchOrientation* не было SQL_FETCH_NEXT.<br /><br /> Аргумент *FetchOrientation* был SQL_FETCH_RESUME.|  
|HY107|Значение строки вне диапазона|Значение, указанное в опции SQL_CURSOR_TYPE оператора, было SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное в атрибуте SQL_KEYSET_SIZE оператора, превышало значение, указанное в атрибуте SQL_ROWSET_SIZE оператора.|  
|HY111|Недействительная стоимость закладки|Аргумент *FetchOrientation* был SQL_FETCH_BOOKMARK, а закладка, указанная в аргументе *FetchOffset,* была недействительной.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает указанный тип извлечения.<br /><br /> Драйвер или источник данных не поддерживает преобразование, указанное комбинацией *TargetType* в **S'LBindCol** и типом данных в соответствующем столбце. Эта ошибка применяется только в том случае, если тип данных столбца был отображен в типе данных, специфичном для драйвера.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул набор результатов. Период тайм-аута устанавливается через **S'LSetStmtOption,** SQL_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Поведение **S'LExtendedFetch** идентично поведению **S'LFetchScroll,** за следующими исключениями:  
  
-   **Для** возврата количества строк **используются** различные методы. **S'LExtendedFetch** возвращает количество строк, извлеченных в * \*RowCountPtr;* **S'LFetchScroll** возвращает количество строк, извлеченных непосредственно в буфер, на который указывает SQL_ATTR_ROWS_FETCHED_PTR. Для получения дополнительной *информации* см.  
  
-   **SLExtendedFetch** и **S'LFetchScroll** возвращают статус каждой строки в разных массивах. Для получения дополнительной *информации* см.  
  
-   **Для** получения закладки, когда *FetchOrientation* SQL_FETCH_BOOKMARK, **используются** различные методы. **SLExtendedFetch** не поддерживает закладки с переменной длиной или извлечения рядов в смещении, кроме 0 от закладки. Для получения дополнительной *информации* см.  
  
-   **СЗЛРасширенныйСии и** **СЗЛУТСРок** используют различные размеры рядов. **В sLExtendedFetch** используется значение атрибута SQL_ROWSET_SIZE оператора, а **s-LFetchScroll** — значение атрибута SQL_ATTR_ROW_ARRAY_SIZE оператора.  
  
-   **СЗЛРасширенныйС имеет** несколько иную семантику обработки ошибок, чем **семантика S'LFetchScroll.** Для получения более [подробной](../../../odbc/reference/syntax/sqlfetchscroll-function.md)информации, см.  
  
-   **SLExtendedFetch** не поддерживает обязательные смещения (атрибут SQL_ATTR_ROW_BIND_OFFSET_PTR оператора).  
  
-   Вызовы на **S'LExtendedFetch** не могут быть смешаны с вызовами на **S'LFetch** или **S'LFetchScroll,** и если **s'LBulkOperations** вызывается до того, как будет вызвана какая-либо функция извлечения, **S'LExtendedFetch** не может быть вызван до тех пор, пока курсор не будет закрыт и открыт повторно. То **есть, S'LExtendedFetch** можно назвать только в заявлении государства S7. Для получения дополнительной информации смотрите [Переходные процессы в приложении](../../../odbc/reference/appendixes/statement-transitions.md) B: Таблицы перехода состояния ODBC.  
  
 Когда приложение вызывает **S'LFetchScroll** при использовании драйвера ODBC 2 *.x,* менеджер драйвера драйвера драйвера драйвера драйвера определяется на **S'LExtendedFetch.** Для получения более подробной информации, см.*.x* [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)  
  
 В ODBC 2 *.x,* **S'LExtendedFetch** был вызван, чтобы принести несколько строк, и **S'LFetch** был вызван, чтобы принести одну строку. В ODBC 3 *.x*, с другой стороны, **s-LFetch** можно вызвать, чтобы получить несколько строк.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение операций по массовой вставке, обновлению или удалению|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение информации о столбце в наборе результатов|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращение числа столбцов набора результатов|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Позиционирование курсора, обновление данных в строке или обновление или удаляние данных в наборе результатов|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|Установка атрибута оператора|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
