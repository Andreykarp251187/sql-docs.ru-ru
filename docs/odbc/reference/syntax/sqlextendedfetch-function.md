---
title: Функция SQLExtendedFetch | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExtendedFetch
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExtendedFetch
helpviewer_keywords:
- SQLExtendedFetch function [ODBC]
ms.assetid: 940b5cf7-581c-4ede-8533-c67d5e9ef488
author: MightyPen
ms.author: genemi
ms.openlocfilehash: ce4bd75b2a1ffac44b14c9906e669421d55888c6
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68003077"
---
# <a name="sqlextendedfetch-function"></a>Функция SQLExtendedFetch
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: Устарело  
  
 **Сводка**  
 **SQLExtendedFetch** Извлекает указанный набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов. Наборы строк можно указать в абсолютные или относительные позиции или по закладкам.  
  
> [!NOTE]
>  В ODBC 3 *.x*, **SQLExtendedFetch** был заменен классом **SQLFetchScroll**. ODBC 3 *.x* приложения не должны вызывать метод **SQLExtendedFetch**; вместо этого им следует вызвать **SQLFetchScroll**. Сопоставляет диспетчера драйверов **SQLFetchScroll** для **SQLExtendedFetch** при работе с ODBC 2 *.x* драйвера. ODBC 3 *.x* драйверы должны поддерживать **SQLExtendedFetch** для работы с ODBC 2 *.x* приложения, которые вызывают его. Дополнительные сведения см. в разделе «Комментарии» и [блочные курсоры, Прокручиваемые курсоры и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: Рекомендации по драйверов для обеспечения обратной совместимости.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExtendedFetch(  
      SQLHSTMT         StatementHandle,  
      SQLUSMALLINT     FetchOrientation,  
      SQLLEN           FetchOffset,  
      SQLULEN *        RowCountPtr,  
      SQLUSMALLINT *   RowStatusArray);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *FetchOrientation*  
 [Вход] Тип выборки. Так же, как это *FetchOrientation* в **SQLFetchScroll**.  
  
 *FetchOffset*  
 [Вход] Количество строк для выборки. Так же, как это *FetchOffset* в **SQLFetchScroll**, за одним исключением. Когда *FetchOrientation* является инструкция SQL_FETCH_BOOKMARK, *FetchOffset* — это закладка фиксированной длины, не смещения относительно закладки. Другими словами **SQLExtendedFetch** извлекает закладки из данного аргумента атрибута инструкции не SQL_ATTR_FETCH_BOOKMARK_PTR. Он не поддерживает закладки переменной длины и не поддерживает извлечение набор строк со смещением (отличное от 0) относительно закладки.  
  
 *RowCountPtr*  
 [Выход] Указатель на буфер, в котором для возврата количества фактически извлеченных строк. Этот буфер используется в так же, как буфер, заданный с помощью атрибута sql_attr_rows_fetched_ptr, которое указывает оператор. Этот буфер будет использоваться только службами **SQLExtendedFetch**. Они не используются **SQLFetch** или **SQLFetchScroll**.  
  
 *RowStatusArray*  
 [Выход] Указатель на массив, в которую будет возвращено состояние каждой строки. Этот массив используется в так же, как массива, заданного параметром значения SQL_ATTR_ROW_STATUS_PTR атрибут инструкции.  
  
 Однако адрес этого массива не хранится в поле SQL_DESC_STATUS_ARRAY_PTR в IRD. Кроме того, этот массив используется только **SQLExtendedFetch** и **SQLBulkOperations** с *операции* из SQL_ADD или **SQLSetPos**при вызове после **SQLExtendedFetch**. Они не используются **SQLFetch** или **SQLFetchScroll**, и они не используются **SQLBulkOperations** или **SQLSetPos** при вызове после **SQLFetch** или **SQLFetchScroll**. Это также не используется, если **SQLBulkOperations** с *операции* SQL_ADD называется перед вызовом любой функции выборки. Другими словами он используется только в состоянии инструкции S7. Он не используется в инструкции состояниях S5 или S6. Дополнительные сведения см. в разделе [переходы инструкций](../../../odbc/reference/appendixes/statement-transitions.md) в приложении б: Таблицы перехода состояния ODBC.  
  
 Приложения должны предоставить допустимый указатель в *RowStatusArray* аргумента; в противном случае поведение **SQLExtendedFetch** и поведение вызовов к **SQLBulkOperations**или **SQLSetPos** после курсор по **SQLExtendedFetch** не определены.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLExtendedFetch** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, можно получить путем вызова связанного значения SQLSTATE **SQLError**. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLExtendedFetch** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное. При возникновении ошибки по одному столбцу, **SQLGetDiagField** может вызываться с *DiagIdentifier* из SQL_DIAG_COLUMN_NUMBER, чтобы определить столбец, произошла ошибка; в противном и  **SQLGetDiagField** может вызываться с *DiagIdentifier* из SQL_DIAG_ROW_NUMBER для определения строки, содержащей этот столбец.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение данных строки справа|Строка или двоичные данные, возвращаемые для столбца привело к усечение непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усекаются справа. Если он был числовое значение, дробная часть числа были усечены.  (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S01|Ошибка в строке|Произошла ошибка при извлечении одной или нескольких строк. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S06|Попытка выборки до появления результирующий набор, возвращаемый первый набор строк|Запрошенный набор строк overlapped начала результирующий набор, если текущая позиция был после первого ряда и либо *FetchOrientation* был SQL_PRIOR или *FetchOrientation* был SQL_RELATIVE с отрицательное *FetchOffset* , абсолютное значение было меньше или равно текущей SQL_ROWSET_SIZE. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S07|Частичное усечение|Данные, возвращенные для столбца были усечены. Для числовых типов данных был усечен, дробная часть числа. Для времени, timestamp и интервальных типов данных, содержащего компонент времени десятичная часть времени были усечены.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных не удалось преобразовать тип данных C, указанный в *TargetType* в **SQLBindCol**.|  
|07009|Недопустимый индекс дескриптора|Столбец 0 был связан с **SQLBindCol**, а атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_OFF.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22002|Переменная индикатора требуется, но не указано|NULL получения данных в столбец, *StrLen_or_IndPtr* задается **SQLBindCol** был пустым указателем.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение (в виде строк или чисел) для одного или нескольких столбцов вызвало бы всего (в отличие от долей) часть усекаемое число.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).<br /><br /> Дополнительные сведения см. в разделе [рекомендации для интервальных и числовых типов данных](../../../odbc/reference/appendixes/guidelines-for-interval-and-numeric-data-types.md) в приложение г Типы данных.|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе была привязана к даты, времени или структура отметки времени C, а значение в столбце было, соответственно, при обнаружении неверной даты, времени или метки времени.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22012|Деление на ноль|Значение от арифметического выражения было возвращено, что привело к деления на ноль.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22015|Переполнение поля интервала|Назначение на основе точное числовое значение или интервал тип SQL тип интервала C привело к потере значащих разрядов в начале поля.<br /><br /> При получении данных в тип интервала C, возникла не представление значения типа SQL в тип интервала C.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22018|Недопустимое символьное значение для спецификации приведения|Тип C был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|24000|Недопустимое состояние курсора|*StatementHandle* была выполненного состоянии, но результирующий набор не связан с *StatementHandle*.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLError** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция была вызвана, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLExtendedFetch** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполненного. Функция был вызван без предварительного вызова функции **SQLExecDirect**, **SQLExecute**, или функции каталога.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) **SQLExtendedFetch** был вызван для *StatementHandle* после **SQLFetch** или **SQLFetchScroll** был вызван и перед  **SQLFreeStmt** был вызван с параметром SQL_CLOSE.<br /><br /> (DM) **SQLBulkOperations** был вызван для инструкции перед **SQLFetch**, **SQLFetchScroll**, или **SQLExtendedFetch** был вызван, и затем **SQLExtendedFetch** был вызван перед **SQLFreeStmt** был вызван с параметром SQL_CLOSE.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY106|Тип выборки за пределами диапазона|(DM) значение, указанное для аргумента *FetchOrientation* был недопустимым. (См. в разделе «Комментарии».)<br /><br /> Аргумент *FetchOrientation* был sql_fetch_bookmark аргумента, и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_OFF.<br /><br /> Значение параметра инструкции SQL_CURSOR_TYPE было SQL_CURSOR_FORWARD_ONLY, а значение аргумента *FetchOrientation* не SQL_FETCH_NEXT.<br /><br /> Аргумент *FetchOrientation* был SQL_FETCH_RESUME.|  
|HY107|Значение строки за пределами диапазона|Значение, указанное с помощью параметра инструкции SQL_CURSOR_TYPE был SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное с помощью атрибута инструкции SQL_KEYSET_SIZE больше 0 и меньше, чем значение, указанное с помощью атрибута инструкции SQL_ROWSET_SIZE .|  
|HY111|Недопустимое значение закладки|Аргумент *FetchOrientation* был sql_fetch_bookmark аргумента и закладки, указанное в *FetchOffset* аргумент не был допустимым.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйверу или источнику данных не поддерживает тип указанного выборки.<br /><br /> Драйвер или источник данных не поддерживает преобразование, определяемое сочетание *TargetType* в **SQLBindCol** и тип данных SQL соответствующего столбца. Данная ошибка относится только в том случае, если тип данных SQL столбца был сопоставлен с типом данных специфические для драйвера SQL.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Период ожидания задается с помощью **SQLSetStmtOption**, SQL_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Поведение **SQLExtendedFetch** идентична из **SQLFetchScroll**, за исключением следующих случаев:  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** использовать различные методы для получения количества извлеченных строк. **SQLExtendedFetch** возвращает число строк, загружаемых в  *\*RowCountPtr*; **SQLFetchScroll** возвращает число возвращаемых строк непосредственно в буфере, на которые указывают SQL_ATTR_ROWS_FETCHED_PTR. Дополнительные сведения см. в разделе *RowCountPtr* аргумент.  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** возвращают статус каждой из строк в разных массивов. Дополнительные сведения см. в разделе *RowStatusArray* аргумент.  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** используются различные методы для получения закладки при *FetchOrientation* является sql_fetch_bookmark аргумента. **SQLExtendedFetch** не поддерживает закладки переменной длины или получение наборов строк со смещением отличное от 0 относительно закладки. Дополнительные сведения см. в разделе *FetchOffset* аргумент.  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** использовать размеры другого набора строк. **SQLExtendedFetch** использует значение атрибута инструкции SQL_ROWSET_SIZE и **SQLFetchScroll** использует значение атрибута SQL_ATTR_ROW_ARRAY_SIZE инструкции.  
  
-   **SQLExtendedFetch** имеет немного другой обработки от семантик таких ошибок **SQLFetchScroll**. Дополнительные сведения см. в разделе «Обработка ошибок» в разделе «Комментарии» [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md).  
  
-   **SQLExtendedFetch** не поддерживает смещения привязки (атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR).  
  
-   Вызовы **SQLExtendedFetch** нельзя комбинировать с вызовами **SQLFetch** или **SQLFetchScroll**и если **SQLBulkOperations** называется Перед вызовом любой функции fetch **SQLExtendedFetch** невозможен, пока не будет закрыт и повторном открытии курсора. То есть **SQLExtendedFetch** может вызываться только в состоянии инструкции S7. Дополнительные сведения см. в разделе [переходы инструкций](../../../odbc/reference/appendixes/statement-transitions.md) в приложении б: Таблицы перехода состояния ODBC.  
  
 Если приложение вызывает **SQLFetchScroll** при использовании ODBC 2 *.x* драйвера, диспетчер драйверов сопоставляет этот вызов **SQLExtendedFetch**. Дополнительные сведения см. в разделе «SQLFetchScroll и ODBC 2 *.x* драйверы» в [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md).  
  
 В ODBC 2 *.x*, **SQLExtendedFetch** был вызван для получения нескольких строк и **SQLFetch** был вызван для получения одной строки. В ODBC 3 *.x*, с другой стороны, **SQLFetch** можно вызвать, чтобы получать несколько строк.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение инструкции bulk insert, update или delete операций|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнении подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Позиционирование курсора, обновление данных в наборе строк или удаления данных в результирующем наборе|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|Присвоение атрибуту инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
