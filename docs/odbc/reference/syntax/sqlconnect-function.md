---
title: Функция SQLConnect | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLConnect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLConnect
helpviewer_keywords:
- SQLConnect function [ODBC]
ms.assetid: 59075e46-a0ca-47bf-972a-367b08bb518d
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 3f2eabec895a0b56d396d5848c8f418451e0afb7
ms.sourcegitcommit: 7a3243c45830cb3f49a7fa71c2991a9454fd6f5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/11/2019
ms.locfileid: "65537676"
---
# <a name="sqlconnect-function"></a>Функция SQLConnect
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLConnect** устанавливает соединения с драйвером и источником данных. Дескриптора соединения ссылается на хранение все сведения о подключении к источнику данных, включая состояние, состояние транзакции и сведения об ошибке.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLConnect(  
     SQLHDBC        ConnectionHandle,  
     SQLCHAR *      ServerName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      UserName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      Authentication,  
     SQLSMALLINT    NameLength3);  
```  
  
## <a name="arguments"></a>Аргументы  
 *ConnectionHandle*  
 [Вход] Дескриптор соединения.  
  
 *ServerName*  
 [Вход] Имя источника данных. Данные могут быть расположены на одном компьютере с программой, или на другом компьютере, где-нибудь в сети. Сведения о выборе источника данных с помощью приложения, см. в разделе [Выбор источника данных или драйвера](../../../odbc/reference/develop-app/choosing-a-data-source-or-driver.md).  
  
 *NameLength1*  
 [Вход] Длина **ServerName* в символах.  
  
 *UserName*  
 [Вход] Идентификатор пользователя.  
  
 *NameLength2*  
 [Вход] Длина **UserName* в символах.  
  
 *Authentication*  
 [Вход] Строка для проверки подлинности (обычно пароль).  
  
 *NameLength3*  
 [Вход] Длина **проверки подлинности* в символах.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE, or SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLConnect** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_DBC и *обрабатывать* из *ConnectionHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые при помощи **SQLConnect** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Драйвер не поддерживает указанное значение *ValuePtr* аргумента в **SQLSetConnectAttr** и заменить примерно такое же значение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08001|Не удается установить подключение клиента|Драйвер не удалось установить соединение с источником данных.|  
|08002|Имя подключения используется|(DM) указанного *ConnectionHandle* уже была использована для установления соединения с источником данных, а также подключение был по-прежнему открыт или вошла пользователя для подключения.|  
|08004|Сервер отклонил подключение|Источник данных отклонены установление соединения по причинам, определяемого реализацией.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому пытается подключиться драйвер перед обработкой функции было завершено.|  
|28000|Недопустимая спецификация авторизации|Значение, указанное для аргумента *UserName* или значение, указанное для аргумента *проверки подлинности* нарушены ограничения, определенные в источнике данных.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Диспетчер драйверов (DM) не удалось выделить память, необходимая для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *ConnectionHandle*. **SQLConnect** была вызвана функция, и до его завершения выполнения, [функция SQLCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md) был вызван для *ConnectionHandle*и затем **SQLConnect** функция была вызвана снова на *ConnectionHandle*.<br /><br /> Или **SQLConnect** была вызвана функция, и до его завершения выполнения, **SQLCancelHandle** был вызван для *ConnectionHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) асинхронно выполняемой функции (не такой) был вызван для *ConnectionHandle* и еще выполнялась при вызове этой функции.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное для аргумента *NameLength1*, *NameLength2*, или *NameLength3* меньше, чем 0, но не равно SQL_NTS.<br /><br /> (DM) значение, указанное для аргумента *NameLength1* превышена максимальная длина для имени источника данных.|  
|HYT00|Время ожидания истекло|Истекло время ожидания запроса для подключения к источнику данных завершена. Период ожидания задается с помощью **SQLSetConnectAttr**, SQL_ATTR_LOGIN_TIMEOUT.|  
|HY114|Драйвер не поддерживает выполнение уровня асинхронной функции подключения|(DM) приложения включен асинхронной операции на дескрипторе соединения перед подключением. Тем не менее драйвер не поддерживает асинхронные операции в этом дескрипторе соединения.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, указанный по имени источника данных не поддерживает функцию.|  
|IM002|Не удалось найти источник данных и не указан драйвер, по умолчанию|(DM) источника данных, имя, указанное в аргументе *ServerName* не найден в сведениях о системе, а также была ли спецификацию драйвера по умолчанию.|  
|IM003|Указанный драйвер, не будут подключены к|Драйвер (DM), перечисленные в данных спецификация источника сведений о системе не найден или не может быть подключен к по другой причине.|  
|IM004|Не удалось SQLAllocHandle драйвера на SQL_HANDLE_ENV|(DM) во время **SQLConnect**, диспетчер драйверов называемая драйвером **SQLAllocHandle** функционировать с *HandleType* SQL_HANDLE_ENV и драйвер вернул ошибку.|  
|IM005|Не удалось SQLAllocHandle драйвера на SQL_HANDLE_DBC|(DM) во время **SQLConnect**, диспетчер драйверов называемая драйвером **SQLAllocHandle** функционировать с *HandleType* SQL_HANDLE_DBC и драйвер вернул ошибку.|  
|IM006|Не удалось SQLSetConnectAttr драйвера|Во время **SQLConnect**, диспетчер драйверов называемая драйвером **SQLSetConnectAttr** функция и драйвер вернул ошибку. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|IM009|Не удалось подключиться к DLL перевода|Драйвер не удалось подключиться к преобразование библиотеки DLL, который был указан для источника данных.|  
|IM010|Слишком длинное имя источника данных|(DM)  *\*ServerName* более SQL_MAX_DSN_LENGTH символов.|  
|IM014|Указанное имя источника данных содержит несоответствие архитектуры драйвера и приложения|32-разрядное приложение (DM) использует имя DSN, подключении к 64-разрядный драйвер; и наоборот.|  
|IM015|Не удалось SQLConnect драйвера на SQL_HANDLE_DBC_INFO_HANDLE|Если драйвер возвращает значение SQL_ERROR, диспетчер драйверов вернет значение SQL_ERROR в приложение, и произойдет сбой подключения.<br /><br /> Дополнительные сведения о SQL_HANDLE_DBC_INFO_TOKEN, см. в разделе [драйвера ODBC с поддержкой пула подключений разработка](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md).|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
|S1118|Драйвер не поддерживает асинхронное уведомление|Если драйвер не поддерживает асинхронное уведомление, невозможно задать SQL_ATTR_ASYNC_DBC_EVENT или SQL_ATTR_ASYNC_DBC_RETCODE_PTR.|  
  
## <a name="comments"></a>Комментарии  
 Сведения о том, почему приложение использует **SQLConnect**, см. в разделе [подключение с помощью SQLConnect](../../../odbc/reference/develop-app/connecting-with-sqlconnect.md).  
  
 Диспетчер драйверов не подключается к драйвером, пока приложение не вызовет функцию (**SQLConnect**, **SQLDriverConnect**, или **SQLBrowseConnect**) для подключения к драйвер. До этого момента, диспетчер драйверов работает в свои собственные дескрипторы и управляет сведениями подключения. Когда приложение вызывает функцию подключения, диспетчер драйверов проверяет драйвера в настоящее время подключен ли для указанного *ConnectionHandle*:  
  
-   Если драйвер не подключен, диспетчер драйверов подключается к драйвера и вызовы **SQLAllocHandle** с *HandleType* из SQL_HANDLE_ENV, **SQLAllocHandle** с *HandleType* из SQL_HANDLE_DBC, **SQLSetConnectAttr** (если оно указано любых атрибутов соединения) и функция подключения в драйвере. Диспетчер драйверов возвращает SQLSTATE IM006 (драйвера **SQLSetConnectOption** сбой) и значение SQL_SUCCESS_WITH_INFO для функции подключения, если драйвер вернул ошибку для **SQLSetConnectAttr**. Дополнительные сведения см. в разделе [подключение к источнику данных или драйверу](../../../odbc/reference/develop-app/connecting-to-a-data-source-or-driver.md).  
  
-   Если указанный драйвер уже подключен к on *ConnectionHandle*, диспетчер драйверов вызывает функцию подключения в драйвере. В этом случае драйвер необходимо убедиться в том, что все подключения атрибуты для *ConnectionHandle* поддерживать свои текущие параметры.  
  
-   Если другой драйвер подключен, диспетчер драйверов вызывает **SQLFreeHandle** с *HandleType* из SQL_HANDLE_DBC, и затем, если нет других драйвера подключен в этой среде, он вызывает **SQLFreeHandle** с *HandleType* из SQL_HANDLE_ENV в драйвере подключенных и отключается этот драйвер. Затем он выполняет те же операции, что если драйвер не подключен к.  
  
 Затем драйвер дескрипторы выделяет и инициализирует себя.  
  
 Когда приложение вызывает **SQLDisconnect**, диспетчер драйверов вызывает **SQLDisconnect** в драйвере. Тем не менее драйвер не отключить. В этом случае драйвер в памяти для приложений, которые многократно подключения и отключения от источника данных. Когда приложение вызывает **SQLFreeHandle** с *HandleType* SQL_HANDLE_DBC, диспетчера драйверов была вызвана **SQLFreeHandle** с *HandleType*  из SQL_HANDLE_DBC и затем **SQLFreeHandle** с *HandleType* из SQL_HANDLE_ENV в драйвере, а затем отключается драйвер.  
  
 Приложение ODBC можно установить несколько подключений.  
  
## <a name="driver-manager-guidelines"></a>Рекомендации по диспетчера драйверов  
 Содержимое **ServerName* влияют на совместную работу диспетчера драйверов и драйверов для установления соединения с источником данных.  
  
-   Если \* *ServerName* содержит допустимый источник данных, диспетчер драйверов находит соответствующей спецификации источника данных в сведения о системе и подключается к соответствующий драйвер. Диспетчер драйверов передает каждого **SQLConnect** аргумент к драйверу.  
  
-   Если не удается найти имя источника данных или *ServerName* является пустым указателем, диспетчер драйверов находит спецификации источника данных по умолчанию и подключается к соответствующий драйвер. Диспетчер драйверов передает драйверу *UserName* и *проверки подлинности* аргументов без изменений и «DEFAULT» для *ServerName* аргумент.  
  
-   Если *ServerName* аргумент «DEFAULT», диспетчер драйверов находит спецификации источника данных по умолчанию и подключается к соответствующий драйвер. Диспетчер драйверов передает каждого **SQLConnect** аргумент к драйверу.  
  
-   Если не удается найти имя источника данных или *ServerName* является указателем null и значение по умолчанию, спецификация источника данных не существует, возвращает значение SQL_ERROR с SQLSTATE IM002, диспетчер драйверов (источник данных не найден и значение по умолчанию отсутствует драйвер указан).  
  
 После подключения к диспетчером драйверов, драйвер можно найти его соответствующей спецификации источника данных в сведения о системе и использовать сведения из спецификации для завершения свой набор необходимые сведения для соединения.  
  
 Если библиотека преобразования по умолчанию указан в сведениях о системе для источника данных, драйвер подключается к нему. Библиотека разных транслируемых можно подключить к путем вызова **SQLSetConnectAttr** с помощью настройки SQL_ATTR_TRANSLATE_LIB атрибута. Вариант перевода можно указать путем вызова **SQLSetConnectAttr** с атрибутом SQL_ATTR_TRANSLATE_OPTION.  
  
 Если драйвер поддерживает **SQLConnect**, должен содержать раздел ключевое слово driver информация о системе для драйвера **ConnectFunctions** ключевое слово с первого знака значение «Y».  
  
### <a name="connection-pooling"></a>Организация пулов соединений  
 Организация пулов соединений позволяет приложению повторно использовать соединение, уже существует. Когда пул подключений включен и **SQLConnect** называется диспетчер драйверов пытается установить подключение с помощью подключения, который является частью пула подключений в среде, предназначенных для организации пулов соединений. Эта среда является совместно используемой среде, используемый для всех приложений, использующих подключения в пуле.  
  
 Пул подключений включен, прежде чем среде выделяется путем вызова **SQLSetEnvAttr** присвоить SQL_ATTR_CONNECTION_POOLING SQL_CP_ONE_PER_DRIVER (указывающая более один пул для каждого драйвера) или SQL_CP_ONE_PER_HENV (которое указывает более одного пула в каждой среде). **SQLSetEnvAttr** в этом случае вызывается с *EnvironmentHandle* значение null, что делает атрибут является атрибутом уровня процесса. Если задано значение SQL_ATTR_CONNECTION_POOLING SQL_CP_OFF, пул подключений отключен.  
  
 Когда организация пулов соединений включено, **SQLAllocHandle** с *HandleType* SQL_HANDLE_ENV, называется выделить среды. Среды, выделенной с помощью этого вызова является общей средой, так как пул подключений включен. Тем не менее, среда, которая будет использоваться будет неопределенным до **SQLAllocHandle** с *HandleType* SQL_HANDLE_DBC, называется.  
  
 **SQLAllocHandle** с *HandleType* SQL_HANDLE_DBC, называется установить соединение. Диспетчер драйверов пытается найти существующий общий окружение, которое соответствует атрибуты среды, установленный приложением. Если среда не существует, он создается как неявный *совместно используемой среде*. Если найден соответствующий совместно используемой среде, дескриптора среды возвращается приложению, и его счетчик ссылок увеличивается.  
  
 Тем не менее, подключение, которое будет использоваться будет неопределенным до **SQLConnect** вызывается. После этого диспетчер драйверов пытается найти существующее соединение в пуле соединений, соответствующий критериям, запрашиваемой приложением. Критерии включают параметры подключения, запрашиваемого при вызове для **SQLConnect** (значения *ServerName*, *UserName*, и  *Проверка подлинности* ключевые слова) и набор любых атрибутов соединения, так как **SQLAllocHandle** с *HandleType* из SQL_HANDLE_DBC был вызван. Диспетчер драйверов проверяет эти условия от соответствующих ключевых слов подключения и атрибуты в соединения в пуле. Если соответствие найдено, используется соединение в пуле. Если совпадений не найдено, создается новое соединение.  
  
 Если атрибуту окружения SQL_ATTR_CP_MATCH присвоено SQL_CP_STRICT_MATCH, должно соблюдаться точное соединения в пул, который будет использоваться совпадение. Если атрибуту окружения SQL_ATTR_CP_MATCH присвоено SQL_CP_RELAXED_MATCH, подключение параметры в вызове **SQLConnect** совпадения, но не все атрибуты соединения необходимо соответствовать.  
  
 Следующие правила применяются при атрибутом соединения, задаваемое при помощи приложения, прежде чем **SQLConnect** вызывается, соответствует ли атрибут соединения соединения в пуле:  
  
-   Если необходимо установить атрибут соединения, прежде чем подключения:  
  
     В случае SQL_ATTR_CP_MATCH SQL_CP_STRICT_MATCH SQL_ATTR_PACKET_SIZE в использовании соединения должен быть идентичен атрибут, установленный приложением. Если SQL_CP_RELAXED_MATCH значения SQL_ATTR_PACKET_SIZE могут быть разными.  
  
     Значение SQL_ATTR_LOGIN_VALUE не влияет на совпадение.  
  
-   Если атрибут соединения можно задать до или после подключения:  
  
     Если атрибут соединения, не было задано для приложения, но был настроен на соединение в пуле, и значения по умолчанию, снова установить атрибут соединения в пуле соединений значение по умолчанию и объявлен совпадение. Если нет значения по умолчанию, соединения не является соответствие.  
  
     Если атрибут соединения настроена для приложения, но не было задано для соединения в пуле, атрибут соединения в пуле изменяется на соответствующем наборе приложением, и объявляется совпадение.  
  
     Если атрибут соединения установлено приложением, а также был настроен на соединение в пуле, но значения различаются, используется значение атрибута соединения приложения и объявлен совпадение.  
  
-   Если значения атрибутов драйвера соединения не совпадают, SQL_ATTR_CP_MATCH присваивается SQL_CP_STRICT_MATCH соединения в пуле не используется.  
  
 Когда приложение вызывает **SQLDisconnect** отключиться, подключение возвращается в пул подключений и будет доступен для повторного использования.  
  
### <a name="optimizing-connection-pooling-performance"></a>Оптимизация производительности пула подключений  
 При использовании распределенных транзакций, это возможно для оптимизации подключений в пул производительности с помощью **SQL_DTC_TRANSITION_COST**, — битовая маска, SQLUINTEGER. Переходы, называется являются переходы подключения атрибут SQL_ATTR_ENLIST_IN_DTC, переход от значения 0, не равно нулю и наоборот. Переход от подключения не прикреплен к распределенной транзакции для прикрепления к распределенной транзакции и наоборот. В зависимости от того, как драйвер реализовала зачисления (параметр подключения атрибут SQL_ATTR_ENLIST_IN_DTC) эти переходы может потреблять много ресурсов и поэтому следует избегать для достижения оптимальной производительности.  
  
 Значение, возвращенное драйвер содержит любое сочетание следующих битов:  
  
-   **SQL_DTC_ENLIST_EXPENSIVE**, если задано, подразумевает, начинающийся с нуля ненулевое переход стоит значительно дороже, чем переход из ненулевое значение на другое ненулевое значение (прикрепление ранее включенный в список соединений в его следующей транзакции).  
  
-   **SQL_DTC_UNENLIST_EXPENSIVE**, если задано, подразумевает ненулевое значение ноль переход значительно дороже, чем при использовании соединения которого атрибут SQL_ATTR_ENLIST_IN_DTC уже присваивается нулевое значение.  
  
 Нет производительности и использования компромисс подключения. Если драйвер указывает, что один или несколько этих переходов ресурсоемки, организатор пулов соединений диспетчера драйверов ответ на это, оставив большее число подключений в пуле. Некоторые подключения в пуле являются предпочтительными для использования нетранзакционные, а некоторые являются предпочтительными для использования транзакций. Тем не менее если драйвер указывает, что эти переходы не дорого, меньшее количество соединений можно использовать, возможно, переключаясь между нетранзакционные и использования транзакций.  
  
 Драйверы, которые не поддерживают SQL_ATTR_ENLIST_IN_DTC не обязательно должны поддерживать SQL_DTC_TRANSITION_COST. Для драйверов, которые поддерживают SQL_ATTR_ENLIST_IN_DTC, но не SQL_DTC_TRANSITION_COST предполагается, что переходы не являются дорогим, а если драйвер вернула 0 (нет установленных битов) для этого значения.  
  
 Несмотря на то, что SQL_DTC_TRANSITION_COST была введена в ODBC 3.5 ODBC 2. *x* драйвер также поддерживает его, поскольку диспетчер драйверов будут запрашивать эти сведения, независимо от версии драйвера.  
  
### <a name="code-example"></a>Пример кода  
 В следующем примере приложение выделяет среды и соединения дескрипторов. Затем он подключается к источнику данных заказов на продажу с пользователем JohnS идентификатор и пароль Sesame и обрабатывает данные. После завершения обработки данных, он отключается от источника данных и освобождает маркеров.  
  
```cpp  
// SQLConnect_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <sqlext.h>  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt;  
   SQLRETURN retcode;  
  
   SQLCHAR * OutConnStr = (SQLCHAR * )malloc(255);  
   SQLSMALLINT * OutConnStrLen = (SQLSMALLINT *)malloc(255);  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLCHAR*) "NorthWind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение дескриптора|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Обнаружение и перечисление значений, необходимых для подключения к источнику данных|[Функция SQLBrowseConnect](../../../odbc/reference/syntax/sqlbrowseconnect-function.md)|  
|Отключение от источника данных|[Функция SQLDisconnect](../../../odbc/reference/syntax/sqldisconnect-function.md)|  
|Подключение к источнику данных с помощью соединения строки или в диалоговом окне|[Функция SQLDriverConnect](../../../odbc/reference/syntax/sqldriverconnect-function.md)|  
|Возвращает значение атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Присвоение атрибуту соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
