---
title: Функция S'LConnect (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLConnect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLConnect
helpviewer_keywords:
- SQLConnect function [ODBC]
ms.assetid: 59075e46-a0ca-47bf-972a-367b08bb518d
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ab0a31845efeb484c554a9c9cf1afeaeab1a8bea
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81301220"
---
# <a name="sqlconnect-function"></a>Функция SQLConnect
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **SLConnect** устанавливает соединения с драйвером и источником данных. Соединение обрабатывает ссылки на хранение всей информации о подключении к источнику данных, включая состояние, состояние транзакций и информацию об ошибках.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLConnect(  
     SQLHDBC        ConnectionHandle,  
     SQLCHAR *      ServerName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      UserName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      Authentication,  
     SQLSMALLINT    NameLength3);  
```  
  
## <a name="arguments"></a>Аргументы  
 *ПодключениеРучка*  
 [Input] Дескриптор подключения  
  
 *ServerName*  
 (Вход) Имя источника данных. Данные могут быть расположены на том же компьютере, что и программа, или на другом компьютере где-то в сети. Для получения информации о том, как приложение выбирает источник данных, [см.](../../../odbc/reference/develop-app/choosing-a-data-source-or-driver.md)  
  
 *NameLength1*  
 (Вход) Длина*сервера В* символах.  
  
 *Пользователя*  
 (Вход) Идентификатор пользователя.  
  
 *NameLength2*  
 (Вход) Длина*пользователя В* символах.  
  
 *Проверка подлинности*  
 (Вход) Строка аутентификации (обычно пароль).  
  
 *NameLength3*  
 (Вход) Длина*аутентификации* в персонажах.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LConnect** возвращается SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив по **телефону S'LGetDiagRec** с *помощью handleType* of SQL_HANDLE_DBC и *ручки* *ConnectionHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LConnect,** и приведены данные в контексте этой функции; нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S02|Изменение значения опциона|Драйвер не поддержал указанное значение аргумента *ValuePtr* в **S'LSetConnectAttr** и заменил аналогичное значение. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08001|Клиент не может установить соединение|Водитель не смог установить связь с источником данных.|  
|08002|Имя соединения в использовании|(DM) Указанный *ConnectionHandle* уже использовался для установления связи с источником данных, и соединение по-прежнему открыто или пользователь просматривает соединение.|  
|08004|Сервер отклонил соединение|Источник данных отклонил установление соединения по причинам, определенным для реализации.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому пытался подключиться, не сработала до завершения обработки функции.|  
|28000|Недействительная спецификация авторизации|Значение, указанное для аргумента *UserName* или значение, указанное для *аргумента Authentication* нарушило ограничения, определенные источником данных.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|(DM) Менеджер драйвера не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *ConnectionHandle*. Функция **S'LConnect** была вызвана, и перед завершением выполнения [функция S'LCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md) была вызвана на *функцию ConnectionHandle,* а затем функция **S'LConnect** была снова вызвана на *ConnectionHandle.*<br /><br /> Или функция **S'LConnect** была вызвана, и перед завершением **выполнения, S'LCancelHandle** был вызван на *ConnectionHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно выполнение функции (не этот) был вызван для *ConnectionHandle* и по-прежнему выполнения, когда эта функция была вызвана.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|(DM) Значение, указанное для аргумента *NameLength1*, *NameLength2*, или *NameLength3* было меньше, чем 0, но не равна SQL_NTS.<br /><br /> (DM) Значение, указанное для *аргумента NameLength1,* превысило максимальную длину для имени источника данных.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до завершения подключения к источнику данных. Период тайм-аута устанавливается с **помощью s'LSetConnectAttr,** SQL_ATTR_LOGIN_TIMEOUT.|  
|HY114|Драйвер не поддерживает выполнение асинхронной функции уровня соединения|(DM) Приложение включило асинхронную операцию на ручке соединения перед подключением. Однако водитель не поддерживает асинхронные операции на ручке соединения.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, указанный именем источника данных, не поддерживает функцию.|  
|IM002|Источник данных не найден и не указан драйвер по умолчанию|(DM) Имя источника данных, указанное в аргументе *ServerName,* не было найдено в информации системы, и не было спецификации драйвера по умолчанию.|  
|IM003|Указанный драйвер не может быть подключен к|(DM) Драйвер, указанный в спецификации источника данных в системной информации, не был найден или не мог быть подключен к по какой-либо другой причине.|  
|IM004|Водитель S'LAllocHandle на SQL_HANDLE_ENV не удалось|(DM) Во время **S'LConnect**менеджер-водитель назвал функцию **драйвера S'LAllocHandle** с *помощью HandleType* SQL_HANDLE_ENV и водитель вернул ошибку.|  
|IM005|Водитель S'LAllocHandle на SQL_HANDLE_DBC не удалось|(DM) Во время **S'LConnect**менеджер-водитель назвал функцию **драйвера S'LAllocHandle** с *помощью HandleType* SQL_HANDLE_DBC и водитель вернул ошибку.|  
|IM006|Сбой драйвера s'LSetConnectAttr|Во время **S'LConnect**менеджер-водитель назвал функцию **драйвера S'LSetConnectAttr,** и водитель вернул ошибку. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|IM009|Невозможно подключиться к переводу DLL|Водитель не смог подключиться к переводу DLL, который был указан для источника данных.|  
|IM010|Имя источника данных слишком длинное|(DM) * \*ServerName* был длиннее SQL_MAX_DSN_LENGTH символов.|  
|IM014|Указанный DSN содержит несоответствие архитектуры между драйвером и приложением|(DM) 32-разрядное приложение использует DSN, соединяющийся с 64-разрядным драйвером; или наоборот.|  
|IM015|Сбой драйвера в SQL_HANDLE_DBC_INFO_HANDLE|Если водитель возвращается SQL_ERROR, менеджер драйвера возвращает SQL_ERROR в приложение, и подключение выйдет из строя.<br /><br /> Для получения дополнительной информации о SQL_HANDLE_DBC_INFO_TOKEN [см.](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md)|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
|S1118|Водитель не поддерживает асинхронное уведомление|Если водитель не поддерживает асинхронное уведомление, вы не можете установить SQL_ATTR_ASYNC_DBC_EVENT или SQL_ATTR_ASYNC_DBC_RETCODE_PTR.|  
  
## <a name="comments"></a>Комментарии  
 Для получения информации о том, почему приложение использует **S'LConnect,** [см.](../../../odbc/reference/develop-app/connecting-with-sqlconnect.md)  
  
 Менеджер драйвера не подключается к драйверу до тех пор, пока приложение не вызывает функцию **(S'LConnect,** **S'LDriverConnect,** или **S'LBrowseConnect)** для подключения к драйверу. До этого момента менеджер драйвера работает со своими собственными ручками и управляет информацией о подключении. Когда приложение вызывает функцию соединения, менеджер драйвера проверяет, подключен ли драйвер в настоящее время для указанного *ConnectionHandle:*  
  
-   Если драйвер не подключен к драйверу, менеджер драйвера подключается к водителю и вызывает **S'LAllocHandle** с *помощью HandleType* of SQL_HANDLE_ENV, **S'LAllocHandle** с *помощью HandleType* SQL_HANDLE_DBC, **S'LSetConnectAttr** (если приложение указало какие-либо атрибуты соединения) и функцию соединения в драйвере. Менеджер драйвера возвращает S'LSTATE IM006 (водитель **s SLSetConnectOption** не удалось) и SQL_SUCCESS_WITH_INFO для функции соединения, если водитель вернул ошибку для **S'LSetConnectAttr**. Для получения дополнительной [информации см. Подключение к источнику данных или драйверу](../../../odbc/reference/develop-app/connecting-to-a-data-source-or-driver.md).  
  
-   Если указанный драйвер уже подключен к *на ConnectionHandle,* менеджер водителя вызывает только функцию соединения в драйвере. В этом случае драйвер должен убедиться, что все атрибуты соединения для *ConnectionHandle* сохраняют свои текущие настройки.  
  
-   Если подключен другой драйвер, менеджер драйвера вызывает **S'LFreeHandle** с *помощью HandleType* SQL_HANDLE_DBC, а затем, если ни один другой драйвер не подключен к в этой среде, он вызывает **S'LFreeHandle** с *SQL_HANDLE_ENV в* подключенном драйвере, а затем отключает этого драйвера. Затем он выполняет те же операции, что и при подключении драйвера.  
  
 Затем водитель выделяет ручки и инициализирует себя.  
  
 Когда приложение вызывает **S'LDisconnect,** менеджер драйвера вызывает **S'LDisconnect** в драйвере. Тем не менее, он не отключает драйвер. Это сохраняет драйвер в памяти для приложений, которые неоднократно подключаются к источнику данных и отключаются от нее. Когда приложение вызывает **S'LFreeHandle** с *помощью SQL_HANDLE_DBC,* менеджер драйвера вызывает **S'LFreeHandle** с *помощью HandleType* SQL_HANDLE_DBC, а затем **с помощью** SQL_HANDLE_ENV *В* драйвере, а затем отключает водителя.  
  
 Приложение ODBC может установить несколько соединений.  
  
## <a name="driver-manager-guidelines"></a>Руководящие принципы менеджера по водителю  
 Содержимое*ServerName* влияет на то, как менеджер драйвера и драйвер работают вместе, чтобы установить подключение к источнику данных.  
  
-   Если \* *ServerName* содержит действительное имя источника данных, менеджер драйвера находит соответствующую спецификацию источника данных в системной информации и подключается к соответствующему драйверу. Менеджер драйвера передает драйверу каждый аргумент **S'LConnect.**  
  
-   Если имя источника данных не найдено или *ServerName* является нулевой указателем, менеджер драйвера находит спецификацию источника данных по умолчанию и подключается к связанного драйвера. Менеджер драйвера передает водителю неизмененные аргументы *UserName* и *Authentication* и "DEFAULT" для аргумента *ServerName.*  
  
-   Если *аргументом ServerName* является "DEFAULT", менеджер драйвера находит спецификацию источника данных по умолчанию и подключается к связанного драйвера. Менеджер драйвера передает драйверу каждый аргумент **S'LConnect.**  
  
-   Если имя источника данных не найдено или *ServerName* является нулевой указателем, а спецификация источника данных по умолчанию не существует, менеджер драйвера возвращает SQL_ERROR с s'LSTATE IM002 (имя источника данных не найдено и не указан драйвер по умолчанию).  
  
 После подключения к нему менеджером драйверов водитель может найти соответствующую спецификацию источника данных в информации системы и использовать конкретную информацию о драйверах из спецификации для завершения набора требуемой информации о подключении.  
  
 Если библиотека перевода по умолчанию указана в системной информации для источника данных, к ней подключается драйвер. С другой библиотекой переводов можно подключиться, позвонив в **SQL_ATTR_TRANSLATE_LIB** атрибута. Вариант перевода можно указать, позвонив по **телефону s'LSetConnectAttr** с SQL_ATTR_TRANSLATE_OPTION атрибутом.  
  
 Если драйвер поддерживает **S'LConnect,** раздел ключевого слова драйвера системной информации для драйвера должен содержать ключевое слово **ConnectFunctions** с первым набором символов на "Y".  
  
### <a name="connection-pooling"></a>Объединение подключений в пул  
 Объединение соединения позволяет приложению повторно использовать уже созданное соединение. При включении объединения соединения и вызове **S'LConnect** менеджер драйвера пытается сделать соединение, используя соединение, которое является частью пула соединений в среде, которая была назначена для объединения соединений. Эта среда является общей средой, используемой всеми приложениями, которые используют соединения в пуле.  
  
 Объединение соединения включено до выделения среды, вызывая **S'LSetEnvAttr,** чтобы установить SQL_ATTR_CONNECTION_POOLING SQL_CP_ONE_PER_DRIVER (который определяет максимум один пул на водителя) или SQL_CP_ONE_PER_HENV (который определяет максимум один пул на среду). В данном случае **s'LSetEnvAttr** называется набором *EnvironmentHandle,* который делает атрибут омичения на уровне процесса. Если SQL_ATTR_CONNECTION_POOLING настроена на SQL_CP_OFF, объединение соединения отключено.  
  
 После включения объединения соединения для выделения среды требуется **s'LAllocHandle** с *помощью SQL_HANDLE_ENV HandleType* SQL_HANDLE_ENV. Среда, выделенная этим вызовом, является общей средой, поскольку объединение соединений было включено. Тем не менее, среда, которая будет использоваться, не определяется до тех пор, пока не будет **названа среда,** которая будет использоваться с помощью *handleType* SQL_HANDLE_DBC.  
  
 **Для** выделения соединения требуется выделение соединения с *помощью handleType* of SQL_HANDLE_DBC. Диспетчер драйвера пытается найти существующую общую среду, которая соответствует атрибутам среды, установленным приложением. Если такой среды не существует, она создается как неявная *общая среда.* При обнаружении соответствующей общей среды в приложение возвращается ручка среды и приравывается ее количество ссылок.  
  
 Тем не менее, соединение, которое будет использоваться, не определяется до тех пор, пока не будет **вызвано соединение.** В этот момент менеджер драйвера пытается найти существующее соединение в пуле соединения, которое соответствует критериям, запрошенным приложением. Эти критерии включают параметры подключения, запрошенные в вызове к **S'LConnect** (значения *KeyName,* *UserName*и ключевых слов *аутентификации)* и любые атрибуты соединения, установленные с момента вызова **S'LAllocHandle** с *SQL_HANDLE_DBC.* Менеджер драйвера проверяет эти критерии на соответствие ключевым словам соединения и атрибутам в соединениях в пуле. При обнаружении совпадения используется соединение в пуле. Если совпадение не найдено, создается новое соединение.  
  
 Если атрибут среды SQL_ATTR_CP_MATCH установлен на SQL_CP_STRICT_MATCH, совпадение должно быть точно для соединения в пуле, который будет использоваться. Если атрибут среды SQL_ATTR_CP_MATCH настроен на SQL_CP_RELAXED_MATCH, параметры подключения в вызове **к S'LConnect** должны совпадать, но не все атрибуты соединения должны совпадать.  
  
 Следующие правила применяются, когда атрибут соединения, установленный приложением до вызова **S'LConnect,** не соответствует атрибуту соединения в пуле:  
  
-   Если атрибут соединения должен быть установлен до создания соединения:  
  
     Если SQL_ATTR_CP_MATCH SQL_CP_STRICT_MATCH, SQL_ATTR_PACKET_SIZE в объединенном соединении должны быть идентичны атрибуту, установленному приложением. Если SQL_CP_RELAXED_MATCH, то ценности SQL_ATTR_PACKET_SIZE могут быть разными.  
  
     Значение SQL_ATTR_LOGIN_VALUE не влияет на матч.  
  
-   Если атрибут соединения может быть установлен до или после создания соединения:  
  
     Если атрибут соединения не был установлен приложением, но был установлен на соединении в пуле, и есть по умолчанию, атрибут соединения в объединенном подключении возвращается к умолчанию и объявлен огласку совпадения. Если по умолчанию нет, объединенное соединение не считается совпадением.  
  
     Если атрибут соединения был установлен приложением, но не установлен на соединении в пуле, атрибут соединения в пуле изменяется на атрибут, установленный приложением, и объявляется совпадение.  
  
     Если атрибут соединения был установлен приложением, а также установлен на соединении в пуле, но значения разные, используется значение атрибута соединения приложения и объявляется совпадение.  
  
-   Если значения атрибутов соединения, специфичными для драйвера, не идентичны и SQL_ATTR_CP_MATCH установлен SQL_CP_STRICT_MATCH, соединение в пуле не используется.  
  
 Когда приложение вызывает **s'LDisisconnect** для отключения, соединение возвращается в пул соединения и доступно для повторного использования.  
  
### <a name="optimizing-connection-pooling-performance"></a>Оптимизация производительности пулинга соединения  
 При распределенных транзакциях можно оптимизировать производительность объединения соединений, используя **SQL_DTC_TRANSITION_COST,** которая является битовой маской S'LUINTEGER. Упомянутые переходы являются переходами атрибута соединения SQL_ATTR_ENLIST_IN_DTC переходота от значения 0 к ненулевому и наоборот. Это соединение, переходящее от не зачисленного в распределенную транзакцию к зачисленной в распределенную транзакцию, и наоборот. В зависимости от того, как драйвер реализовал набор (установка атрибута соединения SQL_ATTR_ENLIST_IN_DTC), эти переходы могут быть дорогими и поэтому следует избегать для наилучшей производительности.  
  
 Значение, возвращаемые водителем, содержит любую комбинацию следующих битов:  
  
-   **SQL_DTC_ENLIST_EXPENSIVE,** когда установлен, подразумевает, что нулевой к нулевой переход значительно дороже, чем переход от ненулевого к другому ненулевому значению (привлечение ранее зачисленного соединения в следующую транзакцию).  
  
-   **SQL_DTC_UNENLIST_EXPENSIVE,** когда набор, подразумевает ненулевой к нулю переход значительно дороже, чем использование соединения, SQL_ATTR_ENLIST_IN_DTC атрибут уже установлен к нулю.  
  
 Существует производительность по сравнению с использованием соединения компромисса. Если драйвер указывает, что один или несколько из этих переходов являются дорогостоящими, пулер соединения менеджера драйвера реагирует на это, сохраняя больше соединений в пуле. Некоторые соединения в пуле предпочтительнее для нетранзакционного использования, а некоторые — для транзакционного использования. Однако, если драйвер указывает, что эти переходы не являются дорогостоящими, можно использовать меньшее количество соединений, возможно, чередуя нетранзакционное и транзакционное использование.  
  
 Водителям, которые не поддерживают SQL_ATTR_ENLIST_IN_DTC, не нужно поддерживать SQL_DTC_TRANSITION_COST. Для водителей, поддерживающих SQL_ATTR_ENLIST_IN_DTC, но не SQL_DTC_TRANSITION_COST, предполагается, что переходы не являются дорогостоящими, как если бы водитель вернул 0 (не набор битов) для этого значения.  
  
 Хотя SQL_DTC_TRANSITION_COST был введен в ODBC 3.5, ODBC 2. *драйвер x* также может поддерживать его, поскольку менеджер драйвера загоняет эту информацию независимо от версии драйвера.  
  
### <a name="code-example"></a>Пример кода  
 В следующем примере приложение выделяет среду и ручки соединения. Затем он подключается к источнику данных SalesOrders с идентификатором пользователя JohnS и паролем Sesame и обрабатывает данные. Когда он закончил обработку данных, он отключается от источника данных и освобождает ручки.  
  
```cpp  
// SQLConnect_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <sqlext.h>  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt;  
   SQLRETURN retcode;  
  
   SQLCHAR * OutConnStr = (SQLCHAR * )malloc(255);  
   SQLSMALLINT * OutConnStrLen = (SQLSMALLINT *)malloc(255);  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLCHAR*) "NorthWind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение ручки|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Обнаружение и перечисление значений, необходимых для подключения к источнику данных|[Функция SQLBrowseConnect](../../../odbc/reference/syntax/sqlbrowseconnect-function.md)|  
|Отключение от источника данных|[Функция SQLDisconnect](../../../odbc/reference/syntax/sqldisconnect-function.md)|  
|Подключение к источнику данных с помощью строки соединения или диалогового окна|[Функция SQLDriverConnect](../../../odbc/reference/syntax/sqldriverconnect-function.md)|  
|Возвращение параметра атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Установка атрибута соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
