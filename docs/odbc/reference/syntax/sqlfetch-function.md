---
title: Функция SQLFetch | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLFetch
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLFetch
helpviewer_keywords:
- SQLFetch function [ODBC]
ms.assetid: 6c6611d2-bc6a-4390-87c9-1c5dd9cfe07c
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 15074b31b1c147ef78a898dbb8624f3b40358d13
ms.sourcegitcommit: 7a3243c45830cb3f49a7fa71c2991a9454fd6f5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/11/2019
ms.locfileid: "65537141"
---
# <a name="sqlfetch-function"></a>Функция SQLFetch
**Соответствие стандартам**  
 Представленные версии: Соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLFetch** извлекает следующий набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLFetch(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLFetch** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав [функция SQLGetDiagRec](../../../odbc/reference/syntax/sqlgetdiagrec-function.md) с *HandleType*значение SQL_HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые при помощи **SQLFetch** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное. При возникновении ошибки по одному столбцу, [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md) может вызываться с *DiagIdentifier* из SQL_DIAG_COLUMN_NUMBER, чтобы определить столбец, произошла ошибка; в противном и  **SQLGetDiagField** может вызываться с *DiagIdentifier* из SQL_DIAG_ROW_NUMBER для определения строки, содержащий этот столбец.  
  
 Для всех этих SQLSTATE, которые могут возвращать значение SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением SQLSTATE 01xxx) возвращается SQL_SUCCESS_WITH_INFO, если в одной или нескольким, но не все строки многострочной операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка Операция одной строки.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Усечение данных строки справа|Строка или двоичные данные, возвращаемые для столбца привело к усечение непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усекаются справа.|  
|01S01|Ошибка в строке|Произошла ошибка при извлечении одной или нескольких строк.<br /><br /> (Если это SQLSTATE возвращается в том случае, если ODBC 3 *.x* при работе с ODBC 2 *.x* драйвер, его можно пропустить.)|  
|01S07|Частичное усечение|Данные, возвращенные для столбца были усечены. Для числовых типов данных был усечен, дробная часть числа. Для времени, timestamp и интервальных типов данных, содержащих компонент времени дробная часть параметра время были усечены.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе не удалось преобразовать тип данных, указанный в *TargetType* в **SQLBindCol**.<br /><br /> Столбец 0 был связан с типом данных SQL_C_BOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_VARIABLE.<br /><br /> Столбец 0 был связан с типом данных SQL_C_VARBOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS не было присвоено SQL_UB_VARIABLE.|  
|07009|Недопустимый индекс дескриптора|Драйвер был ODBC 2 *.x* драйвер, который не поддерживает **SQLExtendedFetch**, и номер столбца, указанный в привязке для столбца было равно 0.<br /><br /> Столбец 0 был привязан, и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было присвоено SQL_UB_OFF.|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22001|Усечение данных строки справа|Возвращено для столбца переменной длины закладки были усечены.|  
|22002|Переменная индикатора требуется, но не указано|NULL получения данных в столбец, *StrLen_or_IndPtr* задается **SQLBindCol** (или задается SQL_DESC_INDICATOR_PTR **SQLSetDescField** или  **SQLSetDescRec**) был пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение как числа или строки для одного или нескольких привязанных столбцов вызвало бы всего (в отличие от долей) часть усекаемое число.<br /><br /> Дополнительные сведения см. в разделе [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в приложение г Типы данных.|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе была привязана к даты, времени или структура отметки времени C, а значение в столбце было, соответственно, при обнаружении неверной даты, времени или метки времени.|  
|22012|Деление на ноль|Значение от арифметического выражения было возвращено, что привело к деления на ноль.|  
|22015|Переполнение поля интервала|Назначение на основе точное числовое значение или интервал тип SQL тип интервала C привело к потере значащих разрядов в начале поля.<br /><br /> При получении данных в тип интервала C, возникла не представление значения типа SQL в тип интервала C.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе была привязана к буфера символов C, а столбец содержится символ, для которого отсутствует представление, отсутствует в наборе символов из буфера.<br /><br /> Тип C был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.|  
|24000|Недопустимое состояние курсора|*StatementHandle* была выполненного состоянии, но результирующий набор не связан с *StatementHandle*.|  
|40001|Сбой сериализации|Транзакции, в котором был выполнен fetch был завершен для недопущения взаимоблокировок.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимая для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. **SQLFetch** была вызвана функция, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем **SQLFetch** функция была вызвана снова на *StatementHandle*.<br /><br /> Или **SQLFetch** была вызвана функция, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*  из другого потока в многопоточных приложениях.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLFetch** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ДОСТУПНО. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполненного. Функция был вызван без предварительного вызова функции **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) **SQLFetch** был вызван для *StatementHandle* после **SQLExtendedFetch** был вызван и перед **SQLFreeStmt** с SQL_ Параметр «ЗАКРЫТЬ» был вызван.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Атрибут инструкции SQL_ATTR_USE_BOOKMARK было присвоено SQL_UB_VARIABLE, а столбец 0 была привязана к буфер, длина которого не равна длине максимального закладки для данного результирующего набора. (Эта длина доступен в поле SQL_DESC_OCTET_LENGTH IRD и может быть получен путем вызова **SQLDescribeCol**, **SQLColAttribute**, или **SQLGetDescField**.)|  
|HY107|Значение строки за пределами диапазона|Значение, указанное в инструкции атрибута SQL_ATTR_CURSOR_TYPE был SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное с помощью атрибута SQL_ATTR_KEYSET_SIZE атрибут инструкции больше 0 и меньше, чем значение, указанное с помощью SQL_ATTR_ROW_ARRAY_ Атрибут инструкции размер.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяемое сочетание *TargetType* в **SQLBindCol** и тип данных SQL соответствующего столбца.|  
|HYT00|Время ожидания истекло|Истекло время ожидания запроса перед источника данных, возвращаемого набора требуемого результата. SQLSetStmtAttr, SQL_ATTR_QUERY_TIMEOUT задается истечения времени ожидания.|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **SQLFetch** возвращает следующий набор строк в результирующем наборе. Он может быть вызван только в том случае, пока существует результирующий набор: таким образом, после вызова метода, который создает результирующий набор, и перед курсор закрыт over, сам себя результирующий набор. Если какие-либо столбцы привязаны, он возвращает данные в этих столбцах. Если приложение указатель на массив состояния строк или буфер, в которую будет возвращено число возвращаемых строк, **SQLFetch** также возвращает эти сведения. Вызовы **SQLFetch** можно комбинировать с вызовами **SQLFetchScroll** , но нельзя комбинировать с вызовами **SQLExtendedFetch**. Дополнительные сведения см. в разделе [выборки данных из строк](../../../odbc/reference/develop-app/fetching-a-row-of-data.md).  
  
 Если ODBC 3 *.x* приложение работает с ODBC 2 *.x* сопоставляет драйвера, диспетчер драйверов **SQLFetch** вызовы **SQLExtendedFetch** для ODBC 2 *.x* драйвер, который поддерживает **SQLExtendedFetch**. Если ODBC 2 *.x* драйвер не поддерживает **SQLExtendedFetch**, диспетчер драйверов сопоставляет **SQLFetch** вызовы **SQLFetch** в ODBC версии 2 *.x* драйвер, который можно получить только одну строку.  
  
 Дополнительные сведения см. в разделе [блочные курсоры, Прокручиваемые курсоры и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: Рекомендации по драйверов для обеспечения обратной совместимости.  
  
## <a name="positioning-the-cursor"></a>Позиционирование курсора  
 При создании результирующего набора, курсор располагается перед началом результирующего набора. **SQLFetch** извлекает следующий набор строк. Он эквивалентен вызову **SQLFetchScroll** с *FetchOrientation* присвоено SQL_FETCH_NEXT. Дополнительные сведения о курсорах см. в разделе [курсоры](../../../odbc/reference/develop-app/cursors.md) и [блочные курсоры](../../../odbc/reference/develop-app/block-cursors.md).  
  
 Атрибут SQL_ATTR_ROW_ARRAY_SIZE инструкции указывает количество строк в наборе строк. Если набор строк к получению с **SQLFetch** перекрывается конец результирующего набора, **SQLFetch** возвращает частичный набор строк. То есть если S + R - 1 больше, чем L, где S — начальной строки набора строк к получению R — размер набора строк, а L является последней строки в результирующем наборе, затем первый L - S + 1 строк для набора строк являются допустимыми. Оставшиеся строки являются пустыми и имеют статус SQL_ROW_NOROW.  
  
 После **SQLFetch** возвращает, текущая строка является первой строки набора строк.  
  
 Правила, перечисленные в следующей таблице описаны после вызова позиционирования курсора **SQLFetch**, основываясь на условиях, указанных во второй таблице в этом разделе.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|Перед запуском|1|  
|*CurrRowsetStart* \< =  *LastResultRow - RowsetSize*[1]|*CurrRowsetStart* + *RowsetSize*[2]|  
|*CurrRowsetStart* > *LastResultRow - RowsetSize*[1]|После окончания|  
|После окончания|После окончания|  
  
 [1] Если размер набора строк изменяется между операций выборки, это размер набора строк, который использовался с предыдущей выборке.  
  
 [2] Если размер набора строк изменяется между операций выборки, это размер набора строк, который был использован с новой выборке.  
  
|Нотация|Значение|  
|--------------|-------------|  
|Перед запуском|Блок курсор располагается перед началом результирующего набора. Перед началом результирующего набора, если первая строка новый набор строк **SQLFetch** не вернет значение SQL_NO_DATA.|  
|После окончания|Блок курсор располагается после конец результирующего набора. Если первая строка новый набор строк находится в конце результирующего набора, **SQLFetch** не вернет значение SQL_NO_DATA.|  
|*CurrRowsetStart*|Номер первой строки в текущем наборе строк.|  
|*LastResultRow*|Номер последней строки в результирующем наборе.|  
|*RowsetSize*|Размер набора строк.|  
  
 Например предположим, что результирующий набор имеет 100 строк и размер набора строк равно 5. В следующей таблице показаны код набора строк и возврата, возвращенный **SQLFetch** для разных начальной позиции.  
  
|Текущего набора строк|Код возврата|Новый набор строк|число получаемых строк|  
|--------------------|-----------------|----------------|------------------------|  
|Перед запуском|SQL_SUCCESS|1 – 5|5|  
|1 – 5|SQL_SUCCESS|6-10|5|  
|52-56|SQL_SUCCESS|57 для 61|5|  
|91 до 95|SQL_SUCCESS|96 до 100|5|  
|93 для 97|SQL_SUCCESS|98 до 100. Строки 4 и 5 массив статусов строк присваивается SQL_ROW_NOROW.|3|  
|96 до 100|SQL_NO_DATA|Нет.|0|  
|99 – 100|SQL_NO_DATA|Нет.|0|  
|После окончания|SQL_NO_DATA|Нет.|0|  
  
## <a name="returning-data-in-bound-columns"></a>Возврат данных в привязанные столбцы  
 Как **SQLFetch** возвращает каждой строке, он помещает данные для каждого привязанного столбца в буфере, привязанного к этому столбцу. Если столбцы не привязаны, **SQLFetch** не возвращает никаких данных, но переход блочного курсора. Данные по-прежнему могут быть получены с помощью **SQLGetData**. Если курсор является несколькими строками (то есть SQL_ATTR_ROW_ARRAY_SIZE больше 1), **SQLGetData** может вызываться только в том случае, если SQL_GD_BLOCK возвращается, когда **SQLGetInfo** вызывается с  *Свойство* из SQL_GETDATA_EXTENSIONS. (Дополнительные сведения см. в разделе [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md).)  
  
 Для каждого привязанного столбца в строке **SQLFetch** делает следующее:  
  
1.  Задает буфер длины/индикатора в значение SQL_NULL_DATA и переходит к следующему столбцу, если данные имеют значение NULL. Если данные имеют значение NULL, и буфер длины/индикатора не был привязан, **SQLFetch** возвращает SQLSTATE 22002 (переменная индикатора требуется, но не предоставляется) для строки и переходит к следующей строке. Сведения о том, как определить адрес буфера длины и индикатора, см. в разделе «Адреса буферов» в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
     Если данные для столбца не равно NULL, **SQLFetch** переходит к шагу 2.  
  
2.  Если атрибут инструкции sql_attr_max_length параметра задано ненулевое значение, и столбец содержит символьных или двоичных данных, данные усекаются до значения SQL_ATTR_MAX_LENGTH байт.  
  
    > [!NOTE]  
    >  Атрибут инструкции sql_attr_max_length параметра предназначена для снижения сетевого трафика. Она обычно реализуется в источнике данных, который производит усечение данных перед его возвратом по сети. Драйверы и источники данных не требуются для его поддержки. Таким образом, чтобы гарантировать, что данные будут усечены до определенного размера, приложение должно выделить буфер указанного размера и укажите размер в *cbValueMax* аргумента в **SQLBindCol**.  
  
3.  Преобразует данные типа, заданного параметром *TargetType* в **SQLBindCol**.  
  
4.  Если данные преобразованы в тип данных переменной длины, например символьный или двоичный файл, **SQLFetch** проверяет ли длина данных превышает длину буфера данных. Если длина символьных данных (включая символ завершения null) превышает длину буфера данных, **SQLFetch** производит усечение данных до длины буфера данных меньше длины символа завершения null. Он затем заканчиваются значением null данные. Если длина двоичных данных превышает длину буфера данных, **SQLFetch** обрезает его до длины буфера данных. Длина буфера данных задается с помощью *BufferLength* в **SQLBindCol**.  
  
     **SQLFetch** никогда не усекает данные преобразовать типы данных фиксированной длины; он всегда предполагается, что длина буфера данных размер типа данных.  
  
5.  Помещает данные преобразованное (и возможно усеченный) в буфере данных. Сведения о том, как определить адрес буфера данных, см. в разделе «Адреса буферов» в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
6.  Помещает длину данных в буфер длины/индикатора. Если указатель индикатора и указатель на длину заданные для одного буфера (как вызов **SQLBindCol** does), длина записывается в буфер для допустимых данных и SQL_NULL_DATA записывается в буфер для данных значение NULL. Если буфер длины/индикатора не был привязан, **SQLFetch** не возвращает длину.  
  
    -   Для символьных или двоичных данных это длина данных после преобразования и перед усечением из-за слишком буфер данных. Если драйвер не может определить длину данных после преобразования, что иногда происходит при использовании длинных данных, он устанавливает длину SQL_NO_TOTAL. Если данные были усечены из-за атрибута инструкции sql_attr_max_length параметра, значение этого атрибута помещается в буфер длины/индикатора, а не фактическая длина. Это потому, что этот атрибут предназначен для усечения данных на сервере перед преобразованием, таким образом, чтобы понять, что такое фактическая длина не может использовать этот драйвер не.  
  
    -   Для всех других типов данных это длина данных после преобразования; он является размер типа, к которому данные преобразованы.  
  
     Сведения о том, как определить адрес буфера длины и индикатора, см. в разделе «Адреса буферов» в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
7.  Если данные будут усечены при выполнении преобразования без потери значимых цифр (например, вещественное число 1,234 усекается до 1, при преобразовании целого числа), **SQLFetch** возвращает кодом SQLSTATE 01S07 (частичное усечение) и SQL_ SUCCESS_WITH_INFO. Если данные будут усечены, так как длина буфера данных слишком мал (например, строка «abcdef» помещается в буфер 4-байтовое), **SQLFetch** возвращает SQLSTATE 01004 (данных) и SQL_SUCCESS_WITH_INFO. Если данные будут усечены из-за атрибута инструкции значения SQL_ATTR_MAX_LENGTH, **SQLFetch** возвращает значение SQL_SUCCESS и не возвращает кодом SQLSTATE 01S07 (частичное усечение) или SQLSTATE 01004 (данных). Если данные будут усечены при преобразовании с потерей значащих цифр (например, если значение больше 100 000 SQL_INTEGER были преобразованы в SQL_C_TINYINT) **SQLFetch** возвращает SQLSTATE 22003 (численное значение вне допустимого диапазона) и значение SQL_ERROR (если размер набора строк равен 1) или SQL_SUCCESS_WITH_INFO (если размер набора строк больше, чем 1).  
  
 Содержимое буфера привязанного к данным и буфер длины/индикатора определены, если **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
## <a name="row-status-array"></a>Массив статусов строк  
 Массив статусов строк используется для возвращения состояния параметра каждой строки в наборе строк. Адрес этого массива указан с атрибутом значения SQL_ATTR_ROW_STATUS_PTR инструкции. Массив выделенная приложением и должен иметь столько элементов задаются с помощью атрибута SQL_ATTR_ROW_ARRAY_SIZE инструкции. Его устанавливаются с помощью **SQLFetch**, **SQLFetchScroll**, и **SQLBulkOperations** или **SQLSetPos** (за исключением, когда они были вызваны После Позиционирует курсор по **SQLExtendedFetch**). Если значение атрибута инструкции значения SQL_ATTR_ROW_STATUS_PTR является пустым указателем, эти функции не возвращают строки состояния.  
  
 Содержимое массива буфера строки состояния не определено, если **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Следующие значения возвращаются в массив статусов строк.  
  
|Значение массива строки состояния|Описание|  
|----------------------------|-----------------|  
|SQL_ROW_SUCCESS|Строка была успешно получен и не был изменен с момента последней загрузки из этого результирующего набора.|  
|SQL_ROW_SUCCESS_WITH_INFO|Строка была успешно получен и не был изменен с момента последней загрузки из этого результирующего набора. Тем не менее предупреждение было возвращено о строке.|  
|SQL_ROW_ERROR|Произошла ошибка при извлечении строки.|  
|SQL_ROW_UPDATED [1], [2] и [3]|Строка была успешно сделана выборка и был изменен с момента последней загрузки из этого результирующего набора. Если строки заново извлечь из этого результирующего набора или обновляется в **SQLSetPos**, состояние изменяется на новое состояние строки.|  
|SQL_ROW_DELETED[3]|Строка была удалена с момента последней загрузки из этого результирующего набора.|  
|SQL_ROW_ADDED[4]|Строка была вставлена **SQLBulkOperations**. Если строки заново извлечь из этого результирующего набора или обновляется в **SQLSetPos**, его состояние будет SQL_ROW_SUCCESS.|  
|SQL_ROW_NOROW|Набор строк overlapped конец результирующего набора, и строка не был возвращен, что, предоставивших к данному элементу массив статусов строк.|  
  
 [1] для ключей, смешанных и динамических курсоров, если обновляется значение ключа, строка данных считается была удалена, и добавлена новая строка.  
  
 [2] некоторые драйверы не может обнаружить обновления данных и поэтому не может возвращать это значение. Чтобы определить, может ли драйвер определить обновления refetched строк, приложение вызывает **SQLGetInfo** с параметром SQL_ROW_UPDATES.  
  
 [3] **SQLFetch** может возвращать это значение, только когда это вперемешку с вызовы **SQLFetchScroll**. Это обусловлено **SQLFetch** переход из результирующего набора и когда он используется в монопольном режиме, не повторно извлечь все строки. Так как строки не являются refetched, **SQLFetch** не обнаруживает изменения, внесенные в ранее извлеченных строк. Тем не менее если **SQLFetchScroll** помещает курсор перед любой предварительно извлечь строки и **SQLFetch** используется для получения этих строк **SQLFetch** может обнаружить все изменения в Эти строки.  
  
 [4], возвращенных SQLBulkOperations только. Не задал **SQLFetch** или **SQLFetchScroll**.  
  
### <a name="rows-fetched-buffer"></a>Строки выбраны буфера  
 Извлеченных буфера строк используется для возврата количества возвращаемых строк, включая те строки, для которых было возвращено никаких данных, так как они были выбраны произошла ошибка. Другими словами это число строк, для которых значение в массив статусов строк не SQL_ROW_NOROW. Адрес буфера указывается с помощью атрибута SQL_ATTR_ROWS_FETCHED_PTR инструкции. Буфер выделяется для приложения. Оно задается **SQLFetch** и **SQLFetchScroll**. Если значение атрибута sql_attr_rows_fetched_ptr, которое указывает оператор является пустым указателем, эти функции не возвращают число возвращаемых строк. Чтобы определить номер текущей строки в результирующем наборе, приложение может вызвать **SQLGetStmtAttr** с атрибутом SQL_ATTR_ROW_NUMBER.  
  
 Содержимое буфера извлеченных строк не определены, если **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, за исключением случаев, когда будет возвращено значение SQL_NO_DATA, в этом случае в получаемых буфера строк имеет значение 0.  
  
### <a name="error-handling"></a>Обработка ошибок  
 Ошибки и предупреждения можно применить к отдельным строкам, или для всей функции. Дополнительные сведения о диагностических записей, см. в разделе [диагностики](../../../odbc/reference/develop-app/diagnostics.md) и [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
#### <a name="errors-and-warnings-on-the-entire-function"></a>Ошибки и предупреждения на всей функции  
 Если ошибка относится ко всей функции, такие как SQLSTATE HYT00 (истекло время ожидания) или SQLSTATE 24000 (недопустимое состояние курсора), **SQLFetch** возвращает значение SQL_ERROR и применимые SQLSTATE. Содержимое набора строк буферов не определены, и положение курсора остается неизменным.  
  
 Если предупреждение применяется ко всей функции, **SQLFetch** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE применимо. Состояние записи для предупреждений, которые применяются ко всей функции возвращаются перед записях состояния, которые применяются к отдельным строкам.  
  
#### <a name="errors-and-warnings-in-individual-rows"></a>Ошибки и предупреждения в отдельных строках  
 Если ошибка (например, SQLSTATE 22012 (деление на ноль)) или предупреждение (например, SQLSTATE 01004 (данных)) применяется к одной строки, **SQLFetch**делает следующее:  
  
-   Задает соответствующий элемент в массиве строк состояния SQL_ROW_ERROR наличие ошибок или SQL_ROW_SUCCESS_WITH_INFO для предупреждения.  
  
-   Добавляет ноль или более записей состояния, которые содержат SQLSTATE для ошибки или предупреждения.  
  
-   Устанавливает поля номеров строк и столбцов в записях состояния. Если **SQLFetch** не удается определить число строк или столбцов, он устанавливает это число SQL_ROW_NUMBER_UNKNOWN или SQL_COLUMN_NUMBER_UNKNOWN, соответственно. Если состояние записи не применяется к отдельному столбцу, **SQLFetch** задает номер столбца для SQL_NO_COLUMN_NUMBER.  
  
 **SQLFetch** продолжает выборка строк, пока он выбраны все строки в наборе строк. Он возвращает значение SQL_SUCCESS_WITH_INFO, пока не произойдет ошибка в каждой строке набора строк (не включая строк с состоянием SQL_ROW_NOROW), в этом случае он возвращает значение SQL_ERROR. В частности, если размер набора строк равен 1, что приведет к ошибкам в этой строке **SQLFetch** возвращает ошибку SQL_ERROR.  
  
 **SQLFetch** возвращает состояние записи в порядке номеров строк. То есть возвращает все записи состояния для неизвестных строк (если таковые имеются); Затем он возвращает все записи о состоянии для первой строки (если таковые имеются), и он возвращает все записи о состоянии для второй строки (если таковые имеются) и т. д. Состояние записи для каждой строки упорядочиваются согласно обычным правилам для упорядочения записей состояния; Дополнительные сведения см. в разделе «Последовательность записей состояния» в [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
### <a name="descriptors-and-sqlfetch"></a>Дескрипторы и SQLFetch  
 В следующих разделах описываются как **SQLFetch** взаимодействует с дескрипторами.  
  
#### <a name="argument-mappings"></a>Аргумент сопоставления  
 Драйвер не устанавливает любой дескриптор поля, основанные на аргументы **SQLFetch**.  
  
#### <a name="other-descriptor-fields"></a>Другие поля дескриптора  
 Используются следующие поля дескриптора **SQLFetch**.  
  
|Поле дескриптора|DESC.|Поля в|Задать с помощью|  
|----------------------|-----------|--------------|-----------------|  
|SQL_DESC_ARRAY_SIZE|ОТМЕНИТЬ|Заголовок|Атрибут SQL_ATTR_ROW_ARRAY_SIZE инструкции|  
|SQL_DESC_ARRAY_STATUS_PTR|IRD|Заголовок|Атрибут значения SQL_ATTR_ROW_STATUS_PTR инструкции|  
|SQL_DESC_BIND_OFFSET_PTR|ОТМЕНИТЬ|Заголовок|Атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR|  
|SQL_DESC_BIND_TYPE|ОТМЕНИТЬ|Заголовок|Атрибут инструкции SQL_ATTR_ROW_BIND_TYPE|  
|SQL_DESC_COUNT|ОТМЕНИТЬ|Заголовок|*ColumnNumber* аргумент **SQLBindCol**|  
|SQL_DESC_DATA_PTR|ОТМЕНИТЬ|Записи|*TargetValuePtr* аргумент **SQLBindCol**|  
|SQL_DESC_INDICATOR_PTR|ОТМЕНИТЬ|Записи|*StrLen_or_IndPtr* аргумента в **SQLBindCol**|  
|SQL_DESC_OCTET_LENGTH|ОТМЕНИТЬ|Записи|*BufferLength* аргумента в **SQLBindCol**|  
|SQL_DESC_OCTET_LENGTH_PTR|ОТМЕНИТЬ|Записи|*StrLen_or_IndPtr* аргумента в **SQLBindCol**|  
|SQL_DESC_ROWS_PROCESSED_PTR|IRD|Заголовок|Атрибут инструкции SQL_ATTR_ROWS_FETCHED_PTR|  
|SQL_DESC_TYPE|ОТМЕНИТЬ|Записи|*TargetType* аргумента в **SQLBindCol**|  
  
 Все поля дескриптора можно также задать с помощью **SQLSetDescField**.  
  
#### <a name="separate-length-and-indicator-buffers"></a>Отдельные длины и индикатора буферов  
 Приложения можно привязать один буфер или двух отдельных буферах, которые могут использоваться для хранения значений длины и индикатора. Если приложение вызывает **SQLBindCol**, драйвер задает поля SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR Отменить один и тот же адрес, который передается в *StrLen_or_IndPtr* аргумент. Если приложение вызывает **SQLSetDescField** или **SQLSetDescRec**, его можно задать эти два поля в разные адреса.  
  
 **SQLFetch** определяет, ли приложение указанного отдельных буферах длины и индикатора. В этом случае, когда данные не равно NULL, **SQLFetch** задает буфер индикатор 0 и возвращает длину в буфер длины. Если данные имеют значение NULL, **SQLFetch** устанавливает буфера индикатора SQL_NULL_DATA и не изменяет длина буфера.  
  
### <a name="code-example"></a>Пример кода  
 См. в разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md), [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md), и [SQLProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md).  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфер|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнении подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Закрытие курсора в инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Получение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
