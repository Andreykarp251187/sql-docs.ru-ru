---
title: Функция S'LFetch (англ.) Документы Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLFetch
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLFetch
helpviewer_keywords:
- SQLFetch function [ODBC]
ms.assetid: 6c6611d2-bc6a-4390-87c9-1c5dd9cfe07c
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: bc7e2da6996d8d6b2ee66befdc90794efec5617b
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81285974"
---
# <a name="sqlfetch-function"></a>Функция SQLFetch
**Соответствия**  
 Представлена версия: Соответствие стандартам ODBC 1.0: ISO 92  
  
 **Сводка**  
 **SLFetch** получает следующий набор данных из набора результатов и возвращает данные для всех связанных столбцов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLFetch(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *Обработка заявления*  
 (Вход) Ручка оператора.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **S'LFetch** возвращается либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное с этим значение S'LSTATE можно получить, позвонив в [функцию «SLGetDiagRec»](../../../odbc/reference/syntax/sqlgetdiagrec-function.md) с *помощью функции HandleType* of SQL_HANDLE_STMT и *ручки* *statementHandle.* В следующей таблице перечислены значения S'LSTATE, обычно возвращаемые **S'LFetch,** и приведены в контексте этой функции. нотация "(DM)" предшествует описаниям S'LSTATEs, возвращенным менеджером драйвера. Код возврата, связанный с каждым значением S'LSTATE, является SQL_ERROR, если не указано иное. Если на одном столбце произошла ошибка, можно вызвать [S'LGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md) с *помощью DiagIdentifier* SQL_DIAG_COLUMN_NUMBER для определения столбца, на которую была допущена ошибка; и **S'LGetDiagField** можно вызвать с *помощью DiagIdentifier* SQL_DIAG_ROW_NUMBER, чтобы определить строку, содержащую этот столбец.  
  
 Для всех тех S'LSTATEs, которые могут вернуться SQL_SUCCESS_WITH_INFO или SQL_ERROR (кроме 01xxx S'LSTATEs), SQL_SUCCESS_WITH_INFO возвращается, если ошибка происходит на одном или нескольких, но не все строки многорычного операции, и SQL_ERROR возвращается, если ошибка происходит на однострокоперации.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, конкретное для водителя. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, правые усеченные|Строка или двоичные данные, возвращенные для столбца, привели к усечению непустого символа или неnull двоичных данных. Если это было значение строки, то оно было правильно усечено.|  
|01S01|Ошибка в строке|Ошибка произошла при извлечении одного или нескольких строк.<br /><br /> (Если это приложение ODBC 3 .x возвращается, когда приложение ODBC 3 *.x* работает с драйвером ODBC 2 *.x,* его можно игнорировать.)|  
|01S07|Фракционная усечение|Данные, возвращенные для столбца, были усечены. Для численных типов данных дробная часть числа была усечена. Для типов времени, меток времени и интервальных данных, содержащих временной компонент, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута типа ограниченного доступа|Значение данных столбца в наборе результатов не может быть преобразовано в тип данных, указанный *TargetType* в **S'LBindCol.**<br /><br /> Столбец 0 был связан с типом данных SQL_C_BOOKMARK, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен для SQL_UB_VARIABLE.<br /><br /> Столбец 0 был связан с типом данных SQL_C_VARBOOKMARK, и атрибут SQL_ATTR_USE_BOOKMARKS оператора не был установлен для SQL_UB_VARIABLE.|  
|07009|Недействительный индекс дескриптора|Драйвером был драйвер ODBC 2 *.x,* который не поддерживает **S'LExtendedFetch,** а номер столбца, указанный в привязке для столбца, был 0.<br /><br /> Колонка 0 была связана, и атрибут SQL_ATTR_USE_BOOKMARKS оператора был установлен на SQL_UB_OFF.|  
|08S01|Сбой связи|Связь между драйвером и источником данных, к которому был подключен драйвер, не сработала до завершения обработки функции.|  
|22001|Строковые данные, правые усеченные|Закладка переменной длины, возвращенная для столбца, была усечена.|  
|22002|Переменная переменная индикатора требуется, но не поставляется|Данные NULL были извлечены в колонку, *StrLen_or_IndPtr* которой, установленный **S'LBindCol** (или SQL_DESC_INDICATOR_PTR, установленные **S'LSetDescField** или **S'LSetDescRec)** был нулевым указателем.|  
|22003|Числовое значение вне диапазона|Возвращение численного значения в числовое или строку для одного или нескольких связанных столбцов привело бы к тому, что вся (в отличие от дробной) часть числа была бы усечена.<br /><br /> Для получения дополнительной информации в приложении D: Типы [данных см.](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md)|  
|22007|Недействительный формат дата-времени|Столбец символов в наборе результатов был привязан к структуре даты, времени или метки времени C, а значение в столбце было, соответственно, недействительной датой, временем или меткой времени.|  
|22012|Разделение на ноль|Значение из арифметического выражения было возвращено, что привело к разделению на ноль.|  
|22015|Переполниние поля интервала|Назначение от точного числа или интервала типа S'L к типу интервала C привело к потере значительных цифр в ведущем поле.<br /><br /> При извлечении данных в тип интервала C не было представлено значение типа S'L в типе интервала C.|  
|22018|Недействительное значение символов для спецификации литья|Столбец символа в наборе результатов был привязан к буферу символа C, а столбец содержал символ, для которого не было представления в наборе символов буфера.<br /><br /> Тип C был точным или приблизительным числом, временем даты или типом данных интервала; тип столбца s'L был типом данных символов; и значение в колонке не было действительным буквальным типа C.|  
|24 000|Недопустимое состояние курсора|*StatementHandle* находился в выполненном состоянии, но набор результатов не был связан с *statementHandle.*|  
|40001|Сбой сериализации|Сделка, в которой был выполнен вывод, была прекращена, чтобы предотвратить взаимоблокировку.|  
|40003|Завершение заявления неизвестно|Связанное соединение сбой во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, в соответствии с которой не было конкретного S'LSTATE и для которой не было определено конкретное осуществление СЗЛСТАТ. Сообщение об ошибке, возвращенное **S'LGetDiagRec** в * \*буфере MessageText,* описывает ошибку и ее причину.|  
|HY001|Ошибка распределения памяти|Водитель не смог выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка была включена для *StatementHandle*. Функция **S'LFetch** была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхенд** был вызван на *StatementHandle*. Затем функция **S'LFetch** была снова вызвана на *statementHandle*.<br /><br /> Или функция **S'LFetch** была вызвана, и перед завершением выполнения, **S'LCancel** или **S'LКансортхенд** был вызван в *StatementHandle* из другого потока в многопоточном приложении.|  
|HY010|Ошибка последовательности функций|(DM) Асинхронно функция выполнения была вызвана для ручки соединения, которая связана с *StatementHandle.* Эта асинхронная функция по-прежнему исполнялась, когда была вызвана функция **S'LFetch.**<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, или **S'LMoreResults** был вызван для *statementHandle* и вернулся SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до того, как данные были извлечены для всех потоковых параметров.<br /><br /> (DM) Указанное *statementHandle* не находилось в выполненном состоянии. Функция была вызвана без предварительного вызова **s'LExecDirect**, **S'LExecute** или функции каталога.<br /><br /> (DM) Асинхронно выполнение функции (не этот) был вызван для *StatementHandle* и по-прежнему выполнения, когда эта функция была вызвана.<br /><br /> (DM) **S'LExecute**, **S'LExecDirect**, **S'LBulkOperations**, или **S'LSetPos** был вызван для *statementHandle* и вернулся SQL_NEED_DATA. Эта функция была вызвана до отправки данных для всех параметров или столбцов данных.<br /><br /> (DM) **S'LFetch** был вызван для *statementHandle* после того, как **sLExtendedFetch** был вызван и до **s'LFreeStmt** с SQL_CLOSE вариант был вызван.|  
|HY013|Ошибка управления памятью|Вызов функции не может быть обработан, поскольку основные объекты памяти не могут быть доступны, возможно, из-за низких условий памяти.|  
|HY090|Недействительная длина строки или буфера|Атрибут SQL_ATTR_USE_BOOKMARK оператора был установлен для SQL_UB_VARIABLE, а столбец 0 был привязан к буферу, длина которого не была равна максимальной длине закладки для этого набора результатов. (Эта длина доступна в SQL_DESC_OCTET_LENGTH поле IRD и может быть получена по телефону **S'LDescribeCol**, **S'LColAttribute**, или **S'LGetDescfield**.)|  
|HY107|Значение строки вне диапазона|Значение, указанное в атрибуте SQL_ATTR_CURSOR_TYPE оператора, было SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное в атрибуте SQL_ATTR_KEYSET_SIZE оператора, превышало значение, указанное в атрибуте SQL_ATTR_ROW_ARRAY_SIZE оператора.|  
|HY117|Подключение приостанавливается из-за неизвестного состояния транзакции. Разрешены только отключить и прочитать только функции.|(DM) Для получения дополнительной информации о приостановленном состоянии, [см.](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|HYC00|Дополнительная функция не реализована|Драйвер или источник данных не поддерживает преобразование, указанное комбинацией *TargetType* в **S'LBindCol** и типом данных в соответствующем столбце.|  
|HYT00|Время ожидания истекло|Период тайм-аута запроса истек до того, как источник данных вернул запрошенный набор результатов. Период тайм-аута устанавливается через s'LSetStmtAttr, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Срок истечения времени подключения|Период тайм-аута соединения истек до того, как источник данных ответил на запрос. Период тайм-аута соединения устанавливается через **S'LSetConnectAttr,** SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) Драйвер, связанный с *StatementHandle,* не поддерживает функцию.|  
|IM017|Опрос отключен в асинхронном режиме уведомления|Всякий раз, когда используется модель уведомления, опрос отключается.|  
|IM018|Для завершения предыдущей асинхронной операции на этой ручке не был вызван **S'LCompleteAsync.**|Если предыдущий вызов функции на ручке возвращается SQL_STILL_EXECUTING и если режим уведомления включен, **s'LCompleteAsync** должен быть вызван на ручку, чтобы сделать пост-обработку и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **S'LFetch** возвращает следующий ряд в наборе результатов. Его можно назвать только при наличии набора результатов: то есть после вызова, который создает набор результатов, и до того, как курсор над набором результатов закрывается. Если какие-либо столбцы связаны, он возвращает данные в этих столбцах. Если приложение указало указатель на массив состояния строки или буфер, в котором можно вернуть количество строк, извлеченных, **S'LFetch** также возвращает эту информацию. Звонки на **S'LFetch** могут быть смешаны с вызовами на **S'LFetchScroll,** но не могут быть смешаны с вызовами на **S'LExtendedFetch.** Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/fetching-a-row-of-data.md)  
  
 Если приложение ODBC *.x* 3 *.x* работает с драйвером ODBC 2 *.x,* менеджер драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера драйвера менеджера драйвера драйвера для водителей, поддерживающего **SQLExtendedFetch** **S'LExtendedFetch.** **SQLFetch** Если драйвер ODBC 2 *.x* не поддерживает **S'LExtendedFetch,** менеджер драйвера драйвера драйвера **S'LFetch** звонит в **драйвер** ODBC 2 *.x,* который может получить только одну строку.  
  
 Для получения дополнительной информации в приложении G: Driver Guidelines for Backward Comatibility можно ознакомиться с [Block Cursors, Scrollable Cursors и обратной совместимости.](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md)  
  
## <a name="positioning-the-cursor"></a>Позиционирование Курсора  
 При создании набора результатов курсор позиционируется до начала набора результатов. **S'LFetch** получает следующий ряд. Это эквивалентно вызову **S'LFetchScroll** с *набором FetchOrientation,* чтобы SQL_FETCH_NEXT. Для получения дополнительной информации о курсорах [Block Cursors](../../../odbc/reference/develop-app/block-cursors.md) [см.](../../../odbc/reference/develop-app/cursors.md)  
  
 Атрибут SQL_ATTR_ROW_ARRAY_SIZE оператора определяет количество строк в строке. Если строка, извлеченная **в s'LFetch,** перекрывает конец набора результатов, **S'LFetch** возвращает частичный набор строк. То есть, если S и R - 1 больше, чем L, где S является стартовым рядом строки, извлеченной, R является размером рядов, а L является последним рядом в наборе результатов, то только первый L - S и 1 строка строки рядов действительны. Остальные строки пусты и имеют статус SQL_ROW_NOROW.  
  
 После возвращения **s'LFetch** текущая строка является первой строкой строки строки.  
  
 Правила, перечисленные в следующей таблице, описывают позиционирование курсора после звонка в **S'LFetch**на основе условий, перечисленных во второй таблице в этом разделе.  
  
|Условие|Первый ряд нового рядового набора|  
|---------------|-----------------------------|  
|Перед началом|1|  
|*CurrRowsetStart* \< =  *LastResultRow - RowsetSize*|*CurrRowsetStart* + *RowsetSize*|  
|*CurrRowsetStart* > *LastResultRow - RowsetSize*|После окончания|  
|После окончания|После окончания|  
  
 Если размер рядового изменяется между извлечений, это размер строки, который был использован при предыдущем извлечении.  
  
 Если размер рядового изменяется между извлечений, это размер строки, который был использован с новым извлечением.  
  
|Notation|Значение|  
|--------------|-------------|  
|Перед началом|Курсор блока расположен перед началом набора результатов. Если первая строка нового строки находится до начала набора результатов, **s'LFetch** возвращается SQL_NO_DATA.|  
|После окончания|Курсор блока расположен после окончания набора результатов. Если первая строка нового строки находится после окончания набора результатов, **s'LFetch** возвращается SQL_NO_DATA.|  
|*CurrRowsetStart*|Число первого ряда в текущем строке.|  
|*LastResultRow*|Число последней строки в наборе результатов.|  
|*RowsetSize*|Размер рядового набора.|  
  
 Например, предположим, что набор результатов имеет 100 строк, а размер рядов — 5. В следующей таблице показан рядии и код возврата, возвращенные **S'LFetch** для различных стартовых позиций.  
  
|Текущий набор строк|Код возврата|Новый ряд|- строки, извлеченные|  
|--------------------|-----------------|----------------|------------------------|  
|Перед началом|SQL_SUCCESS|От 1 до 5|5|  
|От 1 до 5|SQL_SUCCESS|От 6 до 10|5|  
|от 52 до 56|SQL_SUCCESS|от 57 до 61|5|  
|от 91 до 95|SQL_SUCCESS|от 96 до 100|5|  
|от 93 до 97|SQL_SUCCESS|от 98 до 100. Строки 4 и 5 массива статуса строки установлены для SQL_ROW_NOROW.|3|  
|от 96 до 100|SQL_NO_DATA|Отсутствует.|0|  
|от 99 до 100|SQL_NO_DATA|Отсутствует.|0|  
|После окончания|SQL_NO_DATA|Отсутствует.|0|  
  
## <a name="returning-data-in-bound-columns"></a>Возвращение данных в связанных столбцах  
 По мере того, как **S'LFetch** возвращает каждую строку, он помещает данные для каждого связанного столбца в буфер, связанный с этим столбцом. Если столбцы не связаны, **S'LFetch** не возвращает данные, но перемещает курсор блока вперед. Данные по-прежнему могут быть получены с помощью **S'LGetData**. Если курсор является многорычным курсором (т.е. SQL_ATTR_ROW_ARRAY_SIZE больше 1), **s'LGetData** можно **SQLGetInfo** вызвать только в том случае, если SQL_GD_BLOCK возвращается при вызове *с помощью InfoType* SQL_GETDATA_EXTENSIONS. (Для получения дополнительной информации, [см.](../../../odbc/reference/syntax/sqlgetdata-function.md)  
  
 Для каждого связанного столбца **подряд, S'LFetch** делает следующее:  
  
1.  Устанавливает буфер длины/индикатора для SQL_NULL_DATA и переходит к следующему столбцюку, если данные являются NULL. Если данные являются NULL и буфер длины/индикатора не был связан, **S'LFetch** возвращает S'LSTATE 22002 (переменный индикатор требуется, но не поставляется) для строки и переходит к следующему ряду. Информацию о том, как определить адрес буфера длины/индикатора, можно узнать в [s'LBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
     Если данные для столбца не являются NULL, **S'LFetch** переходит к шагу 2.  
  
2.  Если атрибут SQL_ATTR_MAX_LENGTH оператора установлен на ненулевое значение и столбец содержит символ или двоичные данные, данные усечены до SQL_ATTR_MAX_LENGTH байтов.  
  
    > [!NOTE]  
    >  Атрибут SQL_ATTR_MAX_LENGTH оператора предназначен для снижения сетевого трафика. Обычно он реализуется источником данных, который усечения данных, прежде чем вернуть его через сеть. Драйверы и источники данных не обязаны поддерживать его. Таким образом, чтобы гарантировать, что данные усечены до определенного размера, приложение должно выделить буфер такого размера и указать размер в аргументе *cbValueMax* в **S'LBindCol.**  
  
3.  Преобразует данные в тип, указанный *TargetType* в **S'LBindCol.**  
  
4.  Если данные были преобразованы в тип данных с переменной длиной, например символ или двоичную, **S'LFetch** проверяет, превышает ли длина данных длина буфера данных. Если длина данных символов (включая символ нулевого прекращения) превышает длину буфера данных, **S'LFetch** усечения данных по длине буфера данных заменьшит длину символа с нулевым прекращением. Затем он сводит на нет данные. Если длина двоичных данных превышает длину буфера данных, **S'LFetch** усечен ими до длины буфера данных. Длина буфера данных указана с *bufferLength* в **S'LBindCol**.  
  
     **SLFetch** никогда не усечения данных, преобразованных в типы данных с фиксированной длиной; он всегда предполагает, что длина буфера данных — это размер типа данных.  
  
5.  Помещает преобразованные (и, возможно, усеченные) данные в буфер данных. Информацию о том, как определить адрес буфера данных, можно узнать в материале «Buffer Addresses» в [s'LBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
6.  Помещает длину данных в буфер длины/индикатора. Если указатель индикатора и указатель длины были настроены на один и тот же буфер (как это делает вызов **в S'LBindCol),** длина записываются в буфер для достоверных данных, а SQL_NULL_DATA написанв в буфере для данных NULL. Если буфер длины/индикатора не был связан, **S'LFetch** не возвращает длину.  
  
    -   Для символов или двоичных данных это длина данных после преобразования и до усечения из-за слишком малого буфера данных. Если драйвер не может определить длину данных после преобразования, как это иногда бывает с длинными данными, он устанавливает длину, чтобы SQL_NO_TOTAL. Если данные были усечены из-за атрибута SQL_ATTR_MAX_LENGTH оператора, значение этого атрибута ставится в буфер длины/индикатора вместо фактической длины. Это связано с тем, что этот атрибут предназначен для усечения данных на сервере до преобразования, так что водитель не имеет возможности выяснить, что фактическая длина.  
  
    -   Для всех остальных типов данных это длина данных после преобразования; то есть, это размер типа, к которому были преобразованы данные.  
  
     Информацию о том, как определить адрес буфера длины/индикатора, можно узнать в [s'LBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
7.  Если данные усечены во время преобразования без потери значительных цифр (например, реальное число 1.234 усечено до целых 1 при преобразовании), **S'LFetch** возвращает S'LSTATE 01S07 (фракционная усечение) и SQL_SUCCESS_WITH_INFO. Если данные усечены из-за слишком большой длины буфера данных (например, строка "abcdef" помещена в буфер 4 байт), **S'LFetch** возвращает S'LSTATE 01004 (данные усечены) и SQL_SUCCESS_WITH_INFO. Если данные усечены из-за атрибута SQL_ATTR_MAX_LENGTH оператора, **S'LFetch** возвращается SQL_SUCCESS и не возвращает S'Lstate 01S07 (фракционная усечение) или S'LSTATE 01004 (данные усечены). Если данные усечены во время преобразования с потерей значительных цифр (например, если SQL_INTEGER значение, превышающее 100 000, были преобразованы в SQL_C_TINYINT), **S'LFetch** возвращает S'LSTATE 22003 (число вне диапазона) и SQL_ERROR (если размер рядового набора составляет 1) или SQL_SUCCESS_WITH_INFO (если размер рядов больше 1).  
  
 Содержимое связанного буфера данных и буфер длины/индикатора не определены, если **S'LFetch** или **S'LFetchScroll** не возвращаются SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
## <a name="row-status-array"></a>Массив статусов строк  
 Массив состояния строк используется для возвращения состояния каждой строки в строке. Адрес этого массива указан с атрибутом SQL_ATTR_ROW_STATUS_PTR оператора. Массив выделяется приложением и должен иметь столько элементов, сколько указано в атрибуте SQL_ATTR_ROW_ARRAY_SIZE оператора. Его значения устанавливаются **S'LFetch,** **S'LFetchScroll,** и **S'LBulkOperations** или **S'LSetPos** (за исключением случаев, когда они были вызваны после того, как курсор был расположен в **S'LExtendedFetch**). Если значение атрибута SQL_ATTR_ROW_STATUS_PTR оператора является нулевой указкой, эти функции не возвращают статус строки.  
  
 Содержимое буфера буфера статуса строки не определено, если **S'LFetch** или **S'LFetchScroll** не возвращаются SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Следующие значения возвращаются в массиве состояния строки.  
  
|Значение массива строки|Описание|  
|----------------------------|-----------------|  
|SQL_ROW_SUCCESS|Строка была успешно извлечена и не изменилась, так как она была в последний раз извлечена из этого набора результатов.|  
|SQL_ROW_SUCCESS_WITH_INFO|Строка была успешно извлечена и не изменилась, так как она была в последний раз извлечена из этого набора результатов. Тем не менее, предупреждение было возвращено о строке.|  
|SQL_ROW_ERROR|Ошибка произошла при извлечении строки.|  
|SQL_ROW_UPDATED,|Строка была успешно извлечена и изменилась с момента последнего извлечения из этого набора результатов. Если строка снова извлекается из этого набора результатов или обновляется **S'LSetPos,** статус изменяется на новый статус строки.|  
|SQL_ROW_DELETED|Строка была удалена с момента последнего извлечения из этого набора результатов.|  
|SQL_ROW_ADDED|Строка была вставлена **с помощью S'LBulkOperations**. Если строка снова извлекается из этого набора результатов или обновляется **S'LSetPos,** ее статус SQL_ROW_SUCCESS.|  
|SQL_ROW_NOROW|Строка перекрывала конец набора результатов, и не было возвращено строки, соответствующей этому элементу массива состояния строки.|  
  
 Для клавиатур, смешанных и динамических курсоров, если ключевое значение обновляется, ряд данных считается удаленным и добавлен атакжем новой строки.  
  
 Некоторые драйверы не могут обнаруживать обновления данных и поэтому не могут вернуть это значение. Чтобы определить, может ли драйвер обнаруживать обновления для восстановленных строк, приложение вызывает **s'LGetInfo** с опцией SQL_ROW_UPDATES.  
  
 **S'LFetch** может вернуть это значение только тогда, когда оно перемешивается с вызовами на **S'LFetchScroll.** Это происходит потому, что **S'LFetch** продвигается вперед через набор результатов и, когда он используется исключительно, не refetch каких-либо строк. Поскольку строки не переделываются, **S'LFetch** не обнаруживает изменения, внесенные в ранее извлеченные строки. Однако, если **s'LFetchScroll** позиционирует курсор перед тем, как используются ранее извлеченные строки, а для получения этих строк используется **S'LFetch, S'LFetch** может обнаружить любые изменения в этих строках. **SQLFetch**  
  
 Возвращается только по S'LBulkOperations. Не установлено **S'LFetch** или **S'LFetchScroll**.  
  
### <a name="rows-fetched-buffer"></a>Строки Fetched буфер  
 Полученные строки используются для возврата количества строк, извлеченных, включая строки, для которых никакие данные не были возвращены, поскольку ошибка произошла во время их извлечения. Другими словами, это количество строк, для которых значение в массиве состояния строки не SQL_ROW_NOROW. Адрес этого буфера указан с SQL_ATTR_ROWS_FETCHED_PTR атрибутом оператора. Буфер выделяется приложением. Он устанавливается **S'LFetch** и **S'LFetchScroll**. Если значение атрибута SQL_ATTR_ROWS_FETCHED_PTR оператора является нулевой указателем, эти функции не возвращают количество извлеченных строк. Чтобы определить число текущей строки в наборе результатов, приложение может вызвать **S'LGetStmtAttr** с SQL_ATTR_ROW_NUMBER атрибутом.  
  
 Содержимое извлеченных буферов строк не определено, если **S'LFetch** или **S'LFetchScroll** не возвращается SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, за исключением случаев возврата SQL_NO_DATA, и в этом случае значение в строках извлеченного буфера установлено до 0.  
  
### <a name="error-handling"></a>Обработка ошибок  
 Ошибки и предупреждения могут применяться к отдельным строкам или к всей функции. Для получения более подробной информации о диагностических [записях,](../../../odbc/reference/develop-app/diagnostics.md) см Диагностика и [S'LGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
#### <a name="errors-and-warnings-on-the-entire-function"></a>Ошибки и предупреждения на всей функции  
 Если ошибка применяется ко всей функции, например, s'Lstate HYT00 (Тайм-аут истек) или S'Lstate 24000 (недействительное состояние курсора), **S'LFetch** возвращает SQL_ERROR и применимый S'Lstate. Содержимое буферов строки не определено, а положение курсора остается неизменным.  
  
 Если предупреждение распространяется на всю функцию, **s'LFetch** возвращает SQL_SUCCESS_WITH_INFO и применимый S'Lstate. Записи состояния предупреждений, применимых ко всей функции, возвращаются до записей о состоянии, применимых к отдельным строкам.  
  
#### <a name="errors-and-warnings-in-individual-rows"></a>Ошибки и предупреждения в отдельных строках  
 Если ошибка (например, S'LSTATE 22012 (Разделение на ноль)) или предупреждение (например, S'Lstate 01004 (усеченные данные)) применяется к одной строке, **S'LFetch**делает следующее:  
  
-   Устанавливает соответствующий элемент массива состояния строки для SQL_ROW_ERROR для ошибок или SQL_ROW_SUCCESS_WITH_INFO для предупреждений.  
  
-   Добавляет нулевые или более записи о состоянии, содержащие S'LSTATEs для ошибки или предупреждения.  
  
-   Устанавливает поля строки и столбца в записях состояния. Если **S'LFetch** не может определить номер строки или столбца, он устанавливает это число на SQL_ROW_NUMBER_UNKNOWN или SQL_COLUMN_NUMBER_UNKNOWN, соответственно. Если запись состояния не применяется к определенному столбецу, **S'LFetch** устанавливает номер столбца для SQL_NO_COLUMN_NUMBER.  
  
 **S'LFetch** продолжает извлечения строки, пока он не принес все строки в строке. Он возвращает SQL_SUCCESS_WITH_INFO если ошибка не происходит в каждом ряду строки (не включая строки со статусом SQL_ROW_NOROW), и в этом случае он возвращает SQL_ERROR. В частности, если размер строки составляет 1 и в этой строке происходит ошибка, **s'LFetch** возвращает сярвые SQL_ERROR.  
  
 **S'LFetch** возвращает записи статуса в порядке номеров строки. То есть, он возвращает все записи статуса для неизвестных строк (если таковые имеется); затем он возвращает все записи статуса для первого ряда (если таковые имеется), а затем возвращает все записи статуса для второго ряда (если таковые имеется) и так далее. Записи статуса для каждой строки упорядочены в соответствии с обычными правилами для заказа записей о состоянии; для получения дополнительной информации, см. [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md)  
  
### <a name="descriptors-and-sqlfetch"></a>Дескрипторы и S'LFetch  
 В следующих разделах описывается, как **s'LFetch** взаимодействует с дескрипторами.  
  
#### <a name="argument-mappings"></a>Аргумент Картирование  
 Драйвер не устанавливает никаких полей дескриптора на основе аргументов **S'LFetch.**  
  
#### <a name="other-descriptor-fields"></a>Другие поля дескриптора  
 Следующие поля дескриптора используются **s'LFetch.**  
  
|Поле дескриптора|Desc.|Поле в|Установить через|  
|----------------------|-----------|--------------|-----------------|  
|SQL_DESC_ARRAY_SIZE|Ard|Верхний колонтитул|атрибут SQL_ATTR_ROW_ARRAY_SIZE оператора|  
|SQL_DESC_ARRAY_STATUS_PTR|Ird|Верхний колонтитул|атрибут SQL_ATTR_ROW_STATUS_PTR оператора|  
|SQL_DESC_BIND_OFFSET_PTR|Ard|Верхний колонтитул|атрибут SQL_ATTR_ROW_BIND_OFFSET_PTR оператора|  
|SQL_DESC_BIND_TYPE|Ard|Верхний колонтитул|Атрибут SQL_ATTR_ROW_BIND_TYPE оператора|  
|SQL_DESC_COUNT|Ard|Верхний колонтитул|*КолонкаНомер* **аргумента S'LBindCol**|  
|SQL_DESC_DATA_PTR|Ard|records|*Аргумент TargetValuePtr* **из S'LBindCol**|  
|SQL_DESC_INDICATOR_PTR|Ard|records|*StrLen_or_IndPtr* аргумент в **S'LBindCol**|  
|SQL_DESC_OCTET_LENGTH|Ard|records|*Аргумент БуферНая Длина* в **S'LBindCol**|  
|SQL_DESC_OCTET_LENGTH_PTR|Ard|records|*StrLen_or_IndPtr* аргумент в **S'LBindCol**|  
|SQL_DESC_ROWS_PROCESSED_PTR|Ird|Верхний колонтитул|атрибут SQL_ATTR_ROWS_FETCHED_PTR оператора|  
|SQL_DESC_TYPE|Ard|records|*Аргумент TargetType* в **S'LBindCol**|  
  
 Все полеи дескриптора также могут быть установлены с **помощью S'LSetDescField.**  
  
#### <a name="separate-length-and-indicator-buffers"></a>Буферы отдельной длины и индикатора  
 Приложения могут связывать один буфер или два отдельных буфера, которые могут быть использованы для удержания значений длины и индикатора. Когда приложение вызывает **S'LBindCol,** водитель устанавливает SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR поля ARD по тому же адресу, который передается в *StrLen_or_IndPtr* аргумент. Когда приложение вызывает **S'LSetDescfield** или **S'LSetDesccRec,** оно может установить эти два поля по разным адресам.  
  
 **S'LFetch** определяет, есть ли в приложении указаны буферы отдельной длины и индикатора. В этом случае, когда данные не являются NULL, **S'LFetch** устанавливает буфер индикатора до 0 и возвращает длину в буфер длины. Когда данные являются NULL, **S'LFetch** устанавливает буфер индикатора для SQL_NULL_DATA и не изменяет буфер длины.  
  
### <a name="code-example"></a>Пример кода  
 [См. S'LBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [S'LКолонки](../../../odbc/reference/syntax/sqlcolumns-function.md), [S'LGetData](../../../odbc/reference/syntax/sqlgetdata-function.md), и [S'LProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md).  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцовику в наборе результатов|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки оператора|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возвращение информации о столбце в наборе результатов|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение оператора S'L|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнение подготовленного заявления по S'L|[Функция «СЗЛВы»](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Получение блока данных или прокрутка набора результатов|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Закрытие курсора на выписке|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Получение части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращение числа столбцов набора результатов|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Подготовка выписки для исполнения|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справка aPI ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
