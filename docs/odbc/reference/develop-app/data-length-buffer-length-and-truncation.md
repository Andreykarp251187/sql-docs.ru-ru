---
title: Длина данных, длина буфера и усечение | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- data length [ODBC]
- truncating data [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 2825c6e7-b9ff-42fe-84fc-7fb39728ac5d
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 1ed2e5ca1fdaba97dde64329c5e8e1b692f43158
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63267747"
---
# <a name="data-length-buffer-length-and-truncation"></a>Длина данных, длина буфера и усечение
*Длина данных* является байтовая длина данных, так как он будет храниться в буфере данных приложения, не в том случае, поскольку оно хранится в источнике данных. Это различие очень важно, так как данные часто хранятся в различных типов в буфере данных, чем в источнике данных. Так что для данных, отправляемых в источнике данных, это байтовая длина данных перед преобразованием в тип источника данных. Для данных, извлекаемых из источника данных это байтовая длина данных после преобразования к типу буфера данных, и перед выполнением любой усечение.  
  
 Для данных фиксированной длины, например целое число или структура даты байтовая длина данных всегда является размер типа данных. В общем случае приложения выделить буфер данных такого размера, типа данных. Если приложение выделяет буфер меньшего размера, последствия не определено, так как драйвер предполагает буфера данных — это размер типа данных, а не вызывает усечение данных и не помещаются в буфер меньшего размера. Если приложение выделяет буфер большего размера, никогда не используется дополнительное пространство.  
  
 Для данных переменной длины, например символьных или двоичных данных важно понять, что байтовая длина данных отдельно от и часто отличается от длину буфера в байтах. Описывается связью эти два значения длины в [буферы](../../../odbc/reference/develop-app/buffers.md) раздел. Если байтовая длина данных превышает длину буфера в байтах, драйвер производит усечение данных выборки в длину в байтах буфера и возвращает значение SQL_SUCCESS_WITH_INFO с кодом SQLSTATE 01004 (данных). Тем не менее возвращенный байтовая длина представляет собой длину неусеченный данных.  
  
 Например предположим, что приложение выделяет 50 байт для буфера двоичных данных. Если драйвер имеет 10 байтов двоичных данных для возврата, она возвращает эти 10 байт в буфере. Байтовая длина данных — 10, и длину в байтах буфера — 50. Если драйвер 60 байтов двоичных данных для возврата, он производит усечение данных до 50 байт возвращает этих байтов в буфере и возвращает значение SQL_SUCCESS_WITH_INFO. Байтовая длина данных — 60 (длина перед усечением) и длину буфера в байтах по-прежнему равно 50.  
  
 Создается диагностическая запись создается для каждого столбца, усекается. Поскольку занять некоторое время для создания этих записей драйвера и приложения для их обработки, усечение может привести к снижению производительности. Как правило приложения можно избежать этой проблемы, выделив достаточно большие буферы, несмотря на то, что это не всегда возможно при работе с данные большой длины. При усечении данных, приложение может иногда увеличьте размер буфера и повторно извлечь данные; Это не так во всех случаях. Если происходит усечение при получении данных с помощью вызовов **SQLGetData**, приложения не должны вызывать **SQLGetData** для данных, которые уже были возвращены; Дополнительные сведения см. в разделе [начало Данные большого формата](../../../odbc/reference/develop-app/getting-long-data.md).
