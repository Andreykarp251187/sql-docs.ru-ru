---
title: Влияние транзакций на курсоры и подготовленные заявления Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- rolling back transactions [ODBC]
- committing transactions [ODBC]
- transactions [ODBC], rolling back
- cursors [ODBC], transaction commits or roll backs
- prepared statements [ODBC]
- transactions [ODBC], cursors
ms.assetid: 523e22a2-7b53-4c25-97c1-ef0284aec76e
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ef3cb4095410b8ccb03b0a138f65b8df2cfb1a4b
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81300474"
---
# <a name="effect-of-transactions-on-cursors-and-prepared-statements"></a>Влияние транзакций на курсоры и подготовленные инструкции
Совершение или откат транзакции оказывает следующее влияние на курсоры и планы доступа:  
  
-   Все курсоры закрыты, а планы доступа к подготовленным заявлениям об этом подключении удаляются.  
  
-   Все курсоры закрыты, а планы доступа к подготовленным заявлениям об этом подключении остаются нетронутыми.  
  
-   Все курсоры остаются открытыми, и планы доступа к подготовленным заявлениям об этом подключении остаются нетронутыми.  
  
 Например, предположим, что источник данных демонстрирует первое поведение в этом списке, наиболее ограничительное из этих поведений. Теперь предположим, что приложение делает следующее:  
  
1.  Устанавливает режим фиксации для ручного коммит.  
  
2.  Создает набор итоговых заказов на продажу по заявлению 1.  
  
3.  Создает набор результатов строк в заказе продаж по заявлению 2, когда пользователь выделяет этот заказ.  
  
4.  Вызовы **S'LExecute** для выполнения позиционированного оператора обновления, подготовленного в заявлении 3, когда пользователь обновляет строку.  
  
5.  Вызывает **S'LEndTran** для того чтобы зафиксировать позиционированное заявление обновления.  
  
 Из-за поведения источника данных, вызов в **S'LEndTran** в шаге 5 заставляет его закрыть курсоры на инструкции 1 и 2 и удалить план доступа по всем заявлениям. Приложение должно повторно выполнить инструкции 1 и 2, чтобы воссоздать наборы результатов и переподготовить инструкцию к оператору 3.  
  
 В режиме автоматического коммита функции, не связанные с транзакциями **s'LendTran:**  
  
-   **В** предыдущем **SQLExecDirect** примере вызов в **S'LExecute** в шаге 4 совершает транзакцию. Это приводит к тому, что источник данных закрывает курсоры на инструкции 1 и 2 и удаляет план доступа по всем утверждениям в этом соединении.  
  
-   **В** предыдущем примере можно предположить, что в 4 шаге приложение вызывает **S'LSetPos** с SQL_UPDATE опцией на выписке 2, вместо выполнения позиционированного оператора обновления по заявлению 3. **SQLSetPos** Это фиксирует транзакцию и заставляет источник данных закрывать курсоры на инструкции 1 и 2 и отбрасывает все планы доступа к этому соединению.  
  
-   **СЗЛКЛОКурсор** В предыдущем примере предположим, что, когда пользователь выделяет другой заказ продаж, приложение вызывает **S'LCloseCursor** по заявлению 2, прежде чем создать результат строк для нового заказа продаж. Вызов в **S'LCloseCursor** совершает заявление **SELECT,** создавшее набор строк результата и причиняет источник данных закрыть курсор на выписке 1, а затем отбрасывает все планы доступа на этом соединении.  
  
 Приложения, особенно приложения на основе экрана, в которых пользователь прокручивает набор результатов и обновляет или удаляет строки, должны быть осторожны, чтобы кодировать вокруг этого поведения.  
  
 Чтобы определить, как ведет себя источник данных при совершении или откате транзакции, приложение вызывает **s'LGetInfo** с SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR опций.
