---
title: Выполнение инструкции | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], executing
ms.assetid: e5f0d2ee-0453-4faf-b007-12978dd300a1
author: MightyPen
ms.author: genemi
ms.openlocfilehash: d95226e9d895bf78e15176744f651b7e830a1a10
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "67901346"
---
# <a name="executing-a-statement"></a>Выполнение инструкции
Существует четыре способа для выполнения инструкции, в зависимости от при компиляции (подготовлен), компонент database engine и кто определяет их:  
  
-   **Прямое выполнение** приложение определяет инструкцию SQL. Он является подготовленную и выполненную во время выполнения за один шаг.  
  
-   **Подготовленное выполнение** приложение определяет инструкцию SQL. Он является подготовленную и выполненную во время выполнения в отдельности. Инструкция может быть подготовлена один раз и выполняются несколько раз.  
  
-   **Процедуры** приложение можно определить и скомпилировать один или несколько инструкций SQL на этапе разработки, время и хранить эти инструкции в источнике данных, что и процедура. Процедура выполняется один или несколько раз во время выполнения. Приложение может перечислять существующие хранимые процедуры, с помощью функции работы с каталогами.  
  
-   **Функции работы с каталогами** разработчику драйверов создает функцию, которая возвращает набор предварительно определенных результатов. Обычно эта функция отправляет существующую инструкцию SQL или вызывает процедуру, созданную для этой цели. Функция выполняется один или несколько раз во время выполнения.  
  
 Определенной инструкции (которые определяются его дескриптора инструкции) может быть выполняться любое количество раз. Инструкция может быть выполнена с множеством разных инструкций SQL, или он может выполняться несколько раз с той же инструкции SQL. Например, следующий код использует же дескриптора инструкции (*hstmt1*) для получения и отображения таблиц в базе данных Sales. Затем он использует этот дескриптор данному методу получения столбцов таблицы, выбранной пользователем.  
  
```  
SQLHSTMT    hstmt1;  
SQLCHAR *   Table;  
  
// Create a result set of all tables in the Sales database.  
SQLTables(hstmt1, "Sales", SQL_NTS, "sysadmin", SQL_NTS, NULL, 0, NULL, 0);  
  
// Fetch and display the table names; then close the cursor.  
// Code not shown.  
  
// Have the user select a particular table.  
SelectTable(Table);  
  
// Reuse hstmt1 to create a result set of all columns in Table.  
SQLColumns(hstmt1, "Sales", SQL_NTS, "sysadmin", SQL_NTS, Table, SQL_NTS, NULL, 0);  
  
// Fetch and display the column names in Table; then close the cursor.  
// Code not shown.  
```  
  
 И в следующем коде показано использование одного дескриптора для многократного выполнения одной и той же инструкции для удаления строк из таблицы.  
  
```  
SQLHSTMT      hstmt1;  
SQLUINTEGER   OrderID;  
SQLINTEGER    OrderIDInd = 0;  
  
// Prepare a statement to delete orders from the Orders table.  
SQLPrepare(hstmt1, "DELETE FROM Orders WHERE OrderID = ?", SQL_NTS);  
  
// Bind OrderID to the parameter for the OrderID column.  
SQLBindParameter(hstmt1, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 5, 0,  
                  &OrderID, 0, &OrderIDInd);  
  
// Repeatedly execute hstmt1 with different values of OrderID.  
while ((OrderID = GetOrderID()) != 0) {  
   SQLExecute(hstmt1);  
}  
```  
  
 Для большое число драйверов выделение инструкций выполняется дорого, так что повторное использование одной и той же инструкции таким способом обычно более эффективно, чем освобождение существующих инструкций и выделение новых. Приложений, создающих результирующие наборы в операторе следует соблюдать осторожность закрыть курсор над результирующий набор до останавливаясь оператор; Дополнительные сведения см. в разделе [закрытие курсора](../../../odbc/reference/develop-app/closing-the-cursor.md).  
  
 Также повторное использование инструкций принудительно запускает приложение, чтобы избежать ограничений в некоторые драйверы количество инструкций, которые могут быть активны одновременно. Точное определение «активно», относящиеся к драйверу, но он часто ссылается на любая инструкция, подготовки или выполнения и по-прежнему имеет доступных результатов. Например, после **вставить** инструкция была подготовлена, она обычно рассматривается как активный; после **ВЫБЕРИТЕ** выполнения инструкции и курсор открыт, он обычно считается быть активным; После **CREATE TABLE** выполнения инструкции, обычно не считается активным.  
  
 Приложение определяет, сколько инструкций могут быть активны в одном соединении за один раз, вызвав **SQLGetInfo** с параметром SQL_MAX_CONCURRENT_ACTIVITIES. Приложение может использовать несколько активных инструкций, превышает этот предел, открыв несколько подключений к источнику данных; Поскольку соединения может потреблять много ресурсов, однако следует рассматривать воздействие на производительность.  
  
 Для приложений можно ограничить время, выделенное для инструкции для выполнения с помощью атрибута инструкции SQL_ATTR_QUERY_TIMEOUT. Если период ожидания истекает до источник данных возвращает результирующий набор, функция, выполняемая инструкция SQL возвращает SQLSTATE HYT00 (истекло время ожидания). По умолчанию есть отсутствие времени ожидания.  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Прямое выполнение](../../../odbc/reference/develop-app/direct-execution-odbc.md)  
  
-   [Подготовленное выполнение](../../../odbc/reference/develop-app/prepared-execution-odbc.md)  
  
-   [Процедуры](../../../odbc/reference/develop-app/procedures-odbc.md)  
  
-   [Пакеты инструкций SQL](../../../odbc/reference/develop-app/batches-of-sql-statements.md)  
  
-   [Выполнение функций каталога](../../../odbc/reference/develop-app/executing-catalog-functions.md)
