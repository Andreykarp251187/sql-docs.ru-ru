---
title: Выполнение заявления Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], executing
ms.assetid: e5f0d2ee-0453-4faf-b007-12978dd300a1
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: c3ce09809c896a4d1d9333da00367f972655f96b
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81305745"
---
# <a name="executing-a-statement"></a>Выполнение инструкции
Существует четыре способа выполнения оператора, в зависимости от того, когда они компилируются (подготовлены) движком базы данных и кто определяет их:  
  
-   **Прямое исполнение** Приложение определяет выписку s'L. Он готовится и выполняется во время выполнения в течение одного шага.  
  
-   **Подготовленное исполнение** Приложение определяет выписку s'L. Он готовится и выполняется во время выполнения в отдельные шаги. Заявление может быть подготовлено один раз и выполнено несколько раз.  
  
-   **Процедуры** Приложение может определить и компилировать одну или несколько инструкций s'L во время разработки и хранить эти утверждения на источнике данных в качестве процедуры. Процедура выполняется один или несколько раз во время выполнения. Приложение может перечислять доступные сохраненные процедуры с использованием функций каталога.  
  
-   **Функции каталога** Автор драйвера создает функцию, которая возвращает заранее определенный набор результатов. Как правило, эта функция представляет предопределенное заявление S'L или вызывает процедуру, созданную для этой цели. Функция выполняется один или несколько раз во время выполнения.  
  
 Конкретное заявление (как укажет сярлица оператора) может быть выполнено в любое количество раз. Заявление может быть выполнено с помощью различных различных инструкций S'L, или оно может быть выполнено повторно с той же инструкцией S'L. Например, следующий код использует ту же ручку оператора *(hstmt1)* для извлечения и отображения таблиц в базе данных sales. Затем он повторно использует эту ручку для извлечения столбцов в таблице, выбранной пользователем.  
  
```  
SQLHSTMT    hstmt1;  
SQLCHAR *   Table;  
  
// Create a result set of all tables in the Sales database.  
SQLTables(hstmt1, "Sales", SQL_NTS, "sysadmin", SQL_NTS, NULL, 0, NULL, 0);  
  
// Fetch and display the table names; then close the cursor.  
// Code not shown.  
  
// Have the user select a particular table.  
SelectTable(Table);  
  
// Reuse hstmt1 to create a result set of all columns in Table.  
SQLColumns(hstmt1, "Sales", SQL_NTS, "sysadmin", SQL_NTS, Table, SQL_NTS, NULL, 0);  
  
// Fetch and display the column names in Table; then close the cursor.  
// Code not shown.  
```  
  
 Следующий код показывает, как одна ручка используется для повторного выполнения одного и того же оператора для удаления строк из таблицы.  
  
```  
SQLHSTMT      hstmt1;  
SQLUINTEGER   OrderID;  
SQLINTEGER    OrderIDInd = 0;  
  
// Prepare a statement to delete orders from the Orders table.  
SQLPrepare(hstmt1, "DELETE FROM Orders WHERE OrderID = ?", SQL_NTS);  
  
// Bind OrderID to the parameter for the OrderID column.  
SQLBindParameter(hstmt1, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 5, 0,  
                  &OrderID, 0, &OrderIDInd);  
  
// Repeatedly execute hstmt1 with different values of OrderID.  
while ((OrderID = GetOrderID()) != 0) {  
   SQLExecute(hstmt1);  
}  
```  
  
 Для многих драйверов выделение инструкций является дорогостоящей задачей, поэтому повторное использование одного и того же оператора таким образом обычно более эффективно, чем освобождение существующих инструкций и выделение новых. Приложения, создающие наборы результатов в отчете, должны быть осторожны, чтобы закрыть курсор над результатом, установленным перед реистебрией оператора; для получения дополнительной информации, [см. Закрытие Курсор](../../../odbc/reference/develop-app/closing-the-cursor.md).  
  
 Повторное использование заявлений также заставляет приложение избежать ограничения в некоторых драйверах количества инструкций, которые могут быть активны в одно время. Точное определение "активный" специфичен для драйвера, но оно часто относится к любому заявлению, которое было подготовлено или выполнено и все еще имеет доступные результаты. Например, после подготовки заявления **INSERT,** как правило, считается активным; после выполнения оператора **SELECT** и открытия курсора, он обычно считается активным; после выполнения оператора **CREATE TABLE,** как правило, оно не считается активным.  
  
 Приложение определяет, сколько инструкций может быть активировано на одном подключении одновременно, позвонив в **s'LGetInfo** с SQL_MAX_CONCURRENT_ACTIVITIES опцией. Приложение может использовать более активные операторы, чем этот предел, открыв несколько подключений к источнику данных; однако, поскольку соединения могут быть дорогими, следует учитывать влияние на производительность.  
  
 Приложения могут ограничить время, отведенное для выполнения оператора с SQL_ATTR_QUERY_TIMEOUT атрибутом оператора. Если период тайм-аута истекает до того, как источник данных возвращает набор результатов, функция, исполняющая выписку S'L, возвращает S'LSTATE HYT00 (тайм-аут истек). По умолчанию время ожидания отсутствует.  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Прямое выполнение](../../../odbc/reference/develop-app/direct-execution-odbc.md)  
  
-   [Подготовленное выполнение](../../../odbc/reference/develop-app/prepared-execution-odbc.md)  
  
-   [Процедуры](../../../odbc/reference/develop-app/procedures-odbc.md)  
  
-   [Пакеты инструкций SQL](../../../odbc/reference/develop-app/batches-of-sql-statements.md)  
  
-   [Выполнение функций каталога](../../../odbc/reference/develop-app/executing-catalog-functions.md)
