---
title: Исполнение инструкции | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], executing
ms.assetid: e5f0d2ee-0453-4faf-b007-12978dd300a1
author: MightyPen
ms.author: genemi
ms.openlocfilehash: d95226e9d895bf78e15176744f651b7e830a1a10
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "67901346"
---
# <a name="executing-a-statement"></a>Выполнение инструкции
Существует четыре способа выполнения инструкции, в зависимости от того, когда они компилируются (подготавливаются) ядром СУБД и кто их определяет:  
  
-   **Прямое выполнение** Приложение определяет инструкцию SQL. Он подготавливается и выполняется во время выполнения за один шаг.  
  
-   **Подготовленное выполнение** Приложение определяет инструкцию SQL. Он подготавливается и выполняется во время выполнения в отдельных шагах. Инструкция может быть подготовлена и выполнена несколько раз.  
  
-   **Процедуры** Приложение может определить и скомпилировать одну или несколько инструкций SQL во время разработки и сохранить эти инструкции в источнике данных в виде процедуры. Процедура выполняется один или несколько раз во время выполнения. Приложение может перечислить доступные хранимые процедуры с помощью функций каталога.  
  
-   **Функции каталога** Средство записи драйверов создает функцию, которая возвращает предопределенный результирующий набор. Обычно эта функция отправляет предопределенную инструкцию SQL или вызывает процедуру, созданную для этой цели. Функция выполняется один или несколько раз во время выполнения.  
  
 Конкретная инструкция (определяемая ее маркером) может выполняться любое количество раз. Инструкция может быть выполнена с различными инструкциями SQL или многократно выполняться с той же инструкцией SQL. Например, следующий код использует один и тот же маркер инструкции (*hstmt1*) для извлечения и вывода таблиц в базе данных Sales. Затем этот маркер повторно используется для получения столбцов в таблице, выбранной пользователем.  
  
```  
SQLHSTMT    hstmt1;  
SQLCHAR *   Table;  
  
// Create a result set of all tables in the Sales database.  
SQLTables(hstmt1, "Sales", SQL_NTS, "sysadmin", SQL_NTS, NULL, 0, NULL, 0);  
  
// Fetch and display the table names; then close the cursor.  
// Code not shown.  
  
// Have the user select a particular table.  
SelectTable(Table);  
  
// Reuse hstmt1 to create a result set of all columns in Table.  
SQLColumns(hstmt1, "Sales", SQL_NTS, "sysadmin", SQL_NTS, Table, SQL_NTS, NULL, 0);  
  
// Fetch and display the column names in Table; then close the cursor.  
// Code not shown.  
```  
  
 В следующем примере кода показано, как один маркер используется для многократного выполнения той же инструкции для удаления строк из таблицы.  
  
```  
SQLHSTMT      hstmt1;  
SQLUINTEGER   OrderID;  
SQLINTEGER    OrderIDInd = 0;  
  
// Prepare a statement to delete orders from the Orders table.  
SQLPrepare(hstmt1, "DELETE FROM Orders WHERE OrderID = ?", SQL_NTS);  
  
// Bind OrderID to the parameter for the OrderID column.  
SQLBindParameter(hstmt1, 1, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 5, 0,  
                  &OrderID, 0, &OrderIDInd);  
  
// Repeatedly execute hstmt1 with different values of OrderID.  
while ((OrderID = GetOrderID()) != 0) {  
   SQLExecute(hstmt1);  
}  
```  
  
 Для многих драйверов операторы выделения являются дорогостоящей задачей, поэтому повторное использование той же инструкции таким способом обычно более эффективно, чем освобождение существующих инструкций и выделение новых. Приложения, создающие результирующие наборы в инструкции, должны быть внимательны для закрытия курсора над результирующим набором перед повторным выполнением инструкции. Дополнительные сведения см. [в разделе заключение курсора](../../../odbc/reference/develop-app/closing-the-cursor.md).  
  
 Повторное использование инструкций также заставляет приложение избежать ограничения в некоторых драйверах количества инструкций, которые могут быть активными за один раз. Точное определение "Active" зависит от драйвера, но часто оно относится к любой инструкции, которая была подготовлена или выполнена и по-прежнему имеет доступные результаты. Например, после подготовки инструкции **INSERT** обычно считается активной. После выполнения инструкции **SELECT** и до открытия курсора обычно считается активным. После выполнения инструкции **CREATE TABLE** она обычно не считается активной.  
  
 Приложение определяет, сколько инструкций может быть активно в одном соединении за один раз путем вызова **SQLGetInfo** с параметром SQL_MAX_CONCURRENT_ACTIVITIES. Приложение может использовать больше активных инструкций, чем это ограничение, открыв несколько соединений с источником данных; Однако, поскольку соединения могут быть дорогостоящими, следует учитывать воздействие на производительность.  
  
 Приложения могут ограничивать количество времени, выделенного для выполнения инструкции с помощью атрибута SQL_ATTR_QUERY_TIMEOUT оператора. Если время ожидания истекает до того, как источник данных возвратит результирующий набор, функция, которая исполняет инструкцию SQL, возвращает значение SQLSTATE HYT00 (время ожидания истекло). По умолчанию время ожидания отсутствует.  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Прямое выполнение](../../../odbc/reference/develop-app/direct-execution-odbc.md)  
  
-   [Подготовленное выполнение](../../../odbc/reference/develop-app/prepared-execution-odbc.md)  
  
-   [Процедуры](../../../odbc/reference/develop-app/procedures-odbc.md)  
  
-   [Пакеты инструкций SQL](../../../odbc/reference/develop-app/batches-of-sql-statements.md)  
  
-   [Выполнение функций каталога](../../../odbc/reference/develop-app/executing-catalog-functions.md)
