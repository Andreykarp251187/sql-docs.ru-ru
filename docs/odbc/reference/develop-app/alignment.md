---
title: Выравнивание | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 205cc3ff95dd60db215150f46ae894fbb99bd9ff
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81288609"
---
# <a name="alignment"></a>Выравнивание
Проблемы выравнивания в приложении ODBC обычно не отличаются от проблем с выравниванием в любом другом приложении. Это значит, что большинство приложений ODBC не имеют проблем с выравниванием. Штрафы за отсутствие согласования адресов зависят от оборудования и операционной системы и могут быть незначительными, как незначительное снижение производительности или как серьезная ошибка во время выполнения. Таким образом, приложения ODBC и переносимые приложения ODBC в частности должны быть аккуратными для правильного согласования данных.  
  
 Одним из примеров того, когда приложения ODBC сталкиваются с проблемами выравнивания, является выделение большого блока памяти и привязка различных частей этой памяти к столбцам в результирующем наборе. Скорее всего, это происходит, когда универсальное приложение должно определить форму результирующего набора во время выполнения, а также выделить и привязать память соответствующим образом.  
  
 Например, предположим, что приложение выполняет инструкцию **SELECT** , вводимых пользователем, и извлекает результаты из этой инструкции. Поскольку форма этого результирующего набора не известна при написании программы, приложение должно определить тип каждого столбца после создания результирующего набора и соответствующим образом привязать память. Самый простой способ сделать это — выделить большой блок памяти и привязать различные адреса в этом блоке к каждому столбцу. Для доступа к данным в столбце приложение приводит к преобразованию памяти, привязанной к этому столбцу.  
  
 На следующей диаграмме показан образец результирующего набора и способ привязки к нему блока памяти с использованием типа данных C по умолчанию для каждого типа данных SQL. Каждый «X» представляет один байт памяти. (В этом примере показаны только буферы данных, привязанные к столбцам. Это делается для простоты. В фактическом коде буферы длины и индикатора также должны быть согласованы.)  
  
 ![Привязка по умолчанию: тип данных C к типу данных SQL](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 Предполагая, что связанные адреса хранятся в массиве *адресов* , приложение использует следующие выражения для доступа к памяти, привязанной к каждому столбцу:  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 Обратите внимание, что адреса, привязанные к второму и третьему столбцам, начинаются с нечетных байтов и что адрес, привязанный к третьему столбцу, не делится на четыре, то есть на размер СДВОРД. На некоторых компьютерах это не будет проблемой; в других случаях это приведет к незначительному снижению производительности. по-прежнему это приведет к неустранимой ошибке во время выполнения. Лучшим решением будет выравнивание каждого привязанного адреса на естественной границе выравнивания. Если предположить, что это 1 для Учар, 2 для технологий и 4 для СДВОРД, это даст результат, показанный на следующем рисунке, где "X" представляет байт используемой памяти, а "O" представляет байт памяти, который не используется.  
  
 ![Привязка по естественной границе выравнивания](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 Хотя это решение не использует всю память приложения, оно не сталкивается с проблемами выравнивания. К сожалению, для реализации этого решения требуется значительное количество кода, так как каждый столбец должен быть согласован отдельно в соответствии с его типом. Более простое решение — выровнять все столбцы по размеру самой крупной границы выравнивания, которая равна 4 в примере, показанном на следующем рисунке.  
  
 ![Привязка по наиболее широкой границе выравнивания](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 Хотя это решение оставляет более крупные отверстия, код для его реализации является сравнительно простым и быстрым. В большинстве случаев это смещает оплату в неиспользуемую память. Пример использования этого метода см. [в разделе using SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md).
