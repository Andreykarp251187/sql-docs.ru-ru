---
title: Выравнивание | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: e4c86fd8fba66e6424b41fa4b80b42fc089e6d64
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63287448"
---
# <a name="alignment"></a>Выравнивание
Проблемы выравнивания в приложении ODBC, обычно не отличаются, чем в любом другом приложении. То есть большинство приложений ODBC имеют незначительных проблем с выравниванием. Наказания за не выравнивание адреса зависит от оборудования и операционной системы и может быть как значительные как небольшое уменьшение производительности или как фатальной ошибкой во время выполнения. Таким образом, приложения ODBC и переносимые приложения ODBC в частности, должны быть осторожность, чтобы выровнять данные должным образом.  
  
 Один пример того, когда приложения ODBC возникнуть проблемы выравнивания при их выделить большой блок памяти и привязать разные части памяти со столбцами в результирующий набор. Это часто случается при универсального приложения должна определить форму результирующего набора во время выполнения и выделять и привязать памяти соответствующим образом.  
  
 Например, предположим, что приложение выполняет **ВЫБЕРИТЕ** инструкции, введенный пользователем и извлекает результаты из этого оператора. Так, как форма этот результирующий набор неизвестен при записи программы, приложения необходимо определить тип каждого столбца, после создания результирующего набора и привязать памяти соответствующим образом. Самый простой способ сделать это — выделить большой блок памяти и привязать разные адреса в соответствующем блоке для каждого столбца. Доступ к данным в столбце, приложение приводит к памяти, привязанного к этому столбцу.  
  
 В примере ниже показан пример результата задать и как блок памяти может быть привязан к ней с помощью типа данных C по умолчанию для каждого типа данных SQL. Каждый «X» представляет единственный байт памяти. (Этот пример буферов данных, привязанных к столбцам. Это делается для простоты. В фактический код буфер длины/индикатора должны также быть выровнены.)  
  
 ![Привязка по умолчанию тип данных C к типу данных SQL](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 При условии, что связанные адреса хранятся в *адрес* массива, приложение использует следующие выражения для доступа к памяти, связанный с каждым столбцом:  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 Обратите внимание на то, что адреса к узлу второй и третий столбцы запустить на нечетных байт и не делится на четыре, который является размер SDWORD что адрес привязан в третий столбец. На некоторых компьютерах это не будет проблем; для других это вызовет небольшое уменьшение производительности; для по-прежнему других произойдет Неустранимая ошибка времени выполнения. Лучшим решением будет для выравнивания каждого привязанного адреса на его естественной границе выравнивания. При условии, что это 1 для UCHAR, 2 для ПОМЕХОЙ и 4 для SDWORD, это будет получен результат, показано на следующем рисунке, где «X» представляет байт памяти, который используется и «O» представляет байт памяти, который не используется.  
  
 ![Привязка по естественной границе выравнивания](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 Хотя это решение не использует всю память приложения, не возникало проблем выравнивания. К сожалению занимает значительный объем кода для реализации этого решения, так как каждый столбец должны быть выровнены по отдельности в соответствии с его типом. Более простым решением является выравнивание всех столбцов на размер наиболее широкой границе выравнивания, который является 4 в примере, показанном на следующем рисунке.  
  
 ![Привязка по наиболее широкой границе выравнивания](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 Несмотря на то, что это решение покидает бреши в системе большего размера, код для реализации его относительно простой и быстрый. В большинстве случаев это смещения штрафа, оплаченным в неиспользуемую память. Пример использования этого метода, см. в разделе [использование SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md).
