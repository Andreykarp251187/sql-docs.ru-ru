---
title: Выравнивание Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 205cc3ff95dd60db215150f46ae894fbb99bd9ff
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81288609"
---
# <a name="alignment"></a>Выравнивание
Проблемы выравнивания в приложении ODBC, как правило, ничем не отличаются от любых других приложений. То есть, большинство приложений ODBC имеют мало или нет проблем с выравниванием. Штрафы за несогласованность адресов варьируются в зависимости от аппаратного обеспечения и операционной системы и могут быть столь же незначительными, как незначительный штраф за производительность, или столь же серьезными, как фатальная ошибка в времени выполнения. Поэтому приложения ODBC, и портативные приложения ODBC, в частности, должны быть осторожны, чтобы выровнять данные должным образом.  
  
 Одним из примеров проблем с выравниванием приложений ODBC является выделение большого блока памяти и привязка различных частей этой памяти к столбиках в наборе результатов. Это, скорее всего, произойдет, когда генерированное приложение должно определить форму результата, установленного во время выполнения, и соответственно выделить и связать память.  
  
 Например, предположим, что приложение выполняет заявление **SELECT,** введенное пользователем, и получает результаты из этого оператора. Поскольку форма этого набора результатов неизвестна при написании программы, приложение должно определить тип каждого столбца после создания набора результатов и связать память соответствующим образом. Самый простой способ сделать это — выделить большой блок памяти и связать различные адреса в этом блоке с каждым столбцом. Чтобы получить доступ к данным в столбце, приложение отбрасывает память, связанную с этой колонкой.  
  
 На следующей диаграмме показан набор результатов выборки и то, как блок памяти может быть привязан к нему с помощью типа данных C по умолчанию для каждого типа данных S'L. Каждый "X" представляет собой один байт памяти. (Этот пример показывает только буферы данных, привязанные к столбцов. Это делается для простоты. В реальном коде буферы длины/индикатора также должны быть выровнены.)  
  
 ![Привязка по умолчанию: тип данных C к типу данных SQL](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 Предполагая, что связанные адреса хранятся в массиве *Адреса,* приложение использует следующие выражения для доступа к памяти, привязанной к каждому столбце:  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 Обратите внимание, что адреса, привязанные ко второй и третьей столбцов, начинаются на нечетных байтах и что адрес, связанный с третьим столбцом, не делится на четыре, т.е. размер SDWORD. На некоторых машинах это не будет проблемой; на других, это вызовет небольшое наказание производительности; на третьих, это вызовет фатальную ошибку времени выполнения. Лучшим решением было бы выравнивание каждого связанного адреса на его естественной границе выравнивания. Предполагая, что это 1 для UCHAR, 2 для SWORD, и 4 для SDWORD, это даст результат, показанный на следующей иллюстрации, где "X" представляет байт памяти, которая используется и "O" представляет байт памяти, которая не используется.  
  
 ![Привязка по естественной границе выравнивания](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 Хотя это решение не использует всю память приложения, оно не сталкивается с какими-либо проблемами выравнивания. К сожалению, для реализации этого решения требуется достаточное количество кода, так как каждый столбец должен быть выровнен индивидуально в соответствии с его типом. Более простым решением является выравнивание всех столбцов на размер самой большой границы выравнивания, которая составляет 4 в примере, показанном на следующей иллюстрации.  
  
 ![Привязка по наиболее широкой границе выравнивания](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 Хотя это решение оставляет большие дыры, код для его реализации является относительно простым и быстрым. В большинстве случаев это компенсирует штраф, уплаченный в неиспользованной памяти. Например, в этом методе можно [прописать с помощью S'LBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md).
