---
title: Имитация позиционированного обновления и инструкций Delete | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- positioned deletes [ODBC]
- data updates [ODBC], positioned update or delete
- row identifiers [ODBC]
- positioned updates [ODBC]
- updating data [ODBC], positioned update or delete
ms.assetid: b24ed59f-f25b-4646-a135-5f3596abc1a4
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 6d98d40ae24c68f90a304edb0293febfe76fac2c
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "62445896"
---
# <a name="simulating-positioned-update-and-delete-statements"></a>Моделирование инструкций позиционированного обновления и удаления
Если источник данных не поддерживает позиционированного обновления и удаления инструкций, драйвер может имитировать их. Например библиотеку курсоров ODBC имитирует позиционированного обновления и удаления. Общая стратегия для имитации инструкций позиционированного обновления и удаления является преобразование позиционированные инструкции для поиска из них. Это делается путем замены **WHERE CURRENT OF** предложение, с которой выполняется поиск **ГДЕ** предложение, определяющее текущую строку.  
  
 Например так как столбец CustID уникально идентифицирует каждую строку в таблице Customers, позиционированные инструкции удаления  
  
```  
DELETE FROM Customers WHERE CURRENT OF CustCursor  
```  
  
 могут быть преобразованы  
  
```  
DELETE FROM Customers WHERE (CustID = ?)  
```  
  
 Драйвер может использовать одно из следующих *идентификаторами строк* в **ГДЕ** предложение:  
  
-   Столбцы, значения которых служат для идентификации однозначно каждой строки в таблице. Например, вызов **SQLSpecialColumns** SQL_BEST_ROWID возвращает оптимальный столбец или набор столбцов, служащих этой цели.  
  
-   Псевдостолбцов, предоставляемые некоторые источники данных, для уникальной идентификации каждой строки. Их также можно получить путем вызова **SQLSpecialColumns**.  
  
-   Уникальный индекс, если он доступен.  
  
-   Все столбцы в результирующем наборе.  
  
 Только столбцы, которые драйвер следует использовать в **ГДЕ** предложение, он создает зависит от драйвера. К некоторым данным источников, определение идентификатора строки может оказаться затратным. Тем не менее его быстрее выполнить и гарантирует, что имитации инструкция обновляет или удаляет только одной строке. В зависимости от возможностей базовой СУБД с помощью идентификатора строки может быть затратной для настройки. Тем не менее его быстрее выполнить и гарантирует, что имитации инструкция обновляет или удаляет только одну строку. Возможность использовать все столбцы в результирующем наборе обычно гораздо проще настроить. Тем не менее он занимает больше времени для выполнения, и, если столбцы не однозначно идентифицировать строку, может привести к строк непреднамеренно обновляемой или удаляемой, особенно если список выбора для результата значение не содержит все столбцы, которые существуют в базовой таблице.  
  
 В зависимости от которого выше стратегий драйвер поддерживает, приложения можно выбрать, какие стратегии ему драйвер для использования с SQL_ATTR_SIMULATE_CURSOR атрибут инструкции. Несмотря на то, что может показаться странным для приложения на риск случайного обновления или удаления строки, приложение можно удалить этот риск, гарантируя, что столбцы в результирующем наборе однозначно определяют каждую строку в результирующем наборе. Это экономит усилия по необходимости делать это драйвер.  
  
 Если драйвер решил использовать идентификатор строки, он перехватывает **SELECT FOR UPDATE** инструкцию, которая создает результирующий набор. Если столбцы в списке выбора фактически не определяют строку, драйвер добавляет необходимые столбцы в конец списка выбора. Некоторые источники данных имеют один столбец, который всегда однозначно определяет строку, например столбец ROWID в Oracle; Если такой столбец доступен, драйвер использует его. В противном случае драйвер вызывает **SQLSpecialColumns** для каждой таблицы в **FROM** предложение для получения списка столбцов, которые однозначно определяют каждую строку. Общие ограничения, полученный в результате этот метод является, что курсор моделирование завершается неудачей, если имеется более одной таблицы в **FROM** предложение.  
  
 Независимо от того, как драйвер определяет строки, обычно удаляются **FOR UPDATE OF** предложение off **SELECT FOR UPDATE** инструкции перед их отправкой к источнику данных. **Для обновления из** предложение используется только для позиционировать update и delete. Источники данных, которые поддерживают не расположены обновления и инструкций delete обычно не поддерживают его.  
  
 Когда приложение отправляет позиционированного обновления или для выполнения команды DELETE, драйвер заменяет **WHERE CURRENT OF** предложение with **ГДЕ** предложение, содержащее идентификатор строки. Значения этих столбцов извлекаются из кэш, поддерживаемый драйвер для каждого столбца, в нем используются в **ГДЕ** предложение. После заменила драйвер **ГДЕ** предложение, оно отправляет инструкцию к источнику данных для выполнения.  
  
 Например предположим, что приложение отправляет следующую инструкцию, чтобы создать результирующий набор:  
  
```  
SELECT Name, Address, Phone FROM Customers FOR UPDATE OF Phone, Address  
```  
  
 Если приложение установило SQL_ATTR_SIMULATE_CURSOR для запроса гарантирует уникальность и если источник данных не поддерживает псевдо столбец, который всегда однозначно определяет строку, драйвер вызывает **SQLSpecialColumns** для Таблицы Customers, обнаруживает, что CustID — ключ к таблице Customers и добавляет его в список выбора и отделяет **FOR UPDATE OF** предложение:  
  
```  
SELECT Name, Address, Phone, CustID FROM Customers  
```  
  
 Если приложение не запросило гарантирует уникальность, драйвер удаляет только **FOR UPDATE OF** предложение:  
  
```  
SELECT Name, Address, Phone FROM Customers  
```  
  
 Предположим, приложение прокручивает из результирующего набора и отправляет инструкцию позиционированного обновления для выполнения, где Cust — имя курсора на результирующем наборе:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE CURRENT OF Cust  
```  
  
 Если приложение не запросило гарантирует уникальность, драйвер заменяет **ГДЕ** предложение и связывает параметр CustID на эту переменную в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE (CustID = ?)  
```  
  
 Если приложение не запросило гарантирует уникальность, драйвер заменяет **ГДЕ** предложения и имя, адрес и телефон параметры в этом предложении к переменным в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ?  
   WHERE (Name = ?) AND (Address = ?) AND (Phone = ?)  
```
