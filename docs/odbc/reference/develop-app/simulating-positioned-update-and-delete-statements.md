---
title: Моделирование позиционированных обновлений и удалений Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- positioned deletes [ODBC]
- data updates [ODBC], positioned update or delete
- row identifiers [ODBC]
- positioned updates [ODBC]
- updating data [ODBC], positioned update or delete
ms.assetid: b24ed59f-f25b-4646-a135-5f3596abc1a4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e1eb498a99180d145147e67c8955eeb7a0027024
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81301995"
---
# <a name="simulating-positioned-update-and-delete-statements"></a>Моделирование инструкций позиционированного обновления и удаления
Если источник данных не поддерживает позиционируемые операторы обновления и удаления, драйвер может имитировать их. Например, библиотека курсора ODBC имитирует позиционированные обновления и удаления инструкций. Общая стратегия моделирования позиционных обновлений и удалений заявлений заключается в преобразовании позиционированных инструкций в поисковые. Это делается путем замены положения **WHERE CURRENT OF** на пункт **WHERE,** который идентифицирует текущую строку.  
  
 Например, поскольку столбец CustID однозначно идентифицирует каждую строку в таблице Клиентов, позиционированная выписка об удалении  
  
```  
DELETE FROM Customers WHERE CURRENT OF CustCursor  
```  
  
 могут быть преобразованы в  
  
```  
DELETE FROM Customers WHERE (CustID = ?)  
```  
  
 Водитель может использовать один из следующих *идентификаторов строк* в пункте **WHERE:**  
  
-   Столбцы, значения которых служат для идентификации уникальной каждой строки в таблице. Например, вызов **S'LSpecialColumns** с SQL_BEST_ROWID возвращает оптимальный столбец или набор столбцов, которые служат этой цели.  
  
-   Псевдо-колонки, предоставляемые некоторыми источниками данных, с целью однозначной идентификации каждой строки. Они также могут быть извлечены, позвонив по **s'LSpecialColumns**.  
  
-   Уникальный индекс, если он доступен.  
  
-   Все столбцы в наборе результатов.  
  
 Какие именно столбцы водитель должен использовать в пункте **WHERE,** который он конструирует, зависит от драйвера. В некоторых источниках данных определение идентификатора строки может быть дорогостоящим. Тем не менее, это быстрее для выполнения и гарантирует, что смоделированные оператора обновления или удаления в большинстве одной строки. В зависимости от возможностей базового DBMS, использование идентификатора строки может быть дорогостоящим для настройки. Тем не менее, это быстрее для выполнения и гарантирует, что смоделированное заявление будет обновлять или удалять только одну строку. Возможность использования всех столбцов в наборе результатов обычно намного проще в настройке. Однако выполнение выполняется медленнее, и если столбцы не идентифицируют строку однозначно, может привести к непреднамеренному обновлению или удалению строк, особенно если список избранных для набора результатов не содержит всех столбцов, которые существуют в основной таблице.  
  
 В зависимости от того, какую из предыдущих стратегий поддерживает драйвер, приложение может выбрать, какую стратегию он хочет использовать с атрибутом SQL_ATTR_SIMULATE_CURSOR оператора. Хотя может показаться странным, что приложение рискует непреднамеренно обновить или удалить строку, приложение может удалить этот риск, гарантируя, что столбцы в наборе результатов однозначно идентифицируют каждую строку в наборе результатов. Это экономит водителю усилия того, чтобы сделать это.  
  
 Если драйвер выбирает идентификатор строки, он перехватывает заявление **SELECT FOR UPDATE,** создающее набор результатов. Если столбцы в списке избранных не идентифицируют строку эффективно, драйвер добавляет необходимые столбцы в конец списка выбора. Некоторые источники данных имеют один столбец, который всегда однозначно идентифицирует строку, например столбец ROWID в Oracle; если такая колонка доступна, драйвер использует это. В противном случае, водитель вызывает **S'LSpecialColumns** для каждой таблицы в пункте **FROM,** чтобы получить список столбцов, которые однозначно идентифицируют каждую строку. Общее ограничение, которое является результатом этого метода, состоит в том, что моделирование курсора завершается неудачей, если в пункте **FROM** есть несколько таблиц.  
  
 Независимо от того, как водитель определяет строки, он обычно лишает **положение ДЛЯ ОБНОВЛЕНИЕ** от заявления SELECT ДЛЯ **ОБНОВЛЕНИЕ** перед отправкой его в источник данных. **Положение ДЛЯ ОБНОВЛЕНИЕ** используется только с позиционированными утверждениями и удалениями. Источники данных, не поддерживающие позиционные обновления и удаления, как правило, не поддерживают его.  
  
 Когда приложение отправляет позиционированное обновление или удаление оператора для выполнения, драйвер заменяет положение **WHERE CURRENT OF** на положение **WHERE,** содержащее идентификатор строки. Значения этих столбцов извлекаются из кэша, поддерживаемого драйвером для каждого столбца, который он использует в оговорке **WHERE.** После того, как драйвер заменил положение **WHERE,** он отправляет заявление в источник данных для выполнения.  
  
 Например, предположим, что приложение отправляет следующее заявление для создания набора результатов:  
  
```  
SELECT Name, Address, Phone FROM Customers FOR UPDATE OF Phone, Address  
```  
  
 Если приложение установило SQL_ATTR_SIMULATE_CURSOR запросить гарантию уникальности, и если источник данных не предоставляет псевдоколонку, которая всегда однозначно идентифицирует строку, водитель вызывает **s'LSpecialColumns** для таблицы Клиентов, обнаруживает, что CustID является ключом к таблице Клиентов и добавляет это в выбранный список, и полосы **для обновления** пункта:  
  
```  
SELECT Name, Address, Phone, CustID FROM Customers  
```  
  
 Если приложение не запрашивало гарантию уникальности, водитель лишает только **положение ДЛЯ ОБНОВЛЕНИЕ:**  
  
```  
SELECT Name, Address, Phone FROM Customers  
```  
  
 Предположим, что приложение прокручивает набор результатов и отправляет следующее позиционированное утверждение обновления для выполнения, где Cust — это имя курсора по сравнению с набором результатов:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE CURRENT OF Cust  
```  
  
 Если приложение не запросило гарантию уникальности, драйвер заменяет положение **WHERE** и связывает параметр CustID с переменной в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE (CustID = ?)  
```  
  
 Если приложение не запрашивало гарантию уникальности, драйвер заменяет положение **WHERE** и связывает параметры имени, адреса и телефона в этом пункте с переменными в кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ?  
   WHERE (Name = ?) AND (Address = ?) AND (Phone = ?)  
```
