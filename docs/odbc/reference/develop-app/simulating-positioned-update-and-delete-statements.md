---
title: Имитация позиционированных инструкций UPDATE и DELETE | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- positioned deletes [ODBC]
- data updates [ODBC], positioned update or delete
- row identifiers [ODBC]
- positioned updates [ODBC]
- updating data [ODBC], positioned update or delete
ms.assetid: b24ed59f-f25b-4646-a135-5f3596abc1a4
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 85d7642620d510ebba050a3fbc4348898e070070
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "68107536"
---
# <a name="simulating-positioned-update-and-delete-statements"></a>Моделирование инструкций позиционированного обновления и удаления
Если источник данных не поддерживает инструкции позиционированного обновления и удаления, драйвер может имитировать их. Например, Библиотека курсоров ODBC моделирует позиционированные инструкции UPDATE и DELETE. Общая стратегия моделирования позиционированных инструкций UPDATE и DELETE заключается в преобразовании позиционированных операторов в поиск. Это делается путем замены предложения **WHERE CURRENT of** оператором поиска **WHERE** , определяющим текущую строку.  
  
 Например, поскольку столбец CustID однозначно определяет каждую строку в таблице Customers, инструкция позиционированного удаления  
  
```  
DELETE FROM Customers WHERE CURRENT OF CustCursor  
```  
  
 может быть преобразован в  
  
```  
DELETE FROM Customers WHERE (CustID = ?)  
```  
  
 Драйвер может использовать один из следующих *идентификаторов строк* в предложении **WHERE** :  
  
-   Столбцы, значения которых служат для идентификации уникальной каждой строки в таблице. Например, вызов **SQLSpecialColumns** с SQL_BEST_ROWID Возвращает оптимальный столбец или набор столбцов, которые служат для этой цели.  
  
-   Псевдо-столбцы, предоставляемые некоторыми источниками данных, предназначенные для уникальной идентификации каждой строки. Их также можно получить, вызвав **SQLSpecialColumns**.  
  
-   Уникальный индекс, если он доступен.  
  
-   Все столбцы в результирующем наборе.  
  
 В точности те столбцы, которые драйвер должен использовать в предложении **WHERE** , зависит от драйвера. В некоторых источниках данных определение идентификатора строки может быть дорогостоящим. Однако быстрее выполнять и гарантирует, что смоделированный оператор обновляет или удаляет не более одной строки. В зависимости от возможностей базовой СУБД использование идентификатора строки может быть дорогостоящим для настройки. Однако быстрее выполнять и гарантирует, что смоделированная инструкция будет обновлять или удалять только одну строку. Возможность использования всех столбцов в результирующем наборе обычно намного проще в настройке. Однако медленный запуск и, если столбцы не определяют уникальную строку, могут привести к непреднамеренному обновлению или удалению строк, особенно если список выборки для результирующего набора не содержит все столбцы, существующие в базовой таблице.  
  
 В зависимости от того, какие из предыдущих стратегий поддерживает драйвер, приложение может выбрать стратегию, которую драйвер хочет использовать с атрибутом инструкции SQL_ATTR_SIMULATE_CURSOR. Несмотря на то, что приложение может показаться нечетным, чтобы исключить непреднамеренное обновление или удаление строки, приложение может удалить этот риск, убедившись, что столбцы в результирующем наборе уникально идентифицируют каждую строку в результирующем наборе. При этом драйвер сохраняет усилия.  
  
 Если драйвер выбирает использование идентификатора строки, он перехватывает инструкцию **SELECT для Update** , которая создает результирующий набор. Если столбцы в списке выборки не выполняют неэффективное указание строки, драйвер добавляет необходимые столбцы в конец списка выбора. Некоторые источники данных имеют один столбец, который всегда однозначно определяет строку, например столбец ROWID в Oracle; Если такой столбец доступен, драйвер использует его. В противном случае драйвер вызывает **SQLSpecialColumns** для каждой таблицы в предложении **from** для получения списка столбцов, уникально идентифицирующих каждую строку. Общее ограничение, полученное в результате этого метода, заключается в том, что моделирование курсора завершается ошибкой, если в предложении **from** имеется несколько таблиц.  
  
 Независимо от того, как драйвер определяет строки, обычно перед отправкой в источник данных выдает предложение **for** **Update.** Предложение **for Update of** используется только с позиционированными инструкциями UPDATE и DELETE. Источники данных, которые не поддерживают инструкции позиционированного обновления и удаления, обычно не поддерживают их.  
  
 Когда приложение отправляет инструкцию позиционированного обновления или удаления для выполнения, драйвер заменяет предложение **WHERE CURRENT of** предложением **WHERE** , содержащим идентификатор строки. Значения этих столбцов извлекаются из кэша, поддерживаемого драйвером для каждого столбца, который он использует в предложении **WHERE** . После того как драйвер заменит предложение **WHERE** , он отправляет инструкцию в источник данных для выполнения.  
  
 Например, предположим, что приложение отправляет следующую инструкцию для создания результирующего набора:  
  
```  
SELECT Name, Address, Phone FROM Customers FOR UPDATE OF Phone, Address  
```  
  
 Если приложение установило SQL_ATTR_SIMULATE_CURSOR для запроса гарантии уникальности и если источник данных не предоставляет псевдо-столбец, который всегда уникально идентифицирует строку, драйвер вызывает **SQLSpecialColumns** для таблицы Customers, обнаруживает, что CustID является ключом к таблице Customers и добавляет его в список выбора, и предлагает предложение **for Update** предложения.  
  
```  
SELECT Name, Address, Phone, CustID FROM Customers  
```  
  
 Если приложение не запросило гарантию уникальности, драйвер будет разменять только предложение **for Update** .  
  
```  
SELECT Name, Address, Phone FROM Customers  
```  
  
 Предположим, что приложение прокручивается по результирующему набору и отправляет следующую инструкцию позиционированного обновления для выполнения, где Cust — это имя курсора над результирующим набором:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE CURRENT OF Cust  
```  
  
 Если приложение не запросило гарантию уникальности, драйвер заменяет предложение **WHERE** и привязывает параметр CustID к переменной в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE (CustID = ?)  
```  
  
 Если приложение не запросило гарантию уникальности, драйвер заменяет предложение **WHERE** и привязывает параметры Name, Address и Phone в этом предложении к переменным в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ?  
   WHERE (Name = ?) AND (Address = ?) AND (Phone = ?)  
```
