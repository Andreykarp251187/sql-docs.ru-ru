---
title: Блок и прокрутки Курсоры Совместимость для ODBC 3.x Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- compatibility [ODBC], cursors
- backward compatibility [ODBC], cursors
- SQLExtendedFetch function [ODBC], block cursors
- cursors [ODBC], compatibility issues
- SQLFetchScroll function [ODBC], block cursors
ms.assetid: 82f6cf68-cfde-4417-9788-d6382ca14bf8
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: c526eff6e19014c923f05ad91551a7d7c66f5294
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306345"
---
# <a name="block-cursors-scrollable-cursors-and-backward-compatibility-for-odbc-3x-applications"></a>Блочные курсоры, прокручиваемые курсоры и обратная совместимость для приложений ODBC 3.x
Существование как **S'LFetchScroll,** так и **S'LExtendedFetch** представляет собой первый четкий раскол в ODBC между интерфейсом прикладного программирования (API), который представляет собой набор функций, которые вызывает приложение, и интерфейсом поставщика услуг (SPI), который является набором функций, реализуемых драйвером. Этот сплит необходим, чтобы сбалансировать требование в ODBC *3.x*, который использует **S'LFetchScroll**, чтобы соответствовать стандартам и быть совместимым с ODBC *2.x*, который использует **S'LExtendedFetch**.  
  
 API ODBC *3.x,* который представляет собой набор функций, которые вызывает приложение, включает в себя **S'LFetchScroll** и связанные с ними атрибуты оператора. ODBC *3.x* SPI, который представляет собой набор функций, реализуемых драйвером, включает в себя **S'LFetchScroll**, **S'LExtendedFetch**, и связанные атрибуты оператора. Поскольку ODBC формально не обеспечивает соблюдение этого разделения между API и SPI, приложения ODBC *3.x* могут вызывать **s'LExtendedFetch** и связанные с ними атрибуты оператора. Тем не менее, нет никаких оснований для приложений ODBC *3.x* для этого. Для получения дополнительной информации об AI [ODBC Architecture](../../../odbc/reference/odbc-architecture.md)и SPI см.  
  
 Для получения информации о том, как карты менеджера драйверов ODBC *3.x* звонят в драйверы ODBC *3.x* *2.x* и ODBC *3.x,* а какие функции и выписки следует реализовать для блокируемых и прокрутковых курсоров, см., [что водитель делает](../../../odbc/reference/appendixes/what-the-driver-does.md) в приложении G: Руководящие принципы для отсталой совместимости.  
  
 В следующей таблице кратко излагаются функции и приписываемые функции, которые приложение ODBC *3.x* следует использовать с помощью блокируемых и прокрутительных курсоров. Он также перечисляет изменения между ODBC *2.x* и ODBC *3.x* в этой области, что ODBC *3.x* приложения должны быть осведомлены о том, чтобы быть совместимым с драйверами ODBC *2.x.*  
  
|Функция или<br /><br /> атрибут инструкции|Комментарии|  
|-----------------------------------------|--------------|  
|SQL_ATTR_FETCH_BOOKMARK_PTR|Очки на закладку для использования с **S'LFetchScroll**.<br /><br /> Когда приложение устанавливает это в драйвере ODBC *2.x,* это должно указывать на закладку с фиксированной длиной.|  
|SQL_ATTR_ROW_STATUS_PTR|Очки на массиве статуса строки, заполненные **S'LFetch,** **S'LFetchScroll,** **S'LBulkOperations,** и **S'LSetPos.**<br /><br /> Если приложение устанавливает это в драйвере ODBC *2.x* и вызывает **s'LBulkOperation** с *операцией* SQL_ADD прежде чем вызвать **S'LFetchScroll**, **S'LFetch**, или **S'LExtendedFetch**, S'LSTATE HY011 (атрибут не может быть установлен сейчас) возвращается.<br /><br /> Когда приложение вызывает **S'LFetch** в драйвере ODBC *2.x,* **S'LFetch** отображается на **карту s'LExtendedFetch** и, следовательно, возвращает значения в этом массиве.|  
|SQL_ATTR_ROWS_FETCHED_PTR|Указывает на буфер, в котором **S'LFetch** и **S'LFetchScroll** возвращают количество строк, извлеченных.<br /><br /> Когда приложение вызывает **S'LFetch** в драйвере ODBC *2.x,* **S'LFetch** отображается на **карту s'LExtendedFetch** и, следовательно, возвращает значение в этом буфере.|  
|SQL_ATTR_ROW_ARRAY_SIZE|Устанавливает размер рядового набора.<br /><br /> Если приложение вызывает **S'LBulkOperations** с *операцией* SQL_ADD в драйвере ODBC *2.x,* SQL_ROWSET_SIZE будет использоваться для вызова, а не SQL_ATTR_ROW_ARRAY_SIZE, потому что вызов отображается в **S'LSetPos** с *операцией* SQL_ADD, которая использует SQL_ROWSET_SIZE.<br /><br /> Вызов **S'LSetPos** с *операцией* SQL_ADD или **S'LExtendedFetch** в драйвере ODBC *2.x* использует SQL_ROWSET_SIZE.<br /><br /> Вызов **S'LFetch** или **S'LFetchScroll** в драйвере ODBC *2.x* использует SQL_ATTR_ROW_ARRAY_SIZE.|  
|**СЗЛБалКОперации**|Выполняет операции вставки и закладки. Когда **s'LBulkOperations** с *операцией* SQL_ADD вызывается в драйвере ODBC *2.x,* он отображается на **s'LSetPos** с *операцией* SQL_ADD. Ниже приведены детали реализации:<br /><br /> - При работе с драйвером ODBC *2.x* приложение должно использовать только неявно выделенный ARD, связанный с *StatementHandle;* он не может выделить другой ARD для добавления строк, поскольку явные операции дескриптора не поддерживаются в драйвере ODBC *2.x.* Для привязки к ARD, а не к ARD, а не к **СЗЛСетДескФилду** или **S'LSetDesccRec,** необходимо использовать **приложение s'LBindCol.**<br />- При вызове драйвера ODBC *3.x* приложение может вызвать **s'LBulkOperations** с *помощью операции* SQL_ADD, прежде чем звонить в **S'LFetch** или **S'LFetchScroll.** При вызове драйвера ODBC *2.x,* приложение должно позвонить в **S'LFetchScroll,** прежде чем вызывать **S'LBulkOperations** с операцией SQL_ADD.|  
|**SQLFetch**|Возвращает следующий ряд. Ниже приведены детали реализации:<br /><br /> - Когда приложение вызывает **S'LFetch** в драйвере ODBC *2.x,* оно отображается на **карту в S'LExtendedFetch.**<br />- Когда приложение вызывает **S'LFetch** в драйвере ODBC *3.x,* оно возвращает количество строк, указанных в атрибуте SQL_ATTR_ROW_ARRAY_SIZE оператора.|  
|**SQLFetchScroll**|Возвращает указанный ряд. Ниже приведены детали реализации:<br /><br /> - Когда приложение вызывает **S'LFetchScroll** в драйвере ODBC *2.x,* оно возвращает S'Lstate 01S01 (Ошибка в строке) перед каждой ошибкой, которая применяется к одной строке. Он делает это только потому, что менеджер драйверов ODBC *3.x* отображает это на **S'LExtendedFetch** и **S'LExtendedFetch** возвращает этот S'Lstate. Когда приложение вызывает **S'LFetchScroll** в драйвере ODBC *3.x,* оно никогда не возвращает S'Lstate 01S01 (Ошибка в строке).<br />- Когда приложение вызывает **S'LFetchScroll** в драйвере ODBC *2.x* с *набором FetchOrientation,* чтобы SQL_FETCH_BOOKMARK, аргумент *FetchOffset* должен быть установлен на 0. S'LSTATE HYC00 (необязательная функция не реализована) возвращается, если смещенная закладка припопыткает с драйвером ODBC *2.x.*|  
  
> [!NOTE]  
>  Приложения ODBC *3.x* не должны использовать атрибут **SQL_ROWSET_SIZE** оператора. Вместо этого они должны использовать **s'LFetchScroll** и атрибут SQL_ATTR_ROW_ARRAY_SIZE оператора. Приложения ODBC *3.x* не должны использовать **S'LSetPos** с *операцией* SQL_ADD, а должны использовать **S'LBulkOperations** с *операцией* SQL_ADD.
