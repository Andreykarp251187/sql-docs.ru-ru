---
title: Курсоры Keyset-Driven Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- keyset-driven cursors [ODBC]
- cursors [ODBC], key-set driven
ms.assetid: 01769f43-1d9c-4685-84fa-15a6465335e9
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 814fca7d48f50aab51b6b4f7e34835be8c412e9c
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306209"
---
# <a name="keyset-driven-cursors"></a>Управляемые ключевым набором курсоры
Курсор, управляемый ключом, находится между статическим и динамическим курсором в его способности обнаруживать изменения. Так же как статический курсор, он не всегда обнаруживает изменения, внесенные в членство и порядок элементов результирующего набора. Как и динамический курсор, он обнаруживает изменения значений строк в наборе результатов (при условии уровня изоляции транзакции, установленного атрибутом SQL_ATTR_TXN_ISOLATION соединения).  
  
 При открытии курсора с инициативой ключа он сохраняет ключи для всего набора результатов; это фиксирует очевидное членство и порядок набора результатов. Когда курсор прокручивает набор результатов, он использует клавиши в этом *наборе ключей* для получения текущих значений данных для каждой строки. Например, предположим, что курсор с ключами получает строку, а другое приложение обновляет эту строку. Если курсор повторно использует строку, значения, которые он видит, являются новыми, поскольку он повторно использовал строку, используя свой ключ. Из-за этого курсоры, управляемые ключами, всегда обнаруживают изменения, внесенные самими и другими.  
  
 Когда курсор пытается получить строку, которая была удалена, эта строка отображается как "дыра" в наборе результатов: ключ для строки существует в наборе ключей, но строка больше не существует в наборе результатов. Если значения ключей в строке обновляются, строка считается удаленной, а затем вставленной, поэтому такие строки также отображаются как отверстия в наборе результатов. В то время как курсор, управляемый клавиатурой, всегда может обнаруживать строки, удаленные другими, он может дополнительно удалить клавиши для строк, которые он удаляет из набора ключей. Курсоры, управляемые keyset, которые делают это, не могут обнаружить свои собственные удаления. Обнаруживает ли определенный курсор клавиатуры свои собственные удаления через опцию SQL_STATIC_SENSITIVITY в **S'LGetInfo.**  
  
 Строки, вставленные другими, никогда не видны курсору с помощью клавиши, поскольку в наборе ключей нет ключей для этих строк. Тем не менее, курсор, управляемый ключом, может дополнительно добавить клавиши для строк, которые он вставляет к клавиатуре. Курсоры, управляемые Keyset, которые делают это, могут обнаруживать свои собственные вставки. Сообщается, обнаруживает ли определенный курсор клавиатура свои собственные вставки через опцию SQL_STATIC_SENSITIVITY в **S'LGetInfo.**  
  
 Массив состояния строки, указанный атрибутом SQL_ATTR_ROW_STATUS_PTR оператора, может содержать SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO или SQL_ROW_ERROR для любой строки. Он возвращает SQL_ROW_UPDATED, SQL_ROW_DELETED или SQL_ROW_ADDED для строк, которые он обнаруживает как обновленные, удаленные или вставленные.  
  
 Курсоры, управляемые клавиатурой, обычно реализуются путем создания временной таблицы, содержащей ключи для каждой строки в наборе результатов. Поскольку курсор должен также определить, были ли обновлены строки, эта таблица также обычно содержит столбец с информацией о строках версий.  
  
 Чтобы прокрутить исходный набор, курсор, управляемый ключом, открывает статический курсор над временной таблицей. Для получения строки в исходном наборе курсор сначала извлекает соответствующий ключ из временной таблицы, а затем извлекает текущие значения для строки. При использовании курсоров блоков курсор должен получить несколько клавиш и строк.
