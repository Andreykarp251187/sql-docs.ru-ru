---
description: Подготовленное выполнение ODBC
title: Подготовленное выполнение ODBC | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- prepared execution [ODBC]
- SQL statements [ODBC], prepared execution
- SQL statements [ODBC], executing
ms.assetid: f08c8a98-31ee-48b2-9dbf-6f31c2166dbb
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 6141af2cde7106419ab1eb68f86d5817f055aab2
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "88465746"
---
# <a name="prepared-execution-odbc"></a>Подготовленное выполнение ODBC
Подготовленное выполнение является эффективным способом выполнения инструкции более одного раза. Инструкция сначала компилируется или *подготовлена* в план доступа. Затем план доступа выполняется один или несколько раз позже. Дополнительные сведения о планах доступа см. [в разделе Обработка инструкции SQL](../../../odbc/reference/processing-a-sql-statement.md).  
  
 Подготовленное выполнение обычно используется вертикальными и пользовательскими приложениями для многократного выполнения той же параметризованной инструкции SQL. Например, следующий код подготавливает инструкцию для обновления цен различных частей. Затем инструкция выполняется несколько раз с различными значениями параметров каждый раз.  
  
```  
SQLREAL       Price;  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0, PriceInd = 0;  
  
// Prepare a statement to update salaries in the Employees table.  
SQLPrepare(hstmt, "UPDATE Parts SET Price = ? WHERE PartID = ?", SQL_NTS);  
  
// Bind Price to the parameter for the Price column and PartID to  
// the parameter for the PartID column.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_FLOAT, SQL_REAL, 7, 0,  
                  &Price, 0, &PriceInd);  
SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 10, 0,  
                  &PartID, 0, &PartIDInd);  
  
// Repeatedly execute the statement.  
while (GetPrice(&PartID, &Price)) {  
   SQLExecute(hstmt);  
}  
```  
  
 Подготовленное выполнение выполняется быстрее, чем прямое выполнение операторов, выполняемых более одного раза, в основном потому, что инструкция компилируется только один раз; операторы, выполняемые напрямую, компилируются каждый раз, когда они выполняются. Подготовленное выполнение также позволяет сократить сетевой трафик, поскольку драйвер может отправить идентификатор плана доступа в источник данных каждый раз, когда выполняется инструкция, а не всю инструкцию SQL, если источник данных поддерживает идентификаторы планов доступа.  
  
 Приложение может получить метаданные для результирующего набора после подготовки инструкции и перед ее выполнением. Однако возвращение метаданных для подготовленных, невыполненных инструкций требует больших затрат на некоторые драйверы и их следует избегать по возможности взаимодействия с приложениями, если это возможно. Дополнительные сведения см. в разделе [метаданные результирующего набора](../../../odbc/reference/develop-app/result-set-metadata.md).  
  
 Не следует использовать подготовленное выполнение для инструкций, исполняемых один раз. Для таких инструкций это несколько медленнее, чем прямое выполнение, так как требует дополнительного вызова функции ODBC.  
  
> [!IMPORTANT]  
>  Фиксация или откат транзакции путем явного вызова **SQLEndTran** или работы в режиме автоматической фиксации приводит к тому, что некоторые источники данных удаляют планы доступа для всех инструкций в соединении. Дополнительные сведения см. в разделе Параметры SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR в описании функции [SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) .  
  
 Чтобы подготовить и выполнить инструкцию, приложение:  
  
1.  Вызывает **SQLPrepare** и передает ему строку, содержащую инструкцию SQL.  
  
2.  Задает значения любых параметров. Фактически параметры можно задать до или после подготовки инструкции. Дополнительные сведения см. в подразделе [Параметры инструкции](../../../odbc/reference/develop-app/statement-parameters.md)далее в этом подразделе.  
  
3.  Вызывает **SQLExecute** и выполняет необходимую дополнительную обработку, например получение данных.  
  
4.  При необходимости повторяет шаги 2 и 3.  
  
5.  При вызове **SQLPrepare** драйвер:  
  
    -   Изменяет инструкцию SQL для использования грамматики SQL источника данных без синтаксического анализа инструкции. Это включает в себя замену escape-последовательностей, обсуждаемых в [escape-последовательностям в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md). Приложение может извлекать измененную форму инструкции SQL путем вызова **SQLNativeSql**. Escape-последовательности не заменяются, если задан атрибут SQL_ATTR_NOSCAN инструкции.  
  
    -   Отправляет инструкцию в источник данных для подготовки.  
  
    -   Сохраняет возвращенный идентификатор плана доступа для последующего выполнения (если подготовка завершилась успешно) или возвращает ошибки (если подготовка завершилась ошибкой). Ошибки включают синтаксические ошибки, такие как SQLSTATE 42000 (синтаксическая ошибка или нарушение прав доступа), а также семантические ошибки, например SQLSTATE 42S02 (базовая таблица или представление не найдены).  
  
        > [!NOTE]  
        >  Некоторые драйверы не возвращают ошибки на этом этапе, а вместо этого возвращают их при выполнении инструкции или при вызове функций каталога. Таким же **SQLPrepare** может показаться, что они были успешно выполнены, если на самом деле произошел сбой.  
  
6.  При вызове **SQLExecute** драйвер:  
  
    -   Извлекает значения текущих параметров и преобразует их при необходимости. Дополнительные сведения см. в подразделе [Параметры инструкции](../../../odbc/reference/develop-app/statement-parameters.md)далее в этом подразделе.  
  
    -   Отправляет идентификатор плана доступа и значения преобразованных параметров в источник данных.  
  
    -   Возвращает все ошибки. Обычно это ошибки времени выполнения, например SQLSTATE 24000 (недопустимое состояние курсора). Однако некоторые драйверы возвращают синтаксические и семантические ошибки на этом этапе.  
  
 Если источник данных не поддерживает подготовку инструкций, драйвер должен эмулировать его в максимально возможной степени. Например, драйвер может не выполнять никаких действий при вызове **SQLPrepare** , а затем выполнять прямое выполнение инструкции при вызове **SQLExecute** .  
  
 Если источник данных поддерживает проверку синтаксиса без выполнения, драйвер может отправить инструкцию для проверки того, когда вызывается **SQLPrepare** , и отправить инструкцию для выполнения при вызове **SQLExecute** .  
  
 Если драйвер не может эмулировать подготовку инструкции, он сохраняет инструкцию при вызове **SQLPrepare** и отправляет ее для выполнения при вызове **SQLExecute** .  
  
 Поскольку подготовка эмулированных инструкций не идеальна, **SQLExecute** может возвращать любые ошибки, обычно возвращаемые **SQLPrepare**.
