---
title: Подготовленное исполнение ODBC Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- prepared execution [ODBC]
- SQL statements [ODBC], prepared execution
- SQL statements [ODBC], executing
ms.assetid: f08c8a98-31ee-48b2-9dbf-6f31c2166dbb
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 147ca85b21296575ff55afbe66ab286cc4824fae
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81282314"
---
# <a name="prepared-execution-odbc"></a>Подготовленное выполнение ODBC
Подготовленное выполнение — это эффективный способ выполнения оператора более одного раза. Заявление сначала компилируется или *готовится* в план доступа. План доступа выполняется один или несколько раз позже. Для получения более подробной информации о планах доступа можно [ознакомиться на рассмотрении оператора S'L](../../../odbc/reference/processing-a-sql-statement.md).  
  
 Подготовленное выполнение обычно используется вертикальными и пользовательскими приложениями для повторного выполнения одного и того же, параметризированного оператора S'L. Например, следующий код готовит заявление для обновления цен на различные детали. Затем он выполняет заявление несколько раз с различными значениями параметров каждый раз.  
  
```  
SQLREAL       Price;  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0, PriceInd = 0;  
  
// Prepare a statement to update salaries in the Employees table.  
SQLPrepare(hstmt, "UPDATE Parts SET Price = ? WHERE PartID = ?", SQL_NTS);  
  
// Bind Price to the parameter for the Price column and PartID to  
// the parameter for the PartID column.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_FLOAT, SQL_REAL, 7, 0,  
                  &Price, 0, &PriceInd);  
SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 10, 0,  
                  &PartID, 0, &PartIDInd);  
  
// Repeatedly execute the statement.  
while (GetPrice(&PartID, &Price)) {  
   SQLExecute(hstmt);  
}  
```  
  
 Подготовленное выполнение происходит быстрее, чем прямое выполнение для инструкций, выполненных более одного раза, главным образом потому, что оператор компилируется только один раз; выписывания, выполняемые непосредственно, компилируются каждый раз при их выполнении. Подготовленное выполнение также может обеспечить сокращение сетевого трафика, поскольку водитель может отправлять идентификатор плана доступа к источнику данных каждый раз, когда выполняется выписка, а не всю выписку, если источник данных поддерживает идентификаторы плана доступа.  
  
 Приложение может получить метаданные для набора результатов после подготовки оператора и до его выполнения. Однако возвращение метаданных для подготовленных, невыполненных заявлений является дорогостоящим для некоторых водителей и следует по возможности избегать с помощью совместимых приложений. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/result-set-metadata.md)  
  
 Не следует использовать подготовленное выполнение для инструкций, исполняемых один раз. Для таких инструкций он немного медленнее, чем прямое выполнение, поскольку требует дополнительного вызова функции ODBC.  
  
> [!IMPORTANT]  
>  Совершение или откат транзакции, либо путем явного вызова **S'LEndTran,** либо при работе в режиме автоматического коммита, приводит к тому, что некоторые источники данных удаляют планы доступа для всех инструкций по подключению. Для получения дополнительной информации в описании функции [s'LGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) можно ознакомиться на SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR опций.  
  
 Для подготовки и выполнения оператора приложение:  
  
1.  Вызывает **s'LPrepare** и передает ему строку, содержащую выписку s'L.  
  
2.  Устанавливает значения любых параметров. Параметры могут быть установлены до или после подготовки заявления. Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/statement-parameters.md)  
  
3.  Вызывает **s'LExecute** и выполняет любую необходимую дополнительную обработку, например, получение данных.  
  
4.  Повторяет шаги 2 и 3 по мере необходимости.  
  
5.  При вызове **S'LPrepare** драйвер:  
  
    -   Изменяет заявление S'L, чтобы использовать грамматику источника данных без анализа оператора. Это включает в себя замену побега последовательности обсуждаются в [побег последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md). Приложение может получить измененную форму выписки по S'L, позвонив по **телефону S'LNativeSl.** Последовательности побега не заменяются при установке атрибута SQL_ATTR_NOSCAN оператора.  
  
    -   Отправляет заявление в источник данных для подготовки.  
  
    -   Хранит идентификатор плана возврата доступа для последующего выполнения (если подготовка была выполнена) или возвращает любые ошибки (если подготовка не состоялась). Ошибки включают в себя синтаксические ошибки, такие как S'LSTATE 42000 (ошибка Syntax или нарушение доступа) и семантические ошибки, такие как S'LSTATE 42S02 (Базовая таблица или представление не найдено).  
  
        > [!NOTE]  
        >  Некоторые драйверы не возвращают ошибки на данный момент, а вместо этого возвращают их, когда выполняется выписка или когда вызываются функции каталога. Таким образом, может показаться, что **S'LPrepare** преуспел, когда на самом деле он потерпел неудачу.  
  
6.  При вызове **S'LExecute** драйвер:  
  
    -   Извлекает текущие значения параметров и преобразует их по мере необходимости. Для получения дополнительной [информации см.](../../../odbc/reference/develop-app/statement-parameters.md)  
  
    -   Отправляет идентификатор плана доступа и преобразует значения параметров в источник данных.  
  
    -   Возвращает любые ошибки. Как правило, это ошибки времени выполнения, такие как S'LSTATE 24000 (состояние недействительного курсора). Тем не менее, некоторые драйверы возвращают синтаксические и семантические ошибки на данный момент.  
  
 Если источник данных не поддерживает подготовку оператора, водитель должен подражать ему по мере возможности. Например, драйвер может ничего не делать при вызове **S'LPrepare,** а затем выполнять прямое выполнение оператора при вызове **S'LExecute.**  
  
 Если источник данных поддерживает проверку синтаксиса без выполнения, драйвер может представить выписку для проверки, когда вызывается **S'LPrepare,** и отправлять выписку для выполнения, когда вызывается **S'LExecute.**  
  
 Если драйвер не может подражать подготовке оператора, он хранит выписку, когда вызывается **S'LPrepare,** и отправляет ее для выполнения, когда вызывается **S'LExecute.**  
  
 Поскольку подготовка эмулированных инструкций не является идеальной, **S'LExecute** может вернуть любые ошибки, обычно возвращаемые **s'LPrepare.**
