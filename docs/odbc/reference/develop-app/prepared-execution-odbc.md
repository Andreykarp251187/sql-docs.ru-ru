---
title: Подготовленное выполнение ODBC | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- prepared execution [ODBC]
- SQL statements [ODBC], prepared execution
- SQL statements [ODBC], executing
ms.assetid: f08c8a98-31ee-48b2-9dbf-6f31c2166dbb
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: c7bd6bc8281dd6bdc3bcfbd437380b2d5269ee43
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63199105"
---
# <a name="prepared-execution-odbc"></a>Подготовленное выполнение ODBC
Подготовленное выполнение является эффективным способом для выполнения инструкции более одного раза. Инструкция компилируется во-первых, или *подготовлен,* в план доступа. План доступа — а затем выполняются один или несколько раз в более позднее время. Дополнительные сведения о планах доступа см. в разделе [обработки инструкции SQL](../../../odbc/reference/processing-a-sql-statement.md).  
  
 Подготовленное выполнение часто используется с вертикальной и пользовательских приложений для многократного выполнения параметризованных инструкции SQL. Например следующий код подготавливает инструкцию, чтобы обновить цены различных частей. Затем выполняется инструкция несколько раз с различными значениями параметров каждый раз.  
  
```  
SQLREAL       Price;  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0, PriceInd = 0;  
  
// Prepare a statement to update salaries in the Employees table.  
SQLPrepare(hstmt, "UPDATE Parts SET Price = ? WHERE PartID = ?", SQL_NTS);  
  
// Bind Price to the parameter for the Price column and PartID to  
// the parameter for the PartID column.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_FLOAT, SQL_REAL, 7, 0,  
                  &Price, 0, &PriceInd);  
SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_ULONG, SQL_INTEGER, 10, 0,  
                  &PartID, 0, &PartIDInd);  
  
// Repeatedly execute the statement.  
while (GetPrice(&PartID, &Price)) {  
   SQLExecute(hstmt);  
}  
```  
  
 Подготовленное выполнение выполняется быстрее, чем прямое выполнение для инструкций, выполняться несколько раз, потому, что инструкция компилируется только один раз; инструкции, выполняемые прямо, компилируются при каждом выполнении. Подготовленное выполнение также можете указать снизить объем сетевого трафика, так как драйвер может отправлять идентификатор плана доступа к источнику данных каждый раз при инструкция выполняется, а не целую инструкцию SQL, если идентификаторы планов поддерживает доступ источника данных.  
  
 Приложение может получить метаданные для результирующего набора после подготовке инструкции и до его выполнения. Тем не менее возвращать метаданные для подготовленных, невыполненных инструкций является ресурсоемким для некоторых драйверов и следует избегать, взаимодействующие приложения, если это возможно. Дополнительные сведения см. в разделе [результирующий набор метаданных](../../../odbc/reference/develop-app/result-set-metadata.md).  
  
 Не следует использовать подготовленное выполнение для инструкций, исполняемых один раз. Для таких инструкций это немного медленнее, чем прямое выполнение, поскольку она требует дополнительный вызов функции ODBC.  
  
> [!IMPORTANT]  
>  Фиксация или откат транзакции, либо путем явного вызова **SQLEndTran** или по работе в режиме автоматической фиксации, вызывает некоторые источники данных удалить планы доступ для всех инструкций в соединении. Дополнительные сведения см. в разделе Параметры SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR в [SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) описание функции.  
  
 Подготовка и выполнение инструкцию, приложение:  
  
1.  Вызовы **SQLPrepare** и передает его строка, содержащая инструкцию SQL.  
  
2.  Устанавливает значения всех параметров. Параметры можно одновременно установить до или после подготовки инструкции. Дополнительные сведения см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md)далее в этом разделе.  
  
3.  Вызовы **SQLExecute** и выполняет дополнительную обработку, необходимую, таких как извлечение данных.  
  
4.  Повторяйте шаги 2 и 3 при необходимости.  
  
5.  Когда **SQLPrepare** вызывается драйвер:  
  
    -   Изменяет инструкцию SQL для использования источника данных грамматику SQL без анализа инструкцию. Сюда входят, заменив escape-последовательности, рассматриваемые в [escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md). Приложение может получить измененной форме инструкции SQL, вызвав **SQLNativeSql**. Escape-последовательности, не заменяются, если значение атрибута инструкции SQL_ATTR_NOSCAN.  
  
    -   Отправляет инструкцию к источнику данных для подготовки.  
  
    -   Хранит идентификатор плана возвращаемый доступ для последующего выполнения (если Подготовка выполнена успешно) или возвращает все ошибки (если не удалось выполнить подготовку). Ошибки включают синтаксические ошибки, такие как SQLSTATE 42000 (синтаксическая ошибка или нарушение доступа) и семантические ошибки, например SQLSTATE 42S02 (базовая таблица или представление не найден).  
  
        > [!NOTE]  
        >  Некоторые драйверы на этом этапе возвращает ошибки, а возвращайте их при выполнении инструкции или при вызове функций каталога. Таким образом **SQLPrepare** может показаться будут успешно выполнены, когда на самом деле она выдавала сбой.  
  
6.  Когда **SQLExecute** вызывается драйвер:  
  
    -   Получает текущие значения параметров и преобразует их при необходимости. Дополнительные сведения см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md)далее в этом разделе.  
  
    -   Отправляет идентификатор плана доступа и значения параметров, преобразованных в источник данных.  
  
    -   Возвращает все ошибки. Это обычно во время выполнения ошибки например SQLSTATE 24000 (недопустимое состояние курсора). Тем не менее некоторые драйверы возвращают синтаксические и семантические ошибки на этом этапе.  
  
 Если источник данных не поддерживает подготовку, драйвер должен выполнить его возможно. Например, драйвер может ничего не делать при **SQLPrepare** вызывается, а затем выполнить прямое выполнение инструкции при **SQLExecute** вызывается.  
  
 Если источник данных поддерживает проверку без выполнения синтаксиса, драйвер может отправить инструкции для проверки, когда **SQLPrepare** вызывается и отправить инструкции для выполнения при **SQLExecute** — вызывается.  
  
 Если драйвер не может эмулировать подготовку, он сохраняет инструкции при **SQLPrepare** вызывается и передает его для выполнения при **SQLExecute** вызывается.  
  
 Так как подготовка эмулированные инструкции не идеален **SQLExecute** может возвращать ошибки, возвращенные обычно **SQLPrepare**.
