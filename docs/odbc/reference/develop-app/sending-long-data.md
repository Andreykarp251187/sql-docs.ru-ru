---
title: Отправка длинных данных Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- long data [ODBC]
- sending long data [ODBC]
ms.assetid: ea989084-a8e6-4737-892e-9ec99dd49caf
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: aeeeb716aa2f9a72338f3aeb586dffce86f84069
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81304185"
---
# <a name="sending-long-data"></a>Отправка данных типа Long
DBMS определяют *длинные данные* как любой символ или двоичные данные по определенному размеру, например 254 символа. Возможно, невозможно сохранить в памяти весь элемент длинных данных, например, когда элемент представляет собой длинный текстовый документ или битную карту. Поскольку такие данные не могут храниться в одном буфере, источник данных отправляет их водителю в части с **S'LPutData** при выполнении оператора. Параметры, по которым данные отправляются во время выполнения, известны как *параметры данных по исполнению.*  
  
> [!NOTE]  
>  Приложение может отправлять любые типы данных во время выполнения с **помощью S'LPutData,** хотя только символ и двоичные данные могут быть отправлены по частям. Однако, если данные достаточно малы, чтобы поместиться в один буфер, как правило, нет никаких оснований для использования **S'LPutData**. Гораздо проще связать буфер и позволить водителю получить данные из буфера.  
  
 Для отправки данных во время выполнения приложение выполняет следующие действия:  
  
1.  Проходит 32-битное значение, которое определяет параметр в аргументе *ParameterValuePtr* в **S'LBindParameter** вместо того, чтобы передавать адрес буфера. Это значение не анализируется драйвером. Он будет возвращен в приложение позже, так что это должно что-то значить для приложения. Например, это может быть число параметра или ручка файла, содержащего данные.  
  
2.  Проходит адрес буфера длины/индикатора в *StrLen_or_IndPtr* **аргументе S'LBindParameter**.  
  
3.  Хранит SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT_EXEC *(длина)* макрос в буфере длины/индикатора. Оба эти значения указывают водителю на то, что данные по параметру будут отправлены с **помощью S'LPutData.** SQL_LEN_DATA_AT_EXEC *(длина)* используется при отправке длинных данных в источник данных, который должен знать, сколько байтов длинных данных будет отправлено, чтобы он мог предварительно распределить пространство. Чтобы определить, требуется ли источник данных этого значения, приложение вызывает **s'LGetInfo** с опцией SQL_NEED_LONG_DATA_LEN. Все драйверы должны поддерживать этот макрос; если источник данных не требует длины байта, водитель может игнорировать его.  
  
4.  Вызовы **S'LExecute** или **S'LExecDirect**. Драйвер обнаруживает, что буфер длины/индикатора содержит значение SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT_EXEC *(длина)* макроса и возвращает сяритоге SQL_NEED_DATA как значение возврата функции.  
  
5.  Вызовы **S'LParamData** в ответ на SQL_NEED_DATA значение возврата. Если необходимо отправлять длинные данные, SQL_NEED_DATA возвращается **SQL_NEED_DATA.** В буфере, на который указывает аргумент *ValuePtrPtr,* драйвер возвращает значение, идентифицирует параметр данных по исполнению. При наличии более одного параметра данных по исполнению приложение должно использовать это значение для определения того, для какого параметра для отправки данных; водитель не обязан запрашивать данные для параметров выполнения данных в каком-либо конкретном порядке.  
  
6.  Вызывает **S'LPutData** для отправки данных параметра водителю. Если данные параметра не вписываются в один буфер, как это часто бывает с длинными данными, приложение неоднократно вызывает **S'LPutData** для отправки данных частями; это до водителя и источника данных, чтобы собрать данные. Если приложение передает данные строки с нулевым завершением, драйвер или источник данных должен удалить символ нулевого прекращения в процессе повторной сборки.  
  
7.  Снова вызывает **S'LParamData,** чтобы указать, что он отправил все данные по параметру. При наличии каких-либо параметров данных по исполнению, по которым данные не были отправлены, водитель возвращает сяSQL_NEED_DATA и значение, которое определяет следующий параметр; приложение возвращается к шагу 6. Если данные были отправлены по всем параметрам выполнения данных, выписка выполняется. **SLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO и может вернуть любое значение возврата или диагностику, которое может **вернутьs S'L'LExecute** или **S'LExecDirect.**  
  
 После того, как **S'LExecute** или **S'LExecDirect** возвращается SQL_NEED_DATA и до того, как данные были полностью отправлены для последнего параметра данных по исполнению, выписка находится в состоянии need Data. В то время как заявление находится в состоянии need Data, приложение может вызывать только **S'LPutData**, **S'LParamData**, **S'LCancel**, **S'LGetDiagField**, или **S'LGetDiagRec**; все остальные функции возвращаютs S'Lstate HY010 (ошибка последовательности функций). Вызов **S'LCancel** отменяет выполнение оператора и возвращает его в прежнее состояние. Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-b-odbc-state-transition-tables.md)  
  
 Например, при отправке данных [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md) во время выполнения см.
