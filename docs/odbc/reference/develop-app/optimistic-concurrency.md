---
title: Оптимистичный параллелизм | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
- optimistic concurrency [ODBC]
ms.assetid: 9d71e09e-bc68-4c1f-9229-ed2a7be7d324
author: MightyPen
ms.author: genemi
ms.openlocfilehash: f5f4b7101718ea8372c9635a064dc81e1d8f6c1a
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "68023393"
---
# <a name="optimistic-concurrency"></a>Оптимистический параллелизм
*Оптимистическая блокировка* наследует свое имя от оптимистического предположения о том, что конфликт между транзакциями будет редко встречаться. считается, что возник конфликт, когда другая транзакция обновляет или удаляет строку данных между моментом считывания текущей транзакцией и временем ее обновления или удаления. Это противоположность *пессимистичного параллелизма,* или блокировки, в которой разработчик приложения считает, что такие конфликты являются наиболее распространенными.  
  
 В оптимистичном параллелизме строка остается разблокированной до тех пор, пока не поступает время обновления или удаления. На этом этапе строка считывается и проверяется на наличие изменений с момента последнего чтения. Если строка была изменена, обновление или удаление завершается ошибкой, и ее необходимо повторить.  
  
 Чтобы определить, была ли изменена строка, ее новая версия проверяется по кэшированной версии строки. Эта проверка может основываться на версии строки, например столбец timestamp в SQL Server или значения каждого столбца в строке. Многие СУБД не поддерживают версии строк.  
  
 Оптимистичный параллелизм может быть реализован источником данных или приложением. В любом случае приложение должно использовать низкий уровень изоляции транзакций, например READ COMMITTED; использование более высокого уровня отрицательно влияет на увеличенную степень параллелизма, которая достигается с помощью оптимистичного параллелизма.  
  
 Если Оптимистическая блокировка реализуется источником данных, приложение задает для атрибута SQL_ATTR_CONCURRENCY инструкции значение SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Чтобы обновить или удалить строку, она выполняет инструкцию позиционированного обновления или удаления или вызывает функцию **SQLSetPos** так же, как и с пессимистичным параллелизмом. драйвер или источник данных возвращает значение SQLSTATE 01001 (конфликт операции курсора) в случае сбоя обновления или удаления из-за конфликта.  
  
 Если само приложение реализует оптимистичный параллелизм, для атрибута SQL_ATTR_CONCURRENCY инструкции задается значение SQL_CONCUR_READ_ONLY для чтения строки. Если он будет сравнивать версии строк и не знает столбец версии строки, он вызывает **SQLSpecialColumns** с параметром SQL_ROWVER, чтобы определить имя этого столбца.  
  
 Приложение обновляет или удаляет строку, увеличивая параллелизм до SQL_CONCUR_LOCK (чтобы получить доступ на запись к строке) и выполняя инструкцию **Update** или **Delete** с предложением **WHERE** , которое указывает версию или значения строки, когда приложение считывает ее. Если после этого строка изменилась, инструкция завершится ошибкой. Если предложение **WHERE** не однозначно определяет строку, инструкция может также обновлять или удалять другие строки. версии строк всегда однозначно идентифицируют строки, но значения строк уникально идентифицируют строки только в том случае, если они содержат первичный ключ.
