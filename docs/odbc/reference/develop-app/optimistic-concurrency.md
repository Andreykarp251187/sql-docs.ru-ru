---
title: Оптимистичная параллель Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
- optimistic concurrency [ODBC]
ms.assetid: 9d71e09e-bc68-4c1f-9229-ed2a7be7d324
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 30eba3ea03b4c798a74a8cb928014b582846607b
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81282495"
---
# <a name="optimistic-concurrency"></a>Оптимистическая блокировка
*Оптимистичная параллель* черпает свое название из оптимистичного предположения о том, что столкновения между транзакциями будут происходить редко; столкновение, как утверждается, произошло, когда другая транзакция обновляет или удаляет ряд данных между временем ее считывания текущей транзакцией и временем ее обновления или удаления. Это противоположность *пессимистического параллелизма,* или блокировки, в которой разработчик приложения считает, что такие столкновения являются обычным явлением.  
  
 В оптимистичном параллели строка остается разблокированной до тех пор, пока не придет время обновлять или удалять ее. В этот момент строка перечитывается и проверяется, чтобы увидеть, если она была изменена, так как она была последней чтения. Если строка была изменена, обновление или удаление не удается и должны быть опробованы еще раз.  
  
 Чтобы определить, была ли изменена строка, ее новая версия проверяется на кэшированной версии строки. Эта проверка может быть основана на версии строки, например столбца метки времени в сервере S'L или значениях каждого столбца в строке. Многие DBMS не поддерживают строки версии.  
  
 Оптимистический параллелизм может быть реализован с помощью источника данных или приложения. В любом случае приложение должно использовать низкий уровень изоляции транзакций, например Read Committed; использование более высокого уровня сводит на нет возросшую параллелизм, полученную с помощью оптимистичной параллелизма.  
  
 Если оптимистический параллел осуществляется источником данных, приложение устанавливает атрибут SQL_ATTR_CONCURRENCY оператора на SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Для обновления или удаления строки, он выполняет позиционированное обновление или удаление оператора или вызывает **S'LSetPos** так же, как это было бы с пессимистическим параллелизмом; драйвер или источник данных возвращает S'LSTATE 01001 (конфликт операции Cursor), если обновление или удаление не удается из-за столкновения.  
  
 Если приложение само реализует оптимистический параллел, оно устанавливает атрибут SQL_ATTR_CONCURRENCY оператора на SQL_CONCUR_READ_ONLY для чтения строки. Если он будет сравнивать строки версии и не знает столбец строки версии, он вызывает **S'LSpecialColumns** с SQL_ROWVER вариантом для определения имени этого столбца.  
  
 Приложение обновляет или удаляет строку, увеличивая параллелизм до SQL_CONCUR_LOCK (чтобы получить доступ к строке записи) и выполнение заявления **UPDATE** или **DELETE** с оговоркой **WHERE,** которая определяет версию или значения строки, когда приложение прочитало ее. Если строка изменилась с тех пор, заявление выйдет из строя. Если в пункте **WHERE** не содержится однозначной идентификации строки, утверждение может также обновить или удалить другие строки; версии строк всегда однозначно идентифицируют строки, но значения строкоднозначно идентифицируют строки только в том случае, если они включают основной ключ.
