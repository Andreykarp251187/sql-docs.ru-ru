---
title: Оптимистическая блокировка | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
- optimistic concurrency [ODBC]
ms.assetid: 9d71e09e-bc68-4c1f-9229-ed2a7be7d324
author: MightyPen
ms.author: genemi
ms.openlocfilehash: f5f4b7101718ea8372c9635a064dc81e1d8f6c1a
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68023393"
---
# <a name="optimistic-concurrency"></a>Оптимистический параллелизм
*Оптимистичный параллелизм* наследует его имя из оптимистичный предположения, что редко возникает конфликт между транзакциями; конфликт считается, что когда другая транзакция обновляет или удаляет строку данных доступной для чтения в промежутке текущей транзакции, время он обновляется или удаляется. Это противоположность *пессимистичный параллелизм* или блокировки, в котором разработчик приложения считается, что такие конфликты многопроцессорные системы.  
  
 При оптимистическом параллелизме остается строки разблокирован, пока не наступит заданное время, чтобы обновить или удалить его. После этого строка привязанном и проверка на предмет того, если она была изменена с момента последнего чтения. Если строка была изменена, то update или delete завершается ошибкой и необходимо перезапустить.  
  
 Чтобы определить, были ли изменены строки, его новая версия сверяется с кэшированной версии строки. Эту проверку могут основываться на версии строк, например столбец отметки времени в SQL Server, или значения каждого столбца в строке. Версии строк не поддерживают многие СУБД.  
  
 Оптимистичный параллелизм может быть реализован источника данных или приложения. В любом случае приложение должно использовать уровень изоляции транзакции низкой например Read Committed; с помощью более высокого уровня инвертирует расширенные возможности параллельной обработки, полученные с помощью оптимистичного параллелизма.  
  
 Если в источнике данных реализован оптимистичный параллелизм, приложение задает атрибута инструкции SQL_ATTR_CONCURRENCY SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Чтобы обновить или удалить строку, он выполняет позиционированного обновления или инструкции delete или вызовы **SQLSetPos** как и в случае с пессимистичным параллелизмом; драйвер или источник данных возвращает SQLSTATE 01001 (конфликт операции с курсором), если Update или delete завершается сбоем из-за конфликта имен.  
  
 Если само приложение реализует оптимистичного параллелизма, атрибута инструкции SQL_ATTR_CONCURRENCY устанавливает SQL_CONCUR_READ_ONLY для чтения строки. Если он будет сравнить версии строк и не знает, в столбец версий строк, он вызывает **SQLSpecialColumns** с параметром SQL_ROWVER, чтобы определить имя этого столбца.  
  
 Приложение обновляет или удаляет строку, увеличив значение параметра параллелизма для SQL_CONCUR_LOCK (Чтобы получить доступ на запись к строке) и выполнения **обновление** или **удалить** инструкции с **ГДЕ**  у предложение, которое указывает версию или значения строки, когда приложение его чтение. Если строка была изменена с тех пор, инструкция завершится ошибкой. Если **ГДЕ** предложение для уникальной идентификации строки, инструкция также может обновить или удалить другие строки; версии строк всегда уникальной идентификации строк, но значения строк уникальной идентификации строк только в том случае, если они содержат первичный ключ.
