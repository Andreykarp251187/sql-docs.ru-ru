---
title: Получение длинных данных | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- long data [ODBC]
- fetches [ODBC], long data
- result sets [ODBC], fetching
- SQLGetData function [ODBC], getting long data
- retrieving long data [ODBC]
ms.assetid: 6ccb44bc-8695-4bad-91af-363ef22bdb85
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 49f0023f726dd4bb290ffba1018ce2608800dd90
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "68216362"
---
# <a name="getting-long-data"></a>Получение данных типа Long
СУБД определяет *длинные данные* как любые символьные или двоичные данные определенного размера, например 255 символов. Эти данные могут быть достаточно маленькими для хранения в одном буфере, например описание части из нескольких тысяч символов. Однако в памяти может быть слишком много времени для хранения, например, для длинных текстовых документов или точечных рисунков. Так как такие данные не могут храниться в одном буфере, они извлекаются из драйвера в части с **SQLGetData** после получения других данных в строке.  
  
> [!NOTE]  
>  Приложение может фактически получать данные любого типа с помощью **SQLGetData**, а не только длинных данных, хотя в частях могут быть извлечены только символьные и двоичные данные. Однако если данные достаточно малы для размещения в одном буфере, обычно нет причин использовать **SQLGetData**. Гораздо проще привязать буфер к столбцу и позволить драйверу вернуть данные в буфер.  
  
 Для получения длинных данных из столбца приложение сначала вызывает **SQLFetchScroll** или **SQLFetch** , чтобы перейти к строке и получить данные для связанных столбцов. Затем приложение вызывает **SQLGetData**. **SQLGetData** имеет те же аргументы, что и **SQLBindCol**: маркер инструкции; номер столбца; тип данных C, адрес и длина байта переменной приложения; и адрес буфера длины или индикатора. Обе функции имеют одинаковые аргументы, так как они выполняют фактически одну и ту же задачу: они описывают переменную приложения для драйвера и указывают, что данные для определенного столбца должны возвращаться в этой переменной. Основное отличие заключается в том, что **SQLGetData** вызывается после выборки строки (и иногда называется *позднее связыванием* ) и что привязка, заданная **SQLGetData** , действует только на время вызова.  
  
 В отношении одного столбца **SQLGetData** ведет себя как **SQLFetch**: он извлекает данные для столбца, преобразует его в тип переменной приложения и возвращает в этой переменной. Он также возвращает длину в байтах данных в буфере длины или индикатора. Дополнительные сведения о том, как **SQLFetch** возвращает данные, см. [в разделе выборка строки данных](../../../odbc/reference/develop-app/fetching-a-row-of-data.md).  
  
 **SQLGetData** отличается от **SQLFetch** в одном важном отношении. Если для одного и того же столбца вызывается несколько раз подряд, каждый вызов возвращает последовательную часть данных. Каждый вызов, за исключением последнего вызова, возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004 (строковые данные, усеченные справа); Последний вызов возвращает SQL_SUCCESS. Именно так **SQLGetData** используется для получения длинных данных в частях. Если больше нет данных для возврата, **SQLGetData** возвращает SQL_NO_DATA. Приложение отвечает за размещение длинных данных вместе, что может означать объединение частей данных. Каждая часть завершается нулем; приложение должно удалить символ завершения null при объединении частей. Извлечение данных в части может быть выполнено для закладок с переменной длиной, а также для других длинных данных. Значение, возвращаемое в буфере длины и индикатора, уменьшается в каждом вызове числом байтов, возвращенных в результате предыдущего вызова, хотя драйверу обычно не удается обнаружить объем доступных данных и вернуть байтовую длину SQL_NO_TOTAL. Пример:  
  
```  
// Declare a binary buffer to retrieve 5000 bytes of data at a time.  
SQLCHAR       BinaryPtr[5000];  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd, BinaryLenOrInd, NumBytes;  
SQLRETURN     rc;   
SQLHSTMT      hstmt;  
  
// Create a result set containing the ID and picture of each part.  
SQLExecDirect(hstmt, "SELECT PartID, Picture FROM Pictures", SQL_NTS);  
  
// Bind PartID to the PartID column.  
SQLBindCol(hstmt, 1, SQL_C_ULONG, &PartID, 0, &PartIDInd);  
  
// Retrieve and display each row of data.  
while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {  
   // Display the part ID and initialize the picture.  
   DisplayID(PartID, PartIDInd);  
   InitPicture();  
  
   // Retrieve the picture data in parts. Send each part and the number   
   // of bytes in each part to a function that displays it. The number   
   // of bytes is always 5000 if there were more than 5000 bytes   
   // available to return (cbBinaryBuffer > 5000). Code to check if   
   // rc equals SQL_ERROR or SQL_SUCCESS_WITH_INFO not shown.  
   while ((rc = SQLGetData(hstmt, 2, SQL_C_BINARY, BinaryPtr, sizeof(BinaryPtr),  
                           &BinaryLenOrInd)) != SQL_NO_DATA) {  
      NumBytes = (BinaryLenOrInd > 5000) || (BinaryLenOrInd == SQL_NO_TOTAL) ?  
                  5000 : BinaryLenOrInd;  
      DisplayNextPictPart(BinaryPtr, NumBytes);  
   }  
}  
  
// Close the cursor.  
SQLCloseCursor(hstmt);  
```  
  
 Существует несколько ограничений на использование **SQLGetData**. Как правило, столбцы, к которым обращаются с помощью **SQLGetData**:  
  
-   Доступ должен осуществляться в порядке возрастания номера столбца (из-за способа считывания столбцов результирующего набора из источника данных). Например, является ошибкой вызвать **SQLGetData** для столбца 5, а затем вызвать его для столбца 4.  
  
-   Не может быть привязан.  
  
-   Номер столбца должен быть больше, чем у последнего привязанного столбца. Например, если последний привязанный столбец имеет значение столбец 3, вызов **SQLGetData** для столбца 2 является ошибкой. По этой причине приложения должны располагать столбцы данных длиной в конце списка выбора.  
  
-   Не может использоваться, если был вызван **SQLFetch** или **SQLFetchScroll** для получения нескольких строк. Дополнительные сведения см. [в разделе Использование блочных курсоров](../../../odbc/reference/develop-app/using-block-cursors.md).  
  
 Некоторые драйверы не применяют эти ограничения. В приложениях, поддерживающих взаимодействие, следует либо предположить, что они существуют, либо определить, какие ограничения не применяются путем вызова **SQLGetInfo** с параметром SQL_GETDATA_EXTENSIONS.  
  
 Если приложению не нужны все данные в символьном или двоичном столбце данных, можно уменьшить сетевой трафик в драйверах на основе СУБД, установив атрибут инструкции SQL_ATTR_MAX_LENGTH перед выполнением инструкции. Это позволяет ограничивать количество байтов данных, возвращаемых для любого символьного или двоичного столбца. Например, предположим, что столбец содержит длинные текстовые документы. Приложение, которое просматривает таблицу, содержащую этот столбец, может отображать только первую страницу каждого документа. Хотя этот атрибут инструкции может быть смоделирован в драйвере, нет никаких причин. В частности, если приложению требуется усечь символьные или двоичные данные, он должен привязать небольшой буфер к столбцу с помощью **SQLBindCol** и позволить драйверу усечь данные.
