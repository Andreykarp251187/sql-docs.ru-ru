---
title: Получение данных типа Long | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- long data [ODBC]
- fetches [ODBC], long data
- result sets [ODBC], fetching
- SQLGetData function [ODBC], getting long data
- retrieving long data [ODBC]
ms.assetid: 6ccb44bc-8695-4bad-91af-363ef22bdb85
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: d61f6e2d5c2999a1ff7cea86d497eb4f0fb13244
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63061602"
---
# <a name="getting-long-data"></a>Получение данных типа Long
Определите СУБД *данные большой длины* как любой символьных или двоичных данных через определенный размер, например 255 символов. Эти данные могут быть достаточно небольшим, чтобы хранить в один буфер, такие как часть описания несколько тысяч символов. Тем не менее возможно, слишком длинное для хранения в памяти, такие как длинные текстовые документы или растровые изображения. Поскольку такие данные не могут храниться в один буфер, он извлекается из драйвера в частях с **SQLGetData** после другие данные в строке были получены.  
  
> [!NOTE]  
>  Приложение фактически может извлечь данные с любого типа **SQLGetData**, не только длинных данных, несмотря на то, что в части можно получить только символьных и двоичных данных. Тем не менее, если данные помещаются в один буфер, нет смысла использовать **SQLGetData**. Это значительно упрощает привязку к столбцу буфера и разрешить драйверу возвращать данные в буфере.  
  
 Для получения длинных данных из столбца, приложение сначала вызывает **SQLFetchScroll** или **SQLFetch** перейдите к строке, и получения данных для привязанных столбцов. Затем приложение вызывает **SQLGetData**. **SQLGetData** имеет те же аргументы, что **SQLBindCol**: дескриптор инструкции; номер столбца; C тип, адрес и байтов длина данных переменную приложения; и адрес буфера длины и индикатора. Обе функции имеют те же аргументы, поскольку они выполняют по сути, ту же задачу: Они описывают переменную приложения к драйверу и указать, что данные для определенного столбца должно возвращаться в этой переменной. Основные различия, которые **SQLGetData** вызывается после выборке строки (и иногда называется *позднее связывание* по этой причине) и что задана привязка **SQLGetData**  срок действия которой составляет только на протяжении всего вызова.  
  
 Один столбец, в отношении **SQLGetData** ведет себя как **SQLFetch**: Он извлекает данные для столбца, он преобразуется в тип переменной приложения и возвращает его в переменной. Он также возвращает длину данных в байтах буфера длины и индикатора. Дополнительные сведения о том, как **SQLFetch** возвращает данные, см. в разделе [выборки данных из строк](../../../odbc/reference/develop-app/fetching-a-row-of-data.md).  
  
 **SQLGetData** отличается от **SQLFetch** в один важный фактор. Если он вызывается несколько раз подряд для одного столбца, каждый вызов возвращает последовательные части данных. Каждый вызов, за исключением последнего вызова метода возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004 (усечение данных строки справа); последний вызов возвращает значение SQL_SUCCESS. Это как **SQLGetData** используется для получения длинных данных по частям. При отсутствии данных для возврата, не **SQLGetData** не вернет значение SQL_NO_DATA. Приложение отвечает за объединения длинных данных, которой может означать сцепления фрагменты данных. Каждая часть заканчивается нулевым байтом; приложение необходимо удалить знак завершения null, если сцепления частей. Извлечение данных из частей может выполняться для закладок переменной длины, а также другие данные большой длины. Значение, возвращаемое в уменьшение буфер длины/индикатора в каждый вызов количество байтов, возвращаемых в предыдущем вызове, несмотря на то, что характерно для драйвера, он не сможет обнаружить объем доступных данных и возвращают длину SQL_NO_TOTAL в байтах. Пример:  
  
```  
// Declare a binary buffer to retrieve 5000 bytes of data at a time.  
SQLCHAR       BinaryPtr[5000];  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd, BinaryLenOrInd, NumBytes;  
SQLRETURN     rc;   
SQLHSTMT      hstmt;  
  
// Create a result set containing the ID and picture of each part.  
SQLExecDirect(hstmt, "SELECT PartID, Picture FROM Pictures", SQL_NTS);  
  
// Bind PartID to the PartID column.  
SQLBindCol(hstmt, 1, SQL_C_ULONG, &PartID, 0, &PartIDInd);  
  
// Retrieve and display each row of data.  
while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {  
   // Display the part ID and initialize the picture.  
   DisplayID(PartID, PartIDInd);  
   InitPicture();  
  
   // Retrieve the picture data in parts. Send each part and the number   
   // of bytes in each part to a function that displays it. The number   
   // of bytes is always 5000 if there were more than 5000 bytes   
   // available to return (cbBinaryBuffer > 5000). Code to check if   
   // rc equals SQL_ERROR or SQL_SUCCESS_WITH_INFO not shown.  
   while ((rc = SQLGetData(hstmt, 2, SQL_C_BINARY, BinaryPtr, sizeof(BinaryPtr),  
                           &BinaryLenOrInd)) != SQL_NO_DATA) {  
      NumBytes = (BinaryLenOrInd > 5000) || (BinaryLenOrInd == SQL_NO_TOTAL) ?  
                  5000 : BinaryLenOrInd;  
      DisplayNextPictPart(BinaryPtr, NumBytes);  
   }  
}  
  
// Close the cursor.  
SQLCloseCursor(hstmt);  
```  
  
 Существует ряд ограничений на использование **SQLGetData**. Как правило, доступ к столбцам с **SQLGetData**:  
  
-   Должен осуществляться в порядке возрастания номеров столбцов (из-за того, в который столбцы результирующего набора, считываются из источника данных). Например, это ошибка для вызова **SQLGetData** для столбца 5 и затем вызывать его для столбца 4.  
  
-   не удается найти метод.  
  
-   Необходимо иметь более высокий номер столбца, чем последнего связанного столбца. Например, если последнего связанного столбца является столбец 3, является ошибкой для вызова **SQLGetData** для столбца 2. По этой причине приложений следует обязательно поместите данные большой длины столбцов в конце списка выбора.  
  
-   Нельзя использовать, если **SQLFetch** или **SQLFetchScroll** был вызван для получения более одной строки. Дополнительные сведения см. в разделе [использование блочных курсоров](../../../odbc/reference/develop-app/using-block-cursors.md).  
  
 Некоторые драйверы, не принудительного применения этих ограничений. Взаимодействующие приложения следует предположить, они существуют, или определить, какие ограничения не применяются путем вызова **SQLGetInfo** с параметром SQL_GETDATA_EXTENSIONS.  
  
 Если приложение не все данные в столбце двоичных данных или символ, она может снизить сетевой трафик в драйверы на основе СУБД, установив атрибут инструкции sql_attr_max_length параметра до выполнения инструкции. Это ограничивает число байтов, которое будет возвращаться для любого символьных или двоичных столбцов. Например предположим, что столбец содержит документы, длинный текст. Приложение, которое просматривает таблицу, содержащего этот столбец может потребоваться отображать только первая страница каждого документа. Несмотря на то, что этот атрибут инструкции можно моделировать в драйвере, нет причин для этого. В частности, если приложению требуется выполнить усечение символьных или двоичных данных, его необходимо привязать небольшим буфером для столбца с **SQLBindCol** и разрешить драйверу усечения данных.
