---
title: Получение длинных данных Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- long data [ODBC]
- fetches [ODBC], long data
- result sets [ODBC], fetching
- SQLGetData function [ODBC], getting long data
- retrieving long data [ODBC]
ms.assetid: 6ccb44bc-8695-4bad-91af-363ef22bdb85
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: da901c22eb26af063397b4af184179ebe5c75924
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81298994"
---
# <a name="getting-long-data"></a>Получение данных типа Long
DBMS определяют *длинные данные* как любой символ или двоичные данные по определенному размеру, например 255 символов. Эти данные могут быть достаточно небольшими для хранения в одном буфере, например, описание части нескольких тысяч символов. Тем не менее, это может быть слишком долго для хранения в памяти, например, длинные текстовые документы или bitmaps. Поскольку такие данные не могут храниться в одном буфере, они извлекаются из драйвера в части с **S'LGetData** после того, как были получены другие данные в строке.  
  
> [!NOTE]  
>  Приложение может фактически получить любой тип данных с **помощью s'LGetData**, а не только длинные данные, хотя только символ и двоичные данные могут быть извлечены по частям. Однако, если данные достаточно малы, чтобы поместиться в один буфер, как правило, нет причин для использования **S'LGetData**. Гораздо проще привязать буфер к столбецу и позволить водителю вернуть данные в буфере.  
  
 Для получения длинных данных из столбца приложение сначала вызывает **S'LFetchScroll** или **S'LFetch,** чтобы переместиться в строку и получить данные для связанных столбцов. Затем приложение вызывает **S'LGetData**. **У S'LGetData** есть те же аргументы, что и у **S'LBindCol:** ручка оператора; номер столбца; тип данных C, адрес и длина байт переменной приложения; и адрес буфера длины/индикатора. Обе функции имеют одни и те же аргументы, поскольку они выполняют по существу одну и ту же задачу: они оба описывают переменную приложения для драйвера и указывают, что данные для определенного столбца должны быть возвращены в этой переменной. Основные различия заключаются в том, что **s'LGetData** вызывается после того, как строка извлекается (и иногда называется *поздней привязкой* по этой причине) и что связывание, указанное **S'LGetData,** длится только в течение всего срока вызова.  
  
 Что касается одного столбца, то **S'LGetData** ведет себя как **S'LFetch:** Он извлекает данные для столбца, преобразует их в тип переменной приложения и возвращает ее в этой переменной. Он также возвращает длину данных в буфердлина длины/индикатора. Для получения более [подробной информации](../../../odbc/reference/develop-app/fetching-a-row-of-data.md)о том, как **s'LFetch** возвращает данные, см.  
  
 В одном важном отношении **s'LGetData** отличается от **S'LFetch.** Если он вызывается более одного раза подряд для одного и того же столбца, каждый вызов возвращает последовательную часть данных. Каждый вызов, за исключением последнего вызова, возвращается SQL_SUCCESS_WITH_INFO и S'Lstate 01004 (данные струны, право усеченный); последний вызов возвращается SQL_SUCCESS. Таким образом, для извлечения длинных данных по частям используется **s'LGetData.** Когда нет больше данных, чтобы вернуться, **S'LGetData** возвращается SQL_NO_DATA. Приложение отвечает за объединение длинных данных, что может означать свертывание частей данных. Каждая часть непрекращается; приложение должно удалить символ нулевого прекращения, если свертывание частей. Извлечение данных по частям может быть сделано для закладок с переменной длиной, а также для других длинных данных. Возвращается значение буфера длины/индикатора уменьшается в каждом вызове на количество байтов, возвращенных в предыдущем вызове, хотя обычно водитель не может обнаружить объем имеющихся данных и вернуть длину байт SQL_NO_TOTAL. Пример:  
  
```  
// Declare a binary buffer to retrieve 5000 bytes of data at a time.  
SQLCHAR       BinaryPtr[5000];  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd, BinaryLenOrInd, NumBytes;  
SQLRETURN     rc;   
SQLHSTMT      hstmt;  
  
// Create a result set containing the ID and picture of each part.  
SQLExecDirect(hstmt, "SELECT PartID, Picture FROM Pictures", SQL_NTS);  
  
// Bind PartID to the PartID column.  
SQLBindCol(hstmt, 1, SQL_C_ULONG, &PartID, 0, &PartIDInd);  
  
// Retrieve and display each row of data.  
while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {  
   // Display the part ID and initialize the picture.  
   DisplayID(PartID, PartIDInd);  
   InitPicture();  
  
   // Retrieve the picture data in parts. Send each part and the number   
   // of bytes in each part to a function that displays it. The number   
   // of bytes is always 5000 if there were more than 5000 bytes   
   // available to return (cbBinaryBuffer > 5000). Code to check if   
   // rc equals SQL_ERROR or SQL_SUCCESS_WITH_INFO not shown.  
   while ((rc = SQLGetData(hstmt, 2, SQL_C_BINARY, BinaryPtr, sizeof(BinaryPtr),  
                           &BinaryLenOrInd)) != SQL_NO_DATA) {  
      NumBytes = (BinaryLenOrInd > 5000) || (BinaryLenOrInd == SQL_NO_TOTAL) ?  
                  5000 : BinaryLenOrInd;  
      DisplayNextPictPart(BinaryPtr, NumBytes);  
   }  
}  
  
// Close the cursor.  
SQLCloseCursor(hstmt);  
```  
  
 Существует несколько ограничений на использование **S'LGetData.** Как правило, столбцы, доступные с **помощью S'LGetData:**  
  
-   Необходимо получить доступ в порядке увеличения числа столбцов (из-за того, как столбцы набора результатов считываются из источника данных). Например, это ошибка, чтобы вызвать **S'LGetData** для столбца 5, а затем вызвать его для столбца 4.  
  
-   Не может быть связан.  
  
-   Должно быть больше столбца, чем последний связанный столбец. Например, если последний столбец связан столбцом 3, это ошибка вызова **S'LGetData** для столбца 2. По этой причине приложения должны обязательно размещать длинные столбцы данных в конце списка выбора.  
  
-   Не может быть использована, если для получения более чем одной строки был вызван **S'LFetch** или **S'LFetchScroll.** Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/using-block-cursors.md)  
  
 Некоторые драйверы не применяют эти ограничения. Совместимые приложения должны либо считать, что они существуют, либо определять, какие ограничения не применяются, позвонив в **SQL_GETDATA_EXTENSIONS** вариант.  
  
 Если приложению не нужны все данные в столбце символа или двоичной колонке данных, это может уменьшить сетевой трафик в драйверах на основе DBMS, установив атрибут SQL_ATTR_MAX_LENGTH оператора перед выполнением оператора. Это ограничивает количество байтов данных, которые будут возвращены для любого символа или двоичного столбца. Например, предположим, что столбец содержит длинные текстовые документы. Приложение, которое просматривает таблицу, содержащую эту колонку, возможно, придется отображать только первую страницу каждого документа. Хотя этот атрибут оператора может быть смоделирован в драйвере, нет никаких причин для этого. В частности, если приложение хочет усеивать символ или двоичные данные, оно должно привязать небольшой буфер к столбцу с **S'LBindCol** и позволить водителю усеивать данные.
