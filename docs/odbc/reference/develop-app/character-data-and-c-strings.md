---
title: Данные о персонажах и C-струны Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- data buffers [ODBC], character data
- buffers [ODBC], C strings
- buffers [ODBC], character data
- character data and buffers [ODBC]
- length of data buffers [ODBC]
- data buffers [ODBC], C strings
- buffers [ODBC], length
- C strings and buffers [ODBC]
ms.assetid: 3a141cb4-229d-4027-9349-615cb2995e36
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 7bb25022d4e0c0559f2a8f77b89a4ba26aeba33a
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81307494"
---
# <a name="character-data-and-c-strings"></a>Символьные данные и строки C
Параметры ввода, относятся к данным символов с переменной длиной (например, имена столбцов, динамические параметры и значения атрибутов строки), имеют связанный параметр длины. Если приложение завершает строки с нулевым символом, как это характерно для C, оно предоставляет в качестве аргумента либо длину в байтах строки (не включая нулевой терминатор), либо SQL_NTS (null-Terminated String). Неотрицательный аргумент длины определяет фактическую длину связанной строки. Аргумент длины может быть 0, чтобы указать строку нулевой длины, которая отличается от значения NULL. Отрицательное значение SQL_NTS направляет драйверу определить длину строки, направив символ с нулевым окончанием.  
  
 Когда данные о персонажах возвращаются из драйвера в приложение, водитель должен всегда аннулировать его. Это дает приложению выбор: обрабатывать ли данные в виде строки или массива символов. Если буфер приложения недостаточно велик, чтобы вернуть все данные о символе, водитель уселяет его до длины байта, за меньшее количество байтов, требуемых символом нулевого прекращения, сводит на нет усеченные данные и хранит их в буфере. Поэтому приложения всегда должны выделять дополнительное пространство для символа с нулевым окончанием в буферах, используемых для извлечения данных символов. Например, для получения 50 символов данных необходим буфер объемом 51 байт.  
  
 Особое уделость должно уделяться как приложению, так и водителю при отправке или извлечении длинных данных о персонажах по частям с **помощью S'LPutData** или **S'LGetData.** Если данные передаются в виде ряда строк с нулевым завершением, символы с нулевым окончанием на этих строках должны быть удалены до того, как данные могут быть собраны.  
  
 Ряд программистов ODBC перепутали данные о персонажах и строках C. То, что это произошло, является артефактом использования языка C при определении функций ODBC. Если драйвер или приложение ODBC использует другой язык - помните, что ODBC является независимым от языка - эта путаница вряд ли возникнет.  
  
 Когда строки C используются для хранения данных символов, символ нулевого прекращения не считается частью данных и не учитывается как часть его длины байта. Например, данные о персонажах "ABC" могут быть проведены в виде строки C "ABC-0" или массива символов "A", 'B', 'C'. Длина данных составляет 3, независимо от того, рассматривается ли они как строка или массив символов.  
  
 Хотя приложения и драйверы обычно используют строки C (нулевые массивы символов) для хранения данных символов, нет необходимости делать это. В C данные символов также могут рассматриваться как массив символов (без нулевого прекращения), а его длина байта передается отдельно в буфере длины/индикатора.  
  
 Поскольку данные о символах могут находиться в массиве без нулевых, а его длина байт передается отдельно, можно вставлять нулевые символы в данные символов. Однако поведение функций ODBC в данном случае не определено, и именно драйвер определяется тем, правильно ли водитель справляется с этим. Таким образом, совместимые приложения должны всегда обрабатывать данные символов, которые могут содержать встроенные нулевые символы в качестве двоичных данных.
