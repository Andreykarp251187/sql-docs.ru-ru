---
title: Символьные данные и строки C | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- data buffers [ODBC], character data
- buffers [ODBC], C strings
- buffers [ODBC], character data
- character data and buffers [ODBC]
- length of data buffers [ODBC]
- data buffers [ODBC], C strings
- buffers [ODBC], length
- C strings and buffers [ODBC]
ms.assetid: 3a141cb4-229d-4027-9349-615cb2995e36
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 7bb25022d4e0c0559f2a8f77b89a4ba26aeba33a
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81307494"
---
# <a name="character-data-and-c-strings"></a>Символьные данные и строки C
Входные параметры, которые ссылаются на символьные данные переменной длины (такие как имена столбцов, динамические параметры и значения строковых атрибутов), имеют связанный параметр длины. Если приложение завершает строки с нулевым символом, как обычно в C, оно предоставляет в качестве аргумента длину строки в байтах (не включая признак конца null) или SQL_NTS (строка, завершающаяся нулем). Аргумент неотрицательной длины задает фактическую длину связанной строки. Аргумент Length может быть равен 0, чтобы указать строку нулевой длины, которая отличается от значения NULL. Отрицательное значение SQL_NTS указывает драйверу определить длину строки путем поиска символа завершения, заканчивающегося символом NULL.  
  
 Когда символьные данные возвращаются из драйвера в приложение, драйвер должен всегда иметь значение null, завершая его. Это дает приложению возможность выбрать, следует ли выполнять обработку данных в виде строки или массива символов. Если буфер приложения не достаточен для возврата всех символьных данных, драйвер усекает его до длины в байтах буфера, меньшего числа байтов, требуемого для завершающего знака null, NULL — завершает усеченные данные и сохраняет их в буфере. Таким образом, приложения всегда должны выделить дополнительное пространство для завершающего символа NULL в буферах, используемых для получения символьных данных. Например, для получения 50 символов данных требуется буфер размером 51 байт.  
  
 При отправке или извлечении длинных символьных данных в частях с **SQLPutData** или **SQLGetData**необходимо принять во внимание как приложение, так и драйвер. Если данные передаются в виде ряда строк, завершающихся нулем, то перед повторной сборке данных должны быть удалены символы завершения null в этих строках.  
  
 Некоторые программисты ODBC имеют путать символьные данные и строки C. Это является артефактом использования языка C при определении функций ODBC. Если в драйвере или приложении ODBC используется другой язык, не забывайте, что ODBC не зависит от языка. это может привести к снижению вероятности возникновения проблемы.  
  
 Если строки C используются для хранения символьных данных, символ завершения со значением NULL не считается частью данных и не учитывается как часть его длины в байтах. Например, символьные данные "ABC" могут храниться в виде строки C "ABC\0" или массива символов {"A", "B", "C"}. Длина данных в байтах равна 3, независимо от того, обрабатывается ли она как строка или как массив символов.  
  
 Хотя приложения и драйверы обычно используют строки C (массивы символов, заканчивающиеся нулем) для хранения символьных данных, это не обязательно. В языке C символьные данные также могут рассматриваться как массив символов (без завершающего значения NULL), а длина байта, передаваемая отдельно в буфере длины и индикатора.  
  
 Поскольку символьные данные могут храниться в массивах, не заканчивающихся нулем, и его длине байтов по отдельности, можно внедрять символы NULL в символьные данные. Однако поведение функций ODBC в этом случае не определено и зависит от драйвера, правильно ли оно обрабатывается драйвером. Таким образом, взаимодействующие приложения должны всегда работать с символьными данными, которые могут содержать внедренные символы NULL в качестве двоичных данных.
