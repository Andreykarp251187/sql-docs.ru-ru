---
title: Уровни изоляции транзакций (ODBC) Документы Майкрософт
ms.custom: seo-dt-2019
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 622b4cd7f0db259b5ecfd5be63b27df64be965e7
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81298037"
---
# <a name="transaction-isolation-levels-odbc"></a>Уровни изоляции транзакций (ODBC)
*Уровни изоляции транзакций* являются мерой успешной изоляции транзакций. В частности, уровни изоляции транзакций определяются наличием или отсутствием следующих явлений:  
  
-   **Грязные чтения** *Грязное чтение* происходит, когда транзакция считывает данные, которые еще не были зафиксированы. Например, предположим, что транзакция 1 обновляет строку. Транзакция 2 читает обновленную строку перед транзакцией 1, фиксирует обновление. Если транзакция 1 откатывает изменение, транзакция 2 будет считывать данные, которые, как считается, никогда не существовали.  
  
-   **Неповторимые чтения** *Неповторимое считывание* происходит, когда транзакция считывает одну и ту же строку дважды, но каждый раз получает разные данные. Например, предположим, что транзакция 1 читает строку. Транзакция 2 обновляет или удаляет эту строку и фиксирует обновление или удаление. Если транзакция 1 перечитывает строку, она извлекает различные значения строки или обнаруживает, что строка была удалена.  
  
-   **Фантомы** *Фантом* — это строка, которая соответствует критериям поиска, но изначально не просматривается. Например, предположим, что транзакция 1 считывает набор строк, удовлетворяющих некоторым критериям поиска. Транзакция 2 генерирует новую строку (через обновление или вставку), которая соответствует критериям поиска транзакции 1. Если транзакция 1 выполняет оператора, считываемого строки, она получает другой набор строк.  
  
 С точки зрения этих явлений определяются четыре уровня изоляции транзакций (в соответствии с определением S'L-92). В следующей таблице "X" отмечает каждое явление, которое может произойти.  
  
|Уровень изоляции транзакций|Грязные читает|Неповторимые чтения|Фантомы|  
|---------------------------------|-----------------|-------------------------|--------------|  
|Уровень изоляции read uncommitted|X|X|X|  
|Уровень изоляции read committed|--|X|X|  
|Уровень изоляции repeatable read|--|--|X|  
|Упорядочиваемый уровень изоляции|--|--|--|  
  
 В следующей таблице описаны простые способы реализации DBMS уровней изоляции транзакций.  
  
> [!IMPORTANT]  
>  Большинство DBMS используют более сложные схемы, чем эти для увеличения параллелизма. Эти примеры приводятся только для иллюстраций. В частности, ODBC не предписывает, как конкретные DBMS изолируют транзакции друг от друга.  
  
|Изоляция транзакций|Возможная реализация|  
|---------------------------|-----------------------------|  
|Уровень изоляции read uncommitted|Транзакции не изолированы друг от друга. Если DBMS поддерживает другие уровни изоляции транзакций, он игнорирует любой механизм, который он использует для реализации этих уровней. Чтобы они не оказали негативного влияния на другие транзакции, транзакции, совершаемые на уровне Read Uncommitted, обычно читаются только для чтения.|  
|Уровень изоляции read committed|Транзакция ждет, пока строки, заблокированные другими транзакциями, будут разблокированы; это не позволяет ему читать любые "грязные" данные.<br /><br /> Транзакция удерживает блокировку чтения (если она только читает строку) или записывает блокировку (если она обновляет или удаляет строку) в текущей строке, чтобы предотвратить обновление или удаление других транзакций. Релизы транзакций считываете блокировки при переходе от текущей строки. Он удерживает блокировки записей до тех пор, пока он не будет зафиксирован или откатан.|  
|Уровень изоляции repeatable read|Транзакция ждет, пока строки, заблокированные другими транзакциями, будут разблокированы; это не позволяет ему читать любые "грязные" данные.<br /><br /> Транзакция удерживает прочитанные блокировки на всех строках, которые она возвращает в приложение, и записывает блокировки на все строки, которые он вставляет, обновляет или удаляет. Например, если транзакция включает в себя заявление с помощью си-L **SELECT \* FROM Orders,** транзакция блокирует строки по мере их получения приложением. Если транзакция включает в себя выписку **с S'L DELETE От заказов, где статус и 'CLOSED',** то транзакция записывает строки, когда она удаляет их.<br /><br /> Поскольку другие транзакции не могут обновлять или удалять эти строки, текущая транзакция избегает любых неповторимых считываний. Транзакция освобождает свои блокировки при фиксации или откате.|  
|Упорядочиваемый уровень изоляции|Транзакция ждет, пока строки, заблокированные другими транзакциями, будут разблокированы; это не позволяет ему читать любые "грязные" данные.<br /><br /> Транзакция удерживает блокировку чтения (если она читает только строки) или записывает блокировку (если она может обновлять или удалять строки) на диапазоне строк, на которые она влияет. Например, если транзакция включает в себя заявление си-L **SELECT \* FROM Orders,** диапазон представляет собой всю таблицу заказов; транзакция считывает таблицу и не позволяет вставлять в нее новые строки. Если транзакция включает в себя выписку с S'L **DELETE От заказов, где статус и 'CLOSED',** то диапазон состоит из всех строк со статусом "CLOSED"; транзакция записывает все строки в таблице Заказов со статусом "CLOSED" и не допускает вставки или обновления любых строк таким образом, чтобы результирующая строка имеет статус "CLOSED".<br /><br /> Поскольку другие транзакции не могут обновлять или удалять строки в диапазоне, текущая транзакция избегает любых неповторимых считок. Поскольку другие транзакции не могут вставить строки в диапазон, текущая транзакция избегает каких-либо фантомов. Транзакция освобождает блокировку при фиксации или откате.|  
  
 Важно отметить, что уровень изоляции транзакции не влияет на способность транзакции видеть свои собственные изменения; транзакции всегда могут видеть любые изменения, которые они вносят. Например, транзакция может состоять из двух отчетов **UPDATE,** первая из которых повышает заработную плату всех сотрудников на 10 процентов, а вторая устанавливает заработную плату любого сотрудника в течение некоторой максимальной суммы к этой сумме. Это удается как единая транзакция только потому, что второе заявление **UPDATE** может видеть результаты первого.
