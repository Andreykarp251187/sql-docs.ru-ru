---
title: Многопоточность Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- ODBC drivers [ODBC], thread-safe
- thread-safe drivers [ODBC]
- multithreaded applications [ODBC]
ms.assetid: cdfebdf5-12ff-4e28-8055-41f49b77f664
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: c10d1b401ac780d24184c4c2337199e99973e916
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81302422"
---
# <a name="multithreading"></a>Многопоточность
На многопоточных операционных системах драйверы должны быть защищены от потоков. То есть, это должно быть возможным для приложений использовать ту же ручку на более чем одном потоке. Как это достигается, зависит от драйвера, и вполне вероятно, что драйверы будут сериализировать любые попытки одновременно использовать одну и ту же ручку на двух разных потоках.  
  
 Приложения обычно используют несколько потоков вместо асинхронной обработки. Приложение создает отдельный поток, вызывает функцию ODBC на нем, а затем продолжает обработку на основном потоке. Вместо того, чтобы постоянно опрашивать асинхронную функцию, как это имеет место при использовании атрибута SQL_ATTR_ASYNC_ENABLE оператора, приложение может просто позволить вновь созданному потоку закончиться.  
  
 Функции, принимающие ручку оператора и работающие на одном потоке, могут быть отменены, позвонив в **s'LCancel** с той же ручкой оператора из другого потока. Несмотря на то, что драйверы не должны сериализировать использование **S'LCancel** таким образом, нет никакой гарантии, что вызов **S'LCancel** фактически отменит функцию, работающая на другом потоке.
