---
description: Управление параллелизмом
title: Управление параллелизмом | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
ms.assetid: 75e4adb3-3d43-49c5-8c5e-8df96310d912
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e47308cc0224ef73689a3b82d1ab4186fd0c823a
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "88461556"
---
# <a name="concurrency-control"></a>Управление параллелизмом
*Параллелизм* — это способность двух транзакций использовать одни и те же данные одновременно, а повышенная изоляция транзакций обычно достигает меньшего параллелизма. Это обусловлено тем, что изоляция транзакций обычно реализуется с помощью блокировки строк, и по мере того, как количество строк заблокировано, можно завершить меньшее количество транзакций, не блокируя по меньшей мере временно Заблокированную строку. Хотя снижение параллелизма обычно принимается в качестве компромисса для более высоких уровней изоляции транзакций, необходимых для обеспечения целостности базы данных, это может стать проблемой в интерактивных приложениях с большими действиями чтения и записи, в которых используются курсоры.  
  
 Например, предположим, что приложение выполняет инструкцию SQL **SELECT \* из заказов**. Он вызывает **SQLFetchScroll** для прокрутки результирующего набора и позволяет пользователю обновлять, удалять или вставлять заказы. После того как пользователь обновляет, удаляет или вставляет заказ, приложение фиксирует транзакцию.  
  
 Если уровень изоляции читается как повторяемый, транзакция может быть в зависимости от того, как она реализована — блокировка каждой строки, возвращаемой функцией **SQLFetchScroll**. Если уровень изоляции является сериализуемым, транзакция может блокировать всю таблицу Orders. В любом случае транзакция снимает блокировки только при фиксации или откате. Таким образом, если пользователь тратит много времени на чтение заказов и очень мало времени на обновление, удаление или вставку, транзакция может легко заблокировать большое количество строк, делая их недоступными для других пользователей.  
  
 Это проблема, даже если курсор доступен только для чтения и приложение позволяет пользователю читать только существующие заказы. В этом случае приложение фиксирует транзакцию и освобождает блокировки, когда вызывает **SQLCloseCursor** (в режиме автоматической фиксации) или **SQLEndTran** (в режиме ручной фиксации).  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md)  
  
-   [Оптимистическая блокировка](../../../odbc/reference/develop-app/optimistic-concurrency.md)
