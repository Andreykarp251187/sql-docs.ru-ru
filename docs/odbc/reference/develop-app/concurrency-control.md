---
title: Управление параллелизмом | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
ms.assetid: 75e4adb3-3d43-49c5-8c5e-8df96310d912
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 8afba3b3b8c8fee1307473c790186d509b37d982
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81294854"
---
# <a name="concurrency-control"></a>Управление параллелизмом
*Параллелизм* — это способность двух транзакций использовать одни и те же данные одновременно, а повышенная изоляция транзакций обычно достигает меньшего параллелизма. Это обусловлено тем, что изоляция транзакций обычно реализуется с помощью блокировки строк, и по мере того, как количество строк заблокировано, можно завершить меньшее количество транзакций, не блокируя по меньшей мере временно Заблокированную строку. Хотя снижение параллелизма обычно принимается в качестве компромисса для более высоких уровней изоляции транзакций, необходимых для обеспечения целостности базы данных, это может стать проблемой в интерактивных приложениях с большими действиями чтения и записи, в которых используются курсоры.  
  
 Например, предположим, что приложение выполняет инструкцию SQL ** \* SELECT из заказов**. Он вызывает **SQLFetchScroll** для прокрутки результирующего набора и позволяет пользователю обновлять, удалять или вставлять заказы. После того как пользователь обновляет, удаляет или вставляет заказ, приложение фиксирует транзакцию.  
  
 Если уровень изоляции читается как повторяемый, транзакция может быть в зависимости от того, как она реализована — блокировка каждой строки, возвращаемой функцией **SQLFetchScroll**. Если уровень изоляции является сериализуемым, транзакция может блокировать всю таблицу Orders. В любом случае транзакция снимает блокировки только при фиксации или откате. Таким образом, если пользователь тратит много времени на чтение заказов и очень мало времени на обновление, удаление или вставку, транзакция может легко заблокировать большое количество строк, делая их недоступными для других пользователей.  
  
 Это проблема, даже если курсор доступен только для чтения и приложение позволяет пользователю читать только существующие заказы. В этом случае приложение фиксирует транзакцию и освобождает блокировки, когда вызывает **SQLCloseCursor** (в режиме автоматической фиксации) или **SQLEndTran** (в режиме ручной фиксации).  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md)  
  
-   [Оптимистическая блокировка](../../../odbc/reference/develop-app/optimistic-concurrency.md)
