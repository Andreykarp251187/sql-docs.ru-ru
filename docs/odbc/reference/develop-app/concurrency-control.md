---
title: Управление параллелизмом | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
ms.assetid: 75e4adb3-3d43-49c5-8c5e-8df96310d912
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 7c541bf28c1d4c7ec2e2041201bd7c168625bb34
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68083263"
---
# <a name="concurrency-control"></a>Управление параллелизмом
*Параллелизм* является возможность использовать те же данные в то же время две транзакции, и с повышенной транзакцией изоляции обычно уже проблемам при параллельном выполнении. Это обусловлено изоляции транзакций обычно реализуется с блокировки строки, и как дополнительные строки блокируются, меньшее количество транзакций может быть завершена без блокировки по крайней мере временно по в заблокированной строке. Хотя проблемам при параллельном выполнении обычно принимается как компромисс для более высоких уровней изоляции транзакций, необходимые для поддержания целостности базы данных, он может стать проблемой в интерактивные приложения с действием высокой чтения и записи, в котором использовать курсоры.  
  
 Например, предположим, что приложение выполняет инструкцию SQL **ВЫБЕРИТЕ \* заказы из**. Он вызывает **SQLFetchScroll** для прокрутки по результат задать и позволяет пользователю для обновления, удаления или вставки заказов. После пользователь обновляет, удаляет или вставляет заказ, приложение фиксирует транзакцию.  
  
 Если уровень изоляции Repeatable Read, транзакции — в зависимости от его реализации - блокировать каждая строка, возвращенная **SQLFetchScroll**. Если уровень изоляции Serializable, транзакции могут привести к блокировке всей таблицы Orders. В любом случае транзакция освобождает свои блокировки только в том случае, если он фиксируется или откатывается назад. Поэтому если пользователь тратит много времени на чтение заказов и очень мало времени, обновления, удаления или вставки, транзакция может легко заблокируйте большое количество строк, сделав их недоступными для других пользователей.  
  
 Это проблема, даже в том случае, если курсор доступен только для чтения, и приложение позволяет пользователю считывать только существующие заказы. В этом случае приложение фиксирует транзакцию и освобождает блокировки, в том случае, когда он вызывает **SQLCloseCursor** (в режиме автоматической фиксации) или **SQLEndTran** (в режиме ручной фиксации).  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md)  
  
-   [Оптимистический параллелизм](../../../odbc/reference/develop-app/optimistic-concurrency.md)
