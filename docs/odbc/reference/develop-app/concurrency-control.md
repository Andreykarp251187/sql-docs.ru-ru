---
title: Управление параллелизмом | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- transactions [ODBC], concurrency control
- concurrency control [ODBC]
ms.assetid: 75e4adb3-3d43-49c5-8c5e-8df96310d912
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 8afba3b3b8c8fee1307473c790186d509b37d982
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81294854"
---
# <a name="concurrency-control"></a>Управление параллелизмом
*Параллелизм -* это способность двух транзакций использовать одни и те же данные одновременно, а при повышенной изоляции транзакций обычно приходит уменьшенная параллель. Это связано с тем, что изоляция транзакций обычно реализуется путем блокировки строк, и по мере блокировки большего количества строк меньше транзакций может быть завершено без блокировки хотя бы временно заблокированной строкой. Хотя снижение параллелизма обычно воспринимается в качестве компромисса для более высоких уровней изоляции транзакций, необходимых для поддержания целостности базы данных, это может стать проблемой в интерактивных приложениях с высокой активностью чтения/записи, использующей курсоры.  
  
 Например, предположим, что приложение выполняет заявление СЗЛ **SELECT \* FROM Orders.** Он вызывает **S'LFetchScroll** для прокрутки вокруг набора результатов и позволяет пользователю обновлять, удалять или вставлять заказы. После обновления, удаления или вставки заказа приложение совершает транзакцию.  
  
 Если уровень изоляции повторяется, транзакция может - в зависимости от того, как она реализуется - заблокировать каждую строку, возвращенную **S'LFetchScroll.** Если уровень изоляции является serializable, транзакция может заблокировать всю таблицу заказов. В любом случае транзакция освобождает свои блокировки только тогда, когда она зафиксирована или отката. Так что, если пользователь тратит много времени на чтение заказов и очень мало времени на обновление, удалие или вставке, транзакция может легко заблокировать большое количество строк, сделав их недоступными для других пользователей.  
  
 Это проблема, даже если курсор читается только и приложение позволяет пользователю читать только существующие заказы. В этом случае приложение фиксирует транзакцию и выпускает блокировки, когда оно вызывает **S'LCloseCursor** (в режиме автоматического коммита) или **S'LEndTran** (в режиме ручного коммита).  
  
 Этот раздел содержит следующие подразделы.  
  
-   [Типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md)  
  
-   [Оптимистическая блокировка](../../../odbc/reference/develop-app/optimistic-concurrency.md)
