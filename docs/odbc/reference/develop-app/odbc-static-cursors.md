---
title: Статические курсоры ODBC | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- cursors [ODBC], static
- static cursors [ODBC]
ms.assetid: 28cb324c-e1c3-4b5c-bc3e-54df87037317
author: MightyPen
ms.author: genemi
ms.openlocfilehash: bcb7c39d39492b91c0b62c5eff2229eb5f61df6b
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "67987836"
---
# <a name="odbc-static-cursors"></a>Статические курсоры (ODBC)
Статический курсор — это тот, в котором результирующий набор выглядит как статический. Обычно он не обнаруживает изменения, внесенные в членство, порядок или значения результирующего набора после открытия курсора. Например, предположим, что статический курсор извлекает строку, а другое приложение обновляет эту строку. Если статический курсор повторно извлекает строку, отображаемые им значения не меняются, несмотря на изменения, внесенные другим приложением.  
  
 Статические курсоры могут обнаруживать свои собственные обновления, удаления и вставки, хотя это и не является обязательным. Указывает, обнаруживает ли определенный статический курсор эти изменения с помощью параметра SQL_STATIC_SENSITIVITY в **SQLGetInfo**. Статические курсоры никогда не обнаруживают другие обновления, удаления и вставки.  
  
 Массив состояний строк, заданный атрибутом SQL_ATTR_ROW_STATUS_PTR инструкции, может содержать SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO или SQL_ROW_ERROR для любой строки. Он возвращает SQL_ROW_UPDATED, SQL_ROW_DELETED или SQL_ROW_ADDED для строк, которые обновляются, удаляются или вставляются с помощью курсора, предполагая, что курсор может обнаруживать такие изменения.  
  
 Статические курсоры обычно реализуются путем блокировки строк в результирующем наборе или создания копии или моментального снимка результирующего набора. Хотя блокировка строк относительно проста в выполнении, она имеет недостаток значительного снижения параллелизма. Создание копии обеспечивает более высокую степень параллелизма и позволяет курсору отследить свои собственные обновления, удаления и вставки, изменив копию. Тем не менее, копирование является более затратным и может отличаться от базовых данных, так как эти данные изменяются другими пользователями.
