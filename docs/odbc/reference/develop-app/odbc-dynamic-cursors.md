---
title: Динамика ODBC Курзоры (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- cursors [ODBC], dynamic
- dynamic cursors [ODBC]
ms.assetid: de709fd3-9eb2-44e1-a2f0-786e2b9602a6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: f94b83ef1458cd9f8368d1bea3a39682bd80b1a2
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81302326"
---
# <a name="odbc-dynamic-cursors"></a>Динамические курсоры ODBC
Динамический курсор только что: динамический. Он может обнаруживать любые изменения, внесенные в членство, порядок и значения результатов, установленных после открытия курсора. Например, предположим, что динамический курсор извлекает две строки, а другое приложение затем обновляет одну из них и удаляет другую. Если динамический курсор затем попытается восстановить эти строки, он не найдет удаленный ряд, но вернет новые значения для обновленной строки.  
  
 Динамические курсоры обнаруживают все обновления, удаляют и вставляют, как свои собственные, так и сделанные другими. (Это зависит от уровня изоляции транзакции, установленного атрибутом SQL_ATTR_TXN_ISOLATION соединения.) Массив состояния строк, указанный атрибутом SQL_ATTR_ROW_STATUS_PTR оператора, отражает эти изменения и может содержать SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO, SQL_ROW_ERROR, SQL_ROW_UPDATED и SQL_ROW_ADDED. Он не может вернуть SQL_ROW_DELETED, поскольку динамический курсор не возвращает удаленные строки за пределами строки и поэтому больше не признает наличие удаленного строки в наборе результатов или ее соответствующего элемента в массиве состояния строки. SQL_ROW_ADDED возвращается только тогда, когда строка обновляется вызовом в **S'LSetPos,** а не когда она обновляется другим курсором.  
  
 Одним из способов реализации динамических курсоров в базе данных является создание селективного индекса, определяющего членство и порядок набора результатов. Поскольку индекс обновляется, когда другие вносят изменения, курсор, основанный на таком индексе, чувствителен ко всем изменениям. Дополнительный выбор в пределах установленного этим индексом результата возможен путем обработки по индексу.  
  
 Динамические курсоры могут быть смоделированы, требуя, чтобы набор результатов был заказан уникальным ключом. С таким ограничением, извлечения производятся путем выполнения оператора **SELECT** каждый раз, когда курсор получает строки. Например, предположим, что набор результатов определяется этим утверждением:  
  
```  
SELECT * FROM Customers ORDER BY Name, CustID  
```  
  
 Чтобы получить следующий набор строк в этом наборе результатов, смоделированный курсор устанавливает параметры в следующем заявлении **SELECT** к значениям в последнем ряду текущего набора строк, а затем выполняет его:  
  
```  
SELECT * FROM Customers WHERE (Name > ?) AND (CustID > ?)  
   ORDER BY Name, CustID  
```  
  
 Это утверждение создает второй набор результатов, первым рядом которого является следующий ряд в исходном наборе - в данном случае набор строк в таблице Клиентов. Курсор возвращает этот набор строк в приложение.  
  
 Интересно отметить, что динамический курсор, реализованный таким образом, фактически создает множество наборов результатов, что позволяет обнаружить изменения исходного набора. Приложение никогда не узнает о существовании этих вспомогательных наборов результатов; он просто кажется, как будто курсор способен обнаружить изменения исходного набора.
