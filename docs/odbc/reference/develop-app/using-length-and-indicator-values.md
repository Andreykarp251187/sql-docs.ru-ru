---
title: Использование значений длины и индикатора Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- length/indicator buffers [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 849792f1-cb1e-4bc2-b568-c0aff0b66199
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a0c878c9038b26aa996ed206c6b8adfe8d6c21e5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306765"
---
# <a name="using-length-and-indicator-values"></a>Использование значений длины и индикатора
Буфер длины/индикатора используется для передачи длины данных в буфере данных или специального индикатора, такого как SQL_NULL_DATA, что указывает на то, что данные являются NULL. В зависимости от функции, в которой он используется, буфер длины/индикатора определяется как S'LINTEGER или S'LSMALLSMALLINT. Поэтому для его описания необходим единый аргумент. Если буфер данных является неотложенным буфером ввода, этот аргумент содержит длину байта самой данных или значение индикатора. Его часто называют *StrLen_or_Ind* или похожим названием. Например, следующий код вызывает **S'LPutData,** чтобы передать буфер, полный данных; длина байта *(ValueLen*) передается непосредственно потому, что буфер данных *(ValuePtr)* является буфером ввода.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLen;  
  
// Call local function to place data in ValuePtr. In ValueLen, return the  
// number of bytes of data placed in ValuePtr. If there is not enough  
// data, this will be less than 50.  
FillBuffer(ValuePtr, sizeof(ValuePtr), &ValueLen);  
  
// Call SQLPutData to send the data to the driver.  
SQLPutData(hstmt, ValuePtr, ValueLen);  
```  
  
 Если буфер данных является отложенным буфером ввода, неотложенным буфером вывода или буфером вывода, аргумент содержит адрес буфера длины/индикатора. Его часто называют *StrLen_or_IndPtr* или похожим названием. Например, следующий код вызывает **S'LGetData** для получения буфера, полного данных; длина байта возвращается в приложение в буфере длины/индикатора *(ValueLenOrInd),* адрес которого передается **в S'LGetData,** поскольку соответствующий буфер данных *(ValuePtr)* является неотложенным буфером вывода.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLenOrInd;  
SQLGetData(hstmt, 1, SQL_C_CHAR, ValuePtr, sizeof(ValuePtr), &ValueLenOrInd);  
```  
  
 Если это специально не запрещено, аргумент буфера длины/индикатора может быть 0 (если не отложенный ввод) или нулевой указатель (если выход или отложенный вход). Для буферов ввода это приводит к тому, что драйвер игнорирует длину данных. Это возвращает ошибку при передаче данных переменной длины, но часто при передаче данных с ненулевой, фиксированной длиной, потому что не требуется ни длина, ни значение индикатора. Для буферов вывода это приводит к тому, что драйвер не возвращает длину данных или значение индикатора. Это ошибка, если данные, возвращенные драйвером, являются NULL, но являются общими при извлечении данных с фиксированной длиной, не облагаемыми нулевую, поскольку ни длина, ни значение индикатора не требуется.  
  
 Как и при перенаправлении драйвера адреса отложенного буфера данных, адрес буфера отложенной длины/индикатора должен оставаться в силе до тех пор, пока буфер не будет не связан.  
  
 Следующие длины действительны в качестве значений длины/индикатора:  
  
-   *n*, где *n* > 0.  
  
-   0.  
  
-   SQL_NTS. Строка, отправленная водителю в соответствующем буфере данных, не прекращается; это удобный способ для C программистов пройти строки без расчета их длины байт. Это значение является законным только тогда, когда приложение отправляет данные водителю. Когда драйвер возвращает данные в приложение, он всегда возвращает фактическую длину данных.  
  
 Следующие значения действительны как значения длины/индикатора. SQL_NULL_DATA хранится в поле дескриптора SQL_DESC_INDICATOR_PTR; все остальные значения хранятся в поле дескриптора SQL_DESC_OCTET_LENGTH_PTR.  
  
-   SQL_NULL_DATA. Данные являются значением данных NULL, а значение в соответствующем буфере данных игнорируется. Это значение является законным только для данных S'L, отправленных или извлеченных из драйвера.  
  
-   SQL_DATA_AT_EXEC. Буфер данных не содержит данных. Вместо этого данные будут отправляться с **помощью S'LPutData,** когда выписка будет выполнена или когда будет созвано **S'LBulkOperations** или **S'LSetPos.** Это значение является законным только для данных S'L, отправленных водителю. Для получения более подробной информации, [SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)см. [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md) [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)  
  
-   Результат SQL_LEN_DATA_AT_EXEC *(длина)* макроса. Это значение похоже на SQL_DATA_AT_EXEC. Для получения дополнительной информации [см.](../../../odbc/reference/develop-app/sending-long-data.md)  
  
-   SQL_NO_TOTAL. Драйвер не может определить количество байтов длинных данных, которые по-прежнему доступны для возврата в буфере вывода. Это значение является законным только для данных, полученных от драйвера.  
  
-   SQL_DEFAULT_PARAM. Процедура заключается в использовании значения ввода по умолчанию в процедуре вместо значения в соответствующем буфере данных.  
  
-   SQL_COLUMN_IGNORE. **СЗЛБалКОперации** или **S'LSetPos** должны игнорировать значение в буфере данных. При обновлении ряда данных по вызову в **S'LBulkOperations** или **S'LSetPos** значение столбца не изменяется. При вставке нового ряда данных по вызову в **S'LBulkOperations**значение столбца устанавливается по умолчанию или, если столбец не имеет значения по умолчанию, в NULL.
