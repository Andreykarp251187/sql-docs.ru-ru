---
title: Использование значений длины и индикатора | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- length/indicator buffers [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 849792f1-cb1e-4bc2-b568-c0aff0b66199
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a0c878c9038b26aa996ed206c6b8adfe8d6c21e5
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81306765"
---
# <a name="using-length-and-indicator-values"></a>Использование значений длины и индикатора
Буфер длины и индикатора используется для передачи длины байтов данных в буфере данных или специального индикатора, например SQL_NULL_DATA, который указывает, что данные имеют значение NULL. В зависимости от функции, в которой она используется, буфер длины или индикатора определяется как SQLINTEGER или SQLSMALLINT. Поэтому для его описания требуется один аргумент. Если буфер данных является входным буфером нондеферред, этот аргумент содержит длину в байтах самих данных или значение индикатора. Часто имя называется *StrLen_Or_Ind* или аналогичным именем. Например, следующий код вызывает **SQLPutData** , чтобы передать буфер с заполненными данными. Длина байта (*валуелен*) передается напрямую, так как буфер данных (*ValuePtr*) является входным буфером.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLen;  
  
// Call local function to place data in ValuePtr. In ValueLen, return the  
// number of bytes of data placed in ValuePtr. If there is not enough  
// data, this will be less than 50.  
FillBuffer(ValuePtr, sizeof(ValuePtr), &ValueLen);  
  
// Call SQLPutData to send the data to the driver.  
SQLPutData(hstmt, ValuePtr, ValueLen);  
```  
  
 Если буфер данных является отложенным входным буфером, буфером вывода нондеферред или выходным буфером, аргумент содержит адрес буфера длины или индикатора. Часто имя называется *StrLen_or_IndPtr* или аналогичным именем. Например, следующий код вызывает **SQLGetData** , чтобы получить буфер, заполненный данными; Длина байта возвращается приложению в буфере длины или индикатора (*валуеленоринд*), адрес которого передается в **SQLGetData** , так как соответствующий буфер данных (*ValuePtr*) является выходным буфером нондеферред.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLenOrInd;  
SQLGetData(hstmt, 1, SQL_C_CHAR, ValuePtr, sizeof(ValuePtr), &ValueLenOrInd);  
```  
  
 Если это не запрещено специально, аргумент буфера длины или индикатора может иметь значение 0 (если нондеферред input) или указатель null (если выход или отложенный ввод). Для входных буферов это приводит к тому, что драйвер игнорирует длину данных в байтах. Это возвращает ошибку при передаче данных переменной длины, но обычно при передаче данных фиксированной длины, отличных от NULL, поскольку не требуется ни длина, ни значение индикатора. Для буферов вывода это приводит к тому, что драйвер не возвращает длину байт данных или значение индикатора. Это ошибка, если данные, возвращаемые драйвером, имеют значение NULL, но часто используются при извлечении данных фиксированной длины, не допускающих значения NULL, поскольку не требуется ни длина, ни значение индикатора.  
  
 Как и в случае передачи адреса отложенного буфера данных в драйвер, адрес отложенной длины или буфера индикатора должен оставаться действительным до тех пор, пока не будет отменена привязка буфера.  
  
 Следующие длины допустимы в качестве значений длины и индикатора:  
  
-   *n*, где *n* > 0.  
  
-   0.  
  
-   SQL_NTS. Строка, отправленная драйверу в соответствующем буфере данных, завершается нулем. Это удобный способ, позволяющий программистам на языке C передавать строки без вычисления их длины в байтах. Это значение допустимо только в том случае, если приложение отправляет данные драйверу. Когда драйвер возвращает данные в приложение, он всегда возвращает фактическую длину данных в байтах.  
  
 Следующие значения допустимы в качестве значений длины и индикатора. SQL_NULL_DATA хранится в поле дескриптора SQL_DESC_INDICATOR_PTR; все остальные значения хранятся в поле Дескриптор SQL_DESC_OCTET_LENGTH_PTR.  
  
-   SQL_NULL_DATA. Данные имеют значение NULL, а значение в соответствующем буфере данных игнорируется. Это значение допустимо только для данных SQL, отправляемых или получаемых из драйвера.  
  
-   SQL_DATA_AT_EXEC. Буфер данных не содержит данных. Вместо этого данные будут отправляться с помощью **SQLPutData** при выполнении инструкции или при вызове **SQLBulkOperations** или **SQLSetPos** . Это значение допустимо только для данных SQL, отправляемых драйверу. Дополнительные сведения см. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
-   Результат макроса SQL_LEN_DATA_AT_EXEC (*length*). Это значение аналогично SQL_DATA_AT_EXEC. Дополнительные сведения см. в разделе [Отправка длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
-   SQL_NO_TOTAL. Драйвер не может определить число байтов длинных данных, которые все еще доступны для возврата в выходной буфер. Это значение допустимо только для данных SQL, полученных из драйвера.  
  
-   SQL_DEFAULT_PARAM. Процедура заключается в использовании значения по умолчанию входного параметра в процедуре вместо значения в соответствующем буфере данных.  
  
-   SQL_COLUMN_IGNORE. **SQLBulkOperations** или **SQLSetPos** позволяют игнорировать значение в буфере данных. При обновлении строки данных с помощью вызова **SQLBulkOperations** или **SQLSetPos** значение столбца не изменяется. При вставке новой строки данных с помощью вызова **SQLBulkOperations**значение столбца задается по умолчанию или, если столбец не имеет значения по умолчанию, равного null.
