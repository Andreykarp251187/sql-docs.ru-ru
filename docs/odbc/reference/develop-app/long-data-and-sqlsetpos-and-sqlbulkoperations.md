---
title: Длинные данные и S'LSetPos и S'LBulkOperations (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- long data [ODBC]
- SQLSetPos function [ODBC], long data and SQLBulkOperations
- data updates [ODBC], long data
- updating data [ODBC], long data
- SQLBulkOperations function [ODBC], long data
ms.assetid: e2fdf842-5e4c-46ca-bb21-4625c3324f28
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 4bc6c5d2da2f796a7c312971635fc36bc2fae8af
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287868"
---
# <a name="long-data-and-sqlsetpos-and-sqlbulkoperations"></a>Данные типа Long Data и функции SQLSetPos и SQLBulkOperations
Как и в случае с параметрами в выписках по S'L, длинные данные могут быть отправлены при обновлении строк с **помощью S'LBulkOperations** или **S'LSetPos** или при вставке строк с **s'LBulkOperations.** Данные отправляются по частям, с несколькими вызовами на **S'LPutData.** Столбцы, для которых данные отправляются во время выполнения, известны как *столбцы данных по исполнению.*  
  
> [!NOTE]  
>  Приложение фактически может отправлять любые типы данных во время выполнения с **помощью S'LPutData,** хотя только символ и двоичные данные могут быть отправлены по частям. Однако, если данные достаточно малы, чтобы поместиться в один буфер, как правило, нет никаких оснований для использования **S'LPutData**. Гораздо проще связать буфер и позволить водителю получить данные из буфера.  
  
 Поскольку длинные столбцы данных, как правило, не связаны, приложение должно связать столбец перед вызовом **S'LBulkOperations** или **S'LSetPos** и отменить его после вызова **S'LBulkOperations** или **S'LSetPos.** Столбец должен быть связан, так как **S'LBulkOperations** или **S'LSetPos** работают только на связанных столбцах и должны быть несвязаны, так что **S'LGetData** может быть использован для получения данных из столбца.  
  
 Для отправки данных во время выполнения приложение делает следующее:  
  
1.  Размещает 32-битное значение в буфере строки вместо значения данных. Это значение будет возвращено в приложение позже, поэтому приложение должно установить его на значимое значение, например, число столбцов или ручку файла, содержащего данные.  
  
2.  Устанавливает значение в буфере длины/индикатора к результату SQL_LEN_DATA_AT_EXEC *(длина)* макроса. Это значение указывает водителю на то, что данные по параметру будут отправлены с **помощью S'LPutData.** Значение *длины* используется при отправке длинных данных в источник данных, который должен знать, сколько байтов длинных данных будет отправлено, чтобы оно мог предварительно распределить пространство. Чтобы определить, требуется ли источник данных для этого значения, приложение вызывает **s'LGetInfo** с SQL_NEED_LONG_DATA_LEN опцией. Все драйверы должны поддерживать этот макрос; если источник данных не требует длины байта, водитель может игнорировать его.  
  
3.  Вызывает **вызовы s'LBulkOperations** или **S'LSetPos**. Драйвер обнаруживает, что буфер длины/индикатора содержит результат макроса SQL_LEN_DATA_AT_EXEC *(длина)* и возвращается SQL_NEED_DATA как значение возврата функции.  
  
4.  Вызовы **S'LParamData** в ответ на SQL_NEED_DATA значение возврата. Если необходимо отправлять длинные данные, SQL_NEED_DATA возвращается **SQL_NEED_DATA.** В буфере, на который указывает аргумент *ValuePtrPtr,* драйвер возвращает уникальное значение, которое приложение помещает в буфер строки. При наличии нескольких столбцов данных, намоментсных для выполнения, приложение использует это значение, чтобы определить, для какого столбца для отправки данных; водитель не обязан запрашивать данные для столбцов данных в каком-либо конкретном порядке.  
  
5.  Вызывает **sLPutData** для отправки данных столбца водителю. Если данные столбца не вписываются в один буфер, как это часто бывает с длинными данными, приложение неоднократно вызывает **S'LPutData** для отправки данных частями; это до водителя и источника данных, чтобы собрать данные. Если приложение передает данные строки с нулевым завершением, драйвер или источник данных должен удалить символ нулевого прекращения в процессе повторной сборки.  
  
6.  Снова вызывает **S'LParamData,** чтобы указать, что он отправил все данные для столбца. При наличии столбцов данных по исполнению, для которых данные не были отправлены, драйвер возвращается SQL_NEED_DATA и уникальное значение для следующего столбца данных по исполнению; приложение возвращается к шагу 5. Если данные были отправлены для всех столбцов выполнения данных, данные для строки отправляются в источник данных. **Затем sLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO и может вернуть любой S'Lbulk, что **S'LBulkOperations** или **S'LSetPos** может вернуться.  
  
 После того, как **s'LBulkOperations** или **S'LSetPos** возвращается SQL_NEED_DATA и до того, как данные были полностью отправлены для последнего столбца данных по исполнению, заявление находится в состоянии нужных данных. В этом состоянии приложение может вызывать только **S'LPutData**, **S'LParamData**, **S'LCancel**, **S'LGetDiagField**, или **S'LGetDiagRec**; все остальные функции возвращаютs S'Lstate HY010 (ошибка последовательности функций). Вызов **S'LCancel** отменяет выполнение оператора и возвращает его в прежнее состояние. Для получения дополнительной информации [см.](../../../odbc/reference/appendixes/appendix-b-odbc-state-transition-tables.md)
