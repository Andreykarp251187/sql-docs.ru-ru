---
title: Большие объемы данных и функции SQLSetPos и SQLBulkOperations | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- long data [ODBC]
- SQLSetPos function [ODBC], long data and SQLBulkOperations
- data updates [ODBC], long data
- updating data [ODBC], long data
- SQLBulkOperations function [ODBC], long data
ms.assetid: e2fdf842-5e4c-46ca-bb21-4625c3324f28
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 578c85331a65c15cb25b5d9b75b7156ab509e910
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68036410"
---
# <a name="long-data-and-sqlsetpos-and-sqlbulkoperations"></a>Данные типа Long Data и функции SQLSetPos и SQLBulkOperations
Как и в случае с параметрами в инструкции SQL, могут отправляться данные большой длины, при обновлении строки со **SQLBulkOperations** или **SQLSetPos** или при вставке строк с **SQLBulkOperations**. Данные отправляются в части, и в нескольких вызовах **SQLPutData**. Столбцы, для которых данные отправляются во время выполнения, называются *столбцов данных времени выполнения*.  
  
> [!NOTE]  
>  Приложение может отправить данные любого типа во время выполнения с помощью **SQLPutData**, несмотря на то, что в части могут отправляться только символьных и двоичных данных. Тем не менее, если данные помещаются в один буфер, нет смысла использовать **SQLPutData**. Это гораздо проще привязать буфер и позволить драйвер извлечения данных из буфера.  
  
 Так как данные большой длины столбцов обычно не связаны, приложение необходимо привязать столбец перед вызовом **SQLBulkOperations** или **SQLSetPos** и отменить его привязку после вызова метода **SQLBulkOperations**  или **SQLSetPos**. Столбец должен быть привязан, так как **SQLBulkOperations** или **SQLSetPos** действует только для привязанных столбцов и должна быть отменена, чтобы **SQLGetData** может использоваться для получения данных в столбце.  
  
 Для отправки данных во время выполнения, приложение выполняет следующие функции:  
  
1.  32-разрядное значение помещает в буфер строк вместо значения данных. Это значение будет возвращаться в приложение более поздней версии, поэтому приложение должно задать его в осмысленные, например номер столбца или дескриптор файла, содержащего данные.  
  
2.  Задает значение в буфер длины/индикатора к результату значение SQL_LEN_DATA_AT_EXEC (*длина*) макрос. Это значение указывает драйверу, будут отправлены данные для параметра с **SQLPutData**. *Длина* значение используется при отправке длинных данных к источнику данных, что нужно знать, сколько байтов больших объемов данных будут отправляться таким образом, чтобы его можно заранее выделите место. Чтобы определить, требуется ли источник данных это значение, приложение вызывает **SQLGetInfo** с параметром SQL_NEED_LONG_DATA_LEN. Все драйверы должны поддерживать этот макрос; Если источник данных не требует байтовая длина, драйвер можно пропустить.  
  
3.  Вызовы **SQLBulkOperations** или **SQLSetPos**. Драйвер обнаруживает, что буфер длины/индикатора содержит результат значение SQL_LEN_DATA_AT_EXEC (*длина*) макрос и возвращает SQL_NEED_DATA как возвращаемое значение функции.  
  
4.  Вызовы **SQLParamData** в ответ на SQL_NEED_DATA возвращаемое значение. Если данные большой длины должен быть отправлен, **SQLParamData** возвращает SQL_NEED_DATA. В буфере, на которые указывают *ValuePtrPtr* аргумент, драйвер возвращает уникальное значение, которое приложение помещаются в буфер строк. Если имеется более одного столбца данных во время выполнения, приложение использует это значение, чтобы определить, какой столбец для отправки данных; драйвер не является обязательным для запроса данных для столбцов данных времени выполнения в определенном порядке.  
  
5.  Вызовы **SQLPutData** для отправки данных в столбце к драйверу. Если столбец данных не помещается в один буфер, как это часто бывает в случае с длинных данных, приложение вызывает **SQLPutData** несколько раз, чтобы отправить данные в частях; само драйвер и источник данных для пересборки данных. Если приложение передает заканчивающуюся нулем строку данных, драйвер или источник данных необходимо удалить знак завершения null как часть процесса сборки.  
  
6.  Вызовы **SQLParamData** еще раз, чтобы указать, что он отправлены все данные для столбца. Если какие-либо столбцы данных времени выполнения, для которых данные не были отправлены, драйвер возвращает SQL_NEED_DATA и уникальное значение для следующего столбца данных во время выполнения; приложение возвращается к шагу 5. Если данные отправлены для всех столбцов данных времени выполнения, данные для строки отправляются в источник данных. **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO и может возвращать любой SQLSTATE **SQLBulkOperations** или **SQLSetPos** может возвращать.  
  
 После **SQLBulkOperations** или **SQLSetPos** возвращает SQL_NEED_DATA и до передачи данных полностью для последнего столбца данных во время выполнения, инструкция находится в состоянии необходимые данные. В этом состоянии приложение может вызвать только **SQLPutData**, **SQLParamData**, **SQLCancel**, **SQLGetDiagField**, или **SQLGetDiagRec**; все остальные функции возвращают параметром SQLSTATE HY010 (функционировать ошибка последовательности). Вызов **SQLCancel** отменяет выполнение инструкции и возвращает его в предыдущее состояние. Дополнительные сведения см. в разделе [приложении б: Таблицы перехода состояния ODBC](../../../odbc/reference/appendixes/appendix-b-odbc-state-transition-tables.md).
