---
title: Процедурные вызовы Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- escape sequences [ODBC], procedure calls
- procedure calls [ODBC]
ms.assetid: 145130cc-40e7-4722-8417-dff131084752
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a9c52e72512c8b81c6872461207f235ea2731ac5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81282234"
---
# <a name="procedure-calls"></a>Вызовы процедур
*Процедура* — это исполняемый объект, хранящийся на источнике данных. Обычно процедурой является одна или несколько заранее скомпилированных инструкций SQL. Последовательность побега для вызова процедуры  
  
 **Вопрос:***parameter***«Процедура-имя вызова»** *procedure-name***(**» »**» » » » » » »**»*параметр*.**?=** **)**]**}**  
  
 где *процедура-имя* определяет название процедуры и *параметр* определяет параметр процедуры.  
  
 Для получения дополнительной информации о последовательности побега процедуры можно просмотреть [последовательность побега procedure Call в](../../../odbc/reference/appendixes/procedure-call-escape-sequence.md) приложении C: Грамматика S'L.  
  
 Процедура может иметь параметры или не иметь их. Он также может вернуть значение, как указано дополнительным маркером **параметра?** Если *параметр* является вхотворным или вхотворным/выходным параметром, то это может быть буквальный или параметрный маркер. Однако совместимые приложения должны всегда использовать параметры маркеров, поскольку некоторые источники данных не принимают значения буквальных параметров. Если *параметр* является выходным параметром, он должен быть паралимберным маркером. Параметры маркеры должны быть связаны с **S'LBindParameter** до процедуры вызова заявление выполняется.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается с помощью скобк, но без каких-либо параметров, таких как *«имя процедуры*вызова»), водитель поручает источнику данных использовать значение по умолчанию для первого параметра. Если процедура не имеет каких-либо параметров, это может привести к сбою процедуры. Если процедура называется без скобки, например, *«имя процедуры*вызова», драйвер не отправляет значения параметров.  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, предположим, что процедура **InsertOrder** имеет пять входных параметров. Следующий вызов **в InsertOrder** опускает первый параметр, обеспечивает буквальный для второго параметра и использует параметр для третьего, четвертого и пятого параметров:  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}   // Not interoperable!  
```  
  
 Обратите внимание, что если параметр опущен, запятая, разграниченная по другим параметрам, должна по-прежнему отображаться. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Другой способ указать значение ввода или ввода/вывода по умолчанию — это установить значение буфера длины/индикатора, привязанного к параметру SQL_DEFAULT_PARAM.  
  
 Если параметр ввода/выхода опущен или если в параметр поставляется буквальный, драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
 Предположим, что процедура PARTS_IN_ORDERS создает набор результатов, содержащий список ордеров, содержащих определенный номер детали. Следующий код называет эту процедуру для части номер 544:  
  
```  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0;  
  
// Bind the parameter.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0,  
                  &PartID, 0, PartIDInd);  
  
// Place the department number in PartID.  
PartID = 544;  
  
// Execute the statement.  
SQLExecDirect(hstmt, "{call PARTS_IN_ORDERS(?)}", SQL_NTS);  
```  
  
 Чтобы определить, поддерживает ли источник данных процедуры, приложение вызывает **s'LGetInfo** с SQL_PROCEDURES опцией.  
  
 Для получения дополнительной информации о процедурах [см.](../../../odbc/reference/develop-app/procedures-odbc.md)
