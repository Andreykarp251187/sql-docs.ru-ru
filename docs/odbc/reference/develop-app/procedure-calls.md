---
title: Вызовы процедур | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- escape sequences [ODBC], procedure calls
- procedure calls [ODBC]
ms.assetid: 145130cc-40e7-4722-8417-dff131084752
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 775b48eb5a7f2089d65c6e9548a986b2f7b9bec7
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63284577"
---
# <a name="procedure-calls"></a>Вызовы процедур
Объект *процедуры* представляет собой исполняемый объект, хранящиеся в источнике данных. Обычно процедурой является одна или несколько заранее скомпилированных инструкций SQL. Escape-последовательность для вызова процедуры —  
  
 **{**[**? =**]**вызвать** *имя процедуры*[**(**[*параметр*] [**,**[*параметр*]]... **)**]**}**  
  
 где *имя процедуры* указывает имя процедуры и *параметр* указывает параметр процедуры.  
  
 Дополнительные сведения об escape-последовательность вызова процедуры см. в разделе [процедуры вызовите escape-последовательность](../../../odbc/reference/appendixes/procedure-call-escape-sequence.md) в приложение в: Грамматика SQL.  
  
 Процедура может иметь параметры или не иметь их. Он также может возвращать значение, что указывает необязательный маркер параметра **? =** в начале синтаксиса. Если *параметр* является входным или входным и выходным, он может быть литералом или маркер параметра. Тем не менее с возможностью взаимодействия приложения всегда должны использовать маркеры параметров, так как некоторые источники данных не принимают значения параметра literal. Если *параметр* является выходным параметром, он должен быть маркер параметра. Маркеры параметров должен быть привязан с **SQLBindParameter** до вызова процедуры выполнения инструкции.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается со скобками, но без параметров, таких как {вызвать *имя процедуры*()}, драйвер указывает, что источник данных, чтобы использовать значение по умолчанию для первого параметра. Если процедура не имеет параметров, это может вызвать процедуру, переход на другой. Если процедура вызывается без скобок, такие как {вызвать *имя процедуры*}, драйвер не отправляет все значения параметров.  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, предположим, что процедура **InsertOrder** имеет пять входных параметров. Следующий вызов **InsertOrder** пропущен первый параметр предоставляет литерал для второго параметра и использовала маркер параметра для третий, четвертый и пятый параметры:  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}   // Not interoperable!  
```  
  
 Обратите внимание на то, что если параметр пропущен, запятая, отделяющая его от других параметров, должна присутствовать. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Еще один способ указать, что значение по умолчанию параметра ввода или ввода вывода — присвоить значение буфера длины и индикатора, привязанное к параметру процедуры SQL_DEFAULT_PARAM.  
  
 Если входной/выходной параметр указан или если для параметра задано литерал, драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
 Предположим, что процедура PARTS_IN_ORDERS создает результирующий набор, содержащий список заказов, которые содержат номер конкретного компонента. Следующий код вызывает эту процедуру для артикул 544:  
  
```  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0;  
  
// Bind the parameter.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0,  
                  &PartID, 0, PartIDInd);  
  
// Place the department number in PartID.  
PartID = 544;  
  
// Execute the statement.  
SQLExecDirect(hstmt, "{call PARTS_IN_ORDERS(?)}", SQL_NTS);  
```  
  
 Чтобы определить, поддерживает ли источник данных процедур, приложение вызывает **SQLGetInfo** с параметром SQL_PROCEDURES.  
  
 Дополнительные сведения о процедурах см. в разделе [процедуры](../../../odbc/reference/develop-app/procedures-odbc.md).
