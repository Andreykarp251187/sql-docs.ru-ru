---
description: Вызовы процедур
title: Вызовы процедур | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- escape sequences [ODBC], procedure calls
- procedure calls [ODBC]
ms.assetid: 145130cc-40e7-4722-8417-dff131084752
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ed5da9bbe94bf1f508e1b94c17e81c7b0169f6e0
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "88465736"
---
# <a name="procedure-calls"></a>Вызовы процедур
*Процедура* — это исполняемый объект, хранящийся в источнике данных. Обычно процедурой является одна или несколько заранее скомпилированных инструкций SQL. Escape-последовательность для вызова процедуры:  
  
 **{**[**? =**]**вызовите** *процедуру-имя*[**(**[*параметр*] [**,**[*параметр*]]... **)**]**}**  
  
 где *PROCEDURE-Name* указывает имя процедуры, а *параметр* — параметр процедуры.  
  
 Дополнительные сведения о escape-последовательности вызова процедуры см. в разделе [escape-последовательность вызова процедуры](../../../odbc/reference/appendixes/procedure-call-escape-sequence.md) в приложении C: грамматика SQL.  
  
 Процедура может иметь параметры или не иметь их. Он также может возвращать значение, как указано необязательным маркером параметра **? =** в начале синтаксиса. Если *параметр* является входным или параметром ввода-вывода, то он может быть литералом или маркером параметра. Однако взаимодействующие приложения всегда должны использовать маркеры параметров, так как некоторые источники данных не принимают значения литеральных параметров. Если *параметр* является выходным, он должен быть маркером параметра. Маркеры параметров должны быть привязаны к **SQLBindParameter** перед выполнением инструкции вызова процедуры.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается с круглыми скобками, но без параметров, например {Call *PROCEDURE-Name*()}, драйвер предписывает источнику данных использовать значение по умолчанию для первого параметра. Если процедура не имеет параметров, это может привести к сбою процедуры. Если процедура вызывается без скобок, например {Call *PROCEDURE-Name*}, драйвер не отправляет значения параметров.  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, предположим, что процедура **инсертордер** имеет пять входных параметров. Следующий вызов **инсертордер** опускает первый параметр, предоставляет литерал для второго параметра и использует маркер параметра для третьего, четвертого и пятого параметров:  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}   // Not interoperable!  
```  
  
 Обратите внимание, что если параметр пропущен, то запятая, разделяющая его от других параметров, должна по-прежнему отображаться. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Другой способ указания значения по умолчанию входного или выходного параметра заключается в установке значения для буфера длины или индикатора, привязанного к параметру, для SQL_DEFAULT_PARAM.  
  
 Если параметр ввода-вывода пропущен или для параметра указан литерал, драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
 Предположим, что процедура PARTS_IN_ORDERS создает результирующий набор, содержащий список заказов, содержащих определенный номер части. Следующий код вызывает эту процедуру для части номер 544:  
  
```  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0;  
  
// Bind the parameter.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0,  
                  &PartID, 0, PartIDInd);  
  
// Place the department number in PartID.  
PartID = 544;  
  
// Execute the statement.  
SQLExecDirect(hstmt, "{call PARTS_IN_ORDERS(?)}", SQL_NTS);  
```  
  
 Чтобы определить, поддерживает ли источник данных процедуры, приложение вызывает **SQLGetInfo** с параметром SQL_PROCEDURES.  
  
 Дополнительные сведения о процедурах см. в разделе [процедуры](../../../odbc/reference/develop-app/procedures-odbc.md).
