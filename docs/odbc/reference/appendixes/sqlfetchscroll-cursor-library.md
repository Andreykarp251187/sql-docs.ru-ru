---
title: S'LFetchScroll (Библиотека Курсора) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetchScroll function [ODBC], Cursor Library
ms.assetid: 4417e57c-31dd-475e-8fe9-eab00a459c80
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e5573b8afc49afec8b7afa4fc52590e7a6a9e2fb
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81302055"
---
# <a name="sqlfetchscroll-cursor-library"></a>SQLFetchScroll (библиотека курсоров)
> [!IMPORTANT]  
>  Эта функция будет удалена в будущей версии Windows. Избегайте использования этой функции в новых разработках и планируйте модифицировать приложения, использующие эту функцию в настоящее время. Корпорация Майкрософт рекомендует использовать функцию курсора драйвера.  
  
 На этой теме обсуждается использование функции **S'LFetchScroll** в библиотеке курсоров. Для получения общей информации о **s'LFetchScroll,** [см.](../../../odbc/reference/syntax/sqlfetchscroll-function.md)  
  
 Библиотека курсоров осуществила **S'LFetchScroll,** неоднократно вызывая **s'LFetch** в драйвере. Он передает данные, полученные от драйвера, в буферы рядового набора, предоставляемые приложением. Он также кэши данные в памяти и дисковых файлов. Когда приложение запрашивает новый набор строк, библиотека курсора получает его по мере необходимости от драйвера (если он ранее не был извлечен) или кэш (если он был ранее извлечен). Наконец, библиотека курсора сохраняет состояние кэшированных данных и возвращает эту информацию в приложение в массиве состояния строки.  
  
 При использовании библиотеки курсоров, вызовы на **S'LFetchScroll** не могут быть смешаны с вызовами либо на **S'LFetch,** либо **на S'LExtendedFetch.**  
  
 При использовании библиотеки курсоров, вызовы в **S'LFetchScroll** поддерживаются как для ODBC 2. *x* и для ODBC 3. *x* драйверов.  
  
## <a name="rowset-buffers"></a>Роусет Бафферс  
 Библиотека курсора оптимизирует передачу данных от драйвера к буферу строки, предоставляемому приложением, если:  
  
-   Приложение использует связывание по гребню.  
  
-   В структуре, декларируетомую приложением для хранения ряда данных, не используются неиспользованные байты между полями.  
  
-   Поля, в которых **S'LFetch** или **S'LFetchScroll** возвращает длину/индикатор для столбца, следует за буфером для этого столбца и предшествует буферу для следующей колонки. Эти поля необязательные.  
  
 Когда приложение запрашивает новый набор строк, библиотека курсора извлекает данные из кэша и от драйвера по мере необходимости. Если новые и старые строки перекрываются, библиотека курсора может оптимизировать свою производительность, повторно используя данные из перекрывающихся разделов буферов строки. Таким образом, несохраненные изменения буферов набора строк теряются, если новые и старые ряды не перекрываются и изменения не находятся в перекрывающихся разделах буферов рядов. Чтобы сохранить изменения, приложение отправляет позиционную выписку об обновлении.  
  
 Обратите внимание, что библиотека курсора всегда обновляет буферы строк с данными из кэша, когда приложение вызывает **S'LFetchScroll** с аргументом *FetchOrientation,* установленным для SQL_FETCH_RELATIVE, и *аргументом FetchOffset,* установленным на 0.  
  
 Библиотека курсора поддерживает вызов **S'LSetStmtAttr** с *атрибутом* SQL_ATTR_ROW_ARRAY_SIZE, чтобы изменить размер рядового набора во время открытия курсора. Новый размер рядового набора вступит в силу при следующем вызове **S'LFetchScroll.**  
  
## <a name="result-set-membership"></a>Членство в наборе результатов  
 Библиотека курсора извлекает данные из драйвера только по запросу приложения. В зависимости от источника данных и настройки атрибута SQL_CONCURRENCY оператора это имеет следующие последствия:  
  
-   Данные, полученные в библиотеке курсоров, могут отличаться от данных, которые были доступны на момент выполнения оператора. Например, после открытия курсора некоторые драйверы могут быть извлечены рядами, вставленными в точку за пределами текущего положения курсора.  
  
-   Данные в наборе результатов могут быть заблокированы источником данных для библиотеки курсоров и, следовательно, недоступны для других пользователей.  
  
 После того, как библиотека курсора кэшировала ряд данных, она не может обнаружить изменения в этой строке в базовом источнике данных (за исключением позиционированных обновлений и удалений, работающих на кэше того же курсора). Это происходит потому, что для вызовов в **S'LFetchScroll**библиотека курсора никогда не переизгонивает данные из источника данных. Вместо этого он повторно извлекает данные из своего кэша.  
  
## <a name="scrolling"></a>Прокрутка  
 Библиотека курсора поддерживает следующие типы извлечения в **S'LFetchScroll.**  
  
|Тип курсора|Типы извлечений|  
|-----------------|-----------------|  
|Однонаправленный|SQL_FETCH_NEXT|  
|Статические|SQL_FETCH_NEXT<br /><br /> SQL_FETCH_PRIOR<br /><br /> SQL_FETCH_FIRST<br /><br /> SQL_FETCH_LAST<br /><br /> SQL_FETCH_RELATIVE<br /><br /> SQL_FETCH_ABSOLUTE<br /><br /> SQL_FETCH_BOOKMARK|  
  
## <a name="errors"></a>ошибки  
 При вызове **S'LFetchScroll** и одном из вызовов на **s'LFetch** возвращается SQL_ERROR, библиотека курсора продолжается следующим образом. После завершения этих шагов библиотека курсоров продолжает обработку.  
  
1.  Вызывает **S'LGetDiagRec** для получения информации об ошибках от водителя и публикует ее в качестве диагностической записи в менеджере драйвера.  
  
2.  Устанавливает поле SQL_DIAG_ROW_NUMBER в диагностической записи к соответствующему значению.  
  
3.  Устанавливает поле SQL_DIAG_COLUMN_NUMBER в диагностической записи к соответствующему значению, если это применимо; в противном случае, он устанавливает его до 0.  
  
4.  Устанавливает значение строки по ошибке в массиве состояния строки для SQL_ROW_ERROR.  
  
 После того, как библиотека курсоров несколько раз вызывала **s'LFetch** в своей реализации **S'LFetchScroll,** любая ошибка или предупреждение, возвращенные одним из вызовов в **S'LFetch,** будут находиться в диагностической записи и могут быть получены по вызову в **S'LGetDiagRec.** Если данные были усечены при извлечении, то усеченные данные теперь будут выстным в кэше библиотеки курсора. Последующие вызовы на **S'LFetchScroll** для прокрутки в строку с усеченными данными вернут усеченные данные, и предупреждение не будет поднято, поскольку данные извлечены из кэша библиотеки курсора. Чтобы отслеживать длину возвращенных данных, чтобы определить, были ли усечены данные, возвращенные в буфер, приложение должно связать буфер длины/индикатора.  
  
## <a name="bookmark-operations"></a>Операции закладок  
 Библиотека курсоров поддерживает вызов **S'LFetchScroll** с *FetchOrientation* SQL_FETCH_BOOKMARK. Он также поддерживает указание смещения в аргументе *FetchOffset,* который может быть использован в операции закладок. Это единственная операция закладки, которую поддерживает библиотека курсора. Библиотека курсоров не поддерживает вызов **S'LBulkOperations.**  
  
 Если приложение установило атрибут SQL_ATTR_USE_BOOKMARKS оператора и привязалось к столбце закладки, библиотека курсора генерирует закладку с фиксированной длиной и возвращает ее в приложение. Библиотека курсора создает и поддерживает закладки, которые она использует; он не использует закладки, хватерянные в источнике данных. Когда **s'LFetchScroll** вызывается для получения блока данных, которые уже были извлечены из источника данных, он получает данные из кэша библиотеки курсора. В результате закладка, используемая при вызове на **S'LFetchScroll** с *SQL_FETCH_BOOKMARK,* должна быть создана и сохранена библиотекой курсора.  
  
## <a name="interaction-with-other-functions"></a>Взаимодействие с другими функциями  
 Приложение должно вызвать **S'LFetch** или **S'LFetchScroll,** прежде чем он готовит или выполняет любое позиционированное обновление или удаление заявлений.
