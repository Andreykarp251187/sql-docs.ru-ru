---
title: SQLFetchScroll (библиотека курсоров) | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetchScroll function [ODBC], Cursor Library
ms.assetid: 4417e57c-31dd-475e-8fe9-eab00a459c80
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: db7dc5482347ad9b7f194b3c9c8c6cd7fc3f9f6a
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63199595"
---
# <a name="sqlfetchscroll-cursor-library"></a>SQLFetchScroll (библиотека курсоров)
> [!IMPORTANT]  
>  Этот компонент будет удален в будущих версиях Windows. Избегайте использования этой функции в новых разработках и запланируйте изменение приложений, которые сейчас ее используют. Корпорация Майкрософт рекомендует использовать функциональные возможности драйвера курсора.  
  
 В этом разделе рассматривается использование **SQLFetchScroll** функции в библиотеку курсоров. Общие сведения о **SQLFetchScroll**, см. в разделе [функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md).  
  
 Библиотека курсоров реализует **SQLFetchScroll** , повторно вызывая **SQLFetch** в драйвере. Он передает данные, получаемые от драйвера в буферы строк, предоставленных приложением. Он также кэширует данные в памяти файлы и файлы диска. Когда приложение запрашивает новый набор строк, библиотека курсоров извлекает его при необходимости из драйвера (если она не была получена ранее) или кэша (если он ранее извлечены). Наконец библиотека курсоров поддерживает состояние кэшированных данных и возвращает эту информацию в приложение, в массив статусов строк.  
  
 При использовании библиотеки курсоров вызовы **SQLFetchScroll** нельзя комбинировать с вызовами либо **SQLFetch** или **SQLExtendedFetch**.  
  
 При использовании библиотеки курсоров вызовы **SQLFetchScroll** , поддерживаемые одновременно для ODBC 2. *x* и для ODBC 3. *x* драйверы.  
  
## <a name="rowset-buffers"></a>Буферы строк  
 Библиотека курсоров оптимизация передачи данных от драйвера в буфер строк, предоставленных приложением, если:  
  
-   Приложение использует привязку на уровне строки.  
  
-   Байт, которых нет неиспользуемых между полями в структуре приложения, объявленных для хранения строки данных.  
  
-   Поля, в котором **SQLFetch** или **SQLFetchScroll** Возвращает признак длины или столбца следует буфера для этого столбца и предшествует буфер для следующего столбца. Эти поля являются необязательными.  
  
 Когда приложение запрашивает новый набор строк, библиотека курсоров извлекает данные из кэша и драйвера при необходимости. Если перекрываются новые и старые наборы строк, библиотека курсоров можно оптимизировать его производительность, повторно используя данные из перекрывающиеся части буферы строк. Таким образом несохраненные изменения в буферы строк будут потеряны перекрываются новые и старые наборы строк, а изменения в разделах перекрывающиеся буферов набора строк. Чтобы сохранить изменения, приложение отправляет инструкции позиционированного обновления.  
  
 Обратите внимание, что библиотека курсоров всегда обновляет буферы строк с данными из кэша, когда приложение вызывает **SQLFetchScroll** с *FetchOrientation* аргумент значение SQL_FETCH_RELATIVE и *FetchOffset* аргумент присвоено значение 0.  
  
 Библиотека курсоров поддерживает вызов метода **SQLSetStmtAttr** с *атрибут* из SQL_ATTR_ROW_ARRAY_SIZE, чтобы изменить размер набора строк при открытом курсоре. Новый размер набора строк вступят в силу очередном **SQLFetchScroll** вызывается.  
  
## <a name="result-set-membership"></a>Результирующий набор членства  
 Библиотека курсоров извлекает данные из драйвер только в том случае, как приложение запрашивает ее. В зависимости от источника данных и параметр атрибута инструкции SQL_CONCURRENCY это приводит к следующим последствиям:  
  
-   Данные, получаемые библиотекой курсоров могут отличаться от данных, которые были доступны во время выполнения инструкции. Например после открытия курсора, строки, вставленные в точке за текущей позицией курсора можно получить с некоторые драйверы.  
  
-   Данные в результирующем наборе может быть заблокирован источником данных для библиотеки курсоров и таким образом недоступным для других пользователей.  
  
 После библиотеку курсоров записал в кэш строки данных, не сможет определить изменения этой строки в источнике данных (за исключением позиционированные обновления и удаления, работающие с того же курсора кэша). Это происходит потому, что для вызовов **SQLFetchScroll**, библиотека курсоров никогда не refetches данные из источника данных. Вместо этого он refetches данных из кэша.  
  
## <a name="scrolling"></a>Прокрутка  
 Библиотека курсоров поддерживает следующие типы выборки в **SQLFetchScroll**.  
  
|Тип курсора|Типы выборки|  
|-----------------|-----------------|  
|Однонаправленный|SQL_FETCH_NEXT|  
|Статические|SQL_FETCH_NEXT<br /><br /> SQL_FETCH_PRIOR<br /><br /> SQL_FETCH_FIRST<br /><br /> SQL_FETCH_LAST<br /><br /> SQL_FETCH_RELATIVE<br /><br /> SQL_FETCH_ABSOLUTE<br /><br /> SQL_FETCH_BOOKMARK|  
  
## <a name="errors"></a>ошибки  
 Когда **SQLFetchScroll** вызывается и одного из вызовов к **SQLFetch** возвращает значение SQL_ERROR, продолжается библиотеки курсора, следующим образом. После завершения этих действий, библиотека курсоров продолжает обработку.  
  
1.  Вызовы **SQLGetDiagRec** для получения сведений об ошибке из драйвера и отправляет это как создается запись диагностики диспетчера драйверов.  
  
2.  Задает поле SQL_DIAG_ROW_NUMBER диагностическая запись с соответствующим значением.  
  
3.  Задает поле SQL_DIAG_COLUMN_NUMBER диагностическая запись с соответствующим значением, если это применимо; в противном случае он устанавливает значение 0.  
  
4.  Задает значение для строки с ошибками в массив статусов строк для SQL_ROW_ERROR.  
  
 После курсора называется библиотеки **SQLFetch** несколько раз в своей реализации **SQLFetchScroll**, ошибки или предупреждения, возвращаемого одним из вызовов **SQLFetch** будет в журнал диагностической записи, а также можно получить с помощью вызова **SQLGetDiagRec**. Если данные были усечены при ее получения, усеченных данных теперь будет находиться в кэше библиотеку курсоров. Последующие вызовы **SQLFetchScroll** выполнить прокрутку в строку с усеченные данные вернет усекаемые данные и предупреждение не возникнет, так как данные извлекаются из кэша библиотеку курсоров. Чтобы отслеживать длину данных, возвращается, чтобы можно было определить ли данные, возвращаемые в буфер был усечен, приложение должно привязать буфер длины/индикатора.  
  
## <a name="bookmark-operations"></a>Закладка операций  
 Библиотека курсоров поддерживает вызов метода **SQLFetchScroll** с *FetchOrientation* sql_fetch_bookmark аргумента. Она также поддерживает указание смещения в *FetchOffset* аргумент, который может использоваться в операции закладки. Это только одну библиотеку курсоров поддерживает операцию закладки. Библиотека курсоров поддерживает вызов метода **SQLBulkOperations**.  
  
 Если приложение присвоить атрибуту инструкции SQL_ATTR_USE_BOOKMARKS и привязанное к столбцу, закладки, библиотека курсоров приводит к возникновению ошибки закладки фиксированной длины и возвращает его приложению. Библиотека курсоров создает и обслуживает закладки, которые он использует; она не использует закладки, содержащиеся в источнике данных. Когда **SQLFetchScroll** вызывается для получения блока данных, которые уже были получены из источника данных, он получает данные из кэш библиотеки курсоров. Таким образом, использовать закладки в вызове к **SQLFetchScroll** с *FetchOrientation* из sql_fetch_bookmark аргумента должно быть создаются и поддерживаются библиотекой курсоров.  
  
## <a name="interaction-with-other-functions"></a>Взаимодействие с другими функциями  
 Приложение должно вызвать **SQLFetch** или **SQLFetchScroll** подготавливает или выполняет любой расположен инструкции update или delete.
