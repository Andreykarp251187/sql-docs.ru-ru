---
title: Построение поисковых выражений | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- searched statements [ODBC]
- ODBC cursor library [ODBC], statement processing
- ODBC cursor library [ODBC], searched statements
- SQL statements [ODBC], cursor library
- cursor library [ODBC], statement processing
- cursor library [ODBC], searched statements
- SQL statements [ODBC], searched statements
ms.assetid: e429254c-c43f-4fbf-98b2-5f1ed53501ff
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 616e4241c6d28e846a56116a70e79254e13dd5fb
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63224557"
---
# <a name="constructing-searched-statements"></a>Построение поисковых выражений
> [!IMPORTANT]  
>  Этот компонент будет удален в будущих версиях Windows. Избегайте использования этой функции в новых разработках и запланируйте изменение приложений, которые сейчас ее используют. Корпорация Майкрософт рекомендует использовать функциональные возможности драйвера курсора.  
  
 Поддерживает позиционированного обновления и удаления инструкций, библиотека курсоров конструкции искомая **обновление** или **удалить** инструкции от позиционированной инструкции. Для поддержки вызовов в **SQLGetData** в блок данных, библиотека курсоров создает искомая **ВЫБЕРИТЕ** инструкцию, чтобы создать результирующий набор, содержащий текущей строке данных. В каждом из этих инструкций **ГДЕ** предложение перечисляет значения, хранящиеся в кэше для каждого привязанного столбца, который возвращает идентификатор поля SQL_DESC_SEARCHABLE в SQL_PRED_SEARCHABLE или SQL_PRED_BASIC  **SQLColAttribute**.  
  
> [!CAUTION]  
>  **ГДЕ** предложение, созданный библиотекой курсоров для идентификации текущей строки сможет определить все строки, определить другую строку или определить более одной строки.  
  
 Если оператор позиционированного обновления или удаления затрагивает более одной строки, библиотека курсоров обновляет массив статусов строк только для строки, на котором находится курсор и возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01001 (конфликт операции с курсором). Если инструкция не определяет никаких строк, библиотека курсоров не обновляет массив статусов строк и возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01001 (конфликт операции с курсором). Приложение может вызвать **SQLRowCount** для определения числа строк, которые были обновлены или удалены.  
  
 Если **ВЫБЕРИТЕ** предложение, используемый для позиционирования курсора для вызова **SQLGetData** определяет более чем одной строке **SQLGetData** не гарантируется получение результатов правильные данные. Если он не определяет строки, **SQLGetData** не вернет значение SQL_NO_DATA.  
  
 Если приложение соответствует приведенным ниже рекомендациям **ГДЕ** предложение, созданный библиотекой курсоров должен однозначно определять текущей строки, за исключением случаев, когда это невозможно, например, если источник данных содержит дубликат строки.  
  
-   **Привязка столбцов, которые однозначно идентифицируют строку.** Если привязанные столбцы однозначно определяет строки, **ГДЕ** предложение, созданный библиотекой курсоров может определить более одной строки. В выполнении позиционированного обновления или инструкции delete такое предложение может привести к более чем одной строке обновить или удалить. При вызове **SQLGetData**, такое предложение может привести к драйверу для возвращения данных ошибиться. Связав все столбцы уникального ключа гарантирует, что каждая строка идентифицируется уникальным образом.  
  
-   **Выделите буферы данных достаточно большой, усечение не происходит.** Кэш библиотеки курсоров является копией значения в буферы строк, привязаны к результирующему набору с **SQLBindCol**. Если данные будут усечены при ее размещении в эти буферы, он будет усечен также в кэше. Объект **ГДЕ** предложение, создается из усечения значений не может правильно идентифицировать базовой строки в источнике данных.  
  
-   **Укажите ненулевой длины буферов для двоичных данных C.** Библиотека курсоров выделяет буферы длины в его кэше, только если *StrLen_or_IndPtr* аргумента в **SQLBindCol** отлично от NULL. Когда *TargetType* равно SQL_C_BINARY, библиотека курсоров требует длина двоичных данных для создания **ГДЕ** предложение на основе данных. Есть ли буфер не длины для столбца SQL_C_BINARY и приложение вызывает **SQLGetData** или пытается выполнить позиционированного обновления или удалить оператор, возвращает библиотеки курсоров, значение SQL_ERROR и SQLSTATE SL014 (позиционированные запрос был отправлен, и не все поля число столбцов были помещен в буфер).  
  
-   **Укажите ненулевой длины буферов для столбцов со значением NULL.** Библиотека курсоров выделяет буферы длины в его кэше, только если *StrLen_or_IndPtr* аргумента в **SQLBindCol** отлично от NULL. Так как значение SQL_NULL_DATA хранится в буфере длиной, библиотека курсоров предполагается, что любой столбец, для длина не должно быть указано буфера не допускающие значения NULL. Если ни одного столбца длины указано для столбца, допускающего значение NULL, создает библиотеку курсоров **ГДЕ** предложение, которое использует значение данных для столбца. Это предложение не будет правильно идентифицировать строку.
