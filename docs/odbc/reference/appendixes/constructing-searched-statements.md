---
title: Построение поисковых заявлений (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- searched statements [ODBC]
- ODBC cursor library [ODBC], statement processing
- ODBC cursor library [ODBC], searched statements
- SQL statements [ODBC], cursor library
- cursor library [ODBC], statement processing
- cursor library [ODBC], searched statements
- SQL statements [ODBC], searched statements
ms.assetid: e429254c-c43f-4fbf-98b2-5f1ed53501ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: b8b9a27aa9fc84aadc6659993de3e12e269631d2
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81284744"
---
# <a name="constructing-searched-statements"></a>Построение поисковых выражений
> [!IMPORTANT]  
>  Эта функция будет удалена в будущей версии Windows. Избегайте использования этой функции в новых разработках и планируйте модифицировать приложения, использующие эту функцию в настоящее время. Корпорация Майкрософт рекомендует использовать функцию курсора драйвера.  
  
 Для поддержки позиционированных инструкций обновления и удаления библиотека курсора конструирует из позиционируемого оператора выданный отчет **UPDATE** или **DELETE.** Для поддержки вызовов на **S'LGetData** в блоке данных библиотека курсора создает поисковую выписку **SELECT** для создания набора результатов, содержащего текущий ряд данных. В каждом из этих утверждений положение **WHERE** перечисляет значения, хранящиеся в кэше для каждого связанного столбца, который возвращает SQL_PRED_SEARCHABLE или SQL_PRED_BASIC для идентификатора поля SQL_DESC_SEARCHABLE в **s'LColAttribute.**  
  
> [!CAUTION]  
>  Положение **WHERE,** построенное библиотекой курсоров для идентификации текущей строки, может не идентифицировать строки, определить другую строку или определить несколько строк.  
  
 Если позиционированное обновление или удаление оператора влияет не на одну строку, библиотека курсора обновляет массив статуса строки только для строки, на которой расположен курсор, и возвращает SQL_SUCCESS_WITH_INFO и конфликте операции Cursor. Если в отчете не указаны строки, библиотека курсора не обновляет массив состояния строк и возвращает SQL_SUCCESS_WITH_INFO и S'Lstate 01001 (конфликт операции Cursor). Приложение может вызвать **S'LRowCount,** чтобы определить количество строк, которые были обновлены или удалены.  
  
 Если пункт **SELECT,** используемый для размещения курсора для вызова в **S'LGetData,** идентифицирует более одной строки, **s'LGetData** не гарантирует возврат правильных данных. Если он не идентифицирует какие-либо строки, **s'LGetData** возвращается SQL_NO_DATA.  
  
 Если приложение соответствует следующим рекомендациям, положение **WHERE,** построенное библиотекой курсоров, должно однозначно идентифицировать текущую строку, за исключением случаев, когда это невозможно, например, когда источник данных содержит дубликаты строк.  
  
-   **Связать столбцы, которые однозначно идентифицируют строку.** Если связанные столбцы не идентифицируют строку однозначно, положение **WHERE,** построенное библиотекой курсоров, может определить несколько строк. В позиционированном обновлении или удалении оператора такое положение может привести к обновлению или удалению более чем одной строки. При звонке в **S'LGetData**такое положение может привести к тому, что драйвер вернет данные для неправильной строки. Связывание всех столбцов в уникальном ключе гарантирует, что каждая строка однозначно идентифицирована.  
  
-   **Выделите буферы данных достаточно большие, чтобы не происходит усечения.** Кэш библиотеки курсора — это копия значений в буферах строк, привязанных к набору результатов с **помощью S'LBindCol.** Если данные усечены при размещении в этих буферах, они также будут усечены в кэше. Положение **WHERE,** построенное из усеченных значений, может неправильно идентифицировать основной ряд в источнике данных.  
  
-   **Укажите буферы ненулевой длины для двоичных данных C.** Библиотека курсора выделяет буферы длины в кэше только в том случае, если *аргумент StrLen_or_IndPtr* в **S'LBindCol** не является нулевым. Когда аргумент *TargetType* SQL_C_BINARY, библиотека курсоров требует длины двоичных данных, чтобы построить пункт **WHERE** из данных. Если нет буфера длины для SQL_C_BINARY столбца и приложение вызывает **S'LGetData** или пытается выполнить позиционированное обновление или удалить выписку, библиотека курсоров возвращает SQL_ERROR и S'LSTATE SLSTATE SL014 (выданный запрос на размещение, и не все поля подсчета столбов были буферизированы).  
  
-   **Укажите буферы ненулевой длины для недействительных столбцов.** Библиотека курсора выделяет буферы длины в кэше только в том случае, если *аргумент StrLen_or_IndPtr* в **S'LBindCol** не является нулевым. Поскольку SQL_NULL_DATA хранится в буфере длины, библиотека курсора предполагает, что любой столбец, для которого не указан буфер длины, не является недействительным. Если столбец длины не указан для необоснованного столбца, библиотека курсора конструирует положение **WHERE,** использующемзначение данных для столбца. Это положение не будет правильно идентифицировать строку.
