---
title: Составление встроенной программы S'L (ru) Документы Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL [ODBC], embedded SQL
- SQL statements [ODBC], embedded SQL
- compiling embedded SQL programs [ODBC]
- embedded SQL [ODBC]
ms.assetid: 9e94146a-5b80-4a01-b586-1e03ff05b9ac
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: eb801dc532009410055b67031b3e036cc6b9c3d0
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306535"
---
# <a name="compiling-an-embedded-sql-program"></a>Компиляция программы на Embedded SQL
Поскольку встроенная программа S'L содержит сочетание заявлений на языке-хоста, она не может быть отправлена непосредственно компилятору для языка-хозяина. Вместо этого он компилируется в многоступенчатом процессе. Хотя этот процесс отличается от продукта к продукту, шаги примерно одинаковы для всех продуктов.  
  
 На этой иллюстрации показаны шаги, необходимые для компиляции встроенной программы S'L.  
  
 ![Шаги для компиляции встроенной программы SQL](../../odbc/reference/media/pr02.gif "pr02")  
  
 В составлении встроенной программы S'L задействовано пять этапов:  
  
1.  Встроенная программа S'L представлена прекомпиллеру S'L, инструменту программирования. Прекомпилятер сканирует программу, находит встроенные операторы S'L и обрабатывает их. Для каждого языка программирования, поддерживаемого DBMS, требуется другой прекомпилайзер. Продукты DBMS обычно предлагают предкомпиллеры для одного или нескольких языков, включая C, Pascal, COBOL, Fortran, Ada, PL/I, а также различные языки сборки.  
  
2.  Прекомпилятер производит два выходных файла. Первый файл — это исходный файл, лишенный встроенных инструкций по S'L. Вместо них прекомпилайзер заменяет вызовы на собственные процедуры DBMS, которые обеспечивают связь времени выполнения между программой и DBMS. Как правило, имена и последовательности вызовов этих процедур известны только прекомпилятору и DBMS; они не являются общедоступным интерфейсом DBMS. Второй файл — это копия всех встроенных инструкций, используемых в программе. Этот файл иногда называют модулем запроса базы данных, или DBRM.  
  
3.  Вывод исходного файла из предварительного компилятора передается стандартному компилятору для языка программирования хоста (например, компилятор C или COBOL). Компилятор обрабатывает исходный код и производит объектный код в качестве вывода. Обратите внимание, что этот шаг не имеет ничего общего с DBMS или с S'L.  
  
4.  Связующее звено принимает объектные модули, генерируемые компилятором, связывает их с различными библиотечными процедурами и создает исполняемую программу. Библиотечные процедуры, связанные с исполняемой программой, включают собственные процедуры DBMS, описанные в шаге 2.  
  
5.  Модуль запроса базы данных, генерируемый прекомпилятером, передается специальной обязательной утилите. Эта утилита анализирует операторы, анализирует, проверяет и оптимизирует их, а затем производит план доступа для каждой выписки. Результатом является комбинированный план доступа для всей программы, представляющий собой исполняемую версию встроенных инструкций S'L. Обязательная утилита хранит план в базе данных, обычно назначая ему название программы приложения, которая будет использовать его. Происходит ли этот шаг во время компиляции или время выполнения, зависит от DBMS.  
  
 Обратите внимание, что шаги, используемые для компиляции встроенной программы S'L, очень тесно соотносятся с шагами, описанными ранее в [обработке заявления S'L.](../../odbc/reference/processing-a-sql-statement.md) В частности, обратите внимание, что прекомпилайзер отделяет операторы S'L от кода языка хоста, а обязательная утилита разбирает и проверяет операторы S'L и создает планы доступа. В DBMS, где шаг 5 происходит во время компиляции, первые четыре этапа обработки оператора S'L происходят во время компиляции, в то время как последний шаг (выполнение) происходит во время выполнения. Это делает выполнение запроса в таких DBMSs очень быстро.
