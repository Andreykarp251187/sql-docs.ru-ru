---
title: Интеллектуальная обработка запросов в базах данных Microsoft SQL | Документы Майкрософт
description: Функции интеллектуальной обработки запросов для повышения производительности запросов в SQL Server и базе данных SQL Azure.
ms.custom: ''
ms.date: 04/23/2019
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords: ''
author: joesackmsft
ms.author: josack
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 3ae6d0d35da353a9307832989f562f3282af19e5
ms.sourcegitcommit: 636c02bd04f091ece934e78640b2363d88cac28d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2019
ms.locfileid: "67860709"
---
# <a name="intelligent-query-processing-in-sql-databases"></a>Интеллектуальная обработка запросов в базах данных SQL

[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

Семейство функций интеллектуальной обработки запросов включает средства, которые значительно повышают производительность существующих рабочих нагрузок и требуют минимальных усилий при реализации для внедрения. 

![Интеллектуальная обработка запросов](./media/iqp-feature-family.png)

Рабочие нагрузки можно автоматически сделать подходящими для интеллектуальной обработки запросов, включив для базы данных соответствующий уровень совместимости. Это можно сделать с помощью Transact-SQL. Пример:  

```sql
ALTER DATABASE [WideWorldImportersDW] SET COMPATIBILITY_LEVEL = 150;
```

В приведенной ниже таблице представлены все функции интеллектуальной обработки запросов и предъявляемые ими требования к уровню совместимости базы данных.

| **Функция интеллектуальной обработки запросов** | **Поддерживается в Базе данных Azure SQL** | **Поддерживается в SQL Server** |**Описание** |
| --- | --- | --- |--- |
| [Адаптивные соединения в пакетном режиме](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#batch-mode-adaptive-joins) | Да, при уровне совместимости 140| Да, начиная с SQL Server 2017 при уровне совместимости 140|При использовании адаптивных соединений тип соединения выбирается динамически во время выполнения в зависимости от фактических входных строк.|
| [Приблизительный подсчет различных объектов](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#approximate-query-processing) | Да, в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 в режиме общедоступной предварительной версии|Предоставление приблизительного значения COUNT DISTINCT в сценариях обработки больших данных с сохранением производительности и низким потреблением памяти. |
| [Пакетный режим для данных rowstore](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#batch-mode-on-rowstore) | Да, при уровне совместимости 150 в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 при уровне совместимости 150 в режиме общедоступной предварительной версии|Пакетный режим для рабочих нагрузок реляционного хранилища данных, ограниченных производительностью ЦП, без необходимости использовать индексы columnstore.  | 
| [Выполнение с чередованием](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#interleaved-execution-for-mstvfs) | Да, при уровне совместимости 140| Да, начиная с SQL Server 2017 при уровне совместимости 140|Использование фактической кратности из выходных данных функции с табличным значением с несколькими инструкциями, обнаруженной при первой компиляции, вместо фиксированной оценки.|
| [Обратная связь по временно предоставляемому буферу памяти в пакетном режиме](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#batch-mode-memory-grant-feedback) | Да, при уровне совместимости 140| Да, начиная с SQL Server 2017 при уровне совместимости 140|Если при выполнении запроса в пакетном режиме некоторые операции переносятся на диск, объем памяти для последующих выполнений увеличивается. Если запрос потребляет более 50 % выделенной ему памяти, размер временно предоставляемого буфера памяти для последующих выполнений уменьшается.|
| [Обратная связь по временно предоставляемому буферу памяти в строковом режиме](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#row-mode-memory-grant-feedback) | Да, при уровне совместимости 150 в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 при уровне совместимости 150 в режиме общедоступной предварительной версии|Если при выполнении запроса в построчном режиме некоторые операции переносятся на диск, объем памяти для последующих выполнений увеличивается. Если запрос потребляет более 50 % выделенной ему памяти, размер временно предоставляемого буфера памяти для последующих выполнений уменьшается.|
| [Встраивание скалярных определяемых пользователем функций](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#scalar-udf-inlining) | нет | Да, начиная с SQL Server 2019 CTP 2.1 при уровне совместимости 150 в режиме общедоступной предварительной версии|Скалярные пользовательские функции преобразуются в эквивалентные реляционные выражения, которые "встраиваются" в вызывающий запрос, что часто приводит к существенному повышению производительности.|
| [Отложенная компиляция табличных переменных](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#table-variable-deferred-compilation) | Да, при уровне совместимости 150 в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 при уровне совместимости 150 в режиме общедоступной предварительной версии|Использование фактической кратности табличной переменной, обнаруженной при первой компиляции, вместо фиксированной оценки.|

## <a name="batch-mode-adaptive-joins"></a>Адаптивные соединения в пакетном режиме

Эта функция позволяет динамически переключить ваш план на лучшую стратегию соединения во время выполнения, используя отдельный кэшированный план.

Функция адаптивных соединений в пакетном режиме позволяет отложить выбор метода [хэш-соединения или соединения вложенными циклами](../../relational-databases/performance/joins.md) **до** завершения сканирования первых входных данных. Оператор адаптивного соединения определяет пороговое значение, по которому принимается решение о переключении на план вложенного цикла. Таким образом, во время выполнения план может динамически переключаться на более эффективную стратегию соединения.
Это работает следующим образом:
-  Если число строк во входных данных соединения сборки настолько мало, что соединение вложенными циклами будет эффективнее хэш-соединения, ваш план переключается на алгоритм вложенных циклов.
-  Если число строк во входных данных соединения сборки превышает пороговое значение, переключение не выполняется и план продолжает использовать хэш-соединение.

Следующий запрос используется в качестве наглядного примера адаптивного соединения:

```sql
SELECT [fo].[Order Key], [si].[Lead Time Days], [fo].[Quantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Dimension].[Stock Item] AS [si]
       ON [fo].[Stock Item Key] = [si].[Stock Item Key]
WHERE [fo].[Quantity] = 360;
```

Этот запрос возвращает 336 строк. Включив [статистику активных запросов](../../relational-databases/performance/live-query-statistics.md), мы видим следующий план:

![Результат запроса: 336 строк](./media/4_AQPStats336Rows.png)

В плане мы видим следующее:
1. Просмотр индекса columnstore, используемый для предоставления строк для этапа сборки хэш-соединения.
1. Новый оператор адаптивного соединения. Он определяет пороговое значение, по которому принимается решение о переключении на план вложенного цикла. В нашем примере пороговое значение равно 78 строкам. Если число строк &gt; = 78, будет использоваться хэш-соединение. При значении меньше порогового будет использоваться соединение вложенными циклами.
1. Так как мы возвращаем 336 строк, пороговое значение превышено, и поэтому вторая ветвь представляет пробный этап стандартной операции хэш-соединения. Обратите внимание, что статистика активных запросов показывает строки, передаваемые через операторы — в данном случае это "672 из 672".
1. И последней ветвью является поиск кластеризованного индекса, используемый соединением вложенными циклами в случае, если пороговое значение не было превышено. Обратите внимание, что мы видим число строк "0 из 336" (ветвь не используется).

[!INCLUDE[freshInclude](../../includes/paragraph-content/fresh-note-steps-feedback.md)]

 Теперь давайте сравним план с таким же запросом, но на этот раз для значения *Quantity*, имеющего всего одну строку в таблице:
 
```sql
SELECT [fo].[Order Key], [si].[Lead Time Days], [fo].[Quantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Dimension].[Stock Item] AS [si]
       ON [fo].[Stock Item Key] = [si].[Stock Item Key]
WHERE [fo].[Quantity] = 361;
```
Запрос возвращает одну строку. Включив статистику активных запросов, мы видим следующий план:

![Результатом запроса является одна строка.](./media/5_AQPStatsOneRow.png)

В плане мы видим следующее:
- При возврате одной строки видно, что теперь через поиск кластеризованного индекса передаются строки.
- А так как этап сборки хэш-соединения не продолжается, никакие строки через вторую ветвь не передаются.

### <a name="adaptive-join-benefits"></a>Преимущества адаптивных соединений
Наиболее полезной эта функция будет для рабочих нагрузок с частыми переключениями между просмотрами входных данных мелких и крупных соединений.

### <a name="adaptive-join-overhead"></a>Издержки адаптивных соединений
Адаптивные соединения предъявляют более высокие требования к памяти, чем эквивалентный план соединения вложенными циклами индекса. Дополнительная память запрашивается так, как если бы вложенный цикл был хэш-соединением. Существуют также издержки на этапе сборки, такие как стартстопная операция и эквивалентное потоковое соединение вложенными циклами. Эти дополнительные затраты обеспечивают гибкость для сценариев, где количество строк во входных данных сборки может меняться.

### <a name="adaptive-join-caching-and-re-use"></a>Кэширование и повторное использование адаптивных соединений
Адаптивные соединения в пакетном режиме используются для первого выполнения инструкции, а после компиляции последовательные выполнения остаются адаптивными с учетом порога скомпилированных адаптивных соединений и строк времени выполнения, передаваемых через этап сборки внешних входных данных.

### <a name="tracking-adaptive-join-activity"></a>Отслеживание операций адаптивного соединения
Оператор адаптивного соединения имеет следующие атрибуты оператора плана:

| Атрибут плана | Описание |
|--- |--- |
| AdaptiveThresholdRows | Показывает пороговое значение, используемое для переключения с хэш-соединения на соединение вложенными циклами. |
| EstimatedJoinType | К какому типу, вероятнее всего, относится соединение. |
| ActualJoinType | В фактическом плане показывает, какой итоговый алгоритм соединения был выбран на базе порогового значения. |

Предполагаемый план показывает форму плана адаптивного соединения, а также определенное пороговое значение адаптивного соединения и предполагаемый тип соединения.

### <a name="adaptive-join-and-query-store-interoperability"></a>Взаимодействие адаптивного соединения и хранилища запросов
Хранилище запросов захватывает и может принудительно применить план адаптивного соединения в пакетном режиме.

### <a name="adaptive-join-eligible-statements"></a>Допустимые инструкции адаптивного соединения
Чтобы логическое соединение стало допустимым для адаптивного соединения в пакетном режиме, должны выполняться следующие условия:
- Уровень совместимости базы данных равен 140.
- Запрос является инструкцией SELECT (инструкции для изменения данных сейчас недопустимы).
- Соединение может выполняться посредством как индексированного соединения вложенными циклами, так и физического алгоритма хэш-соединения.
- Хэш-соединение использует пакетный режим — либо в результате присутствия индекса columnstore во всем запросе в целом, либо из-за того, что на таблицу индекса columnstore ссылается само соединение.
- Созданные альтернативные решения соединения вложенными циклами и хэш-соединения должны иметь одинаковый первый дочерний элемент (внешняя ссылка).

### <a name="adaptive-joins-and-nested-loop-efficiency"></a>Адаптивные соединения и эффективность вложенного цикла
Если адаптивное соединение переключается на режим вложенного цикла, оно использует строки, уже считанные сборкой хэш-соединения. Этот оператор **не** считывает повторно строки по внешней ссылке.

### <a name="adaptive-threshold-rows"></a>Строки адаптивного порогового значения
Приведенная ниже диаграмма показывает пример пересечения между затратами хэш-соединения и затраты альтернативного ему соединения вложенными циклами. В этой точке пересечения определяется пороговое значение, что, в свою очередь, определяет фактический алгоритм, используемый для операции соединения.

![Пороговое значение соединения](./media/6_AQPJoinThreshold.png)

### <a name="disabling-adaptive-joins-without-changing-the-compatibility-level"></a>Отключение адаптивных соединений без изменения уровня совместимости

Адаптивные соединения можно отключить в области базы данных или инструкции, сохранив уровень совместимости базы данных 140 или более высокий.  
Чтобы отключить адаптивные соединения для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_BATCH_MODE_ADAPTIVE_JOINS = ON;
```

Когда этот параметр включен, он будет иметь соответствующее состояние в представлении [sys.database_scoped_configurations](../../relational-databases/system-catalog-views/sys-database-scoped-configurations-transact-sql.md).
Чтобы снова включить адаптивные соединения для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_BATCH_MODE_ADAPTIVE_JOINS = OFF;
```

Вы также можете отключить адаптивные соединения для определенного запроса, назначив `DISABLE_BATCH_MODE_ADAPTIVE_JOINS` в качестве [указания запроса USE HINT](../../t-sql/queries/hints-transact-sql-query.md#use_hint). Пример:

```sql
SELECT s.CustomerID,
       s.CustomerName,
       sc.CustomerCategoryName
FROM Sales.Customers AS s
LEFT OUTER JOIN Sales.CustomerCategories AS sc
       ON s.CustomerCategoryID = sc.CustomerCategoryID
OPTION (USE HINT('DISABLE_BATCH_MODE_ADAPTIVE_JOINS')); 
```

Указание запроса USE HINT имеет приоритет над конфигурацией, областью действия которой является база данных, или флагом трассировки.

## <a name="batch-mode-memory-grant-feedback"></a>Обратная связь по временно предоставляемому буферу памяти в пакетном режиме
План после выполнения запроса в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] включает минимальный объем памяти, необходимый для выполнения, а также оптимальный временно предоставляемый буфер памяти, позволяющий уместить в памяти все строки. Если размер временно предоставляемого буфера памяти выбран неправильно, производительность снижается. Избыточные буферы ведут к потере памяти и снижению параллелизма. Недостаточные буферы ведут к затратной временной записи на диск. Обратная связь по временно предоставляемому буферу памяти в пакетном режиме, ориентированная на повторяющиеся рабочие процессы, пересчитывает фактическую требуемую память для запроса и затем обновляет значение временного буфера для кэшированного плана. При выполнении идентичной инструкции запроса используется пересмотренный размер временно предоставляемого буфера памяти, который уменьшает чрезмерные буферы, снижающие параллелизм, исправляет недостаточные буферы, вызывающие затратную временную запись на диск.
На следующем графе показан пример использования обратной связи по временно предоставляемому буферу памяти в пакетном режиме. Длительность первого выполнения запроса составила **88 секунд** из-за высокого уровня временной записи на диск.   

```sql
DECLARE @EndTime datetime = '2016-09-22 00:00:00.000';
DECLARE @StartTime datetime = '2016-09-15 00:00:00.000';
SELECT TOP 10 hash_unique_bigint_id
FROM dbo.TelemetryDS
WHERE Timestamp BETWEEN @StartTime and @EndTime
GROUP BY hash_unique_bigint_id
ORDER BY MAX(max_elapsed_time_microsec) DESC;
```

![Высокий уровень временной записи на диск](./media/2_AQPGraphHighSpills.png)

С включенной обратной связью по временно предоставляемому буферу памяти длительность второго выполнения составила **1 секунду** (ранее 88 секунд), при этом временная запись на диск полностью устранена, а временный буфер увеличен. 

![Временная запись на диск отсутствует.](./media/3_AQPGraphNoSpills.png)

### <a name="memory-grant-feedback-sizing"></a>Определение размера с помощью обратной связи по временно предоставляемому буферу памяти
Для чрезмерных временно предоставляемых буферов памяти, когда предоставленный объем памяти больше чем в два раза превышает объем фактической используемой памяти, функция обратной связи пересчитывает временно предоставляемый буфер памяти и обновляет кэшированный план. Для планов, у которых размер временно предоставляемого буфера памяти меньше 1 МБ, пересчет по превышению не выполняется.
Для недостаточных временно предоставляемых буферов памяти, которые приводят к временной записи на диск для операторов пакетного режима, обратная связь по временно предоставляемому буферу памяти активирует пересчет буфера. События временной записи передаются в функцию обратной связи и могут быть предоставлены с помощью события XEvent *spilling_report_to_memory_grant_feedback*. Они возвращает идентификатор узла из плана, а также объем временно записанных данных для этого узла.

### <a name="memory-grant-feedback-and-parameter-sensitive-scenarios"></a>Обратная связь по временно предоставляемому буферу памяти и сценарии, зависящие от параметров
Для сохранения оптимальности различным значениям параметров могут также потребоваться разные планы запроса. Такой тип запроса называется "зависящим от параметров". Для планов, зависящих от параметров, функция обратной связи по временно предоставляемому буферу памяти отключается для запроса, имеющего нестабильные требования к памяти. После нескольких повторных выполнений запроса план отключается, что можно наблюдать, отслеживая событие XEvent *memory_grant_feedback_loop_disabled*. Дополнительные сведения о сканировании и чувствительности параметров см. в разделе [Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md#ParamSniffing).

### <a name="memory-grant-feedback-caching"></a>Кэширование обратной связи по временно предоставляемому буферу памяти
Обратную связь можно хранить в кэшированном плане для однократного выполнения. Но именно последовательные выполнения этой инструкции позволяют использовать преимущества корректировки обратной связи по временно предоставляемому буферу памяти. Эта функция применяется к повторному выполнению инструкций. Обратная связь по временно предоставляемому буферу памяти изменяет только кэшированный план. Изменения сейчас не сохраняются в хранилище запросов.
Обратная связь не сохраняется, если план исключается из кэша. Кроме того, в случае перехода на другой ресурс обратная связь будет утеряна. Инструкция, использующая `OPTION (RECOMPILE)`, создает план и не кэширует его. Из-за отсутствия кэширования обратная связь по временно предоставляемому буферу памяти не создается, а план не сохраняется для компиляции и выполнения. Но если эквивалентная инструкция (т. е. с тем же хэшем запроса), **не** использовавшая `OPTION (RECOMPILE)`, была кэширована и затем повторно выполнена, последующая инструкция может использовать преимущества обратной связи по временно предоставляемому буферу памяти.

### <a name="tracking-memory-grant-feedback-activity"></a>Отслеживание операций обратной связи по временно предоставляемому буферу памяти
Вы можете отслеживать события обратной связи по временно предоставляемому буферу памяти с помощью события xEvent *memory_grant_updated_by_feedback*. Оно отслеживает текущий журнал подсчета выполнений, количество изменений плана функцией обратной связи, оптимальный дополнительный временно предоставляемый буфер памяти перед изменением и оптимальный буфер после изменения кэшированного плана функцией обратной связи.

### <a name="memory-grant-feedback-resource-governor-and-query-hints"></a>Обратная связь по временно предоставляемому буферу памяти, регулятор ресурсов и указания запроса
Фактический объем предоставляемой памяти учитывает лимит памяти запросов, определяемый регулятором ресурсов или указанием запроса.

### <a name="disabling-batch-mode-memory-grant-feedback-without-changing-the-compatibility-level"></a>Отключение сброса данных во временно предоставляемый буфер памяти в пакетном режиме без изменения уровня совместимости
Сброс данных во временно предоставляемый буфер памяти можно отключить в области базы данных или инструкции, сохранив уровень совместимости базы данных 140 или более высокий. Чтобы отключить сброс данных во временно предоставляемый буфер памяти в пакетном режиме для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK = ON;
```

Когда этот параметр включен, он будет иметь соответствующее состояние в представлении [sys.database_scoped_configurations](../../relational-databases/system-catalog-views/sys-database-scoped-configurations-transact-sql.md).

Чтобы снова включить сброс данных во временно предоставляемый буфер памяти в пакетном режиме для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK = OFF;
```

Вы также можете отключить сброс данных во временно предоставляемый буфер памяти в пакетном режиме для определенного запроса, назначив `DISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK` в качестве [указания запроса USE HINT](../../t-sql/queries/hints-transact-sql-query.md#use_hint). Пример:

```sql
SELECT * FROM Person.Address  
WHERE City = 'SEATTLE' AND PostalCode = 98104
OPTION (USE HINT ('DISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK')); 
```

Указание запроса USE HINT имеет приоритет над конфигурацией, областью действия которой является база данных, или флагом трассировки.

## <a name="row-mode-memory-grant-feedback"></a>Обратная связь по временно предоставляемому буферу памяти в строковом режиме

**Область применения**: [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)] в общедоступной предварительной версии

> [!NOTE]
> Функция "Обратная связь по временно предоставляемому буферу памяти в строковом режиме" предоставляется в режиме общедоступной предварительной версии.  

Обратная связь с временно предоставляемым буфером памяти в строковом режиме — это расширение функции обратной связи с временно предоставляемым буфером памяти в пакетном режиме путем настройки размеров временно предоставляемого буфера памяти для операторов пакетного и строкового режимов.  

Чтобы включить общедоступную предварительную версию обратной связи с временно предоставляемым буфером памяти в строковом режиме в [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)], активируйте режим совместимости базы данных 150 для базы данных, к которой вы подключаетесь при выполнении запроса.

Действие обратной связи с временно предоставляемым буфером памяти в строковом режиме можно просмотреть с помощью события XEvent **memory_grant_updated_by_feedback**. 

С момента выпуска функции обратной связи с временно предоставляемым буфером памяти в строковом режиме для фактических планов после выполнения будут отображаться два новых атрибута плана запроса: ***IsMemoryGrantFeedbackAdjusted*** и ***LastRequestedMemory***. Они добавляются в XML-элемент плана запроса *MemoryGrantInfo*. 

*LastRequestedMemory* позволяет просмотреть предоставленный в результате выполнения предыдущего запроса объем памяти в килобайтах (КБ). Атрибут *IsMemoryGrantFeedbackAdjusted* позволяет проверить состояние обратной связи с временно предоставляемым буфером памяти для инструкции в рамках фактического плана выполнения запроса. Ниже приведены значения, отображаемые в этом атрибуте:

| Значение IsMemoryGrantFeedbackAdjusted | Описание |
|---|---|
| Нет: первое выполнение | Обратная связь с временно предоставляемым буфером памяти не настраивает память для первой компиляции и связанной с ней операции выполнения.  |
| Нет: точное предоставление | Если не выполняется временная запись на диск и в инструкции используется не менее 50 % объема предоставленной памяти, обратная связь с временно предоставляемым буфером памяти не активируется. |
| Нет: обратная связь отключена | Если обратная связь с временно предоставляемым буфером памяти непрерывно активируется и сопровождается постоянным увеличением и уменьшением объема памяти, мы отключим обратную связь с временно предоставляемым буфером памяти для этой инструкции. |
| Да: настройка | Обратная связь с временно предоставляемым буфером памяти применена, и ее можно дополнительно настроить для следующего выполнения. |
| Да: объем стабилен | Обратная связь с временно предоставляемым буфером памяти применена, и объем памяти теперь стабилен. Это означает, что предоставленный для предыдущего выполнения объем эквивалентен предоставленному для текущего выполнения. |

> [!NOTE]
> Атрибуты плана обратной связи с временно предоставляемым буфером памяти отображаются в графических планах выполнения запросов в [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] 17.9 и более поздних версий. 

### <a name="disabling-row-mode-memory-grant-feedback-without-changing-the-compatibility-level"></a>Отключение сброса данных во временно предоставляемый буфер памяти в строчном режиме без изменения уровня совместимости
Сброс данных во временно предоставляемый буфер памяти в строчном режиме можно отключить в области базы данных или инструкции, сохранив уровень совместимости базы данных 150 и выше. Чтобы отключить сброс данных во временно предоставляемый буфер памяти в строчном режиме для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET ROW_MODE_MEMORY_GRANT_FEEDBACK = OFF;
```

Чтобы повторно включить сброс данных во временно предоставляемый буфер памяти в строчном режиме для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET ROW_MODE_MEMORY_GRANT_FEEDBACK = ON;
```

Вы также можете отключить сброс данных во временно предоставляемый буфер памяти в строковом режиме для определенного запроса, назначив `DISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK` в качестве [указания запроса USE HINT](../../t-sql/queries/hints-transact-sql-query.md#use_hint). Пример:

```sql
SELECT * FROM Person.Address  
WHERE City = 'SEATTLE' AND PostalCode = 98104
OPTION (USE HINT ('DISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK')); 
```

Указание запроса USE HINT имеет приоритет над конфигурацией, областью действия которой является база данных, или флагом трассировки.

## <a name="interleaved-execution-for-mstvfs"></a>Выполнение с чередованием для MSTVF

При выполнении с чередованием используется фактическое количество строк из функции для принятия обоснованного решения о плане запроса. См. дополнительные сведения о [функциях с табличным значением с несколькими инструкциями (MSTVF)](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#TVF).

Выполнение с чередованием изменяет однонаправленную границу между этапами оптимизации и выполнения для выполнения с одним запросом и позволяет планам адаптироваться с учетом пересмотренных оценок кратности. Если во время оптимизации нам встречается кандидат на выполнение с чередованием, который сейчас является **функциями с табличным значением с несколькими инструкциями (MSTVF)** , мы приостановим оптимизацию, выполним соответствующее поддерево, запишем точные оценки кратности и возобновим оптимизацию для нисходящих операций.   

Функции MSTVF имеют фиксированное предполагаемое значение кратности 100 начиная с [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] и 1 в более ранних версиях [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Выполнение с чередованием помогает устранить проблемы с производительностью рабочих нагрузок, вызванные фиксированными оценками кратности, которые связаны с функциями MSTVF. Дополнительные сведения о функциях MSTVF см. в разделе [Создание определяемых пользователем функций (ядро СУБД)](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#TVF).

На приведенном ниже рисунке изображены выходные данные [статистики активных запросов](../../relational-databases/performance/live-query-statistics.md) — подмножество общего плана выполнения, показывающее влияние фиксированных оценок кратности из функций MSTVF. Вы можете сравнить фактическую передачу строк с предполагаемым значением. Следует отметить три области плана (переход справа налево):
1. Сканирование таблицы MSTVF имеет фиксированную оценку в 100 строк. Однако в данном примере через это сканирование таблицы MSTVF передается 527 597 строк, как видно в статистике активных запросов — *527597 из 100*, то есть фиксированная оценка имеет значительное отклонение.
1. Для операции вложенных циклов предполагается, что наружная часть соединения возвращает всего 100 строк. Учитывая, как много строк функция MSTVF возвращает на самом деле, лучше всего перейти на другой алгоритм соединения.
1. Для операции хэш-совпадений обратите внимание на небольшой предупреждающий символ, который в данном случае указывает на временную запись на диск.

![Поток строк и предполагаемые строки](./media/7_AQPFlowThreeAreas.png)

Сравним предыдущий план с фактическим планом, созданным при включенном выполнении с чередованием:

![План с чередованием](./media/8_AQPInterleavedEnabledPlan.png)

1. Обратите внимание, что сканирование таблицы MSTVF отражает точную оценку кратности. Также обратите внимание на переупорядочение этого сканирования таблицы и других операций.
1. Что касается алгоритмов соединения, мы перешли от операции вложенных циклов Loop к операции хэш-совпадений, которая лучше подходит для такого большого числа строк.
1. Также обратите внимание, что прекратились предупреждения о временной записи, так как мы выделяем больше памяти на основе истинного количества строк, поступающих из сканирования таблицы MSTVF.

### <a name="interleaved-execution-eligible-statements"></a>Допустимые инструкции выполнения с чередованием
Инструкции ссылок MSTVF в выполнении с чередованием сейчас должны быть доступны только для чтения и не входить в состав операции изменения данных. Кроме того, функции MSTVF нельзя выполнять с чередованием, если в них не используются константы времени выполнения.

### <a name="interleaved-execution-benefits"></a>Преимущества выполнения с чередованием
Обычно чем выше отклонение между предполагаемым и фактическим числом строк в сочетании с числом нисходящих операций плана, тем больше негативное влияние на производительность.
В общем случае выполнение с чередованием оказывается полезным для запросов, где выполняются следующие условия:
1. Имеется большое отклонение между предполагаемым и фактическим числом строк для промежуточного результирующего набора (в данном случае — MSTVF).
1. Весь запрос чувствителен к изменению размера промежуточного результата. Обычно это происходит, когда над поддеревом в плане запроса имеется сложное дерево.
Выполнение с чередованием не принесет никакой выгоды для простой инструкции `SELECT *` из MSTVF.

### <a name="interleaved-execution-overhead"></a>Издержки выполнения с чередованием
Издержки должны быть минимальными либо отсутствовать. Функции MSTVF уже были материализованы перед появлением выполнения с чередованием, но различие состоит в том, что теперь мы разрешаем отложенную оптимизацию и используем оценку кратности для набора материализованных строк.
Как и в случае с любым планом, влияющим на изменения, некоторые планы могут изменяться таким образом, что при улучшенной кратности для поддерева мы получаем ухудшенный план для всего запроса в целом. В качестве устранения этой проблемы можно отменить изменения уровня совместимости или использовать хранилище запросов для принудительного применения нерегрессированной версии плана.

### <a name="interleaved-execution-and-consecutive-executions"></a>Выполнение с чередованием и последовательные выполнения
После кэширования плана выполнения с чередованием этот план с оценками, пересмотренными при первом выполнении, используется для последующих выполнений без повторного создания экземпляра выполнения с чередованием.

### <a name="tracking-interleaved-execution-activity"></a>Отслеживание операций выполнения с чередованием
Вы можете просмотреть атрибуты использования в фактическом плане выполнения запроса:

| Атрибут плана выполнения | Описание |
| --- | --- |
| ContainsInterleavedExecutionCandidates | Применяется к узлу *QueryPlan*. Значение *true* означает, что план содержит кандидаты на выполнение с чередованием. |
| IsInterleavedExecuted | Атрибут элемента *RuntimeInformation* под RelOp для узла TVF. Если значение равно *true*, значит, операция была материализована как часть операции выполнения с чередованием. |

Вы также можете отслеживать случаи выполнения с чередованием с помощью следующих событий xEvents:

| xEvent | Описание |
| ---- | --- |
| interleaved_exec_status | Это событие возникает, когда происходит выполнение с чередованием. |
| interleaved_exec_stats_update | Это событие описывает оценки кратности, обновленные выполнением с чередованием. |
| Interleaved_exec_disabled_reason | Это событие возникает, когда запрос с кандидатом на выполнение с чередованием не получает такое выполнение. |

Чтобы разрешить выполнению с чередованием пересматривать оценки кратности MSTVF, нужно выполнить запрос. При этом предполагаемый план выполнения по-прежнему сообщает о наличии кандидатов на выполнение с чередованием с помощью атрибута showplan `ContainsInterleavedExecutionCandidates`.    

### <a name="interleaved-execution-caching"></a>Кэширование выполнения с чередованием
Если план удаляется или извлекается из кэша, при выполнении запроса появляется новая компиляция, в которой используется исполнение чередованием.
Инструкция с использованием `OPTION (RECOMPILE)` создаст план с использованием выполнения с чередованием, но без кэширования.     

### <a name="interleaved-execution-and-query-store-interoperability"></a>Взаимодействие выполнения с чередованием и хранилища запросов
Планы с использованием выполнения с чередованием можно применять принудительно. План представляет собой версию с оценками кратности, исправленными на основе начального выполнения.    

### <a name="disabling-interleaved-execution-without-changing-the-compatibility-level"></a>Отключение выполнения с чередованием без изменения уровня совместимости

Выполнение с чередованием можно отключить в области базы данных или инструкции, сохранив уровень совместимости базы данных 140 или более высокий.  Чтобы отключить выполнение с чередованием для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_INTERLEAVED_EXECUTION_TVF = ON;
```

Когда этот параметр включен, он будет иметь соответствующее состояние в представлении [sys.database_scoped_configurations](../../relational-databases/system-catalog-views/sys-database-scoped-configurations-transact-sql.md).
Чтобы снова включить выполнение с чередованием для всех запросов, выполняемых из базы данных, выполните следующую команду в контексте соответствующей базы данных:

```sql
ALTER DATABASE SCOPED CONFIGURATION SET DISABLE_INTERLEAVED_EXECUTION_TVF = OFF;
```

Вы также можете отключить выполнение с чередованием для определенного запроса, назначив `DISABLE_INTERLEAVED_EXECUTION_TVF` в качестве [указания запроса USE HINT](../../t-sql/queries/hints-transact-sql-query.md#use_hint). Пример:

```sql
SELECT [fo].[Order Key], [fo].[Quantity], [foo].[OutlierEventQuantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Fact].[WhatIfOutlierEventQuantity]('Mild Recession',
                            '1-01-2013',
                            '10-15-2014') AS [foo] ON [fo].[Order Key] = [foo].[Order Key]
                            AND [fo].[City Key] = [foo].[City Key]
                            AND [fo].[Customer Key] = [foo].[Customer Key]
                            AND [fo].[Stock Item Key] = [foo].[Stock Item Key]
                            AND [fo].[Order Date Key] = [foo].[Order Date Key]
                            AND [fo].[Picked Date Key] = [foo].[Picked Date Key]
                            AND [fo].[Salesperson Key] = [foo].[Salesperson Key]
                            AND [fo].[Picker Key] = [foo].[Picker Key]
OPTION (USE HINT('DISABLE_INTERLEAVED_EXECUTION_TVF'));
```

Указание запроса USE HINT имеет приоритет над конфигурацией, областью действия которой является база данных, или флагом трассировки.


## <a name="table-variable-deferred-compilation"></a>Отложенная компиляция табличных переменных

> [!NOTE]
> Функция "Отложенная компиляция табличных переменных" предоставляется в режиме общедоступной предварительной версии.  

Отложенная компиляция табличных переменных позволяет оптимизировать план и повысить общую производительность запросов со ссылками на табличные переменные. Во время оптимизации и первичной компиляции эта функция распространяет оценки кратности, основанные на фактическом количестве строк табличной переменной. Эти точные сведения о количестве строк позволяют оптимизировать последующие операции плана.

Если используется отложенная компиляция табличных переменных, компиляция инструкции со ссылкой на табличную переменную откладывается до первого фактического выполнения этой инструкции. Это поведение отложенной компиляции совпадает с поведением временных таблиц. Такое изменение позволяет использовать реальную кратность вместо обычного предположения по одной строке. 

Вы можете включить отложенную компиляцию табличных переменных в Базе данных SQL Azure в режиме общедоступной предварительной версии. Для этого включите уровень совместимости 150 для той базы данных, к которой вы подключаетесь при выполнении нужного запроса.

См. дополнительные сведения об [отложенной компиляции табличных переменных](../../t-sql/data-types/table-transact-sql.md#table-variable-deferred-compilation).

## <a name="scalar-udf-inlining"></a>Встраивание скалярных пользовательских функций

> [!NOTE]
> Предоставляется общедоступная предварительная версия функции встраивания скалярных определяемых пользователем функций.  

Функция встраивания скалярных определяемых пользователем функций позволяет автоматически преобразовать [скалярные определяемые пользовательские функции](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#Scalar) в реляционные выражения. Затем они внедряются в вызывающий SQL-запрос. Такое преобразование повышает производительность рабочих нагрузок, которые используют скалярные определяемые пользователем функции. Встраивание скалярных определяемых пользователем функций способствует оптимизации с учетом стоимости операций, выполняемых внутри определяемых пользователем функций. Это обеспечивает эффективные планы выполнения с поддержкой наборов и параллелизма вместо неэффективных, итеративных и последовательных планов. Эта функция включена по умолчанию на уровне совместимости базы данных 150.

Дополнительные сведения см. в разделе [Встраивание скалярных функций, определяемых пользователем](../user-defined-functions/scalar-udf-inlining.md).

## <a name="approximate-query-processing"></a>Приблизительная обработка запросов

> [!NOTE]
> Предоставляется общедоступная предварительная версия функции **APPROX_COUNT_DISTINCT**.  

Приблизительная обработка запросов — это новое семейство функций. Оно позволяет агрегировать большие наборы данных, для которых скорость реагирования намного важнее абсолютной точности. В качестве примера предположим, что нам нужно вычислить выражение **COUNT(DISTINCT())** по 10 миллиардам строк, чтобы отобразить результат на панели мониторинга. Абсолютная точность здесь не требуется, но критически важна скорость реагирования. Новая агрегатная функция **APPROX_COUNT_DISTINCT** возвращает приблизительное количество содержащихся в группе уникальных значений, не равных NULL.

Дополнительные сведения см. в описании [APPROX_COUNT_DISTINCT (Transact-SQL)](../../t-sql/functions/approx-count-distinct-transact-sql.md).

## <a name="batch-mode-on-rowstore"></a>Пакетный режим для данных rowstore 

> [!NOTE]
> Предоставляется общедоступная предварительная версия функции "Пакетный режим для данных rowstore".  

Пакетный режим для данных rowstore обеспечивает выполнение в пакетном режиме для аналитических рабочих нагрузок без необходимости использовать индексы columnstore.  Эта функция поддерживает выполнение в пакетном режиме и фильтры по битовым картам для кучи на диске и индексов сбалансированного дерева. Пакетный режим rowstore обеспечивает поддержку для всех операторов, доступных в этом режиме.

### <a name="background"></a>Историческая справка

В [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] появилась новая функция для ускорения аналитических рабочих нагрузок — индексы columnstore. С каждым последующим выпуском мы расширяли возможности использования индексов columnstore и улучшали их производительность. До этого момента мы представляли и документировали все эти возможности как одну функцию. Индексы columnstore создаются на уровне таблиц. Благодаря этому быстрее выполняются аналитические рабочие нагрузки. Но на самом деле здесь применяются два связанных, но различных набора технологий.
- Индексы **columnstore** позволяют аналитическим запросам получать доступ к данным только в требуемых столбцах. Кроме того, сжатие в формате columnstore намного эффективнее, чем для традиционных индексов **rowstore**. 
- При обработке в **пакетном режиме** операторы запросов выполняются более эффективно. Они работают по пакету строк, а не по одной строке за раз. С обработкой в пакетном режиме также связан ряд других улучшений масштабируемости. Дополнительные сведения о пакетном режиме см. в разделе [Режимы выполнения](../../relational-databases/query-processing-architecture-guide.md#execution-modes).

Эти два набора функций взаимодействуют, чтобы оптимизировать скорость выполнения операций ввода-вывода и использования ЦП.
- Благодаря индексам columnstore в памяти помещается больше данных. Это снижает потребность в операциях ввода-вывода.
- При обработке в пакетном режиме ресурсы ЦП используются более эффективно.

Эти две технологии совместно используются везде, где это возможно, для получения дополнительных преимуществ. Например, статические выражения в пакетном режиме можно вычислить в рамках сканирования индекса columnstore. Кроме того, с помощью соединений и статических вычислений пакетного режима мы гораздо более эффективно обрабатываем данные columnstore, которые сжаты с использованием кодирования по длине серий. 
 
Эти две функции можно использовать независимо друг от друга.
* Можно создать план со строковым режимом, который использует индексы columnstore.
* Можно создать план с пакетным режимом, который использует только индексы rowstore. 

Но обычно совместное использование этих компонентов дает наилучший результат. Поэтому до текущего момента оптимизатор запросов SQL Server применял пакетную обработку только для запросов, которые включают хотя бы одну таблицу с индексом columnstore.

Индексы columnstore не подходят для некоторых приложений. Приложение может использовать другие функции, которые не совместимы с индексами columnstore. Например, изменения на месте не совместимы со сжатием columnstore. Поэтому таблицы с кластеризованными индексами columnstore не поддерживают триггеры. Что еще важнее, индексы columnstore повышают затраты на выполнение инструкций **DELETE** и **UPDATE**. 

Для некоторых гибридных транзакционно-аналитических рабочих нагрузок издержки на транзакционные аспекты рабочей нагрузки перевешивают преимущество от использования индексов columnstore. В таких сценариях показатель использования ЦП можно снизить, отдельно применяя режим пакетной обработки. Поэтому функция "Пакетный режим для данных rowstore" позволяет применять пакетный режим для всех запросов. При этом неважно, какие индексы используются.

### <a name="workloads-that-might-benefit-from-batch-mode-on-rowstore"></a>Рабочие нагрузки, для которых целесообразно использовать пакетный режима для данных rowstore

Пакетный режим для данных rowstore предоставляет преимущества для рабочих нагрузок со следующими характеристиками:
* Если значительная часть рабочей нагрузки состоит из аналитических запросов. Обычно такие запросы используют соединения или статистические выражения для обработки сотен тысяч строк или даже больше.
* Если рабочая нагрузка сильно зависит от ЦП. Для всех случаев, когда узким местом остается скорость ввода и вывода, мы по прежнему рекомендуем при любой возможности применять индекс columnstore.
* Если создание индекса columnstore сопряжено со слишком большими транзакционными расходами для рабочей нагрузки. Возможно также, что индекс columnstore создать нельзя из-за зависимости приложения от функции, которая пока не поддерживает работу с индексами columnstore.

> [!NOTE]
> Использование пакетного режима для данных rowstore помогает только сократить потребление ресурсов ЦП. Если же узким местом являются операции ввода-вывода и данные не кэшируются ("холодный" кэш), использование пакетного режима для rowstore не сократит затраченное время. Аналогичным образом, если на компьютере не хватает памяти для кэширования всех данных, повышение производительности маловероятно.

### <a name="what-changes-with-batch-mode-on-rowstore"></a>Что изменяется при использовании пакетного режима для данных rowstore?

Помимо перехода на уровень совместимости 150, с вашей стороны не требуется никаких изменений для применения пакетного режима к данным rowstore для рабочих нагрузок.

Даже если запрос не содержит таблиц с индексом columnstore, обработчик запросов теперь включает пакетный режим в эвристический анализ. Этот эвристический анализ включает следующее:
1. Первоначальной проверки размеров таблиц, используемых операторов и предполагаемого количества элементов во входном запросе.
2. Дополнительных проверок, так как оптимизатор обнаруживает новые, более дешевые планы для запроса. Если эти альтернативные планы используют пакетный режим незначительно, оптимизатор прекратит изучение альтернатив с пакетным режимом.

Если для данных rowstore используется пакетный режим, фактический режим выполнения будет обозначен как **batch mode** (пакетный режим) в плане запроса. Оператор сканирования использует пакетный режим для кучи на диске и индексов сбалансированного дерева. При этом сканировании пакетного режима можно оценить фильтры растрового изображения в пакетном режиме. Вы можете заметить в плане и другие операторы пакетного режима. Например, хэш-соединения, статические операции на основе хэша, сортировки, статистические операции с окнами, фильтры, объединение и операторы вычисления скалярного значения.

### <a name="remarks"></a>Remarks

* Планы запросов не всегда используют пакетный режим. Оптимизатор запросов может определить, что пакетный режим не улучшит обработку запроса. 
* Пространство поиска оптимизатора запросов изменяется. Например, план в строковом режиме может не совпадать с планом, который вы получите на более низком уровне совместимости. А план в пакетном режиме может не совпадать с планом, который вы получите для индекса columnstore. 
* Новый режим сканирования пакетного режима для данных rowstore может изменять планы для запросов, в которых сочетаются индексы columnstore и rowstore.
* Для нового сканирования пакетного режима для данных rowstore действует ряд ограничений: 
    * Сканирование не будет использоваться для таблиц OLTP, выполняющейся в памяти, или для любых других индексов, отличных от индексов в виде куч на диске и сбалансированных деревьев. 
    * Также оно не применяется, если LOB-столбец извлекается или фильтруется. Это ограничение относится и к наборам разреженных столбцов и XML-столбцам.
* Есть запросы, для которых пакетный режим не применяется даже с индексами columnstore. В качестве примера можно назвать запросы с курсорами. Эти исключения относятся и к пакетному режиму для индексов rowstore.

### <a name="configure-batch-mode-on-rowstore"></a>Настройка пакетного режима для данных rowstore

Параметр **BATCH_MODE_ON_ROWSTORE** в конфигурации уровня базы данных включен по умолчанию. Он позволяет отключить пакетный режим для индексов rowstore, не требуя изменять уровень совместимости базы данных:

```sql
-- Disabling batch mode on rowstore
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = OFF;

-- Enabling batch mode on rowstore
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = ON;
```

Вы можете отключить пакетный режим для rowstore в конфигурации уровня базы данных. Но этот параметр можно переопределить на уровне запроса с помощью указания запроса **ALLOW_BATCH_MODE**. В следующем примере пакетный режим для данных rowstore включается, несмотря на то что функция отключена через конфигурацию на уровне базы данных:

```sql
SELECT [Tax Rate], [Lineage Key], [Salesperson Key], SUM(Quantity) AS SUM_QTY, SUM([Unit Price]) AS SUM_BASE_PRICE, COUNT(*) AS COUNT_ORDER
FROM Fact.OrderHistoryExtended
WHERE [Order Date Key]<=DATEADD(dd, -73, '2015-11-13')
GROUP BY [Tax Rate], [Lineage Key], [Salesperson Key]
ORDER BY [Tax Rate], [Lineage Key], [Salesperson Key]
OPTION(RECOMPILE, USE HINT('ALLOW_BATCH_MODE'));
```

Пакетный режим для данных rowstore также можно отключить для отдельных запросов, используя указание запроса **DISALLOW_BATCH_MODE**. См. следующий пример.

```sql
SELECT [Tax Rate], [Lineage Key], [Salesperson Key], SUM(Quantity) AS SUM_QTY, SUM([Unit Price]) AS SUM_BASE_PRICE, COUNT(*) AS COUNT_ORDER
FROM Fact.OrderHistoryExtended
WHERE [Order Date Key]<=DATEADD(dd, -73, '2015-11-13')
GROUP BY [Tax Rate], [Lineage Key], [Salesperson Key]
ORDER BY [Tax Rate], [Lineage Key], [Salesperson Key]
OPTION(RECOMPILE, USE HINT('DISALLOW_BATCH_MODE'));
```

## <a name="see-also"></a>См. также раздел

[Центр производительности для базы данных SQL Azure и ядра СУБД SQL Server](../../relational-databases/performance/performance-center-for-sql-server-database-engine-and-azure-sql-database.md)     
[Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md)    
[Справочник по логическим и физическим операторам Showplan](../../relational-databases/showplan-logical-and-physical-operators-reference.md)    
[Соединения](../../relational-databases/performance/joins.md)    
[Демонстрация адаптивной обработки запросов](https://github.com/joesackmsft/Conferences/blob/master/Data_AMP_Detroit_2017/Demos/AQP_Demo_ReadMe.md)       
[Демонстрация интеллектуальной обработки запросов](https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/intelligent-query-processing)   
