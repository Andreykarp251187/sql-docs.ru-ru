---
description: Оптимизация трассировки SQL
title: Оптимизация трассировки SQL | Документация Майкрософт
ms.custom: ''
ms.date: 03/04/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- time [SQL Server], traces
- SQL Trace, performance
- traces [SQL Server], performance
- performance [SQL Server], trace
ms.assetid: 50944218-925f-4576-aec8-4379846d7681
author: MashaMSFT
ms.author: mathoma
ms.openlocfilehash: 444ef217e226a035b0ddfda00ec969a6bf05dff9
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "88455378"
---
# <a name="optimize-sql-trace"></a>Оптимизация трассировки SQL
 [!INCLUDE [SQL Server](../../includes/applies-to-version/sqlserver.md)]
  Выполнение трассировки SQL негативно сказывается на производительности, поскольку этот процесс использует системные ресурсы для сбора данных, однако существует несколько способов минимизировать потери производительности. Чтобы минимизировать потери производительности, вызванные трассировкой:  
  
-   Рассмотрите возможность использования командной строки для запуска трассировок. Использование графического пользовательского интерфейса уменьшает производительность. Дополнительные сведения см. в разделе [sp_trace_create (Transact-SQL)](../../relational-databases/system-stored-procedures/sp-trace-create-transact-sql.md).  
  
-   Избегайте включения часто возникающих событий. По возможности сократите трассировку посредством особых классов событий и фильтров. Чем меньше собирается событий трассировки, тем меньше требуется ресурсов для ее поддержания.  
  
-   Настройте трассировку на сбор только тех событий, которые содержат нужные данные. Например, если трассировка должна определить взаимоблокировки, включите в нее класс событий **Lock:Deadlock** , а не **Lock:Acquired** . Если включить в трассировку оба класса событий, она будет отвечать на каждую полученную блокировку и производительность снизится в два раза.  
  
-   Старайтесь не собирать дублирующиеся данные. Например, собирая **SQL:BatchStarted** и **SQL:BatchCompleted**, можно минимизировать размер результирующего набора, выбрав только текстовые данные для класса событий **SQL:BatchStarted** .  
  
-   Используйте фильтры в определении трассировки. Например, если известно, что определенный пользователь страдает от низкой производительности во время нерегламентированных запросов, создайте фильтр для **LoginName**. Настройте фильтр так, чтобы включались только события, в которых **LoginName** совпадает с именем пользователя.  
  
 Если необходимо запустить трассировку для событий, которая повлечет за собой серьезное снижение производительности, попробуйте следующие способы ограничения влияния на производительность сервера:  
  
-   Запускайте трассировки на более короткие промежутки времени. Время выполнения трассировки можно контролировать, включив время остановки. Это особенно важно, если нет возможности ограничить классы событий или установить фильтры. Время остановки гарантирует, что потери производительности не будут бесконечными.  
  
-   Ограничьте размер результатов трассировки. Можно ограничить размер результатов трассировки до максимального размера файла. Такая стратегия гарантирует, что потери производительности прекратятся, когда будет достигнуто ограничение по размеру файла (если не включена операция переключения на файл продолжения).  
  
-   Ограничьте число возвращаемых событий. В [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] можно ограничить число возвращаемых событий, сохранив трассировку в таблицу с установленным максимальным числом строк. Результаты трассировки продолжают возвращаться на экран [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] после достижения максимального числа строк, но при этом можно избежать затрат производительности на запись результатов.  
  
## <a name="see-also"></a>См. также:  
 [Фильтрация трассировки](../../relational-databases/sql-trace/filter-a-trace.md)  
  
  
