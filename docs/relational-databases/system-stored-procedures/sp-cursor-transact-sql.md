---
title: sp_cursor (Transact-SQL) | Документация Майкрософт
ms.custom: ''
ms.date: 03/03/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: system-objects
ms.topic: language-reference
f1_keywords:
- sp_cursor_TSQL
- sp_cursor
dev_langs:
- TSQL
helpviewer_keywords:
- sp_cursor
ms.assetid: 41ade0ca-5f11-469d-bd4d-c8302ccd93b3
author: stevestein
ms.author: sstein
ms.openlocfilehash: cd5cae24b30840ea08ec2ae025b021fcf70f2dc6
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68108572"
---
# <a name="spcursor-transact-sql"></a>sp_cursor (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2008-xxxx-xxxx-xxx-md](../../includes/tsql-appliesto-ss2008-xxxx-xxxx-xxx-md.md)]

  Запрашивает позиционированные обновления. Эта процедура выполняет операции с одной или несколькими строками в пределах буфера выборки курсора. sp_cursor вызывается указанием ID = 1 в пакете потока табличных данных.  
  
||  
|-|  
|**Область применения**: SQL Server ( [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] через [текущей версии](https://go.microsoft.com/fwlink/p/?LinkId=299658)).|  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
sp_cursor  cursor, optype, rownum, table  
    [ , value[...n]]]  
```  
  
## <a name="arguments"></a>Аргументы  
 *курсор*  
 Дескриптор курсора. *курсор* является обязательным параметром, который вызывает для **int** входного значения. *курсор* — *обрабатывать* значение, сформированное SQL Server и возвращаемое процедурой sp_cursoropen.  
  
 *optype*  
 Обязательный параметр, назначающий операцию, которую будет выполнять курсор. *optype* требует одного из следующих **int** входных значений.  
  
|Значение|Name|Описание|  
|-----------|----------|-----------------|  
|0X0001|UPDATE|Используется для обновления одной или более строк в буфере выборки.  К строкам, указанным в *rownum* повторный доступ и обновлены.|  
|0x0002|DELETE|Используется для удаления одной или более строк в буфере выборки. К строкам, указанным в *rownum* повторный доступ и удалить.|  
|0X0004|INSERT|Вставляет данные без построения SQL **вставить** инструкции.|  
|0X0008|REFRESH|Используется для повторного заполнения буфера из базовых таблиц. Может использоваться для обновления строки, если обновление или удаление не удалось провести из-за управления оптимистическим параллелизмом, или после выполнения UPDATE.|  
|0X10|LOCK|Заставляет SQL Server U-блокировку на странице, содержащей указанную строку. Эта блокировка совместима с S-блокировками и несовместима с X-блокировками или другими U-блокировками. Может использоваться для краткосрочной блокировки.|  
|0X20|SETPOSITION|Используется, только когда программа будет выдавать последующие SQL Server расположен инструкции DELETE или UPDATE.|  
|0X40|ABSOLUTE|Может использоваться только совместно с UPDATE или DELETE.  ABSOLUTE используется только с курсорами KEYSET (не используется курсорами DYNAMIC, а курсоры STATIC не допускают обновления).<br /><br /> Примечание. Если указано «ABSOLUTE» для строки в ключевом наборе, которая не была получена, операция может завершиться ошибкой проверки на параллелизм и возвращаемый результат не гарантируется.|  
  
 *rownum*  
 Указывает, с какими строками в буфере выборки будет работать курсор, обновляя или удаляя их.  
  
> [!NOTE]  
>  Не оказывает влияния на точку начала любой операции выборки RELATIVE, NEXT или PREVIOUS, а также на операции обновления и удаления, выполняемые с помощью процедуры sp_cursor.  
  
 *rownum* является обязательным параметром, который вызывает для **int** входного значения.  
  
 1  
 Обозначает первую строку в буфере выборки.  
  
 2  
 Обозначает вторую строку в буфере выборки.  
  
 3, 4, 5  
 Обозначает третью строку и так далее.  
  
 n  
 Обозначает n-ю строку в буфере выборки.  
  
 0  
 Обозначает все строки в буфере выборки.  
  
> [!NOTE]  
>  Допустимо только для использования с обновления, удаления, обновления или БЛОКИРОВКИ *optype* значения.  
  
 *table*  
 Имя таблицы, определяющее таблицу, *optype* применяется, когда определение курсора включает соединение или неоднозначные имена столбцов, возвращаемых *значение* параметра. Если таблица не назначена, то по умолчанию берется первая таблица в предложении FROM. *Таблица* — это необязательный параметр, который должен иметь значение входной строки. Строка может иметь любой символьный тип данных или Юникоде. *Таблица* может быть имя таблицы в нескольких частях.  
  
 *value*  
 Используется для вставки или обновления значений. *Значение* строковый параметр используется только с UPDATE и INSERT *optype* значения. Строка может иметь любой символьный тип данных или Юникоде.  
  
> [!NOTE]  
>  Имена параметров для *значение* могут назначаться пользователем.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 При использовании RPC, позиционированные операции DELETE или UPDATE с номером буфера 0 возвращает сообщение DONE со *rowcount* 0 (неуспешное завершение) или 1 (успешное завершение) для каждой строки в буфере выборки.  
  
## <a name="remarks"></a>Примечания  
  
## <a name="optype-parameter"></a>Параметр optype  
 Кроме сочетаний SETPOSITION с UPDATE, DELETE, обновления или БЛОКИРОВКИ; Абсолютный или ОТНОСИТЕЛЬНЫЙ с UPDATE или DELETE, *optype* значения являются взаимоисключающими.  
  
 Предложение SET значения UPDATE формируется из *значение* параметра.  
  
 Одним из преимуществ использования вставки *optype* значение — что не надо преобразовывать несимвольные данные в символьный формат для операции вставки. Значения указываются так же, как в UPDATE. Если какие-либо обязательные столбцы не включены, то возникает ошибка INSERT.  
  
-   Значение SETPOSITION не влияет на начальную точку любой операции выборки RELATIVE, NEXT или PREVIOUS, так же как и любые обновления или удаления, выполненные с помощью интерфейса sp_cursor. Любое число, не указывающее строку в буфере выборки, приведет к установке позиции в значения 1, при этом сообщение об ошибке не выдается. После выполнения инструкции SETPOSITION позиция действует до следующей операции sp_cursorfetch, T-SQL **ВЫБОРКИ** операции или операции sp_cursor SETPOSITION того же курсора. Последующая операция sp_cursorfetch переместит позицию курсора на первую строку в новом буфере выборки, тогда как другие вызовы курсора не повлияют на его позицию. SETPOSITION можно связывать оператором OR с REFRESH, UPDATE, DELETE или LOCK, чтобы установить значение позиции на последнюю измененную строку.  
  
 Если строки в буфере выборки не указана в *rownum* параметр, положение будет указано значение 1, сообщение об ошибке не возвращается. После задания позиции она действует до выполнения следующей операции sp_cursorfetch, команды T-SQL FETCH или операции sp_cursor SETPOSITION для того же курсора.  
  
 SETPOSITION можно связывать оператором OR с REFRESH, UPDATE, DELETE или LOCK, чтобы установить позицию курсора на последнюю измененную строку.  
  
## <a name="rownum-parameter"></a>Параметр rownum  
 Если указано, *rownum* параметра может интерпретироваться как номер строки в наборе ключей, а не номер строки в буфере выборки. Пользователь отвечает за управление параллелизмом. Это означает, что для курсоров SCROLL_LOCKS придется независимо поддерживать блокировку заданной строки (это можно сделать через транзакции). Для курсоров OPTIMISTIC надо предварительно извлечь строку, чтобы выполнить эту операцию.  
  
## <a name="table-parameter"></a>Параметр table  
 Если *optype* значение равно UPDATE или INSERT и полное обновление или инструкции insert отправляется как *значение* параметр, значение, указанное для *таблицы* учитывается.  
  
> [!NOTE]  
>  Для представлений могут изменяться только участвующие в них таблицы. *Значение* имена столбцов параметра должны отражать имена столбцов в представлении, но имя таблицы может быть имя базовой таблице (в этом случае sp_cursor будет заменен именем представления).  
  
## <a name="value-parameter"></a>Параметр value  
 Имеются две альтернативы правилам использования *значение* как уже говорилось в разделе «аргументы»:  
  
1.  Можно использовать имя, которое является "\@" перед активным в имя столбца в списке выбора для любых именованных *значение* параметров. Одним из преимуществ такого варианта является то, что не обязательно преобразовывать данные.  
  
2.  Параметр для передачи полной инструкции UPDATE или INSERT или использовать несколько параметров для передачи частей инструкций UPDATE или INSERT которой SQL Server будет встроить в является законченным оператором. Примеры можно найти далее в подразделе «Примеры» этого раздела.  
  
## <a name="examples"></a>Примеры  
  
### <a name="alternative-value-parameter-uses"></a>Альтернативы использованию параметра value  
 Для UPDATE:  
  
 Когда используется один параметр, инструкцию UPDATE можно передать с использованием следующего синтаксиса:  
  
 `[ [ UPDATE <table name> ] SET ] {<column name> = expression} [,...n]`  
  
> [!NOTE]  
>  Если обновление \<имя таблицы >, заданный любое значение для *таблицы* параметр будет пропущен.  
  
 При использовании нескольких параметров первый параметр должен быть строкой в следующем формате:  
  
 `[ SET ] <column name> = expression  [,...n]`  
  
 Последующие параметры должны быть в формате:  
  
 `<column name> = expression  [,...n]`  
  
 В этом случае \<имя таблицы > в обновлении сконструированный инструкции та же указанным или применяемым по умолчанию для *таблицы* параметра.  
  
 Для INSERT:  
  
 Если используется один параметр, то инструкцию INSERT можно передать с использованием следующего синтаксиса:  
  
 `[ [ INSERT [INTO] <table name> ] VALUES ] ( <expression> [,...n] )`  
  
> [!NOTE]  
>  Если вставить  *\<имя таблицы >* , заданный любое значение для *таблицы* параметр будет пропущен.  
  
 При использовании нескольких параметров первый параметр должен быть строкой в следующем формате:  
  
 `[ VALUES ( ] <expression>  [,...n]`  
  
 Последующие параметры должны быть в формате:  
  
 `expression [,...n]`  
  
 За исключением случаев, когда указан параметр VALUES, в этом случае после последнего выражения должен стоять символ ). В этом случае  *\<имя таблицы >* в ОБНОВЛЕНИИ сконструированный инструкции та же указанным или применяемым по умолчанию для *таблицы* параметра.  
  
> [!NOTE]  
>  Возможно передать один параметр как именованный, то есть «`@VALUES`». В этом случае другие параметры использовать нельзя.  
  
## <a name="see-also"></a>См. также  
 [sp_cursoropen &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-cursoropen-transact-sql.md)   
 [Хранимая процедура sp_cursorfetch &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-cursorfetch-transact-sql.md)   
 [Системные хранимые процедуры (Transact-SQL)](../../relational-databases/system-stored-procedures/system-stored-procedures-transact-sql.md)  
  
  
