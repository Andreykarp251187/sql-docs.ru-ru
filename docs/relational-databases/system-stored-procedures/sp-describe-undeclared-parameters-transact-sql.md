---
title: sp_describe_undeclared_parameters (Transact-SQL) | Документация Майкрософт
ms.custom: ''
ms.date: 09/24/2018
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: system-objects
ms.topic: language-reference
f1_keywords:
- sp_describe_undeclared_parameters
- sp_describe_undeclared_parameters_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- sp_describe_undeclared_parameters
ms.assetid: 6f016da6-dfee-4228-8b0d-7cd8e7d5a354
author: stevestein
ms.author: sstein
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 38428e0a95dcce39589310ee91be2a7d396c2f1e
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "65088507"
---
# <a name="spdescribeundeclaredparameters-transact-sql"></a>sp_describe_undeclared_parameters (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2012-asdb-xxxx-xxx-md](../../includes/tsql-appliesto-ss2012-asdb-xxxx-xxx-md.md)]

  Возвращает результирующий набор, содержащий метаданные о необъявленных параметрах в [!INCLUDE[tsql](../../includes/tsql-md.md)] пакетной службы. Учитывается каждый параметр, который используется в  **\@tsql** пакетной службы, но не объявлены в  **\@params**. Возвращается результирующий набор, содержащий одну строку для каждого такого параметра со сведениями о предполагаемом типе параметра. Процедура возвращает пустой результирующий набор, если  **\@tsql** входном пакете содержит другие параметры, кроме объявленных в  **\@params**.  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```sql
  
sp_describe_undeclared_parameters   
    [ @tsql = ] 'Transact-SQL_batch'   
    [ , [ @params = ] N'parameters' data type ] [, ...n]  
```  
  
## <a name="arguments"></a>Аргументы  
`[ \@tsql = ] 'Transact-SQL\_batch'` Один или несколько [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкций. *Transact SQL_batch* может быть **nvarchar (** _n_ **)** или **nvarchar(max)** .  
  
`[ \@params = ] N'parameters'` \@params обеспечивает строку объявления параметров для [!INCLUDE[tsql](../../includes/tsql-md.md)] работы пакетной службы, точно так же в хранимой процедуре sp_executesql. *Параметры* может быть **nvarchar (** _n_ **)** или **nvarchar(max)** .  
  
 Строка, содержащая определения всех параметров, внедренных в *Transact SQL_batch*. Строка должна представлять собой константу в Юникоде либо переменную в этом же формате. Определение каждого параметра состоит из имени параметра и типа данных. n — заполнитель, указывающий дополнительные определения параметра. Если выполнение инструкции Transact-SQL или пакета в инструкции не содержит параметров, \@params не является обязательным. Этот аргумент по умолчанию принимает значение NULL.  
  
 Datatype  
 Тип данных параметра.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 **sp_describe_undeclared_parameters** всегда возвращает состояние 0 в случае успешного выполнения. Если процедура вызывает ошибку и процедура вызывается через RPC, возвращаемое состояние заполняется типом ошибки, как описано в столбце error_type sys.dm_exec_describe_first_result_set. Если процедура вызывается из [!INCLUDE[tsql](../../includes/tsql-md.md)], возвращаемое значение всегда равно нулю, даже при наличии ошибок.  
  
## <a name="result-sets"></a>Результирующие наборы  
 **sp_describe_undeclared_parameters** возвращает следующий результирующий набор.  
  
|Имя столбца|Тип данных|Описание|  
|-----------------|---------------|-----------------|  
|**parameter_ordinal**|**int NOT NULL**|Содержит порядковый номер параметра в результирующем наборе. Позиция первого параметра будет указана как 1.|  
|**name**|**sysname NOT NULL**|Содержит имя параметра.|  
|**suggested_system_type_id**|**int NOT NULL**|Содержит **system_type_id** типа данных параметра, как указано в sys.types.<br /><br /> Для типов CLR несмотря на то что **system_type_name** столбец вернет значение NULL, этот столбец вернет значение 240.|  
|**suggested_system_type_name**|**nvarchar (256) NULL**|Содержит имя типа данных. Включает аргументы (длина, точность, масштаб), заданные для типа данных параметра. Если тип данных является пользовательским псевдонимом, то здесь указывается базовый системный тип данных. Если это определяемый пользователем тип данных CLR, то в этом столбце возвращается значение NULL. Если не удается определить тип параметра, возвращается значение NULL.|  
|**suggested_max_length**|**smallint NOT NULL**|См. в разделе sys.columns. для **max_length** описание столбца.|  
|**suggested_precision**|**tinyint NOT NULL**|См. в разделе sys.columns. содержащий описание столбца precision.|  
|**suggested_scale**|**tinyint NOT NULL**|См. в разделе sys.columns. содержащий описание столбца scale.|  
|**suggested_user_type_id**|**int NULL**|Для типов CLR и псевдонимов содержит user_type_id для типа данных столбца, как указано в sys.types. В противном случае значение равно NULL.|  
|**suggested_user_type_database**|**аргумент NULL**|Для типов CLR и псевдонимов содержит имя базы данных, в которой этот тип определен. В противном случае значение равно NULL.|  
|**suggested_user_type_schema**|**аргумент NULL**|Для типов CLR и псевдонимов содержит имя схемы, в которой этот тип определен. В противном случае значение равно NULL.|  
|**suggested_user_type_name**|**аргумент NULL**|Для типов CLR и псевдонимов содержит имя типа. В противном случае значение равно NULL.|  
|**suggested_assembly_qualified_type_name**|**nvarchar (4000) NULL**|Для типов CLR возвращает имя сборки и класса, определяющего тип. В противном случае значение равно NULL.|  
|**suggested_xml_collection_id**|**int NULL**|Содержит xml_collection_id для типа данных параметра, как указано в sys.columns. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_database**|**аргумент NULL**|Содержит базу данных, в которой определена коллекция схем XML, связанная с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_schema**|**аргумент NULL**|Содержит схему, в которой определена коллекция схем XML, связанная с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_name**|**аргумент NULL**|Содержит имя коллекции схем XML, связанной с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_is_xml_document**|**бит NOT NULL**|Возвращает значение 1, если возвращается тип XML и этот тип гарантированно представляет собой XML-документ. В противном случае возвращается 0.|  
|**suggested_is_case_sensitive**|**бит NOT NULL**|Возвращает значение 1, если столбец относится к строковому типу с учетом регистра, либо значение 0 в противном случае.|  
|**suggested_is_fixed_length_clr_type**|**бит NOT NULL**|Возвращает значение 1, если столбец относится к типу CLR с фиксированной длиной, либо значение 0 в противном случае.|  
|**suggested_is_input**|**бит NOT NULL**|Возвращает значение 1, если параметр используется за пределами левой стороны присваивания. В противном случае возвращается 0.|  
|**suggested_is_output**|**бит NOT NULL**|Возвращает значение 1, если параметр используется в левой стороне присваивания или передается в выходной параметр хранимой процедуры. В противном случае возвращается 0.|  
|**formal_parameter_name**|**аргумент NULL**|Если параметр служит аргументом хранимой процедуры или определяемой пользователем функции, здесь возвращается имя соответствующего формального параметра. В противном случае возвращается NULL.|  
|**suggested_tds_type_id**|**int NOT NULL**|Для внутреннего использования.|  
|**suggested_tds_length**|**int NOT NULL**|Для внутреннего использования.|  
  
## <a name="remarks"></a>Примечания  
 **sp_describe_undeclared_parameters** всегда возвращает состояние 0.  
  
 Чаще всего она применяется, когда приложению передается инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)], которая может содержать параметры и должна некоторым образом их обрабатывать. Например, пользовательский интерфейс (такие как ODBCTest или RowsetViewer), где пользователь передает запрос с синтаксисом параметров ODBC. Приложение должно динамически обнаруживать число параметров и запрашивать каждый параметр у пользователя.  
  
 Другим примером служит ситуация, где пользователь не вводит данные, а приложение должно просматривать параметры и получать для них данные из другого расположения (из таблицы и т. п.) В этом случае приложение не должно сразу передавать сведения обо всех параметрах. Вместо этого приложение может получить сведения обо всех параметрах от поставщика, а сами данные получить из таблицы. Кода, используя **sp_describe_undeclared_parameters** , более универсален и меньшей вероятностью потребует изменения в случае изменения структуры данных.  
  
 **sp_describe_undeclared_parameters** возвращает сообщение об ошибке в любом из следующих случаев.  
  
-   Если входные данные \@tsql не является допустимым [!INCLUDE[tsql](../../includes/tsql-md.md)] пакетной службы. Допустимость определяется путем синтаксического разбора и анализа [!INCLUDE[tsql](../../includes/tsql-md.md)] пакетной службы. Все ошибки, вызванных пакетом во время оптимизации запроса или во время выполнения не учитываются при определении ли [!INCLUDE[tsql](../../includes/tsql-md.md)] допустимости пакета.  
  
-   Если \@params не равно NULL и содержит строку, которая не является синтаксически правильной строкой объявления параметров или если он содержит строку, объявляющий любого параметра более одного раза.  
  
-   Если входные данные [!INCLUDE[tsql](../../includes/tsql-md.md)] пакет объявляет локальную переменную с тем же именем, как параметр, объявленный в \@params.  
  
- Если оператор ссылается на временные таблицы.

- В запрос включено создание постоянной таблицы, к которой он будет обращен.
  
 Если \@tsql не имеет параметров, не объявленных в \@params, процедура возвращает пустой результирующий набор.  
  
## <a name="parameter-selection-algorithm"></a>Алгоритм выбора параметров  
 Для запроса с необъявленными параметрами выполняется процесс определения типов данных необъявленных параметров, состоящий из трех шагов.  
  
 **Шаг 1**  
  
 Первым шагом определения типов данных для запроса с необъявленными параметрами является поиск типов данных для всех вложенных выражений, типы данных которых не зависят от необъявленных параметров. Тип можно определить для следующих выражений:  
  
-   столбцы, константы, переменные и объявленные параметры;  
  
-   результаты вызова определяемой пользователем функции;  
  
-   выражение с типами данных, не зависящими от необъявленных параметров для всех входов.  
  
 В качестве примера рассмотрим запрос `SELECT dbo.tbl(@p1) + c1 FROM t1 WHERE c2 = @p2 + 2`. Выражения dbo.tbl (\@p1) + c1 и c2 имеют типы данных и выражение \@p1 и \@p2 + 2 — нет.  
  
 Если после этого шага любое выражение (кроме вызова определяемой пользователем функции) содержит два аргумента без типов данных, то определение типов завершается с ошибкой. Например, все следующие инструкции вызывают ошибки:  
  
```sql
SELECT * FROM t1 WHERE @p1 = @p2  
SELECT * FROM t1 WHERE c1 = @p1 + @p2  
SELECT * FROM t1 WHERE @p1 = SUBSTRING(@p2, 2, 3)  
```  
  
 В следующем примере не вызывается ошибка:  
  
```sql
SELECT * FROM t1 WHERE @p1 = dbo.tbl(c1, @p2, @p3)  
```
  
 **Шаг 2**  
  
 Для заданного необъявленного параметра \@p, алгоритм определения типов обнаруживает внутреннее выражение E (\@p), содержащий \@p и является одним из следующих:  
  
-   аргументом оператора сравнения или присваивания;  
  
-   аргументом определяемой пользователем функции (в том числе определяемой пользователем функции, возвращающей табличное значение), процедуры или метода;  
  
-   Аргумент **значения** предложении **вставить** инструкции.  
  
-   Аргумент **ПРИВЕДЕНИЯ** или **преобразовать**.  
  
 Алгоритм определения типов находит целевой тип данных TT (\@p) для E (\@p). Далее показаны целевые типы данных для предыдущих примеров:  
  
-   тип данных на другой стороне сравнения или присваивания;  
  
-   объявленный тип данных параметра, в который передается этот аргумент;  
  
-   тип данных столбца, в который вставляется это значение;  
  
-   тип данных, к которому приводится или преобразуется инструкция.  
  
 В качестве примера рассмотрим запрос `SELECT * FROM t WHERE @p1 = dbo.tbl(@p2 + c1)`. Затем E (\@p1) = \@p1, E (\@p2) = \@p2 + c1, TT (\@p1) — это тип объявленного возвращаемых данных dbo.tbl и TT (\@p2) является объявленным типом данных параметра для dbo.tbl.  
  
 Если \@p не содержится в одном выражении, указанном в начале шага 2, алгоритм определения типов определяет, E (\@p) является самым большим скалярным выражением, которое содержит \@p и алгоритм определения типов не делает вычислений целевого типа данных TT (\@p) для E (\@p). Например, если запрос SELECT `@p + 2` затем E (\@p) = \@p + 2, а не TT (\@p).  
  
 **Шаг 3**  
  
 Теперь, E (\@p) и TT (\@p) являются определения, алгоритм определения типов определяет тип данных для \@p в одном из следующих двух способов:  
  
-   Простое определение  
  
     Если E (\@p) = \@p и TT (\@p) существует, т. е. Если \@p является непосредственным аргументом для одного из выражений в списке в начале шага 2, алгоритм определения типов определяет тип данных \@p, чтобы быть TT ( \@p). Пример:  
  
    ```sql
    SELECT * FROM t WHERE c1 = @p1 AND @p2 = dbo.tbl(@p3)  
    ```  
  
     Тип данных для \@p1, \@p2, и \@p3 будет тип данных c1, тип возвращаемых данных dbo.tbl, а тип данных параметра для dbo.tbl, соответственно.  
  
     Как особый случай если \@p является аргументом для \<, >, \<=, или > =-оператор, простое определение правила не применяются. Алгоритм определения типов будет использовать общие правила определения, описанные в следующем разделе. Например, если столбец c1 имеет тип данных char(30), рассмотрим следующие два запроса:  
  
    ```sql
    SELECT * FROM t WHERE c1 = @p  
    SELECT * FROM t WHERE c1 > @p  
    ```  
  
     В первом случае алгоритм определения типов определяет **char(30)** как тип данных для \@p в соответствии с правилами ранее в этом разделе. Во втором случае алгоритм определения типов определяет **varchar(8000)** в соответствии с правилами общее определение в следующем разделе.  
  
-   Общее определение  
  
     Если простое определение не действует, то для необъявленных параметров рассматриваются следующие типы данных.  
  
    -   Целочисленные типы данных (**бит**, **tinyint**, **smallint**, **int**, **bigint**)  
  
    -   Типы данных (**smallmoney**, **деньги**)  
  
    -   Типы данных с плавающей запятой (**float**, **реальных**)  
  
    -   **numeric (38, 19)** -другие типы данных numeric или decimal не учитываются.  
  
    -   **varchar(8000)** , **varchar(max)** , **nvarchar(4000)** , и **nvarchar(max)** - другие строковые типы данных (такие как **текст**, **char(8000)** , **nvarchar(30)** т. д.) не учитываются.  
  
    -   **varbinary(8000)** и **varbinary(max)** -не учитываются другие двоичные типы данных (такие как **изображение**, **binary(8000)** , **varbinary (30)** и т. д.).  
  
    -   **Дата**, **time(7)** , **smalldatetime**, **datetime**, **datetime2(7)** , **datetimeoffset(7)**  - Другие типы даты и времени, таких как **time(4)** , не учитываются.  
  
    -   **sql_variant**  
  
    -   **xml**  
  
    -   Системные типы CLR (**hierarchyid**, **geometry**, **geography**)  
  
    -   Определяемые пользователем типы CLR  
  
### <a name="selection-criteria"></a>Условия выбора  
 Любой тип данных-кандидат, который нарушает допустимость запроса, отклоняется. Из оставшихся кандидатов алгоритм определения типов выбирает один тип данных по следующим правилам.  
  
1.  Тип данных, который создает наименьшее количество неявные преобразования в E (\@p) выбран. Если определенный тип данных создает тип данных для E (\@p), отличается от TT (\@p), алгоритм определения типов считает это дополнительным неявным преобразованием из типа данных E (\@p) для TT (\@p).  
  
     Пример:  
  
    ```sql
    SELECT * FROM t WHERE Col_Int = Col_Int + @p  
    ```  
  
     В данном случае E (\@p) является Col_Int + \@p и TT (\@p) является **int**. **int** будет автоматически выбран \@p, так как он не требует неявных преобразований. Любой другой выбор типа данных требует не меньше одного неявного преобразования.  
  
2.  Если несколько типов данных имеют минимальное число преобразований, то используется тип данных с максимальным приоритетом. Например.  
  
    ```sql
    SELECT * FROM t WHERE Col_Int = Col_smallint + @p  
    ```  
  
     В этом случае **int** и **smallint** требуется одно преобразование. Для любого другого типа данных требуется несколько преобразований. Так как **int** имеет приоритет над **smallint**, **int** используется для \@p. Дополнительные сведения о приоритете типов данных см. в разделе [приоритетов типов данных &#40;Transact-SQL&#41;](../../t-sql/data-types/data-type-precedence-transact-sql.md).  
  
     Это правило применяется, только если существует неявное преобразование между каждым из типов, равнозначных по правилу 1, и типом данных с максимальным приоритетом. Если неявное преобразование отсутствует, то определение типа данных завершается с ошибкой. Например, в запросе `SELECT @p FROM t`, тип данных выведение завершается ошибкой, так как любой тип данных для \@p бы одинаково хорошо. Например, отсутствует неявное преобразование из **int** для **xml**.  
  
3.  Если два схожих типа данных правилу 1 равнозначными, например **varchar(8000)** и **varchar(max)** , тем меньше тип данных (**varchar(8000)** ) выбирается. Тот же принцип применяется к **nvarchar** и **varbinary** типов данных.  
  
4.  В рамках правила 1 алгоритм определения типов используют различные приоритеты преобразований. Далее показаны преобразования в порядке убывания приоритета.  
  
    1.  Преобразование между типами с одним базовым типом, имеющими разную длину.  
  
    2.  Преобразование между версии разные типы данных фиксированной и переменной длины (например, **char** для **varchar**).  
  
    3.  Преобразование между **NULL** и **int**.  
  
    4.  Все прочие преобразования.  
  
 Например, для запроса `SELECT * FROM t WHERE [Col_varchar(30)] > @p`, **varchar(8000)** выбрано потому, что лучше всего преобразования (a). Для запроса `SELECT * FROM t WHERE [Col_char(30)] > @p`, **varchar(8000)** по-прежнему выбран, поскольку он приводит к преобразованию типа (b), а еще один вариант (такие как **varchar(4000)** ) вызовет преобразования типов (d).  
  
 В последнем примере, учитывая запрос `SELECT NULL + @p`, **int** будет автоматически выбран \@p за счет преобразования типов (c).  
  
## <a name="permissions"></a>Разрешения  
 Требуется разрешение на выполнение \@аргумент tsql.  
  
## <a name="examples"></a>Примеры  
 В следующем примере возвращаются такие данные, как ожидаемый тип данных для необъявленных параметров `@id` и `@name`.  
  
```sql
sp_describe_undeclared_parameters @tsql =   
N'SELECT object_id, name, type_desc   
FROM sys.indexes  
WHERE object_id = @id OR name = @name'  
  
```  
  
 Если параметр `@id` передается по ссылке `@params`, то параметр `@id` исключается из результирующего набора и описывается только параметр `@name`.  
  
```sql
sp_describe_undeclared_parameters @tsql =   
N'SELECT object_id, name, type_desc   
FROM sys.indexes  
WHERE object_id = @id OR NAME = @name',  
@params = N'@id int'  
  
```  
  
## <a name="see-also"></a>См. также  
 [sp_describe_first_result_set &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql.md)   
 [sys.dm_exec_describe_first_result_set &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-transact-sql.md)   
 [sys.dm_exec_describe_first_result_set_for_object &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-for-object-transact-sql.md)
