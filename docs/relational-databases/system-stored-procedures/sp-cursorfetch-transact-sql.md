---
title: Хранимая процедура sp_cursorfetch (Transact-SQL) | Документация Майкрософт
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: system-objects
ms.topic: language-reference
f1_keywords:
- sp_cursorfetch
- sp_cursorfetch_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- sp_cursorfetch
ms.assetid: 14513c5e-5774-4e4c-92e1-75cd6985b6a3
author: stevestein
ms.author: sstein
manager: craigg
ms.openlocfilehash: a7b07ccf7641f0529d03b2b37650e2ac8afbc9d2
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62724578"
---
# <a name="spcursorfetch-transact-sql"></a>sp_cursorfetch (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2008-xxxx-xxxx-xxx-md](../../includes/tsql-appliesto-ss2008-xxxx-xxxx-xxx-md.md)]

  Извлекает из базы данных буфер из одной или нескольких строк. Группа строк в этом буфере называется курсора *буфера выборки*. Хранимая процедура sp_cursorfetch вызывается при указании ID = 7 в пакете потока табличных данных.  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
sp_cursorfetch cursor  
    [ , fetchtype[ , rownum [ , nrows] ]]   
```  
  
## <a name="arguments"></a>Аргументы  
 *курсор*  
 — *Обрабатывать* значение, сформированное [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и возвращаемое процедурой sp_cursoropen параметр. *курсор* является обязательным параметром, который вызывает для **int** входного значения. Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
 *fetchType*  
 Указывает, какой буфер курсора выбирается. *fetchType* является необязательным параметром требует одного из следующих целых входных значений.  
  
|Значение|Имя|Описание|  
|-----------|----------|-----------------|  
|0x0001|FIRST|Извлекает первый буфер *nrows* строк. Если *nrows* равен 0, курсор помещается перед результирующим набором и строки не возвращаются.|  
|0x0002|NEXT|Извлекает следующий буфер *nrows* строк.|  
|0x0004|PREV|Извлекает предыдущий буфер *nrows* строк.<br /><br /> Примечание. При использовании значения PREV для курсора FORWARD_ONLY возвращает сообщение об ошибке, поскольку FORWARD_ONLY поддерживает прокрутку только в одном направлении.|  
|0x0008|LAST|Извлекает последний буфер *nrows* строк. Если *nrows* имеет значение 0, то курсор позиционируется после результирующего набора и строки не возвращаются.<br /><br /> Примечание. При использовании значения LAST для курсора FORWARD_ONLY возвращает сообщение об ошибке, поскольку FORWARD_ONLY поддерживает прокрутку только в одном направлении.|  
|0x10|ABSOLUTE|Извлекает буфер *nrows* строк, начиная с *rownum* строки.<br /><br /> Примечание. Возвращает сообщение об ошибке при использовании значения ABSOLUTE для курсора FORWARD_ONLY или динамический курсор, поскольку FORWARD_ONLY поддерживает прокрутку только в одном направлении.|  
|0x20|RELATIVE|Извлекает буфер *nrows* строк, начиная со строки, указанной в качестве *rownum* значение строки из первой строки в текущем блоке. В этом случае *rownum* может быть отрицательным числом.<br /><br /> Примечание. При использовании значения RELATIVE для курсора FORWARD_ONLY возвращает сообщение об ошибке, поскольку FORWARD_ONLY поддерживает прокрутку только в одном направлении.|  
|0x80|REFRESH|Перезаполняет буфер из базовых таблиц.|  
|0x100|INFO|Извлекает сведения о курсоре. Эти сведения возвращаются с помощью *rownum* и *nrows* параметров. Таким образом, если указан параметр INFO, *rownum* и *nrows* становятся выходными параметрами.|  
|0x200|PREV_NOADJUST|Используется как PREV. Но если вершина результирующего набора встретилась преждевременно, результаты могут отличаться.|  
|0x400|SKIP_UPDT_CNCY|Необходимо использовать с другой *fetchtype* значения, кроме INFO.|  
  
> [!NOTE]  
>  Поддержка значения 0x40 отсутствует.  
  
 Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
 *rownum*  
 Необязательный параметр, который используется для указания позиции строки для ABSOLUTE и INFO *fetchtype* значения с помощью только целочисленные значения для входных или выходных данных. *rownum* служит смещением строки для *fetchtype* битового значения RELATIVE. *rownum* игнорируется для всех остальных значений. Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
 *nrows*  
 Необязательный параметр, используемый для указания количества выбираемых строк. Если *nrows* не указан, значение по умолчанию — 20 строк. Чтобы установить позицию без возврата данных, укажите значение 0. Когда *nrows* применяется к *fetchtype* запрос INFO, он возвращает общее число строк в этом запросе.  
  
> [!NOTE]  
>  *nrows* пропускается обновление *fetchtype* битового значения.  
>   
>  Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 Если указано битовое значение INFO, то могут возвращаться значения, показанные в следующих таблицах.  
  
> [!NOTE]  
>  , перечислены ниже.   Если строки не возвращаются, то содержимое буфера остается прежним.  
  
|*\<rownum >*|Установить в|  
|------------------|------------|  
|Если не открыт|0|  
|Если позиционирован перед результирующим набором|0|  
|Если позиционирован после результирующего набора|-1|  
|Для курсоров KEYSET и STATIC|Абсолютный номер строки в текущей позиции результирующего набора|  
|Для курсоров DYNAMIC|1|  
|Для ABSOLUTE|-1 возвращает последнюю строку в наборе.<br /><br /> -2 возвращает вторую от конца строку в наборе и так далее.<br /><br /> Примечание. Если для выборки в этом случае запрашивается более одной строки, возвращаются две последние строки результирующего набора.|  
  
|*\<nrows >*|Установить в|  
|-----------------|------------|  
|Если не открыт|0|  
|Для курсоров KEYSET и STATIC|Обычно размер текущего набора ключей.<br /><br /> **-m** Если курсор находится в состоянии асинхронного создания со *m* строками, найденными до этой точки.|  
|Для курсоров DYNAMIC|-1|  
  
## <a name="remarks"></a>Примечания  
  
## <a name="cursor-parameter"></a>Параметр cursor  
 Перед началом операций выборки по умолчанию позиция курсора находится перед первой строкой результирующего набора.  
  
## <a name="fetchtype-parameter"></a>Параметр fetchtype  
 Кроме SKIP_UPD_CNCY *fetchtype* значения являются взаимоисключающими.  
  
 Если указано значение SKIP_UPDT_CNCY, то значения столбца отметки времени не записываются в таблицу набора ключей при выборке или обновлении строки. При обновлении строки набора ключей значения столбцов отметки времени остаются в качестве предыдущего значения. При выполнении вставки строки набора ключей значения для столбцов отметки времени не определены.  
  
 Для курсоров типа KEYSET это означает, что в таблице набора ключей имеются значения, установленные во время последней выполненной операции FETCH, если таковая была. В противном случае в ней имеются значения, установленные во время заполнения.  
  
 Для курсоров типа DYNAMIC это означает, что переход с обновлением даст такие же результаты, что и для KEYSET. Для любого другого типа выборки таблица набора ключей усекается. Это означает, что строки будут вставлены с неопределенными значениями отметки времени для одного или нескольких столбцов. Поэтому при запуске процедуры sp_cursorfetch для курсоров DYNAMIC избегайте использования SKIP_UPDT_CNCY для любой операции, отличной от REFRESH.  
  
 Если операция выборки закончилась ошибкой по причине того, что позиция курсора оказалась за границами результирующего набора, позиция курсора устанавливается сразу после последней строки. Если операция выборки закончилась ошибкой по причине того, что позиция курсора оказалась перед результирующим набором, то позиция курсора устанавливается сразу перед первой строкой.  
  
## <a name="rownum-parameter"></a>Параметр rownum  
 При использовании *rownum*, буфер заполняется, начиная с указанной строки.  
  
 *Fetchtype* значением ABSOLUTE относится к положение *rownum* во всем результирующем значение. Если задано значение ABSOLUTE, то отрицательное число указывает на то, что операция считала строки от конца результирующего набора.  
  
 *Fetchtype* значением RELATIVE определяет позицию *rownum* относительно позиции курсора в начале текущего буфера. Если задано значение RELATIVE, то отрицательное число указывает на то, что курсор перемещается назад от текущей позиции курсора.  
  
## <a name="nrows-parameter"></a>Параметр nrows  
 *Fetchtype* значение REFRESH или INFO этот параметр не учитывается.  
  
 При указании *fetchtype* значение FIRST, имеет *nrow* значение 0, то курсор располагается перед результирующим набором, у которого нет строк в буфере выборки.  
  
 При указании *fetchtype* значение LAST, имеющий *nrow* значение 0, то курсор будет помещен после результирующего набора, у которого нет строк в текущем буфере выборки.  
  
 Для *fetchtype* значения Далее, PREV, ABSOLUTE, RELATIVE и PREV_NOADJUST, *nrow* недопустимое значение 0.  
  
## <a name="rpc-considerations"></a>Замечания по RPC  
 Состояние возврата RPC указывает, является ли параметр размера набора ключей окончательным, то есть заполняется ли набор ключей или временная таблица асинхронно.  
  
 Для параметра состояния RPC устанавливается одно из значений, приведенных в следующей таблице.  
  
|Значение|Описание|  
|-----------|-----------------|  
|0|Процедура успешно выполнена.|  
|0x0001|Процедура завершилась ошибкой.|  
|0x0002|Выборка в отрицательном направлении привела к тому, что позиция курсора оказалась в начале результирующего набора, когда выборка логически должна быть перед результатами.|  
|0x10|Курсор FAST_FORWARD автоматически закрыт.|  
  
 Строки возвращаются в виде типичного результирующего набора: формат столбцов (0x2a), строк (0xd1), за которым следует число обработанных (0xfd). Токены метаданных отправляются в тот же формат, что указан для sp_cursoropen, то есть: 0x81, 0xa5 и 0xa4 для пользователей SQL Server 7.0 и т. д. Индикаторы состояния строк отправляются как скрытые столбцы, аналогично режиму BROWSE, в конце каждой строки с именем столбца rowstat и типом данных INT4. Столбец rowstat имеет одно из значений, приведенных в следующей таблице.  
  
|Значение|Описание|  
|-----------|-----------------|  
|0x0001|FETCH_SUCCEEDED|  
|0x0002|FETCH_MISSING|  
  
 Поскольку протокол TDS не предусматривает способа отправки завершающего столбца состояния без отправки предшествующих столбцов, в отсутствующих столбцах отправляются фиктивные данные (поля, допускающие значение NULL, заполняются этим значением, в поля фиксированной длины записывается 0, пробел или значение по умолчанию для этого столбца соответственно).  
  
 Счетчик строк DONE всегда будет содержать ноль. Сообщение DONE содержит реальное число строк результирующего набора, информационные сообщения или сообщения об ошибках могут появляться между любыми сообщениями TDS.  
  
 Чтобы в потоке TDS возвращались запрошенные метаданные о списке выбора курсора, установите входной флажок RPC RETURN_METADATA в значение 1.  
  
## <a name="examples"></a>Примеры  
  
### <a name="a-using-prev-to-change-a-cursor-position"></a>A. Использование PREV для изменения позиции курсора  
 Предположим, курсор h2 сформирует результирующий набор со следующим содержимым и текущей позицией следующим образом.  
  
```  
row 1 contents      
row 2 contents  
row 3 contents  
row 4 contents  <-- current position  
row 5 contents   
row 6 contents  
```  
  
 Затем процедура sp_cursorfetch PREV, у *nrows* значение 5, логически поместит курсор на две строки раньше первой строки результирующего набора. В таких случаях курсор настраивается так, чтобы начинаться у первой строки и возвращать запрошенное число строк. Часто это означает, что будут возвращены строки, которые были в буфере PRIOR.  
  
> [!NOTE]  
>  Это именно тот случай, когда параметр состояния RPC установлен в значение 2.  
  
### <a name="b-using-prevnoadjust-to-return-fewer-rows-than-prev"></a>Б. Использование PREV_NOADJUST для возврата меньшего числа строк, чем PREV  
 PREV_NOADJUST никогда не включает строки, находящиеся в позиции курсора или за ней в блоке строк, который он возвращает. В случаях, когда PREV возвращает строки после текущей позиции, PREV_NOADJUST Возвращает меньшее число строк, чем запрошено в *nrows*. Задана текущая позиция, в примере В более ранних версиях при использовании prev процедура sp_cursorfetch (h2, 4, 1, 5) выберет следующие строки:  
  
```  
row1 contents   
row2 contents  
row3 contents  
row4 contents  
row5 contents  
```  
  
 Тем не менее, если используется prev_noadjust, хранимая процедура sp_cursorfetch (h2, 512, 6, 5) выберет только следующие строки:  
  
```  
row1 contents   
row2 contents  
row3 contents   
```  
  
## <a name="see-also"></a>См. также  
 [sp_cursoropen &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-cursoropen-transact-sql.md)   
 [Системные хранимые процедуры (Transact-SQL)](../../relational-databases/system-stored-procedures/system-stored-procedures-transact-sql.md)  
  
  
