---
title: Полнотекстовый поиск в столбцах XML | Документация Майкрософт
ms.custom: ''
ms.date: 03/01/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- xml columns [full-text search]
- indexes [full-text search]
ms.assetid: 8096cfc6-1836-4ed5-a769-a5d63b137171
author: MightyPen
ms.author: genemi
ms.openlocfilehash: f101051d924c1fca0bfbcd131ea8544ea4781e12
ms.sourcegitcommit: 58158eda0aa0d7f87f9d958ae349a14c0ba8a209
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2020
ms.locfileid: "72909110"
---
# <a name="use-full-text-search-with-xml-columns"></a>Полнотекстовый поиск в XML-столбцах

[!INCLUDE[tsql-appliesto-ss2008-xxxx-xxxx-xxx-md](../../includes/tsql-appliesto-ss2008-xxxx-xxxx-xxx-md.md)]

  Для XML-столбцов можно создавать полнотекстовые индексы, индексирующие XML-значения, но игнорирующие XML-разметку. Теги элементов используются в качестве границ токенов. Индексируются следующие элементы:  
  
-   Содержимое XML-элементов.  
  
-   Только содержимое XML-атрибутов элемента на высшем уровне, за исключением случаев, когда эти значения являются числовыми.  
  
 Иногда можно совместно пользоваться полнотекстовым поиском и XML-индексом следующим образом.  
  
1.  Сначала отфильтруйте интересующие XML-значения, используя механизм полнотекстового поиска SQL.  
  
2.  Затем запросите XML-значения, которые используют XML-индекс, связанный с XML-столбцом.  

## <a name="example-combining-full-text-search-with-xml-querying"></a>Пример. Комбинирование полнотекстового поиска с XML-запросами  
 После создания полнотекстового индекса для XML-столбца следующий запрос проверяет, что название книги содержит слово «custom»:  
  
```sql
SELECT *   
FROM   T   
WHERE  CONTAINS(xCol,'custom')   
AND    xCol.exist('/book/title/text()[contains(.,"custom")]') =1  
```  
  
 В методе **contains()** полнотекстовый индекс используется для выделения всех XML-значений, содержащих слово "custom". Предложение **exist()** гарантирует, что это слово входит в название книги.  
  
 Инструкции полнотекстового поиска, в которых используются методы **contains()** и **contains()** языка XQuery, имеют различную семантику. Во втором случае выполняется сопоставление подстрок, а в первом — сопоставление токенов с применением лемматизации. Таким образом, если искать строку, содержащую в заголовке слово "run", в число найденных вариантов войдут "run", "runs" и "running", потому что они соответствуют требованиям как метода **contains()** механизма полнотекстового поиска, так и метода **contains()** языка XQuery. Однако условия нашего запроса не соответствуют слову customizable в заголовке, что вызывает сбой **contains()** , хотя условия метода **contains()** языка XQuery были бы удовлетворены. Как правило, чтобы провести истинное сопоставление подстрок, метод **contains()** механизма полнотекстового поиска использовать не следует.  
  
 Кроме того, при полнотекстовом поиске выполняется лемматизация, а метод **contains()** языка XQuery осуществляет буквальное сопоставление. Это различие поясняет следующий пример.  
  
## <a name="example-full-text-search-on-xml-values-using-stemming"></a>Пример. Полнотекстовый поиск XML-значений с использованием выделения корней  
 Проверку **contains()** языка XQuery, выполненную в предыдущем примере, обычно устранить нельзя. Рассмотрим следующий запрос:  
  
```sql
SELECT *   
FROM   T   
WHERE  CONTAINS(xCol,'run')   
```  
  
 Слово «run» в документе соответствует условию поиска, потому что при этом осуществляется лемматизация. Кроме того, при использовании XQuery не проверяется контекст поиска.  
  
 Если при помощи схем XML-данные распределены по реляционным столбцам, для которых выполнено полнотекстовое индексирование, при обработке запросов XPath, адресованных XML-представлению, полнотекстовый поиск в базовых таблицах не выполняется.  
  
## <a name="see-also"></a>См. также:  
 [XML-индексы (SQL Server)](../../relational-databases/xml/xml-indexes-sql-server.md)  
  
  
