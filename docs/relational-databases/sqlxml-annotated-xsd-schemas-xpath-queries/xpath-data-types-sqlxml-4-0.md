---
title: Типы данных XPath (S'LXML)
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: MightyPen
ms.author: genemi
ms.custom: seo-lt-2019
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 089b2b006d0159c63e480c8627762ac37dec98b8
ms.sourcegitcommit: a3f5c3742d85d21f6bde7c6ae133060dcf1ddd44
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "75247091"
---
# <a name="xpath-data-types-sqlxml-40"></a>Типы данных XPath (SQLXML 4.0)
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
  [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath и XML Schema (XSD) имеют очень разные типы данных. Например, в XPath отсутствуют целочисленные типы данных и тип данных для обозначения даты, а в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и XSD таких типов множество. Типы данных XSD определяют время с точностью до наносекунды, а [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] только до одной трехсотой доли секунды. Поэтому не всегда возможно сопоставить один тип другому. Для получения дополнительной [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] информации о картировании типов данных к типам данных XSD [&#41;&#40;](../../relational-databases/sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md)см.  
  
 XPath имеет три типа данных: **строка,** **номер,** и **boolean**. Тип данных **номера** всегда является двойной точечной плавающей точкой IEEE 754. Тип [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]данных **поплавка (53)** ближе всего к **номеру**XPath. Тем не менее, **поплавок (53)** не совсем IEEE 754. В частности, этот тип не содержит ни значения NaN (не число), ни значения бесконечности. Попытка конвертировать ненумерную строку в **число** и попытка разделить на ноль приводит к ошибке.  
  
## <a name="xpath-conversions"></a>Преобразования в XPath  
 При использовании запроса XPath, например, `OrderDetail[@UnitPrice > "10.0"]`, явные и неявные преобразования типов данных могут различными неочевидными способами изменить значение запроса. Поэтому важно знать, как реализована система типов данных в XPath. Спецификация языка XPath, XML Путь язык (XPath) версия 1.0 W3C Предлагаемая рекомендация 8 октября http://www.w3.org/TR/1999/PR-xpath-19991008.html1999 года, можно найти на веб-сайте W3C на .  
  
 Операторы XPath делятся на четыре категории:  
  
-   Логические операторы (и, или)  
  
-   Реляционные\<операторы \<(, >, й, >)  
  
-   Операторы равенства (=, !=)  
  
-   Арифметические операторы (+, -, *, div, mod)  
  
 Операторы разных категорий по-разному преобразуют операнды. При необходимости операторы XPath неявно преобразуют операнды. Арифметические операторы преобразуют свои оперы в **число**и приводят к значению числа. Boolean операторы конвертировать свои operands на **boolean**, и в результате Boolean значение. Результатом выполнения реляционных операторов и операторов равенства является логическое значение. Однако правила преобразования, которыми пользуются операторы, зависят от первоначальных типов операндов, как показано в таблице.  
  
|Операнд|Реляционный оператор|Оператор равенства|  
|-------------|-------------------------|-----------------------|  
|Оба операнда представляют собой наборы узлов.|ПРАВДА, если и только если есть узла в одном наборе и узла во втором наборе так, что сравнение их **значения строки** является правдой.|То же.|  
|Один из них узла набор, другой **строки**.|ПРАВДА, если и только если есть узла в узлах установить такие, что при преобразовании в **число**, сравнение его со **строкой** преобразуется в **число** является правдой.|ПРАВДА, если и только если есть узла в узлах установить такие, что при преобразовании в **строку**, сравнение его со **строкой** является правдой.|  
|Один из них узла набор, другой **номер**.|ПРАВДА, если и только если есть узла в узлах установить такие, что при преобразовании в **число**, сравнение его с **числом** является правдой.|То же.|  
|Один из них узла набор, другой **boolean**.|Правда, если и только если есть узла в узлах набор так, что при преобразовании в **boolean,** а затем **на номер**, сравнение его с **булеан** преобразуется в **число** является правдой.|ПРАВДА, если и только если есть узла в узлах набор таких, что при преобразовании в **boolean**, сравнение его с **boolean** является правдой.|  
|Ни один из них не представляет собой набор узлов.|Преобразуйте оба оперы в **число,** а затем сравните.|Преобразует оба операнда к одному типу, а затем сравнивает их. Преобразуйте в **boolean,** если либо **boolean**, **номер,** если либо **номер;** в противном случае, преобразовать в **строку**.|  
  
> [!NOTE]  
>  Поскольку реляционные операторы XPath всегда преобразуют свои операнды в **число,** сравнение **строк** невозможны. Для включения сравнения дат, S'L Server 2000 предлагает эту вариацию спецификации XPath: Когда реляционный оператор **string**сравнивает **строку** со **строкой,** узел-набор строки, или строка стоимостью узла набор строки ценой узла, **строка** сравнения (не **сравнение числа)** выполняется.  
  
## <a name="node-set-conversions"></a>Преобразования наборов узлов  
 Преобразования наборов узлов не всегда интуитивно понятны. Набор узлов преобразуется в **строку,** взяв значение строки только первого узла в наборе. Набор узлов преобразуется в **число,** преобразовывая его в **строку,** а затем преобразовывая **строку** в **число.** Узлы-набор преобразуется в **булеан** путем тестирования на его существование.  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не производит выборку по положению в наборах узлов — например, запрос XPath `Customer[3]` указывает на третьего заказчика; такой тип выборки по положению не поддерживается в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Таким образом, конверсии узла, настроенные на**number** **строку** или конструкторы, установленные в наборе, как описано в спецификации XPath, не реализуются. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует семантику «любой» там, где спецификация XPath использует семантику «первый». Например, на основе спецификации W3C XPath `Order[OrderDetail/@UnitPrice > 10.0]` запрос XPath выбирает эти заказы с первым **OrderDetail,** который имеет **UnitPrice** больше, чем 10.0. В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]этом запросе XPath выбирается эти заказы с любым **OrderDetail,** который имеет **UnitPrice** больше, чем 10.0.  
  
 Преобразование в **булеан** порождает тест на существование; Таким образом, запрос `Products[@Discontinued=true()]` XPath эквивалентен выражению S'L "Products.Discontinued не является недействительным", а не выражением S'L "Products.Discontinued - 1". Чтобы сделать запрос эквивалентным последнему выражению S'L, сначала преобразуйте набор узлов в**небуйный** тип, например **номер.** Например, `Products[number(@Discontinued) = true()]`.  
  
 Большинство операторов реализовано так, что они возвращают TRUE, если их результат равен TRUE хотя бы для одного (любого) узла набора, поэтому они возвращают FALSE, если набор узлов пуст. Таким образом, если набор узлов A пуст, оба оператора `A = B` и `A != B` вернут FALSE, а `not(A=B)` и `not(A!=B)` — TRUE.  
  
 Обычно атрибут или элемент, который отображает сяочку, существует, если значение этого столбца в базе данных не **является нулевым.** Элементы, сопоставляемые со строками, существуют, если есть хотя бы один из их дочерних элементов.  
  
> [!NOTE]  
>  Элементы, аннотированные **постоянными,** всегда существуют. Следовательно, предикаты XPath не могут быть использованы на **постоянных** элементах.  
  
 Когда набор узлов преобразуется в **строку** или **номер,** его тип XDR (если таковой имеется) проверяется в аннотированной схеме, и этот тип используется для определения требуемого преобразования.  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a>Сопоставление типов данных XDR типам данных XPath  
 Тип узла данных XPath получен из типа данных XDR в схеме, как показано в следующей таблице (узла **EmployeeID** используется для иллюстративной цели).  
  
|Тип данных XDR|Эквивалентный<br /><br /> тип данных XPath|Использованное преобразование SQL Server|  
|-------------------|------------------------------------|--------------------------------|  
|Nonebin.base64bin.hex|Недоступно|NoneEmployeeID|  
|Логическое|Логическое|CONVERT(bit, EmployeeID)|  
|number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8|number|CONVERT(float(53), EmployeeID)|  
|id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid|строка|CONVERT(nvarchar(4000), EmployeeID, 126)|  
|fixed14.4|н/д (в XPath нет типа данных, эквивалентного типу fixed14.4 XDR)|CONVERT(money, EmployeeID)|  
|Дата|строка|LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)|  
|time<br /><br /> time.tz|строка|SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)|  
  
 Конверсии даты и времени предназначены для работы независимо [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]от того, хранится ли значение в базе данных с использованием типа данных **о дате** или **строки.** Обратите внимание, что тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **о дате** не использует **часовой пояс** и имеет меньшую точность, чем тип данных **времени** XML. Чтобы включить тип данных **часового пояса** или [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] дополнительную точность, храните данные в использовании типа **строки.**  
  
 При преобразовании узла из типа данных XDR в тип данных XPath иногда требуются дополнительные преобразования (из одного типа XPath в другой тип XPath). В качестве примера рассмотрим следующий запрос XPath:  
  
```  
(@m + 3) = 4  
```  
  
 Если @m тип данных **с фиксированным 14.4** XDR, то преобразование из типа данных XDR в тип данных XPath осуществляется с использованием:  
  
```  
CONVERT(money, m)  
```  
  
 В этом преобразовании `m` узла преобразуется из **фиксированной14.4 в** **деньги.** Однако для прибавления 3 требуется дополнительное преобразование:  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 Выражение XPath вычисляется следующим образом:  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 Как показано в следующей таблице, это то же самое преобразование, которое применялось для других выражений XPath (например, литералов или составных выражений).  
  
||||||  
|-|-|-|-|-|  
||Х неизвестен|X - это **строка**|X - это **число**|X является **булеан**|  
|string(X)|CONVERT (nvarchar(4000), X, 126)|-|CONVERT (nvarchar(4000), X, 126)|CASE WHEN X THEN N'true' ELSE N'false' END|  
|number(X)|CONVERT (float(53), X)|CONVERT (float(53), X)|-|CASE WHEN X THEN 1 ELSE 0 END|  
|boolean(X)|-|LEN (X) > 0|X != 0|-|  
  
## <a name="examples"></a>Примеры  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a>A. Преобразование типа данных в запросе XPath  
 В следующем запросе XPath, указанном в отношении аннотированной схемы XSD, запрос выбирает все узлы **сотрудника** со значением атрибута **EmployeeID** E-1, где "E-" является приставкой, указанной с помощью аннотации: **sql:id-префикс.**  
  
 `Employee[@EmployeeID="E-1"]`  
  
 Предикат в запросе эквивалентен следующему выражению SQL:  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 Поскольку **EmployeeID** является одним из значений **id** **(idref,** **idrefs,** **nmtoken,** **nmtokens**и так далее) значений типа данных в схеме XSD, **EmployeeID** преобразуется в тип данных **строки** XPath с использованием правил преобразования, описанных ранее.  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 К строке добавляется префикс «E-», а результат затем сравнивается с `N'E-1'`.  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a>Б. Несколько преобразований типов данных в запросе XPath  
 Рассмотрим этот запрос XPath, указанный в аннотированной схеме XSD:`OrderDetail[@UnitPrice * @OrderQty > 98]`  
  
 Этот запрос XPath возвращает все элементы ** \<OrderDetail**>`@UnitPrice * @OrderQty > 98`удовлетворяющие предикату. Если **UnitPrice** аннотирован фиксированным типом **данных14.4** в аннотированной схеме, этот предикат эквивалентен выражению S'L:  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 В ходе преобразований значений в запросе XPath сначала тип данных XDR преобразуется в тип данных XPath. Поскольку тип данных Данных **XSD UnitPrice** **фиксируется14.4**, как описано в предыдущей таблице, это первое преобразование, которое используется:  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 Поскольку операторы арифметики преобразуют свои оперы в тип данных **xPath,** применяется второе преобразование (от одного типа данных XPath к другому типу данных XPath), в котором значение преобразуется в **плавающий (53)** **(плавающий (53)** близко к типу данных **номера** XPath):  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 Если предположить, что атрибут **Заказа** не имеет типа данных XSD, **то заказ** преобразуется в тип данных **числа** XPath в одном конверсии:  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 Аналогичным образом значение 98 преобразуется в тип данных **XPath:**  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  Если используемый в схеме тип данных XSD несовместим с базовым типом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в базе данных или нужное преобразование типа данных XPath невозможно выполнить, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может вернуть ошибку. Например, если атрибут **EmployeeID** аннотирован аннотацией **id-префикса,** `Employee[@EmployeeID=1]` XPath генерирует ошибку, потому что **EmployeeID** имеет аннотацию **id-префикса** и не может быть преобразован в **число.**  
  
  
