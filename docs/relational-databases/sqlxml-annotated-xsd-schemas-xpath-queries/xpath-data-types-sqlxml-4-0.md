---
title: Типы данных XPath (SQLXML 4.0) | Документация Майкрософт
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: MightyPen
ms.author: genemi
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 0c5cb588e96bcabad464339b7227ada3aef86221
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62678065"
---
# <a name="xpath-data-types-sqlxml-40"></a>Типы данных XPath (SQLXML 4.0)
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
  Набор типов данных в [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath и XML Schema (XSD) сильно отличается. Например, в XPath отсутствуют целочисленные типы данных и тип данных для обозначения даты, а в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и XSD таких типов множество. Типы данных XSD определяют время с точностью до наносекунды, а [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] только до одной трехсотой доли секунды. Поэтому не всегда возможно сопоставить один тип другому. Дополнительные сведения о сопоставлении [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] типы данных с типами данных XSD, см. в разделе [приведение типов данных и заметка SQL: DataType &#40;SQLXML 4.0&#41;](../../relational-databases/sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).  
  
 В XPath есть три типа данных: **строка**, **номер**, и **логическое**. **Номер** IEEE 754 двойной точности с плавающей запятой всегда имеет тип данных. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **Float(53)** тип данных лучше всего соответствует XPath **номер**. Тем не менее **float(53)** отлично от IEEE 754. В частности, этот тип не содержит ни значения NaN (не число), ни значения бесконечности. Попытка преобразовать нечисловую строку в **номер** и попытка деления на ноль приводит к ошибке.  
  
## <a name="xpath-conversions"></a>Преобразования в XPath  
 При использовании запроса XPath, например, `OrderDetail[@UnitPrice > "10.0"]`, явные и неявные преобразования типов данных могут различными неочевидными способами изменить значение запроса. Поэтому важно знать, как реализована система типов данных в XPath. Спецификация языка XPath, язык XML Path (XPath) версии 1.0 консорциума W3C Proposed Recommendation 8 октября 1999 года, можно найти на веб-сайте W3C по http://www.w3.org/TR/1999/PR-xpath-19991008.html.  
  
 Операторы XPath делятся на четыре категории:  
  
-   Логические операторы (и, или)  
  
-   Реляционные операторы (\<, >, \<=, > =)  
  
-   Операторы равенства (=, !=)  
  
-   Арифметические операторы (+, -, *, div, mod)  
  
 Операторы разных категорий по-разному преобразуют операнды. При необходимости операторы XPath неявно преобразуют операнды. Арифметические операторы преобразуют операнды к **номер**и результатом является число. Логические операторы преобразуют операнды к **логическое**и результатом является логическое значение. Результатом выполнения реляционных операторов и операторов равенства является логическое значение. Однако правила преобразования, которыми пользуются операторы, зависят от первоначальных типов операндов, как показано в таблице.  
  
|Операнд|Реляционный оператор|Оператор равенства|  
|-------------|-------------------------|-----------------------|  
|Оба операнда представляют собой наборы узлов.|Значение TRUE, только в том случае, если есть узел в одном наборе, и набор узлов во втором, например, сравнение их **строка** значений имеет значение TRUE.|То же.|  
|Одним является набор узлов, другой **строка**.|Значение TRUE, только в том случае, если в наборе узлов есть узел таким образом, при преобразовании **номер**, сравнении с **строка** преобразуется **номер** имеет значение TRUE.|Значение TRUE, только в том случае, если в наборе узлов есть узел таким образом, что при преобразовании **строка**, сравнении с **строка** имеет значение TRUE.|  
|Одним является набор узлов, другой **номер**.|Значение TRUE, только в том случае, если в наборе узлов есть узел таким образом, что при преобразовании **номер**, сравнении с **номер** имеет значение TRUE.|То же.|  
|Одним является набор узлов, другой **логическое**.|Значение TRUE, только в том случае, если в наборе узлов есть узел таким образом, что при преобразовании **логическое** и затем **номер**, сравнении с **логическое** преобразуется **номер** имеет значение TRUE.|Значение TRUE, только в том случае, если в наборе узлов есть узел таким образом, что при преобразовании **логическое**, сравнении с **логическое** имеет значение TRUE.|  
|Ни один из них не представляет собой набор узлов.|Преобразует оба операнда для **номер** , а затем сравнить.|Преобразует оба операнда к одному типу, а затем сравнивает их. Преобразовать в **логическое** при выполнении любого **логическое**, **номер** при выполнении любого **номер**; в противном случае преобразование в **строка**.|  
  
> [!NOTE]  
>  Поскольку реляционные операторы XPath всегда преобразуют операнды к **номер**, **строка** сравнения невозможны. Чтобы включить Сравнение дат, SQL Server 2000 предлагает следующее изменение спецификации XPath: Когда Реляционный оператор сравнивает **строка** для **строка**, node-set **строка**, или строковое значение набор узлов строковыми значениями — набор узлов,  **Строка** сравнения (не **номер** сравнения) выполняется.  
  
## <a name="node-set-conversions"></a>Преобразования наборов узлов  
 Преобразования наборов узлов не всегда интуитивно понятны. Набор узлов преобразуется в **строка** , используя строковое значение только первого узла в наборе. Набор узлов преобразуется в **номер** путем преобразования его в **строка**и его преобразование в **строка** для **номер**. Набор узлов преобразуется в **логическое** путем проверки ее наличие.  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не производит выборку по положению в наборах узлов — например, запрос XPath `Customer[3]` указывает на третьего заказчика; такой тип выборки по положению не поддерживается в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Таким образом, узел-задайте-к-**строка** или узел-задайте-для-**номер** преобразования, как описано в спецификации XPath не реализованы. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует семантику «любой» там, где спецификация XPath использует семантику «первый». Например, основанный на спецификации XPath консорциума W3C, запрос XPath `Order[OrderDetail/@UnitPrice > 10.0]` выберет заказы с первым **OrderDetail** с **UnitPrice** превышающая 10.0. В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], этот запрос XPath выберет заказы с любым **OrderDetail** с **UnitPrice** превышающая 10.0.  
  
 Преобразование в **логическое** существование теста; таким образом, запрос XPath `Products[@Discontinued=true()]` эквивалентен выражению SQL «Products.Discontinued is not null», не выражению SQL «Products.Discontinued = 1". Чтобы запрос был эквивалентен второе выражение SQL, сначала преобразовать набор узлов, отличному от**логическое** тип, например **номер**. Например, `Products[number(@Discontinued) = true()]`.  
  
 Большинство операторов реализовано так, что они возвращают TRUE, если их результат равен TRUE хотя бы для одного (любого) узла набора, поэтому они возвращают FALSE, если набор узлов пуст. Таким образом, если набор узлов A пуст, оба оператора `A = B` и `A != B` вернут FALSE, а `not(A=B)` и `not(A!=B)` — TRUE.  
  
 Как правило, атрибут или элемент, который сопоставляется со столбцом существует, если значение этого столбца в базе данных не **null**. Элементы, сопоставляемые со строками, существуют, если есть хотя бы один из их дочерних элементов.  
  
> [!NOTE]  
>  Элементы с аннотацией **является константа** всегда существует. Следовательно, предикаты XPath нельзя применять к **является константа** элементов.  
  
 Если набор узлов преобразуется в **строка** или **номер**, его тип XDR (если таковые имеются) проверяется в схеме с заметками, и этот тип используется для определения преобразования, которое является обязательным.  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a>Сопоставление типов данных XDR типам данных XPath  
 Тип данных XPath узла является производным от типа данных XDR в схему, как показано в следующей таблице (узел **EmployeeID** иллюстративных целях).  
  
|Тип данных XDR|Эквивалентный<br /><br /> тип данных XPath|Использованное преобразование SQL Server|  
|-------------------|------------------------------------|--------------------------------|  
|Nonebin.base64bin.hex|Н/Д|NoneEmployeeID|  
|boolean|boolean|CONVERT(bit, EmployeeID)|  
|number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8|number|CONVERT(float(53), EmployeeID)|  
|id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid|строка|CONVERT(nvarchar(4000), EmployeeID, 126)|  
|fixed14.4|н/д (в XPath нет типа данных, эквивалентного типу fixed14.4 XDR)|CONVERT(money, EmployeeID)|  
|date|строка|LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)|  
|time<br /><br /> time.tz|строка|SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)|  
  
 Преобразования даты и времени, предназначены для работы ли значение хранится в базе данных с помощью [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **datetime** тип данных или **строка**. Обратите внимание, что [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **datetime** тип данных не использует **часовой пояс** и имеет меньшую точность, чем XML **время** тип данных. Для включения **часовой пояс** тип данных или более высокую точность, хранить данные в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с помощью **строка** типа.  
  
 При преобразовании узла из типа данных XDR в тип данных XPath иногда требуются дополнительные преобразования (из одного типа XPath в другой тип XPath). В качестве примера рассмотрим следующий запрос XPath:  
  
```  
(@m + 3) = 4  
```  
  
 Если @m имеет **fixed14.4** тип данных XDR, преобразование из типа данных XDR в тип данных выполняется с помощью XPath:  
  
```  
CONVERT(money, m)  
```  
  
 В данном узле `m` преобразуется из **fixed14.4** для **деньги**. Однако для прибавления 3 требуется дополнительное преобразование:  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 Выражение XPath вычисляется следующим образом:  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 Как показано в следующей таблице, это то же самое преобразование, которое применялось для других выражений XPath (например, литералов или составных выражений).  
  
||||||  
|-|-|-|-|-|  
||Х неизвестен|X — **строка**|X — **номер**|X — **логическое**|  
|string(X)|CONVERT (nvarchar(4000), X, 126)|-|CONVERT (nvarchar(4000), X, 126)|CASE WHEN X THEN N'true' ELSE N'false' END|  
|number(X)|CONVERT (float(53), X)|CONVERT (float(53), X)|-|CASE WHEN X THEN 1 ELSE 0 END|  
|boolean(X)|-|LEN(X) &GT; 0|X != 0|-|  
  
## <a name="examples"></a>Примеры  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a>A. Преобразование типа данных в запросе XPath  
 В следующем запросе XPath к аннотированной схеме XSD запрос выбирает все **сотрудника** узлов с **EmployeeID** значение E-1, где «E-» — префикс, указанный с помощью атрибута **SQL: ID-префикс** заметки.  
  
 `Employee[@EmployeeID="E-1"]`  
  
 Предикат в запросе эквивалентен следующему выражению SQL:  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 Так как **EmployeeID** является одним из **идентификатор** (**idref**, **idrefs**, **nmtoken**,  **NMTOKENS**, и т. д) тип данных значения в схеме XSD, **EmployeeID** преобразуется в **строка** тип данных XPath с помощью описанных ранее правил преобразования.  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 К строке добавляется префикс «E-», а результат затем сравнивается с `N'E-1'`.  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a>Б. Несколько преобразований типов данных в запросе XPath  
 Рассмотрим следующий запрос XPath к аннотированной схеме XSD. `OrderDetail[@UnitPrice * @OrderQty > 98]`  
  
 Этот запрос XPath возвращает все  **\<OrderDetail >** элементы, удовлетворяющие предикату `@UnitPrice * @OrderQty > 98`. Если **UnitPrice** помечается **fixed14.4** типа данных в схеме с заметками, этот предикат эквивалентен выражению SQL:  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 В ходе преобразований значений в запросе XPath сначала тип данных XDR преобразуется в тип данных XPath. Так как тип данных XSD **UnitPrice** — **fixed14.4**, как описано в предыдущей таблице, это первого преобразования, который используется:  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 Поскольку арифметические операторы преобразуют операнды к **номер** тип данных XPath, второе преобразование (из одного типа данных XPath в другой тип данных XPath) применяется в котором значение преобразуется в **float(53)**  (**float(53)** близок к XPath **номер** тип данных):  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 При условии, что **OrderQty** атрибут имеет тип данных XSD не **OrderQty** преобразуется в **номер** тип данных XPath за один:  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 Аналогичным образом значение 98 преобразуется **номер** тип данных XPath:  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  Если используемый в схеме тип данных XSD несовместим с базовым типом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в базе данных или нужное преобразование типа данных XPath невозможно выполнить, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может вернуть ошибку. Например если **EmployeeID** помечается атрибутом **префикс идентификатора** заметки, XPath `Employee[@EmployeeID=1]` вызовет ошибку, поскольку **EmployeeID** имеет **префикс идентификатора** заметки и не может быть преобразован **номер**.  
  
  
