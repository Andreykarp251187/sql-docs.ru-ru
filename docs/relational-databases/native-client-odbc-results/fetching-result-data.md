---
title: Получение данных о результатах (ru) Документы Майкрософт
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: markingmyname
ms.author: maghan
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: e1d9fdfcd7bcc4f86afacc75dff5b40b77bb7b2a
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81304622"
---
# <a name="fetching-result-data"></a>Выборка итоговых данных
[!INCLUDE[appliesto-ss-asdb-asdw-pdw-md](../../includes/appliesto-ss-asdb-asdw-pdw-md.md)]

  Приложение ODBC имеет три параметра для выборки данных результата.  
  
 Первый вариант основан на [S'LBindCol](../../relational-databases/native-client-odbc-api/sqlbindcol.md). Прежде чем получить набор результатов, приложение использует **S'LBindCol,** чтобы связать каждый столбец в наборе результатов к переменной программы. После того, как столбцы были связаны, драйвер передает данные текущей строки в переменные, связанные с столбиками набора результатов каждый раз, когда приложение вызывает **S'LFetch** или [S'LFetchScroll.](../../relational-databases/native-client-odbc-api/sqlfetchscroll.md) Если столбец результирующего набора и программная переменная имеют разные типы данных, драйвер выполняет преобразования данных. Если приложение SQL_ATTR_ROW_ARRAY_SIZE установлено больше 1, оно может связать столбцы результатов с массивами переменных, которые будут заполнены на каждом вызове в **S'LFetchScroll.**  
  
 Второй вариант основан на [S'LGetData](../../relational-databases/native-client-odbc-api/sqlgetdata.md). Приложение не использует **S'LBindCol** для привязки столбцов набора результатов к программным переменным. После каждого звонка в **S'LFetch**приложение вызывает **S'LGetData** один раз для каждого столбца в наборе результатов. **SLGetData** инструктирует водителя передавать данные из определенного столбца набора результатов в конкретную переменную программы и определяет типы данных столбца и переменной. Это позволяет драйверу преобразовать данные, если столбец результата и программная переменная имеют разные типы данных. **Текст,** **ntext**и столбцы **изображений,** как правило, слишком велики, чтобы вписаться в переменную программы, но все еще могут быть извлечены с помощью **S'LGetData.** Если **текст,** **ntext**или данные **изображения** в образе столбца больше, чем переменная программы, **S'LGetData** возвращает сяритоге SQL_SUCCESS_WITH_INFO и S'LSTATE 01004 (данные строки, право усечено). Последовательные вызовы на **S'LGetData** возвращают последовательные фрагменты **текстовых** или **изображений.** По окончании данных, SQL_SUCCESS возвращается **s'LGetData.** Если SQL_ATTR_ROW_ARRAY_SIZE больше 1, то каждая выборка возвращает набор строк. Перед использованием **S'LGetData**необходимо сначала использовать **S'LSetPos,** чтобы указать определенную строку в строке в качестве текущей строки.  
  
 Третий вариант заключается в использовании сочетания **S'LBindCol** и **S'LGetData**. Приложение может, например, связать первые десять столбцов набора результатов, а затем, по каждому извлечению, вызвать **S'LGetData** три раза, чтобы получить данные из трех несвязанных столбцов. Это обычно используется, когда набор результатов содержит один или несколько столбцов **текста** или **изображений.**  
  
 В зависимости от параметров курсора, установленных для набора результатов, приложение может также использовать параметры прокрутки **S'LFetchScroll** для прокрутки набора результатов.  
  
 Чрезмерное использование **S'LBindCol** для привязки столбца набора результатов к переменной программы обходится дорого, поскольку **s'LBindCol** заставляет драйвер ODBC выделять память. При привязывании столбца результата к переменной эта привязка остается в силе до тех пор, пока вы не позвоните в [S'LFreeHandle,](../../relational-databases/native-client-odbc-api/sqlfreehandle.md) чтобы освободить ручку оператора или позвоните в [S'LFreeStmt](../../relational-databases/native-client-odbc-api/sqlfreestmt.md) с *fOption,* установленным для SQL_UNBIND. По завершении инструкции привязки автоматически не снимаются.  
  
 Эта логика позволяет эффективно выполнять инструкцию SELECT несколько раз с различными параметрами. Поскольку набор результатов сохраняет ту же структуру, можно связать набор результатов один раз, обработать все операторы SELECT, а затем вызвать **S'LFreeStmt** с *fOption,* установленным для SQL_UNBIND после последнего выполнения. Вы не должны вызывать **S'LBindCol,** чтобы связать столбцы в наборе результатов без предварительного вызова **S'LFreeStmt** с *fOption* набор, чтобы SQL_UNBIND, чтобы освободить любые предыдущие привязки.  
  
 При **использовании s'LBindCol,** вы можете сделать строку-мудрый или столбец-мудрый связывания. Привязка параметров на уровне строк быстрее, чем привязка на уровне столбцов.  
  
 Вы можете использовать **s'LGetData** для получения данных на основе столбца за столбцом вместо связывания столбцов, установленных результатами, с помощью **S'LBindCol.** Если набор результатов содержит всего несколько строк, то использование **S'LGetData** вместо **S'LBindCol** происходит быстрее; в противном случае, **S'LBindCol** дает наилучшую производительность. Если вы не всегда размещаете данные в одном и том же наборе переменных, следует использовать **S'LGetData** вместо постоянного пересвязывания. Вы можете использовать **s'LGetData** только на столбцах, которые находятся в списке выбора, после того, как все столбцы связаны с **S'LBindCol.** Столбец также должен отображаться после любых столбцов, на которых вы уже использовали **S'LGetData.**  
  
 Функции ODBC, которые касаются перемещения данных в или из программных переменных, таких как **S'LGetData,** **S'LBindCol**, и [S'LBindParameter](../../relational-databases/native-client-odbc-api/sqlbindparameter.md), поддерживают неявное преобразование типа данных. Например, если приложение привязывает целочисленный столбец к строковой программной переменной, драйвер автоматически преобразует данные из целочисленного в символьный тип перед тем, как поместить их в программную переменную.  
  
 Количество преобразований данных в приложениях должно быть минимальным. Если преобразование данных не требуется для вычислений, производимых приложением, приложения привяжут столбцы и параметры к программным переменным того же типа данных. Однако, если данные должны быть преобразованы из одного типа в другой, более эффективным будет преобразовать данные с помощью драйвера, чем делать это в приложении. Драйвер для собственного клиента ODBC [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обычно только передает данные непосредственно из сетевых буферов в переменные приложения. Обращение к драйверу для добавления преобразования данных приведет к буферизации данных драйвером и использованию времени ЦП для преобразования данных.  
  
 Переменные программы должны быть достаточно большими, чтобы удерживать данные, передаваемые из столбца, за исключением **текстовых,** **ntext**и данных **изображений.** Если приложение пытается получить результирующий набор данных и сохранить его в переменной недостаточного размера, драйвер сформирует предупреждение. Это заставит драйвер выделить память для сообщения, а драйвер и приложение будут вынуждены тратить время ЦП на обработку сообщения и ошибок. Приложение должно либо выделить достаточно большую переменную для сохранения полученных данных, либо использовать функцию SUBSTRING в списке выбора для уменьшения размера столбца в результирующем наборе.  
  
 Следует соблюдать осторожность при использовании SQL_C_DEFAULT для указания типа переменной C. SQL_C_DEFAULT указывает, что тип переменной C соответствует типу данных SQL столбца или параметра. Если SQL_C_DEFAULT указан для **ntext,** **nchar**или **nvarchar** column, данные Unicode возвращаются в приложение. Это может привести к возникновению различных проблем, если приложение не было настроено для обработки данных в Юникоде. Те же типы проблем могут возникать с типом **данных uniqueidentifier** (SQL_GUID).  
  
 **текст,** **ntext,** и данные **изображения,** как правило, слишком велики, чтобы вписаться в одну переменную программы, и, как правило, обрабатываются с **помощью S'LGetData** вместо **S'LBindCol**. При использовании курсоров [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] серверов драйвер Native Client ODBC оптимизирован, чтобы не передавать данные для несвязанного **текста,** **ntext**или столбцов **изображений** во время извлечения строки. **Текст,** **ntext**или данные **изображения** фактически не извлекаются с сервера до тех пор, пока приложение не выдаст для столбца **s'LGetData.**  
  
 Эта оптимизация может быть применена к приложениям, так что нет **текста,** **ntext**, или данные **изображения** отображается в то время как пользователь прокрутки вверх и вниз курсора. После того, как пользователь выберет строку, приложение может вызвать **S'LGetData** для получения **текста,** **ntext**или данных **изображений.** Это экономит передачу **текста,** **ntext**или данных **изображений** для любого из строк, которые пользователь не выбирает и может сохранить передачу очень больших объемов данных.  
  
## <a name="see-also"></a>См. также:  
 [Результаты обработки &#40;ODBC&#41;](../../relational-databases/native-client-odbc-results/processing-results-odbc.md)  
  
  
