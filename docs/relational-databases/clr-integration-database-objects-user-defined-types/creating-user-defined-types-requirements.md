---
title: Пользовательские требования к типам | Документация Майкрософт
ms.custom: ''
ms.date: 03/16/2017
ms.prod: sql
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- UDTs [CLR integration], requirements
- serialization
- Native serialization format [CLR integration]
- attributes [CLR integration]
- XML serialization [CLR integration]
- user-defined types [CLR integration], requirements
- user-defined serialization [CLR integration]
- user-defined types [CLR integration], Native serialization
- UDTs [CLR integration], Native serialization
ms.assetid: bedc3372-50eb-40f2-bcf2-d6db6a63b7e6
author: rothja
ms.author: jroth
ms.openlocfilehash: 7fc3da1474546f0719af20c52f44248baa8ce5da
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68028258"
---
# <a name="creating-user-defined-types---requirements"></a>Создание определяемых пользователем типов — требования
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]
  Необходимо принять ряд важных технических вопросов при создании определяемого пользователем типа (UDT), должны быть установлены в [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В большинстве случаев рекомендуется создавать определяемый пользователем тип как структуру, хотя можно создавать его и в виде класса. Чтобы определяемый пользователем тип можно было зарегистрировать в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно соответствовать спецификациям на создание определяемого пользователем типа.  
  
## <a name="requirements-for-implementing-udts"></a>Требования к реализации определяемого пользователем типа  
 Чтобы определяемый пользователем тип работал в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно удовлетворять следующим условиям.  
  
 Необходимо указать определяемый пользователем тип **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute**. Использование **System.SerializableAttribute** необязательно, но рекомендуется.  
  
-   Определяемый пользователем тип должен реализовывать **System.Data.SqlTypes.INullable** интерфейс в классе или структуре по созданию общедоступного **статический** (**Shared** в [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic) **Null** метод. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию может работать со значениями NULL. Это необходимо, чтобы программный код, принадлежащий определяемому пользователем типу, умел распознавать значения NULL.  
  
-   Определяемый пользователем тип должен содержать общедоступный **статический** (или **Shared**) **проанализировать** метод, который поддерживает анализ из "и" общий **ToString** метод преобразование в строковое представление объекта.  
  
-   Необходимо реализовать определяемый пользователем тип в формате определяемая пользователем сериализация **System.Data.IBinarySerialize** интерфейс и предоставляют **чтения** и **записи** метод.  
  
-   Определяемый пользователем тип должен реализовывать **System.Xml.Serialization.IXmlSerializable**, или все открытые поля и свойства должны иметь типы XML-сериализуемы или содержать **XmlIgnore** атрибут переопределить стандартную сериализацию является обязательным.  
  
-   У объекта определяемого пользователем типа может быть только одна сериализация. Если программы сериализации или десериализации обнаружат несколько различных представлений конкретного объекта, проверка закончится ошибкой.  
  
-   **SqlUserDefinedTypeAttribute.IsByteOrdered** должно быть **true** для сравнения данных в байтовом формате. Если интерфейс IComparable не реализован и **SqlUserDefinedTypeAttribute.IsByteOrdered** — **false**, сравнение по порядку байтов завершится ошибкой.  
  
-   Определяемый пользователем тип, заданный в виде класса, должен иметь общедоступный конструктор без аргументов. Дополнительно можно создать перегруженные конструкторы класса.  
  
-   Определяемый пользователем тип должен предоставлять доступ к элементам данных как к общедоступным полям или процедурам свойств.  
  
-   Общедоступные имена не может быть длиннее 128 символов и должно соответствовать [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] правила именования для идентификаторов, как определено в [идентификаторы баз данных](../../relational-databases/databases/database-identifiers.md).  
  
-   **sql_variant** столбцы не могут содержать экземпляры определяемого пользователем типа.  
  
-   Унаследованные элементы недоступны из [!INCLUDE[tsql](../../includes/tsql-md.md)], потому что система типов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ничего не знает об иерархии наследования среди определяемых пользователем типов. Однако можно использовать наследование при определении структуры классов и можно вызывать такие методы в реализации этих типов с помощью управляемого кода.  
  
-   Элементы структуры или класса нельзя перегружать, кроме конструктора класса. Если создан перегруженный метод, при регистрации сборки или создании типа в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ошибка не возникает. Определение наличия перегруженного метода происходит во время выполнения, а не при создании типа. Класс может иметь перегруженные методы при условии, что они не вызываются. При вызове перегруженного метода возникает ошибка.  
  
-   Любой **статический** (или **Shared**) члены должны быть объявлены константами или только для чтения. Элементы, объявленные как статические, нельзя изменять.  
  
-   Если **SqlUserDefinedTypeAttribute.MaxByteSize** установлено в значение -1, сериализованного определяемого пользователем ТИПА может быть задано как максимальный размер большого объекта (LOB) (в настоящее время 2 ГБ). Размер определяемого пользователем типа не может превышать значение, указанное в **MaxByteSized** поля.  
  
> [!NOTE]  
>  Несмотря на то, что он не используется сервером для операций сравнения, при необходимости можно реализовать **System.IComparable** интерфейс, который предоставляет единственный метод, **CompareTo**. Он используется на клиенте в ситуациях, когда нужно провести точное сравнение или сортировку значений определяемого пользователем типа.  
  
## <a name="native-serialization"></a>Собственная сериализация  
 Выбор атрибутов сериализации при создании определяемого пользователем типа зависит от его типа. **Собственного** формат сериализации использует очень простую структуру, которая позволяет [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для хранения на диске в эффективном собственном формате определяемого пользователем типа. **Собственного** формат рекомендуется в том случае, если определяемый пользователем тип проста и содержит только поля следующих типов:  
  
 **bool**, **байтов**, **sbyte**, **короткие**, **ushort**, **int**,  **целое число без знака**, **long**, **ulong**, **float**, **двойные**, **SqlByte**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **SqlSingle**,  **SqlDouble**, **SqlMoney**, **SqlBoolean**  
  
 Типы значений, которые состоят из полей из перечисленных выше типов являются хорошими кандидатами для **собственного** форматирования, такие как **структуры** в Visual C# (или **структуры** как они называются в Visual Basic). Например, определяемого пользователем ТИПА указано с **собственного** формат сериализации может содержать поля другой определяемый пользователем тип, который также был указан с **собственного** формат. Если определение определяемого пользователем ТИПА является более сложной и содержит типы данных не в списке выше, необходимо указать **UserDefined** формата сериализации.  
  
 **Собственного** формат имеет следующие требования:  
  
-   Не должно быть задано значение для **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize**.  
  
-   Все поля должны быть сериализуемыми.  
  
-   **System.Runtime.InteropServices.StructLayoutAttribute** должен быть указан как **StructLayout.LayoutKindSequential** Если определяемый пользователем тип определен в классе, а не в структуре. Этот атрибут управляет физической компоновкой полей данных. Он заставляет члены структуры располагаться в памяти в том порядке, в каком они описаны. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует этот атрибут для задания порядка полей в определяемых пользователем типах с несколькими значениями.  
  
 Примером определяемого пользователем ТИПА, определенных с помощью **собственного** сериализации, см. в разделе определяемого пользователем ТИПА Point в [программирование определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
## <a name="userdefined-serialization"></a>Сериализация, заданная пользователем  
 **UserDefined** Настройка формата **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** атрибут предоставляет разработчику полный доступ к двоичным форматам. При указании **формат** свойство как атрибут **UserDefined**, необходимо выполнить следующие действия в коде:  
  
-   Укажите необязательное **IsByteOrdered** свойству атрибута. Значение по умолчанию — **false**.  
  
-   Укажите **MaxByteSize** свойство **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute**.  
  
-   Напишите код для реализации **чтения** и **записи** методов для определяемого пользователем ТИПА путем реализации **System.Data.Sql.IBinarySerialize** интерфейс.  
  
 Примером определяемого пользователем ТИПА, определенных с помощью **UserDefined** сериализации, см. в разделе Currency в [программирование определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
> [!NOTE]  
>  Чтобы поля определяемого пользователем типа можно было использовать в индексе, они должны иметь собственную сериализацию или быть сохраняемыми.  
  
## <a name="serialization-attributes"></a>Атрибуты сериализации  
 Атрибуты определяют, каким образом сериализация используется для создания хранимых представлений определяемых пользователем типов, а также для передачи таких типов клиенту по значению. Необходимо указать **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** при создании определяемого пользователем ТИПА. **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** атрибут указывает, что класс имеет определяемый пользователем тип и задает тип хранения для определяемого пользователем ТИПА. При необходимости можно указать **Serializable** атрибут, несмотря на то что [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] нет такого требования.  
  
 **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** имеет следующие свойства.  
  
 **Формат**  
 Указывает формат сериализации, который может быть **собственного** или **UserDefined**, в зависимости от типов данных определяемого пользователем типа.  
  
 **IsByteOrdered**  
 Объект **логическое** значение, определяющее, каким образом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит двоичные сравнения значений определяемого пользователем ТИПА.  
  
 **IsFixedLength**  
 Указывает, имеют ли все экземпляры данного определяемого пользователем типа одинаковую длину.  
  
 **MaxByteSize**  
 Максимальный размер экземпляра в байтах. Необходимо указать **MaxByteSize** с **UserDefined** формат сериализации. Для определяемого пользователем ТИПА с задаваемой пользователем сериализацией указан **MaxByteSize** ссылается на общий размер определяемого пользователем типа в сериализованной форме, как определяется пользователем. Значение **MaxByteSize** должен находиться в диапазоне от 1 до 8000, или значение -1 указывает, что определяемого пользователем ТИПА больше 8000 байт (общий размер не может превышать максимального размера LOB). Рассмотрим определяемого пользователем ТИПА со свойством строки длиной 10 символов (**System.Char**). Когда определяемый пользователем тип сериализуется с помощью BinaryWriter, общий размер сериализованной строки будет равен 22 байтам: 2 байта на символ Юникода UTF-16, умноженное на максимальное число символов, плюс 2 управляющих байта, добавляемые из сериализации двоичного потока. Таким образом при определении значения **MaxByteSize**, следует учитывать общий размер сериализованного определяемого пользователем типа: размер данных, сериализованных в двоичной форме, плюс издержки от сериализации.  
  
 **ValidationMethodName**  
 Имя метода, используемого для проверки экземпляров определяемого пользователем типа.  
  
### <a name="setting-isbyteordered"></a>Свойство IsByteOrdered  
 При **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered** свойству **true**, по сути, гарантируя, что сериализованные двоичные данные можно использовать для семантического упорядочивания информации. Таким образом, каждый экземпляр объекта побайтно упорядоченного определяемого пользователем типа может иметь лишь одно сериализованное представление. Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит операцию сравнения на сериализованных байтах, ее результаты должны быть такими же, как если бы та же операция сравнения проводилась в управляемом коде. Следующие функции, также поддерживается при **IsByteOrdered** присваивается **true**:  
  
-   Создание индексов для столбцов этого типа.  
  
-   Создание первичных и внешних ключей, а также ограничений CHECK и UNIQUE для столбцов этого типа.  
  
-   Использование предложений [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY и PARTITION BY. В этих случаях для определения порядка используется двоичное представление типа.  
  
-   Использование операторов сравнения в инструкциях [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
-   Сохранение вычисляемых столбцов этого типа.  
  
 Обратите внимание, что как **собственного** и **UserDefined** форматы сериализации поддерживает следующие операторы сравнения при **IsByteOrdered** присваивается **true** :  
  
-   Равно (=)  
  
-   Не равно (!=)  
  
-   Знак «больше» >)  
  
-   Знак "меньше" (\<)  
  
-   Больше или равно (> =)  
  
-   Меньше или равно (< =)  
  
### <a name="implementing-nullability"></a>Реализация допустимости значений NULL  
 Помимо задания нужных атрибутов для сборок, создаваемый класс должен также поддерживать допустимость значений NULL. Определяемые пользователем типы загружаются в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживают значение null, но чтобы определяемый пользователем тип распознавал значение null, класс должен реализовывать **интерфейс INullable** интерфейс. Дополнительные сведения и пример реализации допустимости значений NULL в определяемом пользователем ТИПЕ, см. в разделе [программирование определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
### <a name="string-conversions"></a>Преобразование строк  
 Чтобы обеспечить поддержку преобразования строк в и из определяемого пользователем ТИПА, необходимо указать **проанализировать** метод и **ToString** метод в классе. **Проанализировать** метод позволяет строка преобразуется в определяемый пользователем тип. Он должен быть объявлен как **статический** (или **Shared** в Visual Basic) и принимать параметр типа **System.Data.SqlTypes.SqlString**. Дополнительные сведения и пример реализации **проанализировать** и **ToString** методы, см. в разделе [программирование определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
## <a name="xml-serialization"></a>Сериализация XML  
 Определяемые пользователем типы должны поддерживать преобразование в и из **xml** тип данных, подчиняясь соглашению для XML-сериализации. **System.Xml.Serialization** пространство имен содержит классы, используемые для сериализации объектов в документы формата XML или в потоки. Вы можете реализовать **xml** сериализации с помощью **IXmlSerializable** интерфейс, который предоставляет пользовательский формат для сериализации и десериализации XML.  
  
 Помимо явных преобразований определяемого пользователем типа в **xml**, сериализация XML позволяет:  
  
-   Используйте **Xquery** над значениями экземпляров определяемого пользователем ТИПА после преобразования в **xml** тип данных.  
  
-   Использование определяемых пользователем типов в параметризованных запросах и веб-методах с собственными XML-веб-службами в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
-   Использовать определяемые пользователем типы для получения массовой загрузки XML-данных.  
  
-   Сериализовать объекты DataSets, содержащие таблицы со столбцами определяемого пользователем типа.  
  
 Определяемые пользователем типы не сериализуются в запросах FOR XML. Для выполнения запроса FOR XML, который отображает XML-сериализации, определяемых пользователем типов, явно преобразовать каждый столбец определяемого пользователем ТИПА для **xml** тип данных в инструкции SELECT. Можно также явно преобразовать столбцы для **varbinary**, **varchar**, или **nvarchar**.  
  
## <a name="see-also"></a>См. также  
 [Создание определяемого пользователем типа](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types.md)  
  
  
