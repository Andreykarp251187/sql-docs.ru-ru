---
title: Требования к определяемому пользователем типу | Документация Майкрософт
description: В этой статье описываются важные решения по проектированию, которые необходимо выполнить при создании определяемого пользователем типа для установки на SQL Server.
ms.custom: ''
ms.date: 03/16/2017
ms.prod: sql
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- UDTs [CLR integration], requirements
- serialization
- Native serialization format [CLR integration]
- attributes [CLR integration]
- XML serialization [CLR integration]
- user-defined types [CLR integration], requirements
- user-defined serialization [CLR integration]
- user-defined types [CLR integration], Native serialization
- UDTs [CLR integration], Native serialization
ms.assetid: bedc3372-50eb-40f2-bcf2-d6db6a63b7e6
author: rothja
ms.author: jroth
ms.openlocfilehash: b20192a3804dfba713b04706d528738ceb8768c3
ms.sourcegitcommit: da88320c474c1c9124574f90d549c50ee3387b4c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/01/2020
ms.locfileid: "85727810"
---
# <a name="creating-user-defined-types---requirements"></a>Создание определяемых пользователем типов — требования
 [!INCLUDE [SQL Server](../../includes/applies-to-version/sqlserver.md)]
  При создании определяемого пользователем типа (UDT) для установки в необходимо принять несколько важных решений по проектированию [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . В большинстве случаев рекомендуется создавать определяемый пользователем тип как структуру, хотя можно создавать его и в виде класса. Чтобы определяемый пользователем тип можно было зарегистрировать в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно соответствовать спецификациям на создание определяемого пользователем типа.  
  
## <a name="requirements-for-implementing-udts"></a>Требования к реализации определяемого пользователем типа  
 Чтобы определяемый пользователем тип работал в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно удовлетворять следующим условиям.  
  
 Определяемый пользователем тип должен указывать объект **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute**. Использование **System. SerializableAttribute** является необязательным, но рекомендуется.  
  
-   Определяемый пользователем тип должен реализовывать интерфейс **System. Data. SqlTypes. интерфейс INullable** в классе или структуре, создавая открытый **статический** (**Shared** в [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic) метод **null** . [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию может работать со значениями NULL. Это необходимо, чтобы программный код, принадлежащий определяемому пользователем типу, умел распознавать значения NULL.  
  
-   Определяемый пользователем тип должен содержать открытый **статический** (или **Общий**) метод **Parse** , который поддерживает синтаксический анализ, и открытый метод **ToString** для преобразования в строковое представление объекта.  
  
-   Определяемый пользователем тип с пользовательским форматом сериализации должен реализовывать интерфейс **System. Data. интерфейс IBinarySerialize** и предоставлять метод **Read** и **Write** .  
  
-   Определяемый пользователем тип должен реализовывать **System.Xml. Сериализация. IXmlSerializable**или все открытые поля и свойства должны иметь типы, которые являются XML-сериализуемыми или дополнены атрибутом **XmlIgnore** , если требуется переопределить стандартную сериализацию.  
  
-   У объекта определяемого пользователем типа может быть только одна сериализация. Если программы сериализации или десериализации обнаружат несколько различных представлений конкретного объекта, проверка закончится ошибкой.  
  
-   **SqlUserDefinedTypeAttribute. IsByteOrdered** должно иметь **значение true** для сравнения данных в порядке байтов. Если интерфейс IComparable не реализован и **SqlUserDefinedTypeAttribute. IsByteOrdered** имеет **значение false**, сравнение порядка байтов завершится ошибкой.  
  
-   Определяемый пользователем тип, заданный в виде класса, должен иметь общедоступный конструктор без аргументов. Дополнительно можно создать перегруженные конструкторы класса.  
  
-   Определяемый пользователем тип должен предоставлять доступ к элементам данных как к общедоступным полям или процедурам свойств.  
  
-   Общедоступные имена не могут быть длиннее 128 символов и должны соответствовать [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] правилам именования идентификаторов, определенным в [идентификаторах баз данных](../../relational-databases/databases/database-identifiers.md).  
  
-   **sql_variant** столбцы не могут содержать экземпляры определяемого пользователем типа.  
  
-   Унаследованные элементы недоступны из [!INCLUDE[tsql](../../includes/tsql-md.md)], потому что система типов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ничего не знает об иерархии наследования среди определяемых пользователем типов. Однако можно использовать наследование при определении структуры классов и можно вызывать такие методы в реализации этих типов с помощью управляемого кода.  
  
-   Элементы структуры или класса нельзя перегружать, кроме конструктора класса. Если создан перегруженный метод, при регистрации сборки или создании типа в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ошибка не возникает. Определение наличия перегруженного метода происходит во время выполнения, а не при создании типа. Класс может иметь перегруженные методы при условии, что они не вызываются. При вызове перегруженного метода возникает ошибка.  
  
-   Все **статические** (или **Общие**) члены должны быть объявлены как константы или доступны только для чтения. Элементы, объявленные как статические, нельзя изменять.  
  
-   Если в поле **SqlUserDefinedTypeAttribute. MaxByteSize** задано значение-1, сериализованный определяемый пользователем тип данных может быть таким же большим, как ограничение размера больших объектов (LOB) (в настоящее время 2 ГБ). Размер определяемого пользователем типа не может превышать значение, указанное в поле **максбитесизед** .  
  
> [!NOTE]  
>  Хотя он не используется сервером для выполнения сравнений, при необходимости можно реализовать интерфейс **System. IComparable** , который предоставляет один метод **CompareTo**. Он используется на клиенте в ситуациях, когда нужно провести точное сравнение или сортировку значений определяемого пользователем типа.  
  
## <a name="native-serialization"></a>Собственная сериализация  
 Выбор атрибутов сериализации при создании определяемого пользователем типа зависит от его типа. **Собственный** формат сериализации использует очень простую структуру, которая позволяет [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранить эффективное собственное представление определяемого пользователем типа на диске. **Собственный** формат рекомендуется, если определяемый пользователем тип является простым и содержит только поля следующих типов:  
  
 **bool**, **Byte**, **SByte**, **Short**, **UShort**, **int**, **uint**, **Long**, **ulong**, **float**, **Double**, **склбите**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **склсингле**, **SqlDouble**, **SqlMoney**, **SqlBoolean**  
  
 Типы значений, состоящие из полей приведенных выше типов, являются хорошим кандидатом для **собственного** формата, например **структур** в Visual C#, (или **структур** , известных в Visual Basic). Например, определяемый пользователем тип, указанный в **собственном** формате сериализации, может содержать поле другого определяемого пользователем типа, которое также было указано в **собственном** формате. Если определение определяемого пользователем типа является более сложным и содержит типы данных, отсутствующие в приведенном выше списке, то вместо этого необходимо указать формат сериализации **пользователяопределенные** .  
  
 **Собственный** формат имеет следующие требования.  
  
-   Тип не должен указывать значение для **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute. MaxByteSize**.  
  
-   Все поля должны быть сериализуемыми.  
  
-   **System. Runtime. InteropServices. StructLayoutAttribute** должен быть указан как **StructLayout. лайауткиндсекуентиал** , если определяемый пользователем тип определен в классе, а не в структуре. Этот атрибут управляет физической компоновкой полей данных. Он заставляет члены структуры располагаться в памяти в том порядке, в каком они описаны. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует этот атрибут для задания порядка полей в определяемых пользователем типах с несколькими значениями.  
  
 Пример определяемого пользователем типа, определенного с помощью **собственной** сериализации, см. в разделе [определение определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md)данных.  
  
## <a name="userdefined-serialization"></a>Сериализация, заданная пользователем  
 Параметр формата **пользователяопределенные** для атрибута **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute** предоставляет разработчику полный контроль над двоичным форматом. При указании свойства "атрибут **формата** " как **пользователяопределенные**необходимо выполнить следующие действия в коде:  
  
-   Укажите необязательное свойство атрибута **IsByteOrdered** . Значение по умолчанию — **false**.  
  
-   Укажите свойство **MaxByteSize** объекта **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute**.  
  
-   Напишите код для реализации методов **чтения** и **записи** для определяемого пользователем типа путем реализации интерфейса **System. Data. SQL. интерфейс IBinarySerialize** .  
  
 Пример определяемого пользователем типа, определяемого с помощью **пользователяопределенные** Serialization, см. в разделе Определение типа валюты в [коде определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
> [!NOTE]  
>  Чтобы поля определяемого пользователем типа можно было использовать в индексе, они должны иметь собственную сериализацию или быть сохраняемыми.  
  
## <a name="serialization-attributes"></a>Атрибуты сериализации  
 Атрибуты определяют, каким образом сериализация используется для создания хранимых представлений определяемых пользователем типов, а также для передачи таких типов клиенту по значению. При создании определяемого пользователем типа необходимо указать **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute** . Атрибут **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute** указывает, что класс является определяемым пользователем типом и задает хранилище для определяемого пользователем типа. При необходимости можно указать **сериализуемый** атрибут, хотя [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] это и не требуется.  
  
 Объект **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute** имеет следующие свойства.  
  
 **Формат**  
 Указывает формат сериализации, который может быть **собственным** или **пользователяопределенные**, в зависимости от типов данных определяемого пользователем типа.  
  
 **IsByteOrdered**  
 **Логическое** значение, определяющее, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняется двоичное сравнение определяемого пользователем типа.  
  
 **Isfixedlength атрибута SqlFacetAttribute**  
 Указывает, имеют ли все экземпляры данного определяемого пользователем типа одинаковую длину.  
  
 **MaxByteSize**  
 Максимальный размер экземпляра в байтах. Необходимо указать **MaxByteSize** в формате сериализации **пользователяопределенные** . Для определяемого пользователем типа с заданной пользовательской сериализацией **MaxByteSize** относится к общему размеру определяемого пользователем типа в его сериализованной форме, как определено пользователем. Значение параметра **MaxByteSize** должно быть в диапазоне от 1 до 8000 или равно-1, чтобы указать, что определяемый пользователем тип больше 8000 байт (общий размер не может превышать максимальный размер LOB). Рассмотрим определяемый пользователем тип со свойством строки из 10 символов (**System. Char**). Когда определяемый пользователем тип сериализуется с помощью BinaryWriter, общий размер сериализованной строки составляет 22 байта: 2 байта на символ Юникода UTF-16, умноженный на максимальное число символов, плюс 2 контрольные байта, вызванные сериализацией двоичного потока. Таким образом, при определении значения **MaxByteSize**необходимо учитывать общий размер сериализованного определяемого пользователем типа: размер данных, сериализованных в двоичной форме, плюс затраты, вызванные сериализацией.  
  
 **валидатионмесоднаме**  
 Имя метода, используемого для проверки экземпляров определяемого пользователем типа.  
  
### <a name="setting-isbyteordered"></a>Свойство IsByteOrdered  
 Если свойство **Microsoft. SqlServer. Server. SqlUserDefinedTypeAttribute. IsByteOrdered** имеет значение **true**, то фактически гарантируется, что сериализованные двоичные данные могут использоваться для семантического упорядочивания информации. Таким образом, каждый экземпляр объекта побайтно упорядоченного определяемого пользователем типа может иметь лишь одно сериализованное представление. Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит операцию сравнения на сериализованных байтах, ее результаты должны быть такими же, как если бы та же операция сравнения проводилась в управляемом коде. Если **IsByteOrdered** имеет значение **true**, также поддерживаются следующие возможности.  
  
-   Создание индексов для столбцов этого типа.  
  
-   Создание первичных и внешних ключей, а также ограничений CHECK и UNIQUE для столбцов этого типа.  
  
-   Использование предложений [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY и PARTITION BY. В этих случаях для определения порядка используется двоичное представление типа.  
  
-   Использование операторов сравнения в инструкциях [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
-   Сохранение вычисляемых столбцов этого типа.  
  
 Обратите внимание, что форматы сериализации **native** и **пользователяопределенные** поддерживают следующие операторы сравнения, если **IsByteOrdered** имеет значение **true**:  
  
-   Равно (=)  
  
-   Не равно (!=)  
  
-   Знак «больше» >)  
  
-   Знак "меньше" (\<)  
  
-   Больше или равно (>=)  
  
-   Оператор «Меньше или равно» (<=)  
  
### <a name="implementing-nullability"></a>Реализация допустимости значений NULL  
 Помимо задания нужных атрибутов для сборок, создаваемый класс должен также поддерживать допустимость значений NULL. Определяемые пользователем типы, загруженные в, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживают значение null, но чтобы определяемый пользователем тип мог распознать значение null, класс должен реализовать интерфейс **интерфейс INullable** . Дополнительные сведения и пример реализации допустимости значений NULL в определяемом пользователем типе см. в разделе [написание определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
### <a name="string-conversions"></a>Преобразование строк  
 Для поддержки преобразования строк в определяемый пользователем тип и из него необходимо предоставить метод **Parse** и метод **ToString** в своем классе. Метод **Parse** позволяет преобразовать строку в определяемый пользователем тип. Он должен быть объявлен как **статический** (или **совместно использоваться** в Visual Basic) и принимать параметр типа **System. Data. SqlTypes. SqlString**. Дополнительные сведения и пример реализации методов **Parse** и **ToString** см. в разделе [кодирование определяемых пользователем типов](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md).  
  
## <a name="xml-serialization"></a>XML-сериализация  
 Определяемые пользователем типы должны поддерживать преобразование в тип данных **XML** и из него путем согласования контракта с XML-сериализацией. **System.Xml. **Пространство имен сериализации содержит классы, используемые для сериализации объектов в документы или потоки формата XML. Можно выбрать реализацию **XML-** сериализации с помощью интерфейса **IXmlSerializable** , который обеспечивает пользовательское форматирование для сериализации XML и десериализации.  
  
 В дополнение к явному преобразованию типа UDT в **XML**, XML-сериализация позволяет выполнять следующие задачи:  
  
-   Используйте **XQuery** для значений экземпляров определяемых пользователем типов после преобразования в тип данных **XML** .  
  
-   Использование определяемых пользователем типов в параметризованных запросах и веб-методах с собственными XML-веб-службами в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
-   Использовать определяемые пользователем типы для получения массовой загрузки XML-данных.  
  
-   Сериализовать объекты DataSets, содержащие таблицы со столбцами определяемого пользователем типа.  
  
 Определяемые пользователем типы не сериализуются в запросах FOR XML. Чтобы выполнить запрос FOR XML, отображающий XML-сериализацию определяемых пользователем типов, явно преобразуйте каждый столбец UDT в тип данных **XML** в инструкции SELECT. Можно также явно преобразовать столбцы в типы **varbinary**, **varchar**или **nvarchar**.  
  
## <a name="see-also"></a>См. также  
 [Создание определяемого пользователем типа](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types.md)  
  
  
