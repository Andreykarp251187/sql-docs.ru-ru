---
title: Требования к типу пользователя Документы Майкрософт
description: В этой статье описываются важные проектные решения, которые необходимо принять при создании UDT для установки на сервере S'L.
ms.custom: ''
ms.date: 03/16/2017
ms.prod: sql
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- UDTs [CLR integration], requirements
- serialization
- Native serialization format [CLR integration]
- attributes [CLR integration]
- XML serialization [CLR integration]
- user-defined types [CLR integration], requirements
- user-defined serialization [CLR integration]
- user-defined types [CLR integration], Native serialization
- UDTs [CLR integration], Native serialization
ms.assetid: bedc3372-50eb-40f2-bcf2-d6db6a63b7e6
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b19a9179cba2225a2209255ce48220669e4bbef
ms.sourcegitcommit: b2cc3f213042813af803ced37901c5c9d8016c24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81486983"
---
# <a name="creating-user-defined-types---requirements"></a>Создание определяемых пользователем типов — требования
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]
  При создании пользовательского типа (UDT), который будет установлен в [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В большинстве случаев рекомендуется создавать определяемый пользователем тип как структуру, хотя можно создавать его и в виде класса. Чтобы определяемый пользователем тип можно было зарегистрировать в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно соответствовать спецификациям на создание определяемого пользователем типа.  
  
## <a name="requirements-for-implementing-udts"></a>Требования к реализации определяемого пользователем типа  
 Чтобы определяемый пользователем тип работал в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно удовлетворять следующим условиям.  
  
 UDT должен указать **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute**. Использование **System.SerializableAttribute** является необязательным, но рекомендуется.  
  
-   UDT должен реализовать интерфейс **System.Data.SqlTypes.INullable** в классе или структуре, [!INCLUDE[msCoName](../../includes/msconame-md.md)] создав общедоступный **статичный** **(общий** в visual Basic) **null** метод. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию может работать со значениями NULL. Это необходимо, чтобы программный код, принадлежащий определяемому пользователем типу, умел распознавать значения NULL.  
  
-   UDT должен содержать общедоступный **статический** (или **общий)** метод **Parse,** поддерживающий разбор из, и общедоступный метод **ToString** для преобразования в строку представления объекта.  
  
-   UDT с пользовательским форматом сериализации должен реализовать интерфейс **System.Data.IBinarySerialize** и предоставить метод **чтения** и **записи.**  
  
-   UDT должен реализовать **System.Xml.Serialization.IXmlSerializable**, или все публичные поля и свойства должны быть типов, которые XML сериализируемых или украшены атрибутом **XmlIgnore,** если требуется переопределение стандартной сериализации.  
  
-   У объекта определяемого пользователем типа может быть только одна сериализация. Если программы сериализации или десериализации обнаружат несколько различных представлений конкретного объекта, проверка закончится ошибкой.  
  
-   **SqlUserDefinedTypeAttribute.IsByteOrdered** должен быть **верным** для сравнения данных в порядке байт. Если интерфейс IComparable не реализован и **SqlUserDefinedTypeAttribute.IsByteOrdered** является **ложным,** сравнение заказов не удастся.  
  
-   Определяемый пользователем тип, заданный в виде класса, должен иметь общедоступный конструктор без аргументов. Дополнительно можно создать перегруженные конструкторы класса.  
  
-   Определяемый пользователем тип должен предоставлять доступ к элементам данных как к общедоступным полям или процедурам свойств.  
  
-   Публичные имена не могут быть длиннее 128 символов и должны соответствовать правилам [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] именования идентификаторов, определенным в [идентификаторах базы данных.](../../relational-databases/databases/database-identifiers.md)  
  
-   **sql_variant** столбцы не могут содержать экземпляры UDT.  
  
-   Унаследованные элементы недоступны из [!INCLUDE[tsql](../../includes/tsql-md.md)], потому что система типов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ничего не знает об иерархии наследования среди определяемых пользователем типов. Однако можно использовать наследование при определении структуры классов и можно вызывать такие методы в реализации этих типов с помощью управляемого кода.  
  
-   Элементы структуры или класса нельзя перегружать, кроме конструктора класса. Если создан перегруженный метод, при регистрации сборки или создании типа в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ошибка не возникает. Определение наличия перегруженного метода происходит во время выполнения, а не при создании типа. Класс может иметь перегруженные методы при условии, что они не вызываются. При вызове перегруженного метода возникает ошибка.  
  
-   Любые **статические** (или **общие)** члены должны быть объявлены константами или только для чтения. Элементы, объявленные как статические, нельзя изменять.  
  
-   Если поле **SqlUserDefinedTypeAttribute.MaxByteSize** установлено до -1, то серийизированное UDT может быть таким же большим, как предел размера большого объекта (LOB) (в настоящее время 2 ГБ). Размер UDT не может превышать значение, указанное в поле **MaxByteSized.**  
  
> [!NOTE]  
>  Хотя он не используется сервером для выполнения сравнений, вы можете дополнительно реализовать **интерфейс System.IComparable,** который предоставляет один метод, **CompareTo**. Он используется на клиенте в ситуациях, когда нужно провести точное сравнение или сортировку значений определяемого пользователем типа.  
  
## <a name="native-serialization"></a>Собственная сериализация  
 Выбор атрибутов сериализации при создании определяемого пользователем типа зависит от его типа. Формат сериализации **Native** использует очень простую [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] структуру, которая позволяет хранить эффективное родное представление UDT на диске. Формат **Native** рекомендуется, если UDT прост и содержит только поля следующих типов:  
  
 **bool**, **байт**, **сбайт**, **короткий**, **ushort**, **Int**, **uint**, **длинные**, **ulong**, **плавать**, **двойной**, **SqlByte**, **SqlInt32**, **SqlBoolean** **SqlInt64**, **SqlDate**, **SqlSingle**, **SqlInt32** **SqlDouble**, **Sql**  
  
 Типы значений, состоящие из полей вышеуказанных типов, являются хорошими кандидатами для **формата Native,** таких как **структуры** в Visual C (или **структуры,** как они известны в Visual Basic). Например, UDT, указанный в формате сериализации **Native,** может содержать поле другого UDT, которое также было определено в формате **Native.** Если определение UDT является более сложным и содержит типы данных, не вкоторых из вышеуказанного списка, необходимо указать формат сериализации **UserDefined.**  
  
 **Формат Native** имеет следующие требования:  
  
-   Тип не должен указывать значение для **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize**.  
  
-   Все поля должны быть сериализуемыми.  
  
-   **System.Runtime.InteropServices.StructLayoutAttribute** должен быть указан как **StructLayout.LayoutKindSequential,** если UDT определен в классе, а не структуры. Этот атрибут управляет физической компоновкой полей данных. Он заставляет члены структуры располагаться в памяти в том порядке, в каком они описаны. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует этот атрибут для задания порядка полей в определяемых пользователем типах с несколькими значениями.  
  
 В примере UDT, определяемого с представлением [Coding User-Defined Types](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md) **Native,** см.  
  
## <a name="userdefined-serialization"></a>Сериализация, заданная пользователем  
 Настройка формата **UserDefined** для атрибута **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** дает разработчику полный контроль над двоичным форматом. При указании свойства атрибута **Формата** как **UserDefined**необходимо сделать следующее в коде:  
  
-   Укажите дополнительное свойство атрибута **IsByteOrdered.** Значение по умолчанию — **false**.  
  
-   Укажите свойство **MaxByteSize** **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute**.  
  
-   Напишите код для реализации методов **чтения** и **записи** для UDT, внедрив интерфейс **System.Data.Sql.IBinarySerialize.**  
  
 В примере UDT, определяемого с помощью [Coding User-Defined Types](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md)сериализации **UserDefined,** см.  
  
> [!NOTE]  
>  Чтобы поля определяемого пользователем типа можно было использовать в индексе, они должны иметь собственную сериализацию или быть сохраняемыми.  
  
## <a name="serialization-attributes"></a>Атрибуты сериализации  
 Атрибуты определяют, каким образом сериализация используется для создания хранимых представлений определяемых пользователем типов, а также для передачи таких типов клиенту по значению. При создании UDT необходимо указать **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.** Атрибут **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** указывает на то, что класс является UDT, и определяет хранилище для UDT. Можно дополнительно указать атрибут **Serializable,** хотя [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и не требует этого.  
  
 **Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute** имеет следующие свойства.  
  
 **Формат**  
 Определяет формат сериализации, который может быть **native** или **UserDefined**, в зависимости от типов данных UDT.  
  
 **IsByteOrdered**  
 Значение **Boolean,** определяющее, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполняется двоичные сравнения на UDT.  
  
 **Зафиксированная длина**  
 Указывает, имеют ли все экземпляры данного определяемого пользователем типа одинаковую длину.  
  
 **MaxByteSize**  
 Максимальный размер экземпляра в байтах. Необходимо указать **MaxByteSize** с форматом сериализации **UserDefined.** Для UDT с указанной серизацией, определенной пользователем, **MaxByteSize** относится к общему размеру UDT в его сериализованной форме, определяемом пользователем. Значение **MaxByteSize** должно быть в диапазоне от 1 до 8000, или установить до -1, чтобы указать, что UDT больше, чем 8000 байт (общий размер не может превышать максимальный размер LOB). Рассмотрим UDT с свойством строки из 10 символов **(System.Char**). Когда UDT сериализуется с помощью BinaryWriter, общий размер сериализованной строки составляет 22 байта: 2 байта на символ Unicode UTF-16, умножаемый на максимальное количество символов, плюс 2 контрольных байта накладных расходов, понесенных от сериализации двоичного потока. Поэтому при определении значения **MaxByteSize**необходимо учитывать общий размер сериализованного UDT: размер данных, состоящий в двоичной форме, плюс накладные расходы, понесенные в результате сериализации.  
  
 **ПроверкаМетоды**  
 Имя метода, используемого для проверки экземпляров определяемого пользователем типа.  
  
### <a name="setting-isbyteordered"></a>Свойство IsByteOrdered  
 Когда **свойство Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered** свойство будет **верно,** вы фактически гарантируете, что сериализованные двоичные данные могут быть использованы для семанического заказа информации. Таким образом, каждый экземпляр объекта побайтно упорядоченного определяемого пользователем типа может иметь лишь одно сериализованное представление. Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит операцию сравнения на сериализованных байтах, ее результаты должны быть такими же, как если бы та же операция сравнения проводилась в управляемом коде. Следующие функции также поддерживаются, когда **IsByteOrdered** установлен на **истину:**  
  
-   Создание индексов для столбцов этого типа.  
  
-   Создание первичных и внешних ключей, а также ограничений CHECK и UNIQUE для столбцов этого типа.  
  
-   Использование предложений [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY и PARTITION BY. В этих случаях для определения порядка используется двоичное представление типа.  
  
-   Использование операторов сравнения в инструкциях [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
-   Сохранение вычисляемых столбцов этого типа.  
  
 Обратите внимание, что оба **родных** и **UserDefined** серийные форматы поддерживают следующие операторы сравнения, когда **IsByteOrdered** установлен на **истину:**  
  
-   Равно (=)  
  
-   Не равно (!=)  
  
-   Знак «больше» >)  
  
-   Знак "меньше" (\<)  
  
-   Больше или равно (>=)  
  
-   Оператор «Меньше или равно» (<=)  
  
### <a name="implementing-nullability"></a>Реализация допустимости значений NULL  
 Помимо задания нужных атрибутов для сборок, создаваемый класс должен также поддерживать допустимость значений NULL. Загруженные UDT [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не осведомлены об нулевая информация, но для того, чтобы UDT распознать нулевую ценность, класс должен реализовать интерфейс **INullable.** Для получения дополнительной информации и примера того, как [Coding User-Defined Types](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md)реализовать нулевую реализацию в UDT, см.  
  
### <a name="string-conversions"></a>Преобразование строк  
 Для поддержки преобразования строки в и из UDT необходимо предоставить метод **Parse** и метод **ToString** в своем классе. Метод **Parse** позволяет преобразовывать строку в UDT. Он должен быть объявлен **статическим** (или **общим** в Visual Basic) и взять параметр типа **System.Data.SqlTypes.SqlString.** Для получения дополнительной информации и примера реализации методов **Parse** и **ToString** [см.](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types-coding.md)  
  
## <a name="xml-serialization"></a>Сериализация XML  
 UDTs должны поддерживать преобразование в и из типа данных **xml,** соответствуя контракту на сериализацию XML. В пространстве имен **System.Xml.Serialization** содержатся классы, которые используются для сериализации объектов в документах или потоках формата XML. Вы можете реализовать **сериализацию xml** с помощью интерфейса **IXmlSerializable,** который обеспечивает пользовательский форматирование для сериализации и десериализации XML.  
  
 В дополнение к выполнению явных конверсий из UDT в **xml,** xML сериализация позволяет:  
  
-   Используйте **Xquery** над значениями экземпляров UDT после преобразования в тип данных **xml.**  
  
-   Использование определяемых пользователем типов в параметризованных запросах и веб-методах с собственными XML-веб-службами в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
-   Использовать определяемые пользователем типы для получения массовой загрузки XML-данных.  
  
-   Сериализовать объекты DataSets, содержащие таблицы со столбцами определяемого пользователем типа.  
  
 Определяемые пользователем типы не сериализуются в запросах FOR XML. Для выполнения запроса FOR XML, отображаемого xML-сериализации UDT, явно преобразуйте каждый столбец UDT в тип данных **xml** в выписке SELECT. Вы также можете явно преобразовать столбцы в **varbinary,** **varchar**, или **nvarchar**.  
  
## <a name="see-also"></a>См. также:  
 [Создание определяемого пользователем типа](../../relational-databases/clr-integration-database-objects-user-defined-types/creating-user-defined-types.md)  
  
  
