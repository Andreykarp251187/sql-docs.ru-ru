---
title: Регистрация пользовательских типов в сервере S'L (ru) Документы Майкрософт
description: Перед установкой на сервер S'L необходимо зарегистрировать UDT. Необходимо зарегистрировать сборку и создать тип в базе данных, где вы хотите ее использовать.
ms.custom: ''
ms.date: 03/16/2017
ms.prod: sql
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
dev_langs:
- TSQL
helpviewer_keywords:
- UDTs [CLR integration], maintaining
- user-defined types [CLR integration], maintaining
- dependencies [CLR integration]
- deploying user-defined types [CLR integration]
- CurrencyConversion function
- user-defined types [CLR integration], deploying
- Transact-SQL deploying UDTs
- assemblies [CLR integration], user-defined types
- cross-database UDT support
- CREATE ASSEMBLY statement
- DROP TYPE statement
- Currency UDT
- CREATE TYPE statement
- registering user-defined types
- UDTs [CLR integration], deploying
- removing user-defined types
- user-defined types [CLR integration], registering
- ALTER ASSEMBLY statement
- UDTs [CLR integration], registering
- ADD FILE clause
ms.assetid: f7da3e92-e407-4f0b-b3a3-f214e442b37d
author: rothja
ms.author: jroth
ms.openlocfilehash: e4383e245048035d4c05f7be3bedb7d3d13f835d
ms.sourcegitcommit: b2cc3f213042813af803ced37901c5c9d8016c24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81486946"
---
# <a name="registering-user-defined-types-in-sql-server"></a>Регистрация определяемых пользователем типов в SQL Server
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]
  Для того, чтобы использовать пользовательский тип [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)](UDT) в, вы должны зарегистрировать его. Регистрация определяемого пользователем типа включает регистрацию сборки и создание типа в базе данных, в которой его нужно использовать. Определяемые пользователем типы находятся в одной базе данных и не могут использоваться в нескольких базах данных, пока идентичная сборка и определяемый пользователем тип не будут зарегистрированы в каждой базе данных. После регистрации сборки определяемого пользователем типа и создания типа этот тип можно использовать в [!INCLUDE[tsql](../../includes/tsql-md.md)] и клиентском коде. Дополнительные сведения об определяемых пользователем типах данных CLR см. в разделе [Определяемые пользователем типы данных CLR](../../relational-databases/clr-integration-database-objects-user-defined-types/clr-user-defined-types.md).  
  
## <a name="using-visual-studio-to-deploy-udts"></a>Использование среды Visual Studio для развертывания определяемых пользователем типов  
 Самым простым способом развертывания определяемого пользователем типа является использование среды [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Studio. Однако для более сложных сценариев развертывания и большей гибкости используется язык [!INCLUDE[tsql](../../includes/tsql-md.md)], как описано далее в этом разделе.  
  
 Для создания и развертывания определяемых пользователем типов с помощью среды Visual Studio выполните следующие шаги.  
  
1.  Создайте новый проект **базы данных** в языковых узлах **Visual Basic** или **Visual C.**  
  
2.  Добавьте ссылку на базу данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], содержащую определяемый пользователем тип.  
  
3.  Добавьте класс **типа, определяемого пользователем.**  
  
4.  Напишите код для реализации определяемого пользователем типа.  
  
5.  Из меню **сборки** выберите **Развертывание**. Эта команда регистрирует сборку и создает тип в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  

## <a name="using-transact-sql-to-deploy-udts"></a>Использование Transact-SQL для развертывания определяемых пользователем типов  
 Синтаксис CREATE ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] используется для регистрации сборки в базе данных, в которой требуется использование определяемого пользователем типа. Он хранится внутри системных таблиц базы данных, а во внешней файловой системе. Если определяемый пользователем тип зависит от внешних сборок, их тоже необходимо загрузить в базу данных. Инструкция CREATE TYPE используется для создания определяемого пользователем типа в базе данных, в которой он будет использоваться. Для получения дополнительной информации [см. CREATE ASSEMBLY &#40;&#41;Transact-S'L](../../t-sql/statements/create-assembly-transact-sql.md) и CREATE TYPE &#40;&#41;[Transact-S'L. ](../../t-sql/statements/create-type-transact-sql.md)  
  
### <a name="using-create-assembly"></a>Использование инструкции CREATE ASSEMBLY  
 Инструкция CREATE ASSEMBLY регистрирует сборку в базе данных, в которой требуется использование определяемого пользователем типа. После регистрации сборки она не имеет зависимостей.  
  
 Создание нескольких версий одной сборки в одной базе данных не допускается. Однако возможно создание нескольких версий одной сборки, зависящих от культуры данной базы данных. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] разделяет несколько культурных версий сборки по разным именам, зарегистрированным в экземпляре [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в разделе «Создание и использование сборок со строгими именами» пакета .NET Framework SDK.  
  
 Если инструкция CREATE ASSEMBLY выполняется с наборами разрешений SAFE или EXTERNAL_ACCESS, сборка проверяется на совместимость и безопасность типа. Если набор разрешений не указан, предполагается набор разрешений SAFE. Код с набором разрешений UNSAFE не проверяется. Дополнительные сведения о наборах разрешений сборки см. в разделе [Проектирование сборок](../../relational-databases/clr-integration/assemblies-designing.md).  
  
#### <a name="example"></a>Пример  
 Следующее [!INCLUDE[tsql](../../includes/tsql-md.md)] заявление регистрирует сборку [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Точек в базе данных **AdventureWorks** с набором разрешений SAFE. Если предложение WITH PERMISSION_SET не указано, сборка регистрируется с набором разрешений SAFE.  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM '\\ShareName\Projects\Point\bin\Point.dll'   
WITH PERMISSION_SET = SAFE;  
```  
  
 Следующее [!INCLUDE[tsql](../../includes/tsql-md.md)] заявление регистрирует сборку с использованием *<assembly_bits>* аргументом в оговорке FROM. Это **варбинарное** значение представляет файл как поток байтов.  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM 0xfeac4 ... 21ac78  
```  
  
### <a name="using-create-type"></a>Использование инструкции CREATE TYPE  
 После загрузки сборки в базу данных можно создать тип с помощью инструкции CREATE TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)]. Она добавляет тип в список доступных типов для этой базы данных. Тип имеет область базы данных и может использоваться только в той базе данных, в которой он был создан. Если определяемый пользователем тип уже существует в базе данных, то инструкция CREATE TYPE завершится с ошибкой.  
  
> [!NOTE]  
>  Синтаксис CREATE TYPE также используется [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для создания типов данных родного псевдонима и предназначен для замены **sp_addtype** в качестве средства создания типов аименной данных. Некоторые из дополнительных аргументов в синтаксисе CREATE TYPE служат для создания определяемых пользователем типов и неприменимы для создания псевдонимов типов данных (например базового типа).  
  
 Для получения дополнительной информации см [&#41;&#40;. ](../../t-sql/statements/create-type-transact-sql.md)  
  
#### <a name="example"></a>Пример  
 Следующее [!INCLUDE[tsql](../../includes/tsql-md.md)] утверждение создает тип **точки.** EXTERNAL NAME указан с помощью синтаксиса с именования в двух частей *AssemblyName.* *UDTName*.  
  
```  
CREATE TYPE dbo.Point   
EXTERNAL NAME Point.[Point];  
```  
  
## <a name="removing-a-udt-from-the-database"></a>Удаление определяемого пользователем типа из базы данных  
 Инструкция DROP TYPE удаляет определяемый пользователем тип из текущей базы данных. После удаления определяемого пользователем типа можно инструкцией DROP ASSEMBLY удалить сборку из базы данных.  
  
 Инструкция DROP TYPE не выполняется в следующих ситуациях.  
  
-   Таблицы в базе данных, которые содержат столбцы, определенные с помощью определяемого пользователем типа.  
  
-   Функции, хранимые процедуры или триггеры, которые используют переменные или параметры определяемого пользователем типа и созданы в базе данных с помощью предложения WITH SCHEMABINDING.  
  
### <a name="example"></a>Пример  
 Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] должна выполняться в следующем порядке. Сначала должна быть удалена таблица, отсылающая **к точке** UDT, затем тип и, наконец, сборка.  
  
```  
DROP TABLE dbo.Points;  
DROP TYPE dbo.Point;  
DROP ASSEMBLY Point;  
```  
  
### <a name="finding-udt-dependencies"></a>Поиск зависимостей определяемого пользователем типа  
 Если есть зависимые объекты, например таблицы с определениями столбцов определяемых пользователем типов, то инструкция DROP TYPE завершится с ошибкой. Также она завершится с ошибкой, если есть функции, хранимые процедуры или триггеры, созданные в базе данных с помощью предложения WITH SCHEMABINDING, или эти процедуры используют переменные и параметры определяемого пользователем типа. Сначала необходимо удалить все зависимые объекты, а затем выполнить инструкцию DROP TYPE.  
  
 Следующий [!INCLUDE[tsql](../../includes/tsql-md.md)] запрос находит все столбцы и параметры, которые используют UDT в базе данных **AdventureWorks.**  
  
```  
USE Adventureworks;  
SELECT o.name AS major_name, o.type_desc AS major_type_desc  
     , c.name AS minor_name, c.type_desc AS minor_type_desc  
     , at.assembly_class  
  FROM (  
        SELECT object_id, name, user_type_id, 'SQL_COLUMN' AS type_desc  
          FROM sys.columns  
     UNION ALL  
        SELECT object_id, name, user_type_id, 'SQL_PROCEDURE_PARAMETER'  
          FROM sys.parameters  
     ) AS c  
  JOIN sys.objects AS o  
    ON o.object_id = c.object_id  
  JOIN sys.assembly_types AS at  
    ON at.user_type_id = c.user_type_id;  
```  
  
## <a name="maintaining-udts"></a>Обслуживание определяемых пользователем типов  
 После создания определяемого пользователем типа в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] вы не можете его изменить, хотя можно изменить сборку, на которой основан этот тип. В большинстве случаев необходимо удалить из базы данных определяемый пользователем тип с помощью инструкции DROP TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)], внести изменения в базовую сборку и загрузить ее повторно с помощью инструкции ALTER ASSEMBLY. Затем необходимо повторно создать определяемый пользователем тип и зависимые объекты.  
  
### <a name="example"></a>Пример  
 Инструкция ALTER ASSEMBLY используется после внесения изменений в исходный код сборки определяемого пользователем типа и ее повторной компиляции. Она копирует DLL-файл на сервер и выполняет повторную привязку к новой сборке. Для полного синтаксиса [&#41;&#40;](../../t-sql/statements/alter-assembly-transact-sql.md)см.  
  
 Следующая инструкция ALTER ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] повторно загружает сборку Point.dll из указанного места на диске.  
  
```  
ALTER ASSEMBLY Point  
FROM '\\Projects\Point\bin\Point.dll'  
```  
  
### <a name="using-alter-assembly-to-add-source-code"></a>Использование инструкции ALTER ASSEMBLY для добавления исходного кода  
 Предложение ADD FILE в синтаксисе инструкции ALTER ASSEMBLY отсутствует в инструкции CREATE ASSEMBLY. Оно обеспечивает возможность добавления исходного кода или любых других файлов, связанных со сборкой. Файлы копируются из исходных расположений и сохраняются в системных таблицах базы данных. Это обеспечивает постоянную доступность исходного кода или других файлов на тот случай, если возникнет необходимость повторного создания или документирования текущей версии определяемого пользователем типа.  
  
 Следующее [!INCLUDE[tsql](../../includes/tsql-md.md)] заявление ALTER ASSEMBLY добавляет исходный код Point.cs класса для **Point** UDT. В результате этого текст, содержащийся в файле Point.cs, будет скопирован и сохранен в базе данных с именем PointSource.  
  
```  
ALTER ASSEMBLY Point  
ADD FILE FROM '\\Projects\Point\Point.cs' AS PointSource;  
```  
  
 Информация о сборке хранится в таблице **sys.assembly_files** в базе данных, где была установлена сборка. Таблица **sys.assembly_files** содержит следующие столбцы.  
  
 **assembly_id**  
 Идентификатор, определенный для сборки. Это число назначается всем объектам, относящимся к одной сборке.  
  
 **name**  
 Имя объекта.  
  
 **file_id**  
 Номер, идентифицирующий каждый объект, с первым объектом, связанным с данным **assembly_id,** получает значение 1. Если есть несколько объектов, связанных с **одной**assembly_id, то каждое последующее **file_id** значение приравнивается на 1.  
  
 **content**  
 Шестнадцатеричное представление сборки или файла.  
  
 Функция CAST или CONVERT можно использовать для преобразования содержимого столбца **содержимого** в читаемый текст. Следующий запрос преобразует содержимое файла Point.cs в доступный для чтения текст, используя для ограничения результирующего набора до одной строки имя в предложении WHERE.  
  
```  
SELECT CAST(content AS varchar(8000))   
  FROM sys.assembly_files   
  WHERE name='PointSource';  
```  
  
 При копировании и вставке результатов в текстовый редактор видно, что разделители строк и пробелы, существовавшие в исходном тексте, сохранились.  
  
## <a name="managing-udts-and-assemblies"></a>Управление определяемыми пользователем типами и сборками  
 При планировании реализации определяемых пользователем типов обдумайте, какие методы нужны в самой сборке определяемого пользователем типа, а какие нужно создать в отдельных сборках и реализовать в виде определяемых пользователем функций или хранимых процедур. Выделение методов в отдельные сборки позволяет обновлять код, не затрагивая данные, которые могут храниться в столбце определяемого пользователем типа таблицы. Сборки определяемого пользователем типа можно изменять без удаления столбцов и других зависимых объектов только в случае, если новое определение может считывать предыдущие значения, а подпись типа не изменена.  
  
 Выделение процедурного кода, который может отличаться от кода, требуемого для реализации определяемого пользователем типа, значительно упрощает обслуживание. Включение кода, необходимого для функционирования определяемого пользователем типа, и максимально возможное упрощение определений определяемого пользователем типа снижает риск необходимости удаления этого типа из базы данных для изменения кода или исправления ошибок.  
  
### <a name="the-currency-udt-and-currency-conversion-function"></a>Определяемый пользователем тип Currency и функция конвертации валюты  
 **Валюта** UDT в базе данных **образцов AdventureWorks** является полезным примером рекомендуемого способа структурирования UDT и связанных с ним функций. **Валюта** UDT используется для обработки денег на основе денежной системы конкретной культуры, и позволяет хранить различные типы валют, таких как доллары, евро и так далее. Класс UDT предоставляет название культуры как строку, а количество денег — тип **десятичных** данных. Все необходимые методы сериализации содержатся внутри сборки, определяющей класс. Функция, которая реализует преобразование валюты из одной культуры в другую, реализуется как внешняя функция под названием **ConvertCurrency,** и эта функция находится в отдельной сборке. Функция **ConvertCurrency** выполняет свою работу, извлекая коэффициент конверсии из таблицы в базе данных **AdventureWorks.** Если источник коэффициентов конверсии должен когда-либо измениться, или если должны быть какие-либо другие изменения в существующем коде, сборка может быть легко изменена, не влияя на **валюту** UDT.  
  
 Список кода для функций **Currency** UDT и **ConvertCurrency** можно найти, установив образцы общего времени выполнения языка (CLR).  
  
### <a name="using-udts-across-databases"></a>Использование определяемых пользователем типов в нескольких базах данных  
 Определяемые пользователем типы по определению находятся в одной базе данных. Таким образом, определяемый пользователем тип, созданный в одной базе данных, нельзя использовать в определении столбца другой базы данных. Чтобы использовать определяемые пользователем типы в нескольких базах данных, в каждой базе данных необходимо выполнить инструкции CREATE ASSEMBLY и CREATE TYPE для тех же сборок. Сборки считаются одинаковыми, если имеют одинаковое имя, строгое имя, культуру, версию, набор разрешений и двоичное содержимое.  
  
 После того как определяемый пользователем тип зарегистрирован и доступен в обеих базах данных, можно преобразовать значение данного типа из одной базы данных для использования в другой. Одинаковые определяемые пользователем типы могут использоваться в нескольких базах данных в следующих сценариях.  
  
-   Вызываемые хранимые процедуры определены в различных базах данных.  
  
-   Запрашиваемые таблицы определены в различных базах данных.  
  
-   Выбор данных определяемого пользователем типа из столбца одной базы данных и вставка в столбец такого же типа другой базы данных.  
  
 В этих ситуациях любое преобразование, требуемое сервером, происходит автоматически. Эти преобразования нельзя выполнить явным образом с помощью функций CAST или CONVERT языка [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
 Обратите внимание, что при [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] настройке рабочих таблиц в базе данных системы **tempdb** не требуется предпринимать никаких действий для использования UDT. Это включает в себя обработку курсоров, переменных таблици и пользовательских функций, оцениваемых таблицей, которые включают UDT и которые прозрачно используют **tempdb.** Однако, если вы явно создаете временную таблицу в **tempdb,** которая определяет столбец UDT, то UDT должен быть зарегистрирован в **tempdb** так же, как и для базы данных пользователей.  
  
## <a name="see-also"></a>См. также:  
 [Определяемые пользователем типы данных CLR](../../relational-databases/clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
