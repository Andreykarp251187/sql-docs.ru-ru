---
title: Учебник. Создание модели на языке Python для категоризации клиентов
description: В третьей части серии руководств из четырех частей вы создадите модель K-средних для выполнения кластеризации в Python с SQL Server Службы машинного обучения.
ms.prod: sql
ms.technology: machine-learning
ms.devlang: python
ms.date: 08/27/2019
ms.topic: tutorial
author: garyericson
ms.author: garye
ms.reviewer: davidph
monikerRange: '>=sql-server-2017||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: 8707d14b1e332ae6ecebf83213ed53701343bcd3
ms.sourcegitcommit: 26715b4dbef95d99abf2ab7198a00e6e2c550243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70294409"
---
# <a name="tutorial-build-a-model-in-python-to-categorize-customers-with-sql-server-machine-learning-services"></a>Учебник. Создание модели на языке Python для категоризации клиентов с помощью SQL Server Службы машинного обучения

[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

В третьей части серии руководств из четырех частей вы создадите модель K-средних в Python для выполнения кластеризации. В следующей части этой серии вы развернете эту модель в базе данных SQL с помощью SQL Server Службы машинного обучения.

Из этой статьи вы узнаете о следующем:

> [!div class="checklist"]
> * Определение числа кластеров для алгоритма K-средних
> * Выполнение кластеризации
> * Анализ результатов

В [первой части](python-clustering-model.md)вы установили необходимые компоненты и восстановили образец базы данных.

В [части 2](python-clustering-model-prepare-data.md)вы узнали, как подготавливать данные из базы данных SQL для выполнения кластеризации.

В [части 4](python-clustering-model-deploy.md)вы узнаете, как создать хранимую процедуру в базе данных SQL, которая может выполнять кластеризацию в Python на основе новых данных.

## <a name="prerequisites"></a>Предварительные требования

* В третьей части этого руководства предполагается, что вы выполнили предварительные требования к первой [**части**](python-clustering-model.md)и выполнили действия, описанные в [**второй части**](python-clustering-model-prepare-data.md).

## <a name="define-the-number-of-clusters"></a>Определение количества кластеров

Для кластеризации данных клиента используется алгоритм кластеризации **K-средних** , один из самых простых и известных способов группирования данных.
Дополнительные сведения о K-средних см. в полном разделе, посвященном [алгоритму кластеризации k-средних](https://www.kdnuggets.com/2019/05/guide-k-means-clustering-algorithm.html).

Алгоритм принимает два входных значения: Сами данные и предопределенный номер "*k*", представляющий число создаваемых кластеров.
Выходные данные — это *k* кластеры с входными данными, секционированными между кластерами.

Целью K-средних является группирование элементов на K кластеры таким образом, чтобы все элементы в одном кластере совпадали друг с другом и по возможности отличаться от элементов в других кластерах.

Чтобы определить количество кластеров, используемых алгоритмом, используйте график в пределах групп в сумме квадратов по количеству извлеченных кластеров. Необходимое количество используемых кластеров — изгиб или изгиб графика.

```python
################################################################################################
## Determine number of clusters using the Elbow method
################################################################################################

cdata = customer_data
K = range(1, 20)
KM = (sk_cluster.KMeans(n_clusters=k).fit(cdata) for k in K)
centroids = (k.cluster_centers_ for k in KM)

D_k = (sci_distance.cdist(cdata, cent, 'euclidean') for cent in centroids)
dist = (np.min(D, axis=1) for D in D_k)
avgWithinSS = [sum(d) / cdata.shape[0] for d in dist]
plt.plot(K, avgWithinSS, 'b*-')
plt.grid(True)
plt.xlabel('Number of clusters')
plt.ylabel('Average within-cluster sum of squares')
plt.title('Elbow for KMeans clustering')
plt.show()
```

![Уступовый график](./media/python-tutorial-elbow-graph.png)

На основе графа он выглядит так *: k = 4* будет хорошим значением. Это значение *k* будет группировать клиентов по четырем кластерам.

## <a name="perform-clustering"></a>Выполнение кластеризации

В следующем скрипте Python вы будете использовать функцию Кмеанс из пакета sklearn.

```python
################################################################################################
## Perform clustering using Kmeans
################################################################################################

# It looks like k=4 is a good number to use based on the elbow graph.
n_clusters = 4

means_cluster = sk_cluster.KMeans(n_clusters=n_clusters, random_state=111)
columns = ["orderRatio", "itemsRatio", "monetaryRatio", "frequency"]
est = means_cluster.fit(customer_data[columns])
clusters = est.labels_
customer_data['cluster'] = clusters

# Print some data about the clusters:

# For each cluster, count the members.
for c in range(n_clusters):
    cluster_members=customer_data[customer_data['cluster'] == c][:]
    print('Cluster{}(n={}):'.format(c, len(cluster_members)))
    print('-'* 17)
print(customer_data.groupby(['cluster']).mean())
```

## <a name="analyze-the-results"></a>Анализ результатов

Теперь, когда вы выполнили кластеризацию с помощью K-средних, следующим шагом является анализ результата и Просмотр сведений о действиях, которые можно выполнить.

Взгляните на средние значения кластеризации и размеры кластеров, выводимые из предыдущего сценария.

```results
Cluster0(n=31675):
-------------------
Cluster1(n=4989):
-------------------
Cluster2(n=1):
-------------------
Cluster3(n=671):
-------------------

         customer  orderRatio  itemsRatio  monetaryRatio  frequency
cluster
0        50854.809882    0.000000    0.000000       0.000000   0.000000
1        51332.535779    0.721604    0.453365       0.307721   1.097815
2        57044.000000    1.000000    2.000000     108.719154   1.000000
3        48516.023845    0.136277    0.078346       0.044497   4.271237
```

Четыре кластера означают использование переменных, определенных в [первой части](python-clustering-model-prepare-data.md#separate-customers):

* *ордерратио* = коэффициент возврата (общее количество заказов частично или полностью возвращено, а также общее количество заказов)
* *итемсратио* = коэффициент возвращаемых элементов (общее число возвращенных элементов в сравнении с количеством приобретенных элементов)
* *монетариратио* = коэффициент возврата суммы (всего денежных единиц, возвращенных в сравнении с приобретенным объемом)
* *Частота* = частота возврата

Интеллектуальный анализ данных с помощью K-средних часто требует дальнейшего анализа результатов и дальнейшие действия для лучшего понимания каждого кластера, но могут предоставить некоторые хорошие интересы.
Вот несколько способов интерпретации этих результатов:

* Кластер 0, вероятно, является группой клиентов, которые не активны (все значения равны нулю).
* Как правило, кластер 3 является группой, которая представляет собой поведение возврата.

Кластер 0 — это набор клиентов, которые явно неактивны. Возможно, вы можете ориентироваться на маркетинговые усилия по этой группе, чтобы активировать интерес к покупкам. На следующем шаге вы запрашиваете у базы данных адреса электронной почты клиентов в кластере 0, чтобы вы могли отправить им маркетинговую электронную почту.

## <a name="clean-up-resources"></a>Очистка ресурсов

Если вы не собираетесь продолжать работу с этим руководством, удалите базу данных tpcxbb_1gb из SQL Server.

## <a name="next-steps"></a>Следующие шаги

В третьей части этой серии руководств вы выполнили следующие действия:

* Определение числа кластеров для алгоритма K-средних
* Выполнение кластеризации
* Анализ результатов

Чтобы развернуть созданную модель машинного обучения, следуйте четвертой части этой серии руководств:

> [!div class="nextstepaction"]
> [Учебник. Развертывание модели кластеризации в Python с помощью SQL Server Службы машинного обучения](python-clustering-model-deploy.md)