---
title: Краткое руководство по типам данных и объектам R и SQL
description: В этом кратком руководстве описано, как работать с типами данных и объектами данных в R и SQL Server.
ms.prod: sql
ms.technology: machine-learning
ms.date: 01/04/2019
ms.topic: quickstart
author: dphansen
ms.author: davidph
ms.openlocfilehash: e8c8ccd60417d4c1d492d53041280ab0c8e318af
ms.sourcegitcommit: c1382268152585aa77688162d2286798fd8a06bb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/19/2019
ms.locfileid: "68345423"
---
# <a name="quickstart-handle-data-types-and-objects-using-r-in-sql-server"></a>Краткое руководство. Работа с типами данных и объектами с помощью R в SQL Server
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md-winonly](../../includes/appliesto-ss-xxxx-xxxx-xxx-md-winonly.md)]

В этом кратком руководстве вы получите практические сведения о распространенных проблемах, возникающих при перемещении данных между R и SQL Server. Опыт, который вы получаете в этом упражнении, предоставляет вам фундаментальные навыки при работе с данными в собственном сценарии.

Распространенные проблемы, которые следует иметь в начале:

+ Иногда типы данных не совпадают.
+ Неявные преобразования могут выполняться
+ Иногда требуются операции приведения и преобразования.
+ R и SQL используют разные объекты данных.

## <a name="prerequisites"></a>Предварительные требования

Предыдущее краткое руководство, [Проверка наличия R в SQL Server](quickstart-r-verify.md), содержит сведения и ссылки для настройки среды R, необходимой для этого краткого руководства.

## <a name="always-return-a-data-frame"></a>Всегда возвращать кадр данных

Когда скрипт возвращает результаты из R в SQL Server, он должен возвращать данные в виде **data.frame**. Любой другой тип объекта, создаваемого в скрипте — это список, коэффициент, вектор или двоичные данные, которые должны быть преобразованы в кадр данных, если требуется выводить их как часть результатов хранимой процедуры. К счастью существует несколько функций R, поддерживающих изменение других объектов на кадр данных. Вы даже можете сериализовать двоичную модель и возвратить ее в блок данных, что вы сделаете далее в этом руководстве.

Во-первых, давайте поэкспериментируем с некоторыми объектами r Basic R — векторами, матрицами и списками, и посмотрим, как преобразование в кадр данных изменяет выходные данные, передаваемые в SQL Server.

Сравните эти два сценария "Hello World" в R. Скрипты выглядят почти одинаково, но первый возвращает один столбец из трех значений, а второй возвращает три столбца с одним значением.

**Пример 1**

```sql
EXECUTE sp_execute_external_script
       @language = N'R'
     , @script = N' mytextvariable <- c("hello", " ", "world");
       OutputDataSet <- as.data.frame(mytextvariable);'
     , @input_data_1 = N' ';
```

**Пример 2**

```sql
EXECUTE sp_execute_external_script
        @language = N'R'
      , @script = N' OutputDataSet<- data.frame(c("hello"), " ", c("world"));'
      , @input_data_1 = N'  ';
```

## <a name="identify-schema-and-data-types"></a>Выявление схемы и типов данных

Почему результаты настолько отличаются? 

Обычно ответ можно найти, использовав команду R `str()`. Добавьте функцию `str(object_name)` в скрипте R для получения сведений о схеме данных возвращаемого объекта R в виде информационного сообщения. Сообщения можно просмотреть на панели **Сообщения** Visual Studio Code или на вкладке **Сообщения** в среде SSMS.

Чтобы понять, почему результаты примера 1 и 2 так сильно отличаются, вставьте строку `str(OutputDataSet)` в конце определения переменной _@script_ в каждой инструкции следующим образом:

**Пример 1 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script
        @language = N'R'
      , @script = N' mytextvariable <- c("hello", " ", "world");
      OutputDataSet <- as.data.frame(mytextvariable);
      str(OutputDataSet);'
      , @input_data_1 = N'  '
;
```

**Пример 2 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script
  @language = N'R', 
  @script = N' OutputDataSet <- data.frame(c("hello"), " ", c("world"));
    str(OutputDataSet);' , 
  @input_data_1 = N'  ';
```

Теперь просмотрите текст на вкладке **Сообщения**, в котором можно определить причину такой разницы.

**Результаты примера 1**

```sql
STDOUT message(s) from external script:
'data.frame':   3 obs. of  1 variable:
$ mytextvariable: Factor w/ 3 levels " ","hello","world": 2 1 3
```

**Результаты примера 2**

```sql
STDOUT message(s) from external script:
'data.frame':   1 obs. of  3 variables:
$ c..hello..: Factor w/ 1 level "hello": 1
$ X...      : Factor w/ 1 level " ": 1
$ c..world..: Factor w/ 1 level "world": 1
```

Как видно, небольшие изменения в синтаксисе R сильно повлияли на схему результатов. Мы не будем перейдем к тем, почему, но различия в типах данных R подробно описаны в разделе *Data* Structures статьи [«Advanced R» by Hadley Wickham](http://adv-r.had.co.nz).

Сейчас помните, что необходимо проверить ожидаемые результаты при приведении объектов R в кадры данных.

> [!TIP]
> Можно также использовать функции идентификации R, такие как `is.matrix`, `is.vector`для получения сведений о внутренней структуре данных.

## <a name="implicit-conversion-of-data-objects"></a>Неявное преобразование объектов данных

Каждый объект данных R имеет собственные правила обработки значений в сочетании с другими объектами данных, если объекты данных имеют одинаковое количество измерений или если любой объект данных содержит разнородные типы данных.

Например, предположим, что вы выполнили следующую инструкцию для умножения матриц с помощью R. Матрица с одним столбцом с тремя значениями умножается на массив с четырьмя значениями и предполагается, что в результате 4x3 матрица.

```sql
EXECUTE sp_execute_external_script
    @language = N'R'
    , @script = N'
        x <- as.matrix(InputDataSet);
        y <- array(12:15);
    OutputDataSet <- as.data.frame(x %*% y);'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
    WITH RESULT SETS (([Col1] int, [Col2] int, [Col3] int, Col4 int));
```

Один столбец с тремя значениями преобразуется в матрицу с одним столбцом. Так как матрица представляет собой особый вид массива в R, массив `y` неявно приводится к матрице с одним столбцом, чтобы обеспечить соответствие двух аргументов.

**Результаты**

|Col1|Col2|Col3|Col4|
|---|---|---|---|
|12|13|14|15|
|120|130|140|150|
|1200|1300|1400|1500|

Однако обратите внимание, что происходит при изменении размера массива `y`.

```sql
execute sp_execute_external_script
   @language = N'R'
   , @script = N'
        x <- as.matrix(InputDataSet);
        y <- array(12:14);
   OutputDataSet <- as.data.frame(y %*% x);'
   , @input_data_1 = N' SELECT [Col1]  from RTestData;'
   WITH RESULT SETS (([Col1] int ));
```

На этот раз код R вернет одно значение в качестве результата.

**Результаты**
    
|Col1|
|---|
|1542|

Почему? В этом случае, поскольку два аргумента могут обрабатываться как векторы одинаковой длины, R возвращает внутренний продукт в виде матрицы.  Это ожидаемое поведение в соответствии с правилами линейной алгебры. Тем не менее могут возникнуть проблемы, если нисходящее приложение ожидает, что выходная схема вывода не должна изменяться.

> [!TIP]
> 
> Получить ошибки? Для этих примеров требуется таблица **RTestData**. Если вы еще не создали таблицу тестовых данных, вернитесь к этому разделу, чтобы создать таблицу. [Обрабатывает входные и выходные данные](../tutorials/rtsql-working-with-inputs-and-outputs.md).
> 
> Если таблица была создана, но по-прежнему возникает ошибка, убедитесь, что хранимая процедура выполняется в контексте базы данных, содержащей таблицу, а не в **главной** или другой базе данных.
> 
> Кроме того, мы рекомендуем не использовать временные таблицы для этих примеров. Некоторые клиенты R будут завершать подключение между пакетами, удаляя временные таблицы.

## <a name="merge-or-multiply-columns-of-different-length"></a>Слияние или перемножение столбцов разной длины

R обеспечивает большую гибкость при работе с векторами различных размеров, а также для объединения этих структур, таких как столбцы, к кадрам данных. Списки векторов могут выглядеть как таблица, но они не подчиняются всем правилам, управляющим таблицами базы данных.

Например, следующий скрипт определяет числовой массив, длина которого равна 6, и сохраняет его в переменной R `df1`. Затем числовой массив объединяется с целыми числами таблицы RTestData, которая содержит три (3) значения, для создания нового кадра `df2`данных.

```sql
EXECUTE sp_execute_external_script
    @language = N'R'
    , @script = N'
               df1 <- as.data.frame( array(1:6) );
               df2 <- as.data.frame( c( InputDataSet , df1 ));
               OutputDataSet <- df2'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
    WITH RESULT SETS (( [Col2] int not null, [Col3] int not null ));
```

Чтобы заполнить кадр данных, R повторно использует элементы, полученные из RTestData, столько раз, сколько требуется в соответствии с числом элементов в массиве `df1`.

**Результаты**
    
|*Col2*|*Col3*|
|----|----|
|1|1|
|10|2|
|100|3|
|1|4|
|10|5|
|100|6|

Помните, что кадр данных только выглядит как таблица и на самом деле является списком векторов.

## <a name="cast-or-convert-sql-server-data"></a>Приведение или преобразование данных SQL Server

R и SQL Server используют разные типы данных, поэтому при выполнении запроса в SQL Server для получения данных и их передаче в среду выполнения R обычно выполняется неявное преобразование. Кроме того, преобразования выполняются при возвращении данных из R в SQL Server.

- SQL Server передает данные из запроса в процесс R, управляемый службой панели запуска, и преобразует их во внутреннее представление для повышения эффективности.
- Среда выполнения R загружает данные в переменную data.frame и выполняет собственные операции с данными.
- Ядро СУБД возвращает данные в SQL Server по защищенному внутреннему соединению и представляет данные в контексте типов данных SQL Server.
- Вы можете получить данные путем подключения к SQL Server с помощью клиентской или сетевой библиотеки, которая может выполнять запросы SQL и обрабатывать табличные наборы данных. Это клиентское приложение может и по-другому влиять на данные.

Чтобы увидеть, как это работает, выполните такой запрос в хранилище данных [AdventureWorksDW](https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks) . Это представление возвращает данные продаж, используемые для создания прогнозов.

```sql
USE AdventureWorksDW
GO

SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = 'M200 Europe'
           ORDER BY ReportingDate ASC
```

> [!NOTE]
> 
> Можно использовать любую версию AdventureWorks или создать другой запрос, используя собственную базу данных. Точка заключается в попытке выполнить обработку некоторых данных, содержащих текстовые, DateTime и числовые значения.

Теперь попробуйте выполнить этот запрос в качестве входных данных для хранимой процедуры.

```sql
EXECUTE sp_execute_external_script
       @language = N'R'
      , @script = N' str(InputDataSet);
      OutputDataSet <- InputDataSet;'
      , @input_data_1 = N'
           SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = ''M200 Europe''
           ORDER BY ReportingDate ASC ;'
WITH RESULT SETS undefined;
```

Если появляется сообщение об ошибке, возможно, необходимо внести некоторые изменения в текст запроса. Например, строковый предикат в предложении WHERE нужно заключать в два набора одинарных кавычек.

После того, как запрос начнет действовать, просмотрите результаты выполнения функции `str`, чтобы увидеть, как R обрабатывает входные данные.

**Результаты**

```sql
STDOUT message(s) from external script: 'data.frame':    37 obs. of  3 variables:
STDOUT message(s) from external script: $ ReportingDate: POSIXct, format: "2010-12-24 23:00:00" "2010-12-24 23:00:00"
STDOUT message(s) from external script: $ ProductSeries: Factor w/ 1 levels "M200 Europe",..: 1 1 1 1 1 1 1 1 1 1
STDOUT message(s) from external script: $ Amount       : num  3400 16925 20350 16950 16950
```

+ Столбец datetime был обработан с использованием типа данных R **POSIXct**.
+ Текстовый столбец "ProductSeries" определен как **фактор**, что означает переменную категории. Строковые значения обрабатываются как коэффициенты по умолчанию. Если передать строку в R, она преобразуется в целое число для внутреннего использования и сопоставляется со строками на выходе.

### <a name="summary"></a>Сводка

Даже в этих кратких примерах можно увидеть, как следует проверять последствия преобразования данных при передаче запросов SQL в качестве входных данных. Поскольку некоторые типы данных SQL Server не поддерживаются R, рассмотрите следующие способы избежать ошибок:

+ Протестируйте данные заранее и проверьте столбцы или значения в схеме, которые могут стать проблемой при передаче в код R.
+ Указывайте столбцы из источника входных данных по отдельности. Не используйте `SELECT *`. Определите способ обработки каждого столбца.
+ Во избежание непредвиденных ситуаций во время подготовки входных данных при необходимости выполняйте явные приведения.
+ Избегайте передачи столбцов данных (например, идентификаторов GUID или ROWGUID), которые вызывают ошибки и не полезны для моделирования.

Дополнительные сведения о поддерживаемых и неподдерживаемых типах данных см. в разделе [библиотеки и типы данных R](../r/r-libraries-and-data-types.md).

Сведения о влиянии преобразования строк в числовые факторы на производительность во время выполнения см. в разделе [SQL Server R Servicesная Настройка производительности](../r/sql-server-r-services-performance-tuning.md).

## <a name="next-step"></a>Следующий шаг

В следующем кратком руководстве вы узнаете, как применять функции R к SQL Serverным данным.

> [!div class="nextstepaction"]
> [QuickStart Использование функций R с данными SQL Server](quickstart-r-functions.md)
