---
title: Работа с типами данных и объектами R и SQL
titleSuffix: SQL Server Machine Learning Services
description: В этом кратком руководстве описано, как работать с типами данных и объектами данных в R и SQL Server с помощью SQL Server Службы машинного обучения.
ms.prod: sql
ms.technology: machine-learning
ms.date: 10/04/2019
ms.topic: quickstart
author: garyericson
ms.author: garye
ms.reviewer: davidph
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: 0e490821194e909643e5307e833f093363cb9558
ms.sourcegitcommit: 454270de64347db917ebe41c081128bd17194d73
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72006010"
---
# <a name="quickstart-handle-data-types-and-objects-using-r-in-sql-server-machine-learning-services"></a>Краткое руководство. Работа с типами данных и объектами с помощью R в SQL Server Службы машинного обучения
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

В этом кратком руководстве вы узнаете об общих проблемах, возникающих при перемещении данных между R и SQL Server. Опыт, который вы получаете в этом упражнении, предоставляет вам фундаментальные навыки при работе с данными в собственном сценарии.

Распространенные проблемы, которые следует иметь в начале:

- Иногда типы данных не совпадают
- Неявные преобразования могут выполняться
- Иногда требуются операции приведения и преобразования.
- R и SQL используют разные объекты данных.

## <a name="prerequisites"></a>Предварительные требования

- Для этого краткого руководства требуется доступ к экземпляру SQL Server с [SQL Server службы машинного обучения](../install/sql-machine-learning-services-windows-install.md) с установленным языком R.

  Ваш экземпляр SQL Server может находиться на виртуальной машине Azure или в локальной среде. Просто имейте в виду, что функция внешних скриптов по умолчанию отключена, поэтому может потребоваться [включить внешние сценарии](../install/sql-machine-learning-services-windows-install.md#bkmk_enableFeature) и убедиться, что **Служба панель запуска SQL Server** запущена перед началом работы.

- Вам также понадобится средство для выполнения SQL-запросов, содержащих скрипты R. Эти сценарии можно выполнять с помощью любого средства управления базами данных или запросов, если они могут подключаться к SQL Server экземпляру и выполнять запрос T-SQL или хранимую процедуру. В этом кратком руководстве используется [SQL Server Management Studio (SSMS)](https://docs.microsoft.com/sql/ssms/sql-server-management-studio-ssms).

## <a name="always-return-a-data-frame"></a>Всегда возвращать кадр данных

Когда скрипт возвращает результаты из R в SQL Server, он должен возвращать данные в виде **data.frame**. Любой другой тип объекта, создаваемого в скрипте — это список, коэффициент, вектор или двоичные данные, которые должны быть преобразованы в кадр данных, если требуется выводить их как часть результатов хранимой процедуры. К счастью существует несколько функций R, поддерживающих изменение других объектов на кадр данных. Можно даже сериализовать двоичную модель и вернуть ее в кадр данных, что будет сделано позже в этом кратком руководстве.

Во-первых, давайте поэкспериментируем с некоторыми объектами r Basic R — векторами, матрицами и списками, и посмотрим, как преобразование в кадр данных изменяет выходные данные, передаваемые в SQL Server.

Сравните эти два сценария "Hello World" в R. Скрипты выглядят почти одинаково, но первый возвращает один столбец из трех значений, а второй возвращает три столбца с одним значением.

**Пример 1**

```sql
EXECUTE sp_execute_external_script
       @language = N'R'
     , @script = N' mytextvariable <- c("hello", " ", "world");
       OutputDataSet <- as.data.frame(mytextvariable);'
     , @input_data_1 = N' ';
```

**Пример 2**

```sql
EXECUTE sp_execute_external_script
        @language = N'R'
      , @script = N' OutputDataSet<- data.frame(c("hello"), " ", c("world"));'
      , @input_data_1 = N'  ';
```

## <a name="identify-schema-and-data-types"></a>Выявление схемы и типов данных

Почему результаты настолько отличаются?

Обычно ответ можно найти, использовав команду R `str()`. Добавьте функцию `str(object_name)` в скрипте R для получения сведений о схеме данных возвращаемого объекта R в виде информационного сообщения. Сообщения можно просмотреть на панели **Сообщения** Visual Studio Code или на вкладке **Сообщения** в среде SSMS.

Чтобы понять, почему результаты примера 1 и 2 так сильно отличаются, вставьте строку `str(OutputDataSet)` в конце определения переменной _@script_ в каждой инструкции следующим образом:

**Пример 1 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script
        @language = N'R'
      , @script = N' mytextvariable <- c("hello", " ", "world");
      OutputDataSet <- as.data.frame(mytextvariable);
      str(OutputDataSet);'
      , @input_data_1 = N'  '
;
```

**Пример 2 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script
  @language = N'R', 
  @script = N' OutputDataSet <- data.frame(c("hello"), " ", c("world"));
    str(OutputDataSet);' , 
  @input_data_1 = N'  ';
```

Теперь просмотрите текст на вкладке **Сообщения**, в котором можно определить причину такой разницы.

**Результаты примера 1**

```sql
STDOUT message(s) from external script:
'data.frame':   3 obs. of  1 variable:
$ mytextvariable: Factor w/ 3 levels " ","hello","world": 2 1 3
```

**Результаты примера 2**

```sql
STDOUT message(s) from external script:
'data.frame':   1 obs. of  3 variables:
$ c..hello..: Factor w/ 1 level "hello": 1
$ X...      : Factor w/ 1 level " ": 1
$ c..world..: Factor w/ 1 level "world": 1
```

Как видно, небольшие изменения в синтаксисе R сильно повлияли на схему результатов. Мы не будем перейдем к тем, почему, но различия в типах данных R подробно описаны в разделе *Data* Structures статьи [«Advanced R» by Hadley Wickham](http://adv-r.had.co.nz).

Сейчас помните, что необходимо проверить ожидаемые результаты при приведении объектов R в кадры данных.

> [!TIP]
> Можно также использовать функции идентификации R, такие как `is.matrix`, `is.vector`, чтобы получить сведения о внутренней структуре данных.

## <a name="implicit-conversion-of-data-objects"></a>Неявное преобразование объектов данных

Каждый объект данных R имеет собственные правила обработки значений в сочетании с другими объектами данных, если объекты данных имеют одинаковое количество измерений или если любой объект данных содержит разнородные типы данных.

Сначала создайте небольшую таблицу тестовых данных.

```sql
CREATE TABLE RTestData (col1 INT NOT NULL)

INSERT INTO RTestData
VALUES (1);

INSERT INTO RTestData
VALUES (10);

INSERT INTO RTestData
VALUES (100);
GO
```

Например, предположим, что вы выполнили следующую инструкцию для умножения матриц с помощью R. Матрица с одним столбцом с тремя значениями умножается на массив с четырьмя значениями и предполагается, что в результате 4x3 матрица.

```sql
EXECUTE sp_execute_external_script
    @language = N'R'
    , @script = N'
        x <- as.matrix(InputDataSet);
        y <- array(12:15);
    OutputDataSet <- as.data.frame(x %*% y);'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
    WITH RESULT SETS (([Col1] int, [Col2] int, [Col3] int, Col4 int));
```

Один столбец с тремя значениями преобразуется в матрицу с одним столбцом. Так как матрица представляет собой особый вид массива в R, массив `y` неявно приводится к матрице с одним столбцом, чтобы обеспечить соответствие двух аргументов.

**Результаты**

|Col1|Col2|Col3|Col4|
|---|---|---|---|
|12|13|14|15|
|120|130|140|150|
|1200|1300|1400|1500|

Однако обратите внимание, что происходит при изменении размера массива `y`.

```sql
execute sp_execute_external_script
   @language = N'R'
   , @script = N'
        x <- as.matrix(InputDataSet);
        y <- array(12:14);
   OutputDataSet <- as.data.frame(y %*% x);'
   , @input_data_1 = N' SELECT [Col1]  from RTestData;'
   WITH RESULT SETS (([Col1] int ));
```

На этот раз код R вернет одно значение в качестве результата.

**Результаты**

|Col1|
|---|
|1542|

Почему? В этом случае, поскольку два аргумента могут обрабатываться как векторы одинаковой длины, R возвращает внутренний продукт в виде матрицы.  Это ожидаемое поведение в соответствии с правилами линейной алгебры. Тем не менее могут возникнуть проблемы, если нисходящее приложение ожидает, что выходная схема вывода не должна изменяться.

> [!TIP]
> 
> Получить ошибки? Убедитесь, что хранимая процедура выполняется в контексте базы данных, содержащей таблицу, а не в **главной** или другой базе данных.
>
> Кроме того, мы рекомендуем не использовать временные таблицы для этих примеров. Некоторые клиенты R будут завершать подключение между пакетами, удаляя временные таблицы.

## <a name="merge-or-multiply-columns-of-different-length"></a>Слияние или перемножение столбцов разной длины

R обеспечивает большую гибкость при работе с векторами различных размеров, а также для объединения этих структур, таких как столбцы, к кадрам данных. Списки векторов могут выглядеть как таблица, но они не подчиняются всем правилам, управляющим таблицами базы данных.

Например, следующий скрипт определяет числовой массив, длина которого равна 6, и сохраняет его в переменной R `df1`. Затем числовой массив объединяется с целыми числами таблицы RTestData, которая содержит три (3) значения, для создания нового кадра данных `df2`.

```sql
EXECUTE sp_execute_external_script
    @language = N'R'
    , @script = N'
               df1 <- as.data.frame( array(1:6) );
               df2 <- as.data.frame( c( InputDataSet , df1 ));
               OutputDataSet <- df2'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
    WITH RESULT SETS (( [Col2] int not null, [Col3] int not null ));
```

Чтобы заполнить кадр данных, R повторно использует элементы, полученные из RTestData, столько раз, сколько требуется в соответствии с числом элементов в массиве `df1`.

**Результаты**

|*Col2*|*Col3*|
|----|----|
|1|1|
|10|2|
|100|3|
|1|4|
|10|5|
|100|6|

Помните, что кадр данных только выглядит как таблица и на самом деле является списком векторов.

## <a name="cast-or-convert-sql-server-data"></a>Приведение или преобразование данных SQL Server

R и SQL Server используют разные типы данных, поэтому при выполнении запроса в SQL Server для получения данных и их передаче в среду выполнения R обычно выполняется неявное преобразование. Кроме того, преобразования выполняются при возвращении данных из R в SQL Server.

- SQL Server передает данные из запроса в процесс R, управляемый службой панели запуска, и преобразует их во внутреннее представление для повышения эффективности.
- Среда выполнения R загружает данные в переменную data.frame и выполняет собственные операции с данными.
- Ядро СУБД возвращает данные в SQL Server по защищенному внутреннему соединению и представляет данные в контексте типов данных SQL Server.
- Вы можете получить данные путем подключения к SQL Server с помощью клиентской или сетевой библиотеки, которая может выполнять запросы SQL и обрабатывать табличные наборы данных. Это клиентское приложение может и по-другому влиять на данные.

Чтобы увидеть, как это работает, выполните такой запрос в хранилище данных [AdventureWorksDW](https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks) . Это представление возвращает данные продаж, используемые для создания прогнозов.

```sql
USE AdventureWorksDW
GO

SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = 'M200 Europe'
           ORDER BY ReportingDate ASC
```

> [!NOTE]
>
> Можно использовать любую версию AdventureWorks или создать другой запрос, используя собственную базу данных. Точка заключается в попытке выполнить обработку некоторых данных, содержащих текстовые, DateTime и числовые значения.

Теперь попробуйте выполнить этот запрос в качестве входных данных для хранимой процедуры.

```sql
EXECUTE sp_execute_external_script
       @language = N'R'
      , @script = N' str(InputDataSet);
      OutputDataSet <- InputDataSet;'
      , @input_data_1 = N'
           SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = ''M200 Europe''
           ORDER BY ReportingDate ASC ;'
WITH RESULT SETS undefined;
```

Если появляется сообщение об ошибке, возможно, необходимо внести некоторые изменения в текст запроса. Например, строковый предикат в предложении WHERE нужно заключать в два набора одинарных кавычек.

После того, как запрос начнет действовать, просмотрите результаты выполнения функции `str`, чтобы увидеть, как R обрабатывает входные данные.

**Результаты**

```sql
STDOUT message(s) from external script: 'data.frame':    37 obs. of  3 variables:
STDOUT message(s) from external script: $ ReportingDate: POSIXct, format: "2010-12-24 23:00:00" "2010-12-24 23:00:00"
STDOUT message(s) from external script: $ ProductSeries: Factor w/ 1 levels "M200 Europe",..: 1 1 1 1 1 1 1 1 1 1
STDOUT message(s) from external script: $ Amount       : num  3400 16925 20350 16950 16950
```

- Столбец datetime был обработан с использованием типа данных R **POSIXct**.
- Текстовый столбец "ProductSeries" определен как **фактор**, что означает переменную категории. Строковые значения обрабатываются как коэффициенты по умолчанию. Если передать строку в R, она преобразуется в целое число для внутреннего использования и сопоставляется со строками на выходе.

### <a name="summary"></a>Сводка

Даже в этих кратких примерах можно увидеть, как следует проверять последствия преобразования данных при передаче запросов SQL в качестве входных данных. Поскольку некоторые типы данных SQL Server не поддерживаются R, рассмотрите следующие способы избежать ошибок:

- Протестируйте данные заранее и проверьте столбцы или значения в схеме, которые могут стать проблемой при передаче в код R.
- Указывайте столбцы из источника входных данных по отдельности. Не используйте `SELECT *`. Определите способ обработки каждого столбца.
- Во избежание непредвиденных ситуаций во время подготовки входных данных при необходимости выполняйте явные приведения.
- Избегайте передачи столбцов данных (например, идентификаторов GUID или ROWGUID), которые вызывают ошибки и не полезны для моделирования.

Дополнительные сведения о поддерживаемых и неподдерживаемых типах данных см. в разделе [библиотеки и типы данных R](../r/r-libraries-and-data-types.md).

Сведения о влиянии преобразования строк в числовые факторы на производительность во время выполнения см. в разделе [SQL Server R Servicesная Настройка производительности](../r/sql-server-r-services-performance-tuning.md).

## <a name="next-steps"></a>Следующие шаги

Чтобы узнать о написании расширенных функций R в SQL Server, следуйте указаниям в этом кратком руководстве:

> [!div class="nextstepaction"]
> [Написание расширенных функций R с помощью SQL Server Службы машинного обучения](quickstart-r-functions.md)

Дополнительные сведения об использовании R в SQL Server Службы машинного обучения см. в следующих статьях:

- [Создание и оценка прогнозной модели в R с помощью SQL Server Службы машинного обучения](quickstart-r-train-score-model.md)
- [Что такое Службы машинного обучения SQL Server (Python и R)?](../what-is-sql-server-machine-learning.md)
