---
title: Выполнение пользовательских функций R на SQL Server с помощью RevoScaleR rxExec - машинного обучения SQL Server
description: Руководство о том, как запустить настраиваемый скрипт R в SQL Server с помощью функций RevoScaleR.
ms.prod: sql
ms.technology: machine-learning
ms.date: 11/27/2018
ms.topic: tutorial
author: dphansen
ms.author: davidph
ms.openlocfilehash: c9cb9d84637d20f3f0e73f97fa6565d84d12fb4e
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "67961952"
---
# <a name="run-custom-r-functions-on-sql-server-using-rxexec"></a>Выполнения пользовательских функций R на SQL Server с помощью rxExec
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md-winonly](../../includes/appliesto-ss-xxxx-xxxx-xxx-md-winonly.md)]

Можно выполнять пользовательские функции R в контексте SQL Server, передав функции через [rxExec](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rxexec)при условии, что все библиотеки, сценарий требует также устанавливаются на сервере, и эти библиотеки, совместимы с базой Распределение R. 

**RxExec** работать в **RevoScaleR** предоставляет механизм для запуска любого скрипта R, вам требуется. Кроме того **rxExec** может явно распределить нагрузку между несколькими ядрами на одном сервере, добавление масштабирования в сценарии, в противном случае ограниченные ресурсы, потребляемые собственного модуля R.

В этом руководстве используется смоделированные данные для демонстрации выполнения пользовательскую функцию R, которая выполняется на удаленном сервере.

## <a name="prerequisites"></a>Предварительные требования

+ [Службы машинного обучения SQL Server 2017 (с помощью R)](../install/sql-machine-learning-services-windows-install.md) или [SQL Server 2016 R Services (в базе данных)](../install/sql-r-services-windows-install.md)
  
+ [Разрешения базы данных](../security/user-permission.md) и имя входа пользователя базы данных SQL Server

+ [Рабочей станции разработки с помощью библиотек RevoScaleR](../r/set-up-a-data-science-client.md)

Распределение R на клиентской рабочей станции предусмотрены встроенные **Rgui** средство, которое можно использовать для выполнения сценария r. в этом руководстве. Также можно использовать интегрированную среду разработки, например RStudio или инструменты R для Visual Studio.

## <a name="create-the-remote-compute-context"></a>Создайте контекст удаленных вычислений

Выполните следующие команды R на клиентской рабочей станции. Например, при использовании **Rgui**, запустите его из этого расположения: C:\Program Files\Microsoft\R Client\R_SERVER\bin\x64\.

1. Укажите строку подключения для экземпляра SQL Server, где вычисления выполняются. Сервер должен быть настроен для интеграции R. Имя базы данных не используется в этом упражнении, но строка подключения требует один. Если у вас есть тест или образец базы данных, можно использовать.

    **Использование имени для входа SQL**

    ```R
    sqlConnString <- "Driver=SQL Server;Server=<SQL-Server-instance-name>; Database=<database-name>;Uid=<SQL-user-name>;Pwd=<password>"
    ```

    **Использование проверки подлинности Windows**

    ```R
    sqlConnString <- "Driver=SQL Server;Server=<SQL-Server-instance-name>;Database=<database-name>;Trusted_Connection=True"
    ```

2. Создайте контекст удаленных вычислений к экземпляру SQL Server, указанный в строке подключения.

    ```R
    sqlCompute <- RxInSqlServer(connectionString = sqlConnString)
    ```

3. Активировать контекст вычисления и затем возвращают определение объекта в качестве шага подтверждения. Вы увидите свойства объекта контекста вычислений.

    ```R
    rxSetComputeContext(sqlCompute)
    rxGetComputeContext()
    ```

## <a name="create-the-custom-function"></a>Создайте пользовательскую функцию

В этом упражнении вы создадите пользовательскую функцию R, которая имитирует распространенных casino, состоящий из бросании dice. Правила игры определяют win или потери результат:

+ Развертывания на платформе на первом броске выпала сумма 7 или 11, вы выигрываете.
+ Откатить 2, 3 или 12, будут потеряны.
+ Откатить 4, 5, 6, 8, 9 или 10, это число становится точка и можно продолжать бросать кости, пока вы выпадет точка еще раз (в этом случае вы победили) или сумма, 7, в котором случае вы не потеряете.

Эту игру легко смоделировать в R, создав пользовательскую функцию, которую затем можно выполнять много раз.

1.  Создайте пользовательскую функцию, используя следующий код R:
  
    ```R
    rollDice <- function()
    {
        result <- NULL
        point <- NULL
        count <- 1
            while (is.null(result))
            {
                roll <- sum(sample(6, 2, replace=TRUE))
  
                if (is.null(point))
                { point <- roll }
                if (count == 1 && (roll == 7 || roll == 11))
                {  result <- "Win" }
                else if (count == 1 && (roll == 2 || roll == 3 || roll == 12))
                { result <- "Loss" }
                else if (count > 1 && roll == 7 )
                { result <- "Loss" }
                else if (count > 1 && point == roll)
                { result <- "Win" }
                else { count <- count + 1 }
            }
            result
    }
    ```
  
2.  Смоделировать одну игру в кости, выполнением функции.
  
    ```R
    rollDice()
    ```
  
    Выиграли вы или проиграли?
  
Теперь, когда у вас есть сценарий оперативной, давайте посмотрим, как можно использовать **rxExec** для выполнения функции несколько раз, чтобы создать моделирование, позволяющее определить вероятность выигрыша.

## <a name="pass-rolldice-in-rxexec"></a>Передайте rollDice() rxExec

Чтобы выполнить произвольную функцию в контексте удаленный экземпляр SQL Server, вызовите **rxExec** функции.

1. Вызовите эту пользовательскую функцию в качестве аргумента **rxExec**вместе с другими параметрами, которые изменяют симулятор.
  
    ```R
    sqlServerExec <- rxExec(rollDice, timesToRun=20, RNGseed="auto")
    length(sqlServerExec)
    ```
  
    + Аргумент *timesToRun* позволяет указать, сколько раз должна выполняться функция.  В этом случае кости бросаются 20 раз.
  
    + Аргументы *RNGseed* и *RNGkind* позволяют управлять генерацией случайных чисел. Если параметр *RNGseed* имеет значение **auto**, в каждом рабочем процессе инициализируется параллельный поток случайных чисел.
  
2. Функция **rxExec** создает список с одним элементом для каждого запуска, однако, пока список не заполнится, практически ничего происходить не будет. Когда все итерации будут завершены, строку, начинающуюся с **длина** будет возвращать значение.
  
    После этого можно перейти к следующему шагу, чтобы получить сводку по выигрышам и проигрышам.
  
3. Преобразуйте полученный список в вектор с помощью функции R **unlist** и обобщите результаты с помощью функции **table** .
  
    ```R
    table(unlist(sqlServerExec))
    ```
  
    Результаты должны выглядеть примерно так:
  
     *Проигрыш выигрыш* *12 8*

## <a name="conclusion"></a>Заключение

Несмотря на то, что в этом упражнении упрощенный, он демонстрирует важным механизмом для интеграции произвольных функций R в скрипт R, работающий на сервере SQL Server. Итак ключевые моменты, которые делают этот прием можно следующим образом.

+ Необходимо настроить SQL Server для машинного обучения и интеграция R: [Службы машинного обучения SQL Server 2017](../install/sql-machine-learning-services-windows-install.md) с помощью функции R, или [SQL Server 2016 R Services (в базе данных)](../install/sql-r-services-windows-install.md).

+ Открытым кодом или сторонние библиотеки, используемые в функции, включая все зависимости, необходимо установить на сервере SQL Server. Дополнительные сведения см. в разделе [Установка новых пакетов R](../r/install-additional-r-packages-on-sql-server.md).

+ Перемещение скрипт из среды разработки в жесткой рабочей среде может стать причиной ограничения брандмауэра и сети. Проверьте тщательно, чтобы убедиться в том, что сценарий может как ожидалось.

## <a name="next-steps"></a>Следующие шаги

Более сложный пример использования **rxExec**, см. в статье: [Параллелизм грубое детализации в foreach и rxExec](https://blog.revolutionanalytics.com/2015/04/coarse-grain-parallelism-with-foreach-and-rxexec.html)
