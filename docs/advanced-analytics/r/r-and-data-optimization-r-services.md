---
title: Настройка производительности для оптимизации данных - службы машинного обучения SQL Server
ms.prod: sql
ms.technology: machine-learning
ms.date: 04/15/2018
ms.topic: conceptual
author: dphansen
ms.author: davidph
manager: cgronlun
ms.openlocfilehash: 4fdc699437ef44d32e944d810e9e38571d20472c
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "62642279"
---
# <a name="performance-for-r-services---data-optimization"></a>Производительность службы R — оптимизация данных
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md-winonly](../../includes/appliesto-ss-xxxx-xxxx-xxx-md-winonly.md)]

В этой статье — третья в серии, описывает оптимизацию производительности для служб R, в зависимости от двух исследований. В этой статье рассматриваются оптимизацию производительности для R или Python сценарии, выполняемые в SQL Server. Здесь также описываются методы, которые можно использовать для обновления кода R, для повышения производительности и для предотвращения известных проблем.

## <a name="choosing-a-compute-context"></a>Выбор контекста вычислений

В SQL Server 2016 и 2017, можно использовать либо **локального** или **SQL** контекста вычислений во время запуска скрипта R или Python.

При использовании **локального** контекста вычислений анализ выполняется на компьютере, а не на сервере. Таким образом при получении данных из SQL Server для использования в коде, необходимо извлечь данные по сети. Снижение производительности, вызванное такой передачей по сети, зависит от объема передаваемых данных, скорости сети и других передач данных по сети, выполняемых одновременно.

При использовании **контекста вычислений SQL Server**, код выполняется на сервере. При получении данных из SQL Server, данные должны быть локально на сервере под управлением анализа, и поэтому вводится без нагрузки на сеть. Если вам нужно импортировать данные из других источников, рассмотрите возможность заранее упорядочение ETL.

При работе с большими наборами данных следует всегда использовать контекст вычислений SQL.

## <a name="factors"></a>Факторы

Язык R использует концепцию *факторов*, которые являются специальная переменная для категориальных данных. Специалисты по анализу данных часто используют переменные коэффициентов в формулах, так как обработка категориальные переменные как коэффициенты гарантирует, что данные правильно обрабатывается функций машинного обучения. Дополнительные сведения см. в разделе [R для «чайников»: Переменными](https://www.dummies.com/programming/r/how-to-look-at-the-structure-of-a-factor-in-r/).

По своей структуре факторные переменные может быть преобразован из строки в целые числа и обратно, для хранения или обработки. R `data.frame` функция обрабатывает все строки как переменные идентификации, если аргумент *stringsasfactors значения* присваивается **False**. Это значит, что строки являются автоматически преобразуется в целое число для обработки и затем сопоставляется в исходную строку.

Если исходные данные на предмет факторов хранится как целое число, может наблюдаться снижение производительности, так как R преобразует коэффициент целых чисел в строки во время выполнения, а затем выполняет собственную внутреннее преобразование строки в целое число.

Чтобы избежать таких преобразований времени выполнения, рекомендуется хранить значения как целые числа в таблице SQL Server и с помощью _colInfo_ аргумент для указания уровней для столбца, используемого в качестве фактора. Большинство объектов источников данных в RevoScaleR принимают параметр _colInfo_. Этот параметр позволяет называть переменные, используемые в источнике данных, указывать их тип и определить уровни переменные или преобразований по значениям столбца.

Например следующий вызов функции R возвращает целых чисел, 1, 2 и 3 из таблицы, но сопоставляет значения в фактор с уровнями «apple», «orange» и «banana».

```R
c("fruit" = c(type = "factor", levels=as.character(c(1:3)), newLevels=c("apple", "orange", "banana")))
```

Если исходный столбец содержит строки, это всегда более эффективно для определения уровней, заранее с помощью _colInfo_ параметра. Например следующий код R обрабатывает строки как факторы, как во время чтения.

```R
c("fruit" = c(type = "factor", levels= c("apple", "orange", "banana")))
```

Если нет семантических различий в модели поколении, последний подход может привести к более высокую производительность.

## <a name="data-transformations"></a>Преобразования данных

Специалисты по анализу и обработке данных часто используют функции преобразования, написанные на языке R, в процессе анализа. Функции преобразования применяется к каждой строке, полученной из таблицы. В SQL Server таких преобразований применяются ко всем строкам, полученные в пакете, в которой требуется обмен данными между интерпретатором R, а также модуль аналитики. Чтобы выполнить преобразование, данные перемещаются из SQL в подсистему аналитики, а затем в процесс интерпретатора R и обратно.

По этой причине использование преобразований как часть кода R может иметь значительное отрицательное влияние на производительность этого алгоритма, в зависимости от объема тестовых данных.

Он является более эффективным, чтобы добавить все необходимые столбцы в таблицу или представление перед анализом и избежать преобразований во время вычисления. Если вы не можете добавить дополнительные столбцы к существующим таблицам, создайте другую таблицу или представление с преобразованными столбцами и используйте соответствующий запрос для получения данных.

## <a name="batch-row-reads"></a>Считывает строки пакетной службы

Если вы используете источник данных SQL Server (`RxSqlServerData`) в коде, мы рекомендуем попробовать использовать параметр _rowsPerRead_ для указания размера пакета. Этот параметр определяет количество строк, которые, запрашиваются и затем отправлено внешних скриптов для обработки. Во время выполнения алгоритма видит указанным числом строк в каждом пакете.

Возможность управлять объемом данных, обрабатываемых одновременно может помочь решить или избежать проблем. Например, если входной набор данных является очень широкие (содержит много столбцов), или если набор данных содержит несколько больших столбцов (например, произвольный текст), можно уменьшить размер пакета, чтобы избежать разбиение по страницам данных не хватает памяти.

По умолчанию значение этого параметра имеет значение 50 000, чтобы обеспечить неплохую производительность даже на компьютерах с недостаточным объемом памяти. Если на сервере имеется достаточно памяти, увеличение этого значения до 500 000 или даже до миллиона может привести к повышению производительности, особенно для больших таблиц.

Преимущества увеличение размера пакета, становились заметны, на основе большого набора данных, а также в задачу, которая выполняется на нескольких процессов. Тем не менее увеличение этого значения не всегда дают наилучшие результаты. Мы рекомендуем экспериментировать с данными и алгоритм для определения оптимального значения.

## <a name="parallel-processing"></a>Параллельная обработка

Чтобы повысить производительность **rx** аналитические функции можно использовать возможность выполнять задачи параллельно, используя доступные ядра на компьютере сервера SQL Server.

Существует два способа достижения параллелизации с языком R в SQL Server:

-   **Используйте \@parallel.** При использовании хранимой процедуры `sp_execute_external_script` для выполнения скрипта R установите для параметра `@parallel` значение `1`. Это наилучший способ, если ваш скрипт R выполняет **не** использовать функции RevoScaleR, которые имеют другие механизмы для обработки. Если ваш скрипт использует функции RevoScaleR (обычно начинаются с префикса «rx»), параллельная обработка выполняется автоматически и не нужно явно задать `@parallel` для `1`.

    Если скрипт R может выполняться параллельно, и запрос SQL может выполняться параллельно, компонент database engine создает несколько параллельных процессов. Максимальное число процессов, которые могут быть созданы равен **максимальная степень параллелизма** параметр (MAXDOP) для экземпляра. Затем все процессы выполните тот же сценарий, но получать только часть данных.
    
    Таким образом, этот метод не является полезным для сценариев, которые должны видеть все данные, например, при обучении модели. Тем не менее это пригодится при выполнении задач, таких как пакетное прогнозирование в параллельном режиме. Дополнительные сведения об использовании параллелизма с `sp_execute_external_script`, см. в разделе **Дополнительные советы: параллельная обработка** раздел [с помощью кода R в Transact-SQL](../tutorials/rtsql-using-r-code-in-transact-sql-quickstart.md).

-   **Использовать numTasks = 1.** При использовании **rx** функции в контексте вычислений SQL Server, установите для параметра _numTasks_ параметр число процессов, которые вы хотите создать. Количество создаваемых процессов не может быть более чем **MAXDOP**; тем не менее фактическое количество создаваемых процессов определяется компонентом database engine и можно меньше, чем можно запрашивать.

    Если скрипт R может выполняться параллельно, и запрос SQL может выполняться параллельно, SQL Server создает несколько параллельных процессов при выполнении функций rx. Фактическое число процессов, которые создаются зависит от различных факторов, таких как управление ресурсами, текущее использование ресурсов, другие сеансы и план выполнения запроса для запроса, используемого со скриптом R.

## <a name="query-parallelization"></a>Параллелизация запросов

В Microsoft R можно работать с источниками данных SQL Server путем определения данных как объект источника данных RxSqlServerData.

Создает источник данных на основе всей таблицы или представления:

```R
RxSqlServerData(table= "airline", connectionString = sqlConnString)
```

Создает источник данных на основе запроса SQL:

```R
RxSqlServerData(sqlQuery= "SELECT [ArrDelay],[CRSDepTime],[DayOfWeek] FROM  airlineWithIndex WHERE rowNum <= 100000", connectionString = sqlConnString)
```

> [!NOTE]
> Если указана таблица в источнике данных, а не запрос, службы R использует внутренний эвристику для определяет необходимые столбцы для выборки из таблицы; Однако такой подход вряд ли произойдет параллельное выполнение.

Чтобы убедиться, что данные можно проанализировать в параллельном режиме, следует встроить запрос, используемый для извлечения данных таким образом, что ядро базы данных можно создать параллельный план запроса. Если код или алгоритм использует большие объемы данных, убедитесь, что запрос, переданный в `RxSqlServerData` оптимизирован для параллельного выполнения. Запрос, который не выполняется в рамках плана параллельного выполнения, может выполниться в одном процессе для вычисления.

Если вам нужно работать с большими наборами данных, используйте среду Management Studio или другой анализатор запросов SQL, прежде чем выполнять код R, для анализа плана выполнения. Выполните все рекомендуемые действия, чтобы повысить производительность запроса. Например, отсутствующий индекс таблицы может повлиять на время, затраченное на выполнение запроса. Дополнительные сведения см. в разделе [наблюдение и настройка производительности](../../relational-databases/performance/monitor-and-tune-for-performance.md).

Другой распространенной ошибкой, может повлиять на производительность является то, что запрос возвращает больше столбцов, чем необходимо. Например если формула зависит только три столбца, но в исходной таблице есть 30 столбцов, вы перемещаете данные без необходимости.

 + Старайтесь не использовать `SELECT *`!
 + Занять некоторое время просмотрите столбцы в наборе данных и определите только те, необходимые для анализа
 + Удалить из запросов все столбцы, которые содержат типы данных, которые несовместимы с кода R, например идентификаторы GUID и идентификаторами rowguids
 + Проверьте форматы неподдерживаемые даты и времени
 + Вместо того чтобы загружать таблицы, создаете представление, которое выбирает определенные значения или приводит к столбцам во избежание ошибок преобразования

## <a name="optimizing-the-machine-learning-algorithm"></a>Оптимизация алгоритма машинного обучения

Здесь содержатся различные советы и ресурсы, относящиеся к RevoScaleR и другие параметры в Microsoft R.

> [!TIP]
> Общие сведения об оптимизации R выходит за рамки данной статьи. Тем не менее, если требуется сделать код быстрее, мы рекомендуем популярные статьи [R Inferno](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf). Он охватывает программных конструкций в R и распространенных проблем в виде наглядных язык и сведения о и множество примеров конкретных методах программирования R.

### <a name="optimizations-for-revoscaler"></a>Оптимизация для RevoScaleR

Множество алгоритмов RevoScaleR поддерживает параметры для управления созданием обученной модели. Хотя точность и правильность модели важна, производительность алгоритма может быть не менее важна. Чтобы получить правильный баланс между точность и время обучения, можно изменить параметры, чтобы увеличить скорость вычислений и во многих случаях, повысить производительность, не уменьшая точность и правильность.

+ [rxDTree](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxdtree)

    `rxDTree` поддерживает `maxDepth` параметр, который управляет глубину дерева принятия решений. Как `maxDepth` — увеличивается, может привести к снижению производительности, поэтому важно проанализировать преимущества увеличения глубины и вреда для производительности.

    Вы также можете управлять балансом между время сложность и точность прогнозирования, такие как Настройка параметров `maxNumBins`, `maxDepth`, `maxComplete`, и `maxSurrogate`. Если увеличить глубину до 10 или 15, стоимость вычислений сильно увеличится.

+ [rxLinMod](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxlinmod)

    Попробуйте использовать `cube` аргумента, если первая зависимая переменная в формулы является переменной коэффициента.
    
    Когда `cube` присваивается `TRUE`, Регрессия выполняется с помощью секционированных обратное, который может быстрее и использует меньше памяти, чем стандартной регрессии. Если в формуле используется много переменных, производительность может существенно повыситься.

+ [rxLogit](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxlogit)

    Используйте `cube` аргумента, если первая зависимая переменная является переменной коэффициента.
    
    Когда `cube` присваивается `TRUE`, алгоритм использует секционированную обратное, который может быстрее и использует меньше памяти. Если в формуле используется много переменных, производительность может существенно повыситься.

Дополнительные рекомендации по оптимизации RevoScaleR см. в статьях:

+ Статья службы поддержки: [Настройка параметров для rxDForest и rxDTree производительности](https://support.microsoft.com/kb/3104235)

+ Методы управления помещаются в модель повышенного дерева модели: [Оценка моделей с помощью вероятностного градиентного Бустинга](https://docs.microsoft.com/r-server/r/how-to-revoscaler-boosting)

+ Общие сведения о том, как RevoScaleR перемещает и обрабатывает данные: [Написать пользовательские алгоритмы фрагментации в ScaleR](https://docs.microsoft.com/r-server/r/how-to-developer-write-chunking-algorithms)

+ Модель программирования для RevoScaleR. [Управление потоками в RevoScaleR](https://docs.microsoft.com/r-server/r/how-to-developer-manage-threads)

+ Справочник по функциям [rxDForest](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxdforest)

+ Справочник по функциям [rxBTrees](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxbtrees)

### <a name="use-microsoftml"></a>Использовать MicrosoftML

Мы также рекомендуем взглянуть в новый **MicrosoftML** пакет, который предоставляет масштабируемые алгоритмы обучения, которые могут использовать контексты вычисления и преобразования, предоставляемые RevoScaleR.

+ [Начало работы с MicrosoftML](https://docs.microsoft.com/r-server/r/concept-what-is-the-microsoftml-package)

+ [Как выбрать алгоритм MicrosoftML](https://docs.microsoft.com/r-server/r/how-to-choose-microsoftml-algorithms-cheatsheet)

### <a name="operationalize-a-solution-using-microsoft-r-server"></a>Ввод в эксплуатацию решения с использованием Microsoft R Server

Если вам необходимо быстрое прогнозирование с помощью хранимой модели или интеграции машинного обучения в приложения, можно использовать [ввода в эксплуатацию](https://docs.microsoft.com/r-server/what-is-operationalization) возможностях Microsoft R Server (ранее известные как DeployR).

+ Как **специалист по обработке данных**, использовать [пакет mrsdeploy](https://docs.microsoft.com/r-server/r-reference/mrsdeploy/mrsdeploy-package) для совместного использования кода R с другими компьютерами и интеграции функций аналитики R внутри рабочего стола, мобильных, панели мониторинга и веб-приложений: [Как опубликовать и управление веб-службами R в R Server](https://docs.microsoft.com/r-server/operationalize/how-to-deploy-web-service-publish-manage-in-r)

+ Как **администратора**, узнайте, как управлять пакетами, отслеживать веб-узлов и вычислительных узлов и управлять безопасностью заданий R: [Как взаимодействовать с и использовать веб-службы в R](https://docs.microsoft.com/r-server/operationalize/how-to-consume-web-service-interact-in-r)

## <a name="articles-in-this-series"></a>Статьях этой серии

[Производительность Настройка для R — введение](sql-server-r-services-performance-tuning.md)

[Настройка производительности для R — конфигурация SQL Server](sql-server-configuration-r-services.md)

[Настройка производительности для R — R оптимизации кода и данных](r-and-data-optimization-r-services.md)

[Помощник по настройке производительности - пример внедрения результатов](performance-case-study-r-services.md)
