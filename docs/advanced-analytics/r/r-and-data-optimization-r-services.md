---
title: Настройка производительности для оптимизации данных
ms.prod: sql
ms.technology: machine-learning
ms.date: 04/15/2018
ms.topic: conceptual
author: dphansen
ms.author: davidph
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: a65afba9455fb475b760439e92ad8d4d38a70be8
ms.sourcegitcommit: 321497065ecd7ecde9bff378464db8da426e9e14
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/01/2019
ms.locfileid: "68715649"
---
# <a name="performance-for-r-services---data-optimization"></a>Производительность служб R — Оптимизация данных
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

Эта статья третья в серии, в которой описывается оптимизация производительности для служб R на основе двух примеров внедрения. В этой статье рассматривается оптимизация производительности для сценариев R или Python, выполняемых в SQL Server. Здесь также описываются методы, которые можно использовать для обновления кода R, чтобы повысить производительность и избежать известных проблем.

## <a name="choosing-a-compute-context"></a>Выбор контекста вычислений

В SQL Server 2016 и 2017 можно использовать **локальный** или контекст вычислений **SQL** при выполнении скрипта R или Python.

При использовании **локального** контекста вычислений анализ выполняется на компьютере, а не на сервере. Поэтому при получении данных из SQL Server для использования в коде необходимо получить данные по сети. Снижение производительности, вызванное такой передачей по сети, зависит от объема передаваемых данных, скорости сети и других передач данных по сети, выполняемых одновременно.

При использовании **контекста вычислений SQL Server**код выполняется на сервере. Если данные поступают из SQL Server, данные должны быть локальными для сервера, на котором выполняется анализ, и поэтому сетевые издержки не появляются. Если необходимо импортировать данные из других источников, рекомендуется заранее расположить ETL.

При работе с большими наборами данных следует всегда использовать контекст вычислений SQL.

## <a name="factors"></a>Факторы

Язык R имеет концепцию *факторов*, которые представляют собой специальную переменную для данных по категориям. Специалисты по обработке и анализу данных часто используют переменные фактора в своей формуле, так как обработка переменных категории в качестве факторов гарантирует, что данные должны обрабатываться функциями машинного обучения. Дополнительные сведения см. в [разделе R for фиктивные модули: Переменные](https://www.dummies.com/programming/r/how-to-look-at-the-structure-of-a-factor-in-r/)коэффициента.

При проектировании переменные коэффициента можно преобразовать из строк в целые числа и обратно для хранения или обработки. Функция R `data.frame` обрабатывает все строки как переменные коэффициента, если только аргумент *стрингсасфакторс* не имеет значение **false**. Это означает, что строки автоматически преобразуются в целое число для обработки, а затем сопоставляются с исходной строкой.

Если исходные данные для коэффициентов хранятся в виде целого числа, производительность может снизиться, так как R преобразует целочисленные значения коэффициента в строки во время выполнения, а затем выполняет собственное преобразование из внутренней строки в целое число.

Чтобы избежать таких преобразований во время выполнения, рекомендуется хранить значения в виде целых чисел в SQL Server таблице и использовать аргумент _colInfo_ для указания уровней столбца, используемого в качестве коэффициента. Большинство объектов источника данных в RevoScaleR принимают параметр _colInfo_. Используйте этот параметр, чтобы присвоить имена переменным, используемым источником данных, указать их тип и определить уровни переменных или преобразования значений столбцов.

Например, следующий вызов функции R возвращает целые числа 1, 2 и 3 из таблицы, но сопоставляет значения с коэффициентом "Apple", "оранжевый" и "полукруглым".

```R
c("fruit" = c(type = "factor", levels=as.character(c(1:3)), newLevels=c("apple", "orange", "banana")))
```

Если исходный столбец содержит строки, то всегда более эффективно указывать уровни заранее с помощью параметра _colInfo_ . Например, следующий код R обрабатывает строки как коэффициенты чтения.

```R
c("fruit" = c(type = "factor", levels= c("apple", "orange", "banana")))
```

Если семантическая разница в создании модели отсутствует, то второй подход может привести к повышению производительности.

## <a name="data-transformations"></a>Преобразования данных

Специалисты по анализу и обработке данных часто используют функции преобразования, написанные на языке R, в процессе анализа. Функция преобразования применяется к каждой строке, полученной из таблицы. В SQL Server такие преобразования применяются ко всем строкам, полученным в пакете, что требует обмена данными между интерпретатором R и подсистемой аналитики. Чтобы выполнить преобразование, данные перемещаются из SQL в подсистему аналитики, а затем в процесс интерпретатора R и обратно.

По этой причине использование преобразований в качестве части кода R может оказать значительное негативное воздействие на производительность алгоритма в зависимости от объема используемых данных.

Перед выполнением анализа более эффективно использовать все необходимые столбцы в таблице или представлении, а также избежать преобразований во время вычисления. Если вы не можете добавить дополнительные столбцы к существующим таблицам, создайте другую таблицу или представление с преобразованными столбцами и используйте соответствующий запрос для получения данных.

## <a name="batch-row-reads"></a>Считывание строк пакета

Если в коде используется SQL Server источник данных (`RxSqlServerData`), рекомендуется использовать параметр _rowsPerRead_ для указания размера пакета. Этот параметр определяет количество строк, которые запрашиваются и затем отправляются внешнему скрипту для обработки. Во время выполнения алгоритм видит только указанное число строк в каждом пакете.

Возможность управлять объемом обрабатываемых в каждый момент времени данных может помочь решить проблему или избежать ее. Например, если входной набор данных является очень широким (имеет много столбцов) или если набор данных содержит несколько больших столбцов (например, бесплатный текст), размер пакета можно уменьшить, чтобы избежать нехватки памяти при разбиении на страницы.

По умолчанию для этого параметра задано значение 50000, чтобы обеспечить нехватку производительности даже на компьютерах с нехваткой памяти. Если на сервере достаточно памяти, увеличение этого значения до 500 000 или даже миллиона может повысить производительность, особенно для больших таблиц.

Преимущества увеличения размера пакета становятся очевидными в большом наборе данных, а также в задаче, которая может выполняться в нескольких процессах. Однако увеличение этого значения не всегда дает лучшие результаты. Для определения оптимального значения рекомендуется поэкспериментировать с данными и алгоритмом.

## <a name="parallel-processing"></a>Параллельная обработка

Чтобы повысить производительность аналитических функций **RX** , можно воспользоваться возможностью SQL Server параллельного выполнения задач с помощью доступных ядер на компьютере сервера.

Существует два способа достижения параллелизма с помощью R в SQL Server:

-   **Используйте \@Parallel.** При использовании хранимой процедуры `sp_execute_external_script` для выполнения скрипта R установите для параметра `@parallel` значение `1`. Это лучший метод, если скрипт R **не использует функции** RevoScaleR, которые имеют другие механизмы обработки. Если в скрипте используются функции RevoScaleR (обычно с префиксом "RX"), параллельная обработка выполняется автоматически, и вам не нужно явно задавать `@parallel` значение `1`.

    Если скрипт R можно параллельно использовать, а SQL Server можно параллельно выполнить, ядро СУБД создает несколько параллельных процессов. Максимальное число создаваемых процессов равно значению параметра **максимальной степени параллелизма** (MAXDOP) для экземпляра. Затем все процессы выполняют один и тот же сценарий, но получают только часть данных.
    
    Таким образом, этот метод не полезен для скриптов, которые должны просматривать все данные, например при обучении модели. Тем не менее это пригодится при выполнении задач, таких как пакетное прогнозирование в параллельном режиме. Дополнительные сведения об использовании параллелизма с `sp_execute_external_script`см. в разделе **Дополнительные советы: параллельная обработка** раздела [использование кода R в Transact-SQL](../tutorials/rtsql-using-r-code-in-transact-sql-quickstart.md).

-   **Используйте Нумтаскс = 1.** При использовании функций **RX** в SQL Server контексте вычислений задайте для параметра _нумтаскс_ число процессов, которые вы хотите создать. Число созданных процессов не может быть больше **MAXDOP**; Однако фактическое число созданных процессов определяется ядром СУБД и может быть меньше запрошенного.

    Если скрипт R можно параллельно использовать, а SQL Query можно параллельно выполнить, SQL Server создает несколько параллельных процессов при выполнении функций RX. Фактическое количество создаваемых процессов зависит от различных факторов, таких как управление ресурсами, текущее использование ресурсов, другие сеансы и план выполнения запроса, используемый в скрипте R.

## <a name="query-parallelization"></a>Параллелизации запросов

В Microsoft R можно работать с SQL Server источниками данных, определив данные в качестве объекта источника данных RxSqlServerData.

Создает источник данных на основе всей таблицы или представления:

```R
RxSqlServerData(table= "airline", connectionString = sqlConnString)
```

Создает источник данных на основе SQL-запроса:

```R
RxSqlServerData(sqlQuery= "SELECT [ArrDelay],[CRSDepTime],[DayOfWeek] FROM  airlineWithIndex WHERE rowNum <= 100000", connectionString = sqlConnString)
```

> [!NOTE]
> Если таблица указана в источнике данных вместо запроса, службы R используют внутренние эвристики для определения необходимых столбцов для выборки из таблицы. Однако этот подход вряд ли будет приводить к параллельному выполнению.

Чтобы обеспечить возможность параллельного анализа данных, запрос, используемый для получения данных, должен быть заключен в стек таким образом, что ядро СУБД может создать параллельный план запроса. Если в коде или алгоритме используются большие объемы данных, убедитесь, что запрос, предоставленный `RxSqlServerData` , оптимизирован для параллельного выполнения. Запрос, который не выполняется в рамках плана параллельного выполнения, может выполниться в одном процессе для вычисления.

Если необходимо работать с большими наборами данных, то перед выполнением кода R Используйте Management Studio или другой анализатор SQL Query Analyzer, чтобы проанализировать план выполнения. Затем выполните все рекомендуемые действия для повышения производительности запроса. Например, отсутствующий индекс таблицы может повлиять на время, затраченное на выполнение запроса. Дополнительные сведения см. в разделе [мониторинг и настройка производительности](../../relational-databases/performance/monitor-and-tune-for-performance.md).

Другой распространенной ошибкой, которая может повлиять на производительность, является то, что запрос получает больше столбцов, чем требуется. Например, если формула основана только на трех столбцах, но в исходной таблице есть 30 столбцов, то данные перемещаются необязательно.

 + Старайтесь не `SELECT *`использовать!
 + Проверьте столбцы в наборе данных и найдите только те из них, которые необходимы для анализа.
 + Удалите из запросов все столбцы, содержащие типы данных, несовместимые с кодом R, такие как идентификаторы GUID и ROWGUID.
 + Проверить неподдерживаемые форматы даты и времени
 + Вместо загрузки таблицы создайте представление, которое выбирает определенные значения или приводит столбцы, чтобы избежать ошибок преобразования.

## <a name="optimizing-the-machine-learning-algorithm"></a>Оптимизация алгоритма машинного обучения

В этом разделе приводятся различные советы и ресурсы, относящиеся к RevoScaleR и другим вариантам в Microsoft R.

> [!TIP]
> Общее обсуждение оптимизации R выходит за рамки этой статьи. Тем не менее, если вам нужно ускорить выполнение кода, мы рекомендуем ознакомиться с популярной статьей [R Inferno адский](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf). В нем рассматриваются конструкции программирования в R и распространенные ошибки на выстроенном языке и подробностях, а также представлено множество примеров методов программирования R.

### <a name="optimizations-for-revoscaler"></a>Оптимизации для RevoScaleR

Многие алгоритмы RevoScaleR поддерживают параметры для управления созданием обученной модели. Хотя точность и правильность модели очень важны, производительность алгоритма может быть так же важна. Чтобы получить правильный баланс между точностью и временем обучения, можно изменить параметры, чтобы увеличить скорость вычислений, и во многих случаях повысить производительность без снижения точности или правильности.

+ [rxDTree](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxdtree)

    `rxDTree``maxDepth` поддерживает параметр, который управляет глубиной дерева принятия решений. По `maxDepth` мере увеличения производительности может снизиться производительность, поэтому важно проанализировать преимущества увеличения глубины и вреда производительности.

    Можно также управлять балансом между сложностью времени и точностью прогнозов, изменяя `maxDepth`такие `maxComplete`параметры, `maxSurrogate`как `maxNumBins`,, и. Если увеличить глубину до 10 или 15, стоимость вычислений сильно увеличится.

+ [rxLinMod](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxlinmod)

    Попробуйте использовать аргумент `cube` , если первая зависимая переменная в формуле является переменной коэффициента.
    
    Если `cube` для`TRUE`задано значение, регрессия выполняется с использованием секционированного инверсии, что может выполняться быстрее и использовать меньше памяти, чем стандартные регрессионные вычисления. Если в формуле используется много переменных, производительность может существенно повыситься.

+ [rxLogit](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxlogit)

    Используйте аргумент `cube` , если первая зависимая переменная является переменной коэффициента.
    
    Если `cube` для`TRUE`задано значение, то алгоритм использует секционированный инверсный, что может быть быстрее и использовать меньше памяти. Если в формуле используется много переменных, производительность может существенно повыситься.

Дополнительные рекомендации по оптимизации RevoScaleR см. в следующих статьях:

+ Статья технической поддержки: [Параметры настройки производительности для rxDForest и rxDTree](https://support.microsoft.com/kb/3104235)

+ Методы управления соответствием модели в модели с повышенным деревом: [Оценка моделей с помощью повышения метод стохастического градиента](https://docs.microsoft.com/r-server/r/how-to-revoscaler-boosting)

+ Общие сведения о том, как RevoScaleR перемещает и обрабатывает данные: [Запись пользовательских алгоритмов фрагментации в масштабируемый](https://docs.microsoft.com/r-server/r/how-to-developer-write-chunking-algorithms)

+ Модель программирования для RevoScaleR: [Управление потоками в RevoScaleR](https://docs.microsoft.com/r-server/r/how-to-developer-manage-threads)

+ Справочник по функциям для [rxDForest](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxdforest)

+ Справочник по функциям для [рксбтрис](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxbtrees)

### <a name="use-microsoftml"></a>Использование MicrosoftML

Мы также рекомендуем взглянуть на новый пакет **MicrosoftML** , который предоставляет масштабируемые алгоритмы машинного обучения, которые могут использовать контексты вычислений и преобразования, предоставляемые RevoScaleR.

+ [Начало работы с MicrosoftML](https://docs.microsoft.com/r-server/r/concept-what-is-the-microsoftml-package)

+ [Выбор алгоритма MicrosoftML](https://docs.microsoft.com/r-server/r/how-to-choose-microsoftml-algorithms-cheatsheet)

### <a name="operationalize-a-solution-using-microsoft-r-server"></a>Эксплуатацию решение с помощью Microsoft R Server

Если в сценарии используется быстрое прогнозирование с помощью хранимой модели или интеграция машинного обучения в приложение, можно [использовать функции работы](https://docs.microsoft.com/r-server/what-is-operationalization) в Microsoft R Server (ранее известные как средство развертывания).

+ В качестве **анализу данных**используйте [пакет mrsdeploy](https://docs.microsoft.com/r-server/r-reference/mrsdeploy/mrsdeploy-package) для совместного использования кода R с другими компьютерами и интеграции R Analytics в приложениях для Интернета, настольных, мобильных и информационных панелей: [Как публиковать веб-службы R и управлять ими на R Server](https://docs.microsoft.com/r-server/operationalize/how-to-deploy-web-service-publish-manage-in-r)

+ Как **Администратор**, вы узнаете, как управлять пакетами, отслеживать веб-узлы и вычислять компьютеры, а также контролировать безопасность заданий R: [Взаимодействие и использование веб-служб в R](https://docs.microsoft.com/r-server/operationalize/how-to-consume-web-service-interact-in-r)

## <a name="articles-in-this-series"></a>Статьи в этой серии

[Настройка производительности для R — введение](sql-server-r-services-performance-tuning.md)

[Настройка производительности для конфигурации R-SQL Server](sql-server-configuration-r-services.md)

[Настройка производительности для кода R-R и оптимизации данных](r-and-data-optimization-r-services.md)

[Настройка производительности — результаты исследования вариантов](performance-case-study-r-services.md)
