---
title: Конфигурации SQL Server для служб R
ms.prod: sql
ms.technology: machine-learning
ms.date: 03/29/2019
ms.topic: conceptual
author: dphansen
ms.author: davidph
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: dda5d84aca714530bbc2bef79344db889e113d4f
ms.sourcegitcommit: 321497065ecd7ecde9bff378464db8da426e9e14
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/01/2019
ms.locfileid: "68714995"
---
# <a name="sql-server-configuration-for-use-with-r"></a>Конфигурация SQL Server для использования с R
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

Эта статья является вторым в серии, в которой описывается оптимизация производительности для служб R на основе двух примеров внедрения.  В этой статье содержатся рекомендации по конфигурации оборудования и сети компьютера, который используется для запуска SQL Server R Services. Он также содержит сведения о способах настройки SQL Server экземпляра, базы данных или таблиц, используемых в решении. Поскольку использование NUMA в SQL Server размытие линии между оптимизацией оборудования и базы данных, в третьем разделе подробно обсуждается аффинитизатион ЦП и управление ресурсами.

> [!TIP]
> Если вы не знакомы с SQL Server, настоятельно рекомендуем также ознакомиться с руководством по настройке производительности SQL Server. [Мониторинг и настройка производительности](https://docs.microsoft.com/sql/relational-databases/performance/monitor-and-tune-for-performance).

## <a name="hardware-optimization"></a>Оптимизация оборудования

Оптимизация компьютера сервера важна для обеспечения доступности ресурсов для выполнения внешних скриптов. Если ресурсы ограничены, можно столкнуться с такими симптомами:

- Выполнение задания откладывается или отменяется для определения приоритета других операций с базой данных
- Ошибка "превышена квота", вызывающая завершение скрипта R без выполнения
- Данные, загруженные в память R, усечены, для неполных результатов

### <a name="memory"></a>Память

Объем доступной памяти может иметь значительное влияние на производительность расширенных аналитических алгоритмов. Недостаток памяти может повлиять на степень параллелизма при использовании контекста вычислений SQL. Это также может повлиять на размер фрагмента данных (строк на каждую операцию чтения), который можно обработать, и поддерживаемое число одновременных сеансов.

Настоятельно рекомендуется не менее 32 ГБ. Если доступно более 32 ГБ, можно настроить в источнике данных SQL использование большего количества строк в каждой операции чтения, чтобы повысить производительность.

Кроме того, можно управлять памятью, используемой экземпляром. По умолчанию SQL Server назначается по приоритету для процессов внешних скриптов при выделении памяти. При установке служб R по умолчанию для R выделяется только 20% доступной памяти.

Обычно это недостаточно для задач обработки и анализа данных, но не нужно размал SQL Server памяти. Следует поэкспериментировать и точно настроить выделение памяти между ядром СУБД, связанными службами и внешними скриптами, зная, что оптимальная конфигурация различает регистр.

Для модели сопоставления возобновления использование внешнего скрипта было тяжелым, а другие службы ядра СУБД не запущены. Таким образом, ресурсы, выделенные для внешних скриптов, были увеличены до 70%, что было лучшим вариантом для производительности сценариев.

### <a name="power-options"></a>Параметры электропитания

В операционной системе Windows следует использовать параметр **высокой производительности** электропитания. Использование другого параметра питания приводит к снижению или нестабильной производительности при использовании SQL Server.

### <a name="disk-io"></a>Дисковые операции ввода-вывода

Задания обучения и прогнозирования, использующие службы R, по сути привязаны к операциям ввода-вывода и зависят от скорости дисков, на которых хранится база данных. Более быстрые диски, например твердотельные накопители (SSD), могут помочь.

На дисковые операции ввода-вывода также оказывают влияние и другие приложения, у которых есть доступ к диску, например операции чтения базы данных, выполняемые другими клиентами. На производительность дисковых операций ввода-вывода могут влиять параметры текущей файловой системы, например размер блока, используемый этой системой.

Если доступно несколько дисков, храните базы данных на другом диске, чем SQL Server, чтобы запросы к ядру СУБД не применялись к тому же диску, что и запросы к данным, хранящимся в базе данных.

Дисковые операции ввода-вывода могут оказывать значительное влияние на производительность при выполнении аналитических функций RevoScaleR, использующих несколько итераций во время обучения. Например `rxLogit` ,,,`rxDTree` и`rxBTrees` используют несколько итераций. `rxDForest` Если источник данных SQL Server, эти алгоритмы используют временные файлы, оптимизированные для записи данных. Эти файлы автоматически удаляются после завершения сеанса. Наличие высокопроизводительного диска для операций чтения и записи может значительно повысить общее затраченное время для этих алгоритмов.

> [!NOTE]
> Ранние версии служб R требовали поддержки 8,3 имен файлов в операционных системах Windows. Это ограничение было ликвидировано после пакета обновления 1 (SP1). Однако можно использовать файл fsutil. exe, чтобы определить, поддерживает ли диск 8,3 имен файлов, или включить поддержку, если это не так.

### <a name="paging-file"></a>Файл подкачки

Операционная система Windows использует файл подкачки для управления аварийными дампами и хранения страниц виртуальной памяти. Если обнаружена излишняя подкачка, необходимо увеличить физическую память компьютера. Несмотря на то что больший объем физической памяти не устранит подкачку, это значительно уменьшит потребность в ней.

Скорость диска, на котором хранится файл подкачки, также влияет на производительность. Вы можете улучшить ее, если сохраните файл подкачки на диске SSD или если будете использовать файлы подкачки на нескольких дисках SSD.

Сведения о размере файла подкачки см. в разделе [Определение подходящего размера файла подкачки для 64-разрядных версий Windows](https://support.microsoft.com/kb/2860880).

## <a name="optimizations-at-instance-or-database-level"></a>Оптимизация на уровне экземпляра или базы данных

Оптимизация экземпляра SQL Server является ключом к эффективному выполнению внешних скриптов.

> [!NOTE]
> Оптимальные параметры различаются в зависимости от размера и типа данных, числа столбцов, используемых для оценки или обучения модели.
> 
> Результаты конкретной оптимизации можно посмотреть в последней статье: [Настройка производительности — результаты исследования вариантов](../../advanced-analytics/r/performance-case-study-r-services.md)
> 
> Примеры сценариев см. в отдельном [репозитории GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning).

### <a name="table-compression"></a>Сжатие таблицы

Производительность операций ввода-вывода часто можно улучшить с помощью сжатия или хранилища данных по столбцам. Как правило, данные часто повторяются в нескольких столбцах таблицы, поэтому при сжатии данных с помощью columnstore используются преимущества этих повторений.

Индекс columnstore может оказаться неэффективным, если в таблицу имеется много вставок, но это хороший выбор, если данные являются статическими или редко изменяются. Если хранилище столбцов нельзя использовать по каким-либо причинам, чтобы улучшить операции ввода-вывода, можно включить сжатие для основной таблицы строк.

Дополнительные сведения см. в следующих статьях:

+ [Сжатие данных](../../relational-databases/data-compression/data-compression.md)

+ [Включение сжатия таблицы или индекса](../../relational-databases/data-compression/enable-compression-on-a-table-or-index.md)

+ [Руководство по индексам columnstore](../../relational-databases/indexes/columnstore-indexes-overview.md)

### <a name="memory-optimized-tables"></a>Таблицы, оптимизированные для памяти

Настоящее время, память больше не является проблемой для современных компьютеров. По мере того, как спецификации оборудования продолжают совершенствоваться, достаточно легко получить оперативную память. Однако в то же время данные создаются быстрее, чем раньше, и данные должны обрабатываться с низкой задержкой.

Оптимизированные для памяти таблицы представляют одно решение, в котором для решения проблем с большими данными используются большие объемы памяти, доступные на дополнительных компьютерах. Оптимизированные для памяти таблицы в основном находятся в памяти, поэтому данные считываются из памяти и записываются в память. Для устойчивости вторая копия таблицы сохраняется на диске, а данные считываются с диска только во время восстановления базы данных.

Если необходимо часто выполнять чтение и запись в таблицы, оптимизированные для памяти таблицы могут способствовать высокой масштабируемости и низкой задержке.  В сценарии возобновления использования оптимизированные для памяти таблицы позволили нам считывать все функции возобновления из базы данных и сохранять их в основной памяти, чтобы соответствовать новым вакансиям заданий. Это значительно сокращает число операций ввода-вывода на диск.

Увеличение производительности достигается за счет использования оптимизированной для памяти таблицы в процессе записи прогнозов обратно в базу данных из нескольких параллельных пакетов. Использование оптимизированных для памяти таблиц в SQL Server включает низкую задержку при чтении и записи таблицы.

Во время разработки этот процесс также был незаметным. Устойчивые таблицы, оптимизированные для памяти, были созданы одновременно с созданием базы данных. Таким образом, разработка использовала тот же рабочий процесс независимо от того, где хранились данные.

### <a name="processor"></a>Процессор

SQL Server могут параллельно выполнять задачи с помощью доступных ядер на компьютере; чем больше ядер доступно, тем выше производительность. Хотя увеличение числа ядер может не помочь в операциях ввода-вывода, алгоритмы с ограниченным использованием ЦП используют более быстрые процессоры с множеством ядер.

Поскольку сервер обычно используется несколькими пользователями одновременно, администратор базы данных должен определить идеальное количество ядер, необходимое для поддержки пиковых вычислений рабочей нагрузки.

### <a name="resource-governance"></a>Управление ресурсами

В выпусках, поддерживающих Resource Governor, можно использовать пулы ресурсов, чтобы указать, что для определенных рабочих нагрузок выделяется некоторое количество ЦП. Кроме того, можно управлять объемом памяти, выделенной для конкретных рабочих нагрузок.

Управление ресурсами в SQL Server позволяет централизовать мониторинг и контроль различных ресурсов, используемых SQL Server и R. Например, можно выделить половину доступной памяти для ядра СУБД, чтобы обеспечить постоянное выполнение основных служб, несмотря на временные более тяжелые рабочие нагрузки.

Значение по умолчанию для использования памяти внешними скриптами ограничено 20% от общего объема памяти, доступного для SQL Server. Это ограничение применяется по умолчанию, чтобы гарантировать, что все задачи, зависящие от сервера базы данных, не будут затронуты долго выполняющимися заданиями R. Однако администратор базы данных может изменить эти ограничения. Во многих случаях ограничение в 20% не подходит для поддержки серьезных рабочих нагрузок машинного обучения.

Поддерживаются параметры конфигурации **MAX_CPU_PERCENT**, **max_memory_percent**и **MAX_PROCESSES**. Чтобы просмотреть текущие параметры, используйте следующую инструкцию:`SELECT * FROM sys.resource_governor_external_resource_pools`

-  Если сервер в основном используется для служб R Services, может быть полезно увеличить MAX_CPU_PERCENT до 40% или 60%.

-  Если несколько сеансов R должны использовать один и тот же сервер одновременно, необходимо увеличить все три параметра.

Чтобы изменить выделенные значения ресурсов, используйте инструкции T-SQL.

+ Эта инструкция задает использование памяти 40%:`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_MEMORY_PERCENT = 40)`

+ Эта инструкция задает все три настраиваемых значения:`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_CPU_PERCENT = 40, MAX_MEMORY_PERCENT = 50, MAX_PROCESSES = 20)`

+ Если вы измените параметр памяти, ЦП или максимального процесса, а затем хотите применить параметры немедленно, выполните следующую инструкцию:`ALTER RESOURCE GOVERNOR RECONFIGURE`

## <a name="soft-numa-hardware-numa-and-cpu-affinity"></a>Soft-NUMA, аппаратное NUMA и соответствие ПРОЦЕССОРов

При использовании SQL Server в качестве контекста вычислений иногда можно добиться лучшей производительности путем настройки параметров, связанных с NUMA и соответствием процессоров. 

Системы с _аппаратным обеспечением NUMA_ имеют более одной системной шины, каждая из которых обслуживает небольшой набор процессоров. Каждый ЦП может использовать память, связанную с другими группами, согласованным образом. Каждая группа называется узлом NUMA. Если имеется оборудование NUMA, оно может быть настроено так, что вместо NUMA используется чередующаяся память. В этом случае Windows и, следовательно, SQL Server не сможет распознать его как NUMA. 

Чтобы узнать количество узлов памяти, доступных для SQL Server, можно выполнить следующий запрос:

```sql
SELECT DISTINCT memory_node_id
FROM sys.dm_os_memory_clerks
```

Если запрос возвращает один узел памяти (узел 0), то либо у вас нет аппаратного NUMA, либо оборудование настроено как чередование (не NUMA). SQL Server также игнорирует аппаратную архитектуру NUMA при наличии четырех или меньших процессоров или в случае, если хотя бы один узел имеет только один ЦП.

Если на компьютере установлено несколько процессоров, но на нем нет аппаратного NUMA, можно также использовать [Soft-NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server) , чтобы разделить ЦП на небольшие группы.  В SQL Server 2016 и SQL Server 2017 функция Soft-NUMA автоматически включается при запуске службы SQL Server.

При включении программной архитектуры NUMA SQL Server автоматически управляет узлами. Однако для оптимизации конкретных рабочих нагрузок можно отключить мягкое сходство и вручную настроить сходство ЦП для узлов с мягкими NUMA. Это обеспечивает более полный контроль над тем, какие рабочие нагрузки назначаются узлам, особенно если используется выпуск SQL Server, поддерживающий управление ресурсами. Указав сходство ЦП и выровняйте пулы ресурсов с группами ЦП, можно сократить задержку и убедиться, что связанные процессы выполняются в пределах одного узла NUMA.

Общий процесс настройки архитектуры Soft-NUMA и привязки ЦП для поддержки рабочих нагрузок R выглядит следующим образом:

1. Включение программной архитектуры NUMA (при наличии)
2. Определение соответствия процессоров
3. Создание пулов ресурсов для внешних процессов с помощью [Resource Governor](../r/resource-governance-for-r-services.md)
4. Назначение [групп рабочей нагрузки](../../relational-databases/resource-governor/resource-governor-workload-group.md) конкретным территориальным группам

Дополнительные сведения, включая пример кода, см. в этом руководстве: [Советы и рекомендации по оптимизации SQL (Хаун)](https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services)

**Другие ресурсы:**

+ [Программная архитектура NUMA в SQL Server](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server)
    
    Как сопоставлять узлы программной архитектуры NUMA с ЦП

## <a name="task-specific-optimizations"></a>Оптимизация для конкретных задач

В этом разделе приводятся сводные сведения о методах, принятых в этих примерах, и в других тестах для оптимизации конкретных рабочих нагрузок машинного обучения. К общим рабочим нагрузкам относятся обучение модели, извлечение компонентов и проектирование признаков и различные сценарии оценки: одна строка, Малый пакет и крупный пакет.

### <a name="feature-engineering"></a>Формирование признаков

Одной из проблем с R заключается в том, что она обычно обрабатывается на одном ЦП. Это существенное узкие места производительности для многих задач, особенно для проектирования характеристик. В решении "возобновление сопоставления" задача проектирования признаков только что создала 2 500 функций перекрестных продуктов, которые были бы объединены с исходными функциями 100. Эта задача займет значительное время, если все было выполнено на одном ЦП.

Существует несколько способов повысить производительность проектирования признаков. Можно либо оптимизировать код R, чтобы извлекать компоненты в рамках процесса моделирования, либо переместить процесс проектирования компонентов в SQL.

- Использование языка R. Вы определяете функцию и передаете ее в качестве аргумента [ркстрансформ](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxtransform) во время обучения. Если модель поддерживает параллельную обработку, задача проектирования признаков может быть обработана с использованием нескольких процессоров. При таком подходе Группа обработки и анализа данных насмотрела на производительность 16% в плане оценки времени. Однако для этого подхода требуется модель, которая поддерживает параллелизации, и запрос, который можно выполнить с помощью параллельного плана.

- Используйте R с контекстом вычислений SQL. В многопроцессорной среде с изолированными ресурсами, доступными для выполнения отдельных пакетов, можно повысить эффективность, изолируя запросы SQL, используемые для каждого пакета, для извлечения данных из таблиц и ограничения данных в одной группе рабочей нагрузки. Методы, используемые для изоляции пакетов, включают секционирование и использование PowerShell для параллельного выполнения отдельных запросов.

- Прямое параллельное выполнение: В SQL Server контексте вычислений можно полагаться на ядро СУБД SQL, чтобы принудительно применять параллельное выполнение, если это возможно, и если этот параметр будет более эффективным.

- Используйте T-SQL в отдельном процессе Добавление признаков. Предварительное вычисление данных о компонентах с помощью SQL обычно выполняется быстрее.

### <a name="prediction-scoring-in-parallel"></a>Прогнозирование (оценка) в параллельном режиме

Одним из преимуществ SQL Server является возможность параллельной обработки большого объема строк. Нигде это преимущество не так, как в случае с оценкой. Обычно модели не требуется доступ ко всем данным для оценки, поэтому можно секционировать входные данные с каждой группой рабочей нагрузки, обрабатывающей одну задачу.

Можно также отправить входные данные в виде одного запроса, а затем SQL Server проанализировать запрос. Если для входных данных можно создать параллельный план запроса, он автоматически разбивает данные, назначенные узлам, и выполняет необходимые объединения и агрегаты в параллельном режиме.

Если вы заинтересованы в подробностях определения хранимой процедуры для использования в оценке, см. Пример проекта на сайте [GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips/SQLR) и найдите файл "step5_score_for_matching. SQL". Пример скрипта также отслеживает время начала и окончания запроса и записывает время в консоль SQL, чтобы можно было оценить производительность.

### <a name="concurrent-scoring-using-resource-groups"></a>Одновременная Оценка с использованием групп ресурсов

Чтобы увеличить масштаб задачи оценки, рекомендуется применять подход с масштабированием, в котором миллионы элементов делятся на несколько пакетов. Затем несколько заданий оценки выполняются одновременно. В этой платформе пакеты обрабатываются на разных наборах ЦП, а результаты собираются и записываются обратно в базу данных.

Этот подход используется в сценарии сопоставления возобновления. Однако управление ресурсами в SQL Server важно для реализации этого подхода. Настроив группы рабочей нагрузки для внешних заданий скриптов, можно направить задания оценки R в разные группы процессоров и повысить пропускную способность.

Управление ресурсами может также помочь выделить разделение доступных ресурсов на сервере (ЦП и память) для снижения конкуренции рабочей нагрузки. Можно настроить функции-классификаторы для различения различных типов заданий R. Например, можно решить, что оценка, вызываемая из приложения, всегда имеет приоритет, а задания переобучения имеют низкий приоритет. Эта изоляция ресурсов потенциально может улучшить время выполнения и обеспечить более предсказуемую производительность.

### <a name="concurrent-scoring-using-powershell"></a>Параллельная оценка с помощью PowerShell

Если вы решили самостоятельно секционировать данные, можно использовать скрипты PowerShell для выполнения нескольких параллельных задач оценки. Для этого используйте командлет Invoke-SqlCmd и запустите задачи оценки параллельно.

В сценарии возобновления параллелизма была разработана следующим образом:

- 20 процессоров делятся на четыре группы из пяти процессоров. Каждая группа ЦП размещается на одном узле NUMA.

- Максимальное число одновременных пакетов было равно восьми.

- Каждая группа рабочей нагрузки должна выполнять две задачи оценки. Как только одна задача завершила чтение данных и начинает оценку, другая задача может начать чтение данных из базы данных.

Чтобы просмотреть скрипты PowerShell для этого сценария, откройте файл эксперимент. ps1 в [проекте GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips).

### <a name="storing-models-for-prediction"></a>Хранение моделей для прогнозирования

После завершения обучения и оценки и выбора лучшей модели рекомендуется хранить модель в базе данных, чтобы она была доступна для прогнозов. Загрузка предварительно вычисленной модели из базы данных для прогноза является эффективной, поскольку SQL Server машинное обучение использует специальные алгоритмы сериализации для хранения и загрузки моделей при перемещении между R и базой данных.

> [!TIP]
> В SQL Server 2017 можно использовать функцию PREDICT для оценки, даже если R не установлен на сервере. В пакете RevoScaleR поддерживаются ограниченные типы моделей.

Однако в зависимости от используемого алгоритма некоторые модели могут быть довольно большими, особенно при обучении большого набора данных. Например, такие алгоритмы, как **LM** или **GLM** , создают множество сводных данных вместе с правилами. Поскольку существуют ограничения на размер модели, которая может храниться в столбце varbinary, рекомендуется удалить ненужные артефакты из модели перед сохранением модели в базе данных для рабочей среды.

## <a name="articles-in-this-series"></a>Статьи в этой серии

[Настройка производительности для R — введение](../r/sql-server-r-services-performance-tuning.md)

[Настройка производительности для конфигурации R-SQL Server](../r/sql-server-configuration-r-services.md)

[Настройка производительности для кода R-R и оптимизации данных](../r/r-and-data-optimization-r-services.md)

[Настройка производительности — результаты исследования вариантов](../r/performance-case-study-r-services.md)
