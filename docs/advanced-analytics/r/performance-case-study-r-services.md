---
title: Производительность SQL Server R Services — результаты и ресурсы
ms.prod: sql
ms.technology: machine-learning
ms.date: 03/29/2019
ms.topic: conceptual
author: dphansen
ms.author: davidph
ms.openlocfilehash: 8d7f046e961efb6129f807a7626e498062c415b6
ms.sourcegitcommit: 9062c5e97c4e4af0bbe5be6637cc3872cd1b2320
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/24/2019
ms.locfileid: "68470160"
---
# <a name="performance-for-r-services-results-and-resources"></a>Производительность служб R: результаты и ресурсы
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

Эта статья является четвертой и последней в серии, в которой описывается оптимизация производительности для служб R. В этой статье перечислены методы, выводы и выводы двух примеров внедрения, которые протестировали различные методы оптимизации.

В двух примерах используется разная цель:

+ В первом практическом примере команда разработчиков служб R затронула влияние конкретных методов оптимизации.
+ Во втором примере с помощью команды анализу данных мы экспериментируем с несколькими методами для определения наилучшей оптимизации для конкретного сценария с большим объемом.

В этом разделе перечислены подробные результаты первого примера внедрения. Во втором практическом примере сводка описывает общие результаты. В конце этого раздела приведены ссылки на все сценарии и образцы данных, а также ресурсы, используемые исходными авторами.

## <a name="performance-case-study-airline-dataset"></a>Пример использования производительности: Набор данных авиакомпании

В нашем примере команда разработчиков SQL Server R Services проверила влияние различных оптимизаций. Была создана отдельная модель rxLogit и выполнена оценка набора данных авиакомпании. Оптимизации были применены во время обучения и оценки для оценки отдельных последствий.

- GitHub [Примеры данных и скриптов](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning) для оптимизации SQL Server

### <a name="test-methods"></a>Методы теста

1. Набор данных авиакомпании состоит из одной таблицы 10 миллионов строк. Он был скачан и выполнил загрузку в SQL Server.
2. Были сделаны шесть копий таблицы.
3. К копиям таблицы применены различные изменения, чтобы протестировать SQL Server такие функции, как сжатие страниц, сжатие строк, индексирование, хранилище данных по столбцам и т. д.
4. Производительность была измерена до и после применения каждой оптимизации.

| Имя таблицы| Описание|
|------|------|
| *airline* | Данные, преобразованные из исходного XDF-файла с использованием `rxDataStep`.|                          |
| *airlineWithIntCol*   | Параметр *DayOfWeek*, преобразованный в целое число, а не в строку. Эта таблица также добавляет столбец *rowNum*.|
| *airlineWithIndex*    | Здесь содержатся те же данные, что и в таблице *airlineWithIntCol*, но с одним кластеризованным индексом с применением столбца *rowNum*.|
| *airlineWithPageComp* | Здесь содержатся те же данные, что и в таблице *airlineWithIndex*, но с включенным сжатием страниц. Эта таблица также добавляет два столбца, *CRSDepHour* и *Late*, которые вычисляются из параметров *CRSDepTime* и *ArrDelay*. |
| *airlineWithRowComp*  | Здесь содержатся те же данные, что и в таблице *airlineWithIndex*, но с включенным сжатием строк. Эта таблица также добавляет два столбца, *CRSDepHour* и *Late*, которые вычисляются из параметров *CRSDepTime* и *ArrDelay*. |
| *airlineColumnar*     | Хранилище столбцов с одним кластеризованным индексом. Эта таблица заполняется данными из очищенного CSV-файла.|

Каждый тест состоит из следующих шагов:

1. Перед выполнением каждого теста вызывалась сборка мусора R.
2. Модель логистической регрессии создана на основе данных таблицы. Для параметра *rowsPerRead* каждого теста было задано значение 500 000.
3. Оценки были созданы с помощью обученной модели
4. Каждый тест выполнялся шесть раз. Время первого запуска ("холодный запуск") было удалено. Чтобы разрешить случайное выброс, **Максимальное** время выполнения оставшихся пяти запусков также было удалено. На основе среднего значения продолжительности четырех оставшихся выполнений вычислено среднее значение времени, затраченного на выполнение каждого теста.
5. Тесты выполнялись с параметром *репортпрогресс* со значением 3 (= отчет о времени и ходе выполнения). Каждый выходной файл содержит сведения о времени, затраченном на ввод-вывод, время перехода и время вычислений. Эти значения полезны для устранения неполадок и диагностики.
6. Выходные данные консоли также направляются в файл в выходном каталоге.
7. Скрипты тестирования обрабатывали время в этих файлах для вычисления среднего времени выполнения.

Например, следующие результаты являются значениями времени из одного теста. Нам нужны значения **общего времени чтения** (время ввода-вывода) и **времени перехода** (дополнительное время на настройку процессов для вычисления).

**Выборка времени**

```text
Running IntCol Test. Using airlineWithIntCol table.
run 1 took 3.66 seconds
run 2 took 3.44 seconds
run 3 took 3.44 seconds
run 4 took 3.44 seconds
run 5 took 3.45 seconds
run 6 took 3.75 seconds
  
Average Time: 3.4425
metric time pct
1 Total time 3.4425 100.00
2 Overall compute time 2.8512 82.82
3 Total read time 2.5378 73.72
4 Transition time 0.5913 17.18
5 Total non IO time 0.3134 9.10
```

Рекомендуется загрузить и изменить скрипты тестирования, чтобы помочь в устранении неполадок служб R или с помощью функций RevoScaleR.

### <a name="test-results-all"></a>Результаты теста (все)

В этом разделе сравниваются результаты для каждого из тестов до и после.

#### <a name="data-size-with-compression-and-a-columnar-table-store"></a>Размер данных с сжатием и табличным хранилищем столбцов

Первый тест по сравнению с использованием сжатия и таблицы столбцов для уменьшения размера данных.

| Имя таблицы            | Строки     | Зарезервировано   | Data       | index_size | Не используется  | Процент сохранения (зарезервировано) |
|-----------------------|----------|------------|------------|------------|---------|---------------------|
| *airlineWithIndex*    | 10 000 000 | 2 978 816 КБ | 2 972 160 КБ | 6128 КБ    | 528 КБ  | 0                   |
| *airlineWithPageComp* | 10 000 000 | 625 784 КБ  | 623 744 КБ  | 1352 КБ    | 688 КБ  | 79 %                 |
| *airlineWithRowComp*  | 10 000 000 | 1 262 520 КБ | 1 258 880 КБ | 2552 КБ    | 1088 КБ | 58 %                 |
| *airlineColumnar*     | 9 999 999  | 201 992 КБ  | 201 624 КБ  | н/д        | 368 КБ  | 93 %                 |

**Выводы**

Максимальное сокращение размера данных достигается за счет применения индекса columnstore, за которым следует сжатие страницы.

#### <a name="effects-of-compression"></a>Эффекты сжатия

Этот тест сравнивает преимущества сжатия строк, сжатия страниц и отсутствие сжатия. Модель обучена с `rxLinMod` использованием данных из трех разных таблиц данных. Для всех таблиц использованы те же формулы и запросы.

| Имя таблицы            | Имя теста       | numTasks | Среднее время |
|-----------------------|-----------------|----------|--------------|
| *airlineWithIndex*    | NoCompression   | 1        | 5,6775       |
|                       | Несжатие — параллельно| 4        | 5,1775       |
| *airlineWithPageComp* | PageCompression | 1        | 6,7875       |
|                       | Пажекомпрессион — Parallel | 4        | 5,3225       |
| *airlineWithRowComp*  | RowCompression  | 1        | 6,1325       |
|                       | Ровкомпрессион — Parallel  | 4        | 5,2375       |

**Выводы**

Только сжатие не помогает. В этом примере увеличение ресурсов процессора для сжатия компенсирует снижение времени ввода-вывода.

Однако при выполнении теста в параллельном режиме (для параметра *numTasks* задано значение 4) значение среднего времени сокращается.

Для более крупных наборов данных влияние сжатия может быть более заметным. Сжатие зависит от набора данных и значений. Поэтому, чтобы определить, как сжатие влияет на ваш набор данных, нужно поэкспериментировать.

### <a name="effect-of-windows-power-plan-options"></a>Воздействие параметров схемы управления питанием Windows

В этом эксперименте параметр `rxLinMod` использовался с таблицей *airlineWithIntCol*. Для схемы управления питанием Windows установлено значение **сбалансированная** или **Высокая производительность**. Для всех тестов для параметра *numTasks* было задано значение 1. Тест выполнялся шесть раз, и был выполнен дважды в обоих параметрах питания для исследования изменчивости результатов.

Режим **высокой производительности** :

| Имя теста | Выполнить \# | Истекшее время | Среднее время |
|-----------|--------|--------------|--------------|
| IntCol    | 1      | 3,57 с |              |
|           | 2      | 3,45 с |              |
|           | 3      | 3,45 с |              |
|           | 4      | 3,55 с |              |
|           | 5      | 3,55 с |              |
|           | 6      | 3,45 с |              |
|           |        |              | 3.475        |
|           | 1      | 3,45 с |              |
|           | 2      | 3,53 с |              |
|           | 3      | 3,63 с |              |
|           | 4      | 3,49 с |              |
|           | 5      | 3,54 с |              |
|           | 6      | 3,47 с |              |
|           |        |              | 3,5075       |

Вариант **сбалансированного** электропитания:

| Имя теста | Выполнить \# | Истекшее время | Среднее время |
|-----------|--------|--------------|--------------|
| IntCol    | 1      | 3,89 с |              |
|           | 2      | 4,15 с |              |
|           | 3      | 3,77 с |              |
|           | 4      | 5 с    |              |
|           | 5      | 3,92 с |              |
|           | 6      | 3,8 с  |              |
|           |        |              | 3,91         |
|           | 1      | 3,82 с |              |
|           | 2      | 3,84 с |              |
|           | 3      | 3,86 с |              |
|           | 4      | 4,07 с |              |
|           | 5      | 4,86 с |              |
|           | 6      | 3,75 с |              |
|           |        |              | 3,88         |

**Выводы**

При использовании высокопроизводительной схемы управления питанием Windows время выполнения  является более последовательным и быстрым.

#### <a name="using-integer-vs-strings-in-formulas"></a>Использование целых чисел и строк в формулах

Эта проверка оценивает влияние изменения кода на R, чтобы избежать распространенной проблемы со строковыми факторами. В частности, модель была обучена с `rxLinMod` использованием двух таблиц: в первую очередь эти факторы хранятся в виде строк. во второй таблице факторы хранятся в виде целых чисел.

+ Для таблицы *авиакомпании* столбец [DayOfWeek] содержит строки. Параметр _colInfo_ использовался для указания уровней коэффициента (понедельник, вторник,...)

+  Для таблицы *airlineWithIndex* значение [DayOfWeek] является целым числом. Параметр _colInfo_ не указан.

+ В обоих случаях использовалась одна формула: `ArrDelay ~ CRSDepTime + DayOfWeek`.

| Имя таблицы          | Имя теста   | Среднее время |
|---------------------|-------------|--------------|
| *Итог*           | *FactorCol* | 10,72        |
| *airlineWithIntCol* | *IntCol*    | 3,4475       |

**Выводы**

При использовании целых чисел вместо строк с коэффициентами существует четкая преимущество.

### <a name="avoiding-transformation-functions"></a>Предотвращение функций преобразования

В этом тесте модель обучена с `rxLinMod`помощью, но код был изменен между двумя запусками:

+ При первом запуске в процессе создания модели была применена функция преобразования. 
+ Во втором запуске значения компонентов были предварительно вычислены и доступны, поэтому функция преобразования не требуется.

| Имя теста             | Среднее время |
|-----------------------|--------------|
| WithTransformation    | 5,1675       |
| WithoutTransformation | 4,7          |

**Выводы**

Время обучения было короче, если функция преобразования **не** используется. Иными словами, модель была обучена быстрее при использовании столбцов, предварительно вычисленных и сохраненных в таблице.

Экономия должна быть больше, если было гораздо больше преобразований, а набор данных был больше (\> 100 млн).

### <a name="using-columnar-store"></a>Использование хранилища столбцов

Этот тест оценивает преимущества производительности при использовании хранилища данных и индекса столбцов. Одна и та же модель обучена с использованием `rxLinMod` и без преобразований данных.

+ В первом запуске таблица данных использовала стандартное хранилище строк.
+ Во втором выполнении было использовано хранилище столбцов.

| Имя таблицы         | Имя теста | Среднее время |
|--------------------|-----------|--------------|
| *airlineWithIndex* | RowStore  | 4,67         |
| *airlineColumnar*  | ColStore  | 4,555        |

**Выводы**

Более высокая производительность — хранилище столбцов, чем стандартное хранилище строк. Значительная разница в производительности может быть ожидаемой в больших наборах\> данных (100 м).

### <a name="effect-of-using-the-cube-parameter"></a>Воздействие использования параметра Cube

Цель этого теста — определить, может ли повысить производительность параметр в RevoScaleR для использования параметра предварительно вычисленного **куба** . Модель обучена с `rxLinMod`помощью, используя следующую формулу:

```R
ArrDelay ~ Origin:DayOfWeek + Month + DayofMonth + CRSDepTime
```

В таблице факторы *DayOfWeek* хранятся в виде строки.

| Имя теста     | Параметр куба | numTasks | Среднее время | Прогнозирование на одну строку (ArrDelay_Pred) |
|---------------|----------------|----------|--------------|---------------------------------|
| CubeArgEffect | `cube = F`     | 1        | 91,0725      | 9,959204                        |
|               |                | 4        | 44,09        | 9,959204                        |
|               | `cube = T`     | 1        | 21,1125      | 9,959204                        |
|               |                | 4        | 8,08         | 9,959204                        |

**Выводы**

Использование аргумента параметра Куба ясно повышает производительность.

### <a name="effect-of-changing-maxdepth-for-rxdtree-models"></a>Воздействие изменения maxDepth для моделей rxDTree

В этом эксперименте `rxDTree` алгоритм использовался для создания модели в таблице *аирлинеколумнар* . Для этого теста для параметра *numTasks* задано значение 4. Несколько различных значений для *MaxDepth* использовались для демонстрации того, как изменение глубины дерева влияет на время выполнения.

| Имя теста       | maxDepth | Среднее время |
|-----------------|----------|--------------|
| TreeDepthEffect | 1        | 10,1975      |
|                 | 2        | 13,2575      |
|                 | 4        | 19,27        |
|                 | 8        | 45,5775      |
|                 | 16       | 339,54       |

**Выводы**

По мере увеличения глубины дерева общее число узлов увеличивается экспоненциально. Время, затраченное на создание модели, также значительно увеличилось.

### <a name="prediction-on-a-stored-model"></a>Прогнозирование для хранимой модели

Цель этого теста — определить влияние оценки производительности на оценку, когда обученная модель сохраняется в SQL Server таблице, а не в виде части выполняемого в данный момент кода. Для оценки хранимая модель загружается из базы данных, а прогнозы создаются с помощью однострочного кадра данных в памяти (локального контекста вычислений).

Результаты теста показывают время сохранения модели и время, затрачиваемое на загрузку модели и прогнозирование.

| Имя таблицы | Имя теста | Среднее время (для обучения модели) | Время сохранения и загрузки модели|
|------------|------------|------------|------------|
| airline    | SaveModel| 21,59| 2,08|
| airline    | LoadModelAndPredict | | 2,09 (со временем для прогнозирования) |

**Выводы**

Загрузка обученной модели из таблицы, очевидно, является более быстрым способом прогнозирования. Рекомендуется избегать создания модели и выполнения оценки в одном и том же сценарии.

## <a name="case-study-optimization-for-the-resume-matching-task"></a>Пример использования: Оптимизация для задачи «возобновление сопоставления»

Модель сопоставления возобновления была разработана корпорацией Microsoft Data анализу Хаун для тестирования производительности кода R в SQL Server, а это помогает специалистам по обработке и анализу данных создавать масштабируемые решения корпоративного уровня.

### <a name="methods"></a>Методы

Пакеты RevoScaleR и MicrosoftML использовались для обучения прогнозной модели в сложном решении R, включающем большие наборы данных. Запросы SQL и код R были идентичны во всех тестах. Тесты были проведены на одной виртуальной машине Azure с установленными SQL Server. Затем автор сравнивает время оценки с и без следующих оптимизаций, предоставляемых SQL Server:

- Таблицы в памяти
- Soft-NUMA
- Resource Governor

Чтобы оценить воздействие программной архитектуры NUMA на выполнение скрипта R, Группа обработки и анализа данных проверила решение на виртуальной машине Azure с 20 физическими ядрами. На этих физических ядрах четыре узла программной архитектуры NUMA были созданы автоматически, так что каждый узел содержал пять ядер.

Аффинитизатион ЦП был применен в сценарии возобновления, чтобы оценить влияние на задания R. Были созданы четыре **пула ресурсов SQL** и четыре **внешних пула ресурсов** , и было указано сходство ЦП, чтобы обеспечить использование одного и того же набора процессоров в каждом узле.

Каждый пул ресурсов был назначен другой группе рабочей нагрузки для оптимизации использования оборудования. Причина заключается в том, что архитектура Soft-NUMA и привязка ЦП не могут делить физическую память на физических узлах NUMA. Таким образом, по определению, все узлы мягкого NUMA, основанные на одном физическом узле NUMA, должны использовать память в одном блоке памяти ОС. Иными словами, не существует сходства памяти с процессором.

Для создания этой конфигурации использовался следующий процесс:

1. Уменьшите объем памяти, выделенной по умолчанию, для SQL Server.

2. Создайте четыре новых пула для параллельного выполнения заданий R.

3. Создайте четыре группы рабочей нагрузки, чтобы каждая группа рабочей нагрузки была связана с пулом ресурсов.

4. Перезапустите Resource Governor с новыми группами и назначениями рабочей нагрузки.

5. Создайте определяемую пользователем функцию-классификатор (UDF), чтобы назначить различные задачи для разных групп рабочей нагрузки.

6. Обновите конфигурацию Resource Governor, чтобы использовать функцию для соответствующих групп рабочей нагрузки.

### <a name="results"></a>Результаты

Конфигурация, для которой была оптимальная производительность в исследовании возобновления, была следующей:

-   Четыре внутренних пула ресурсов (для SQL Server)

-   Четыре внешних пула ресурсов (для заданий внешних скриптов)

-   Каждый пул ресурсов связан с определенной группой рабочей нагрузки.

-   Каждый пул ресурсов назначается различным ЦП.

-   Максимальный объем использования внутренней памяти (для SQL Server) = 30%

-   Максимальный объем памяти, используемый сеансами R = 70%

Для модели сопоставления возобновления использование внешнего скрипта было тяжелым, а другие службы ядра СУБД не запущены. Таким образом, ресурсы, выделенные для внешних скриптов, были увеличены до 70%, что подходило наилучшую конфигурацию для производительности сценариев.

Эта конфигурация была получена путем экспериментов с различными значениями. При использовании другого оборудования или другого решения Оптимальная конфигурация может отличаться. Всегда экспериментируйте, чтобы найти оптимальную конфигурацию для вашего случая!

В оптимизированном решении 1 100 000 строк данных (с функциями 100) были оценены в течение 8,5 секунд на 20-ядерном компьютере. Оптимизация значительно улучшила производительность с точки зрения оценки времени.

Кроме того, в результатах было предложено, что **количество функций** существенно повлияло на время оценки. Улучшение было еще более наглядным, когда в модели прогнозирования были использованы дополнительные функции.

Рекомендуем ознакомиться с этой статьей в блоге и сопутствующим руководством для получения подробного обсуждения.

-   [Советы и рекомендации по оптимизации для машинного обучения в SQL Server](https://azure.microsoft.com/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/)

Многие пользователи отметили, что существует небольшая пауза, так как среда выполнения R (или Python) загружается в первый раз. По этой причине, как описано в этих тестах, время первого запуска часто измеряется, но позже отбрасывается. Последующее кэширование может привести к существенным различиям в производительности между первым и вторым запуском. Кроме того, при перемещении данных между SQL Server и внешней средой выполнения также взимается дополнительная нагрузка, особенно если данные передаются по сети, а не загружаются непосредственно из SQL Server.

По всем этим причинам не существует единого решения для устранения этого начального времени загрузки, так как влияние на производительность значительно зависит от задачи. Например, кэширование выполняется для оценки одной строки в пакетах; Следовательно, последующие операции оценки выполняются гораздо быстрее, и ни модель, ни среда выполнения R не будут перезагружены. Можно также использовать [собственную](../sql-native-scoring.md) оценку, чтобы полностью избежать загрузки среды выполнения R.

Для обучения больших моделей или оценки больших пакетов издержки могут быть минимальны по сравнению с ростом объема данных или потоковой передачей и параллельной обработкой. Дополнительные рекомендации по повышению производительности см. в этой записи блога:

+ [Использование R для обнаружения мошенничества в 1 000 000 транзакций в секунду](https://blog.revolutionanalytics.com/2016/09/fraud-detection.html/)

## <a name="resources"></a>Ресурсы

Ниже приведены ссылки на сведения, средства и сценарии, используемые при разработке этих тестов.

+ Скрипты тестирования производительности и ссылки на данные: [Примеры данных и скриптов для оптимизации SQL Server](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning)

+ Статья с описанием решения для возобновления поиска: [Советы и рекомендации по оптимизации для SQL Server R Services](https://azure.microsoft.com/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/)

+ Скрипты, используемые в оптимизации SQL для решения "возобновление сопоставления": [Репозиторий GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips)

### <a name="learn-about-windows-server-management"></a>Дополнительные сведения об управлении Windows Server

+ [Как определить размер файла подкачки для 64-разрядных версий Windows](https://support.microsoft.com/kb/2860880)

+ [Основные сведения о NUMA](https://technet.microsoft.com/library/ms178144.aspx)

+ [Как SQL Server поддерживает NUMA](https://technet.microsoft.com/library/ms180954.aspx)

+ [Мягкая архитектура NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server)

### <a name="learn-about-sql-server-optimizations"></a>Дополнительные сведения о оптимизации SQL Server

+ [Реорганизация и перестроение индексов](../../relational-databases/indexes/reorganize-and-rebuild-indexes.md)

+ [Общие сведения о таблицах, оптимизированных для памяти](https://docs.microsoft.com/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables)

+ [Демонстрация. Улучшение производительности выполняющейся в памяти OLTP](https://docs.microsoft.com/sql/relational-databases/in-memory-oltp/demonstration-performance-improvement-of-in-memory-oltp)

+ [Сжатие данных](../../relational-databases/data-compression/data-compression.md)

+ [Включение сжатия таблицы или индекса](../../relational-databases/data-compression/enable-compression-on-a-table-or-index.md)

+ [Отключение сжатия таблицы или индекса](../../relational-databases/data-compression/disable-compression-on-a-table-or-index.md)

### <a name="learn-about-managing-sql-server"></a>Дополнительные сведения об управлении SQL Server

+ [Наблюдение и настройка производительности](../../relational-databases/performance/monitor-and-tune-for-performance.md)

+ [Регулятор ресурсов](../../relational-databases/resource-governor/resource-governor.md)

+ [Введение в Resource Governor](https://technet.microsoft.com/library/bb895232.aspx)

+ [Управление ресурсами для служб R](resource-governance-for-r-services.md)

+ [Создание пула ресурсов для R](how-to-create-a-resource-pool-for-r.md)

+ [Пример настройки Resource Governor](https://blog.sqlauthority.com/2012/06/04/sql-server-simple-example-to-configure-resource-governor-introduction-to-resource-governor/)

### <a name="tools"></a>Инструменты

+ [Генератор загрузки хранилища DISKSPD. Тестовое средство производительности](https://github.com/microsoft/diskspd)

+ [Fsutil](https://technet.microsoft.com/library/cc753059.aspx)


## <a name="other-articles-in-this-series"></a>Другие статьи в этой серии

[Настройка производительности для R — введение](sql-server-r-services-performance-tuning.md)

[Настройка производительности для конфигурации R-SQL Server](sql-server-configuration-r-services.md)

[Настройка производительности для кода R-R и оптимизации данных](r-and-data-optimization-r-services.md)

[Настройка производительности — результаты исследования вариантов](performance-case-study-r-services.md)
