---
title: Производительность служб R SQL Server — результаты и ресурсы — SQL Server службы машинного обучения
ms.prod: sql
ms.technology: machine-learning
ms.date: 03/29/2019
ms.topic: conceptual
author: dphansen
ms.author: davidph
manager: cgronlun
ms.openlocfilehash: 392a6da09827355e6bc9a901b0e4580e5eb72bf5
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "62642677"
---
# <a name="performance-for-r-services-results-and-resources"></a>Производительность для служб R: результаты и ресурсы
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md-winonly](../../includes/appliesto-ss-xxxx-xxxx-xxx-md-winonly.md)]

В этой статье, — это четвертый и последний в ряде, описывающий оптимизации производительности для служб R. В этой статье перечислены методы, результаты и выводы двух примеров, которые протестировать различные методы оптимизации.

В двух примерах внедрения перед другой цели.

+ Первый пример использования, группа разработчиков служб R, поиск для оценки влияния конкретного пути оптимизации
+ Второй пример использования можно командой по обработке и анализу данных поэкспериментировали с несколько методов, чтобы определить лучшие показатели оптимизации для конкретного сценария оценки большого объема.

В этом разделе перечислены сведения о результатах первый пример использования. Для второй исследований Сводка описывает общую результаты. В конце этого раздела приведены ссылки на все сценарии и образцы данных и ресурсы, используемые первых авторов.

## <a name="performance-case-study-airline-dataset"></a>Пример производительности: Набор данных об авиарейсах

В этом практическом, группа разработчиков SQL Server R Services протестировать влияние различные оптимизации. Был создан один rxLogit модели и оценки над набора данных по Авиарейсам. Оптимизация были применены во время обучения и оценки процессов, чтобы оценить влияние отдельных.

- Github: [Демонстрационные данные и скрипты](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning) для оптимизации использования SQL Server

### <a name="test-methods"></a>Методы теста

1. Набор данных Airline состоит из одной таблицы 10 миллионов строк. Он был загружен и массовой загрузки в SQL Server.
2. Шесть копий таблицы были внесены.
3. Различные изменения были применены к копии таблицы, для тестирования функций SQL Server, такие как сжатие page, сжатие row, индексирования, хранения данных в хранилище и т. д.
4. Производительность измерялась до и после каждого оптимизации была применена.

| Имя таблицы| Описание|
|------|------|
| *airline* | Данные, преобразованные из исходного XDF-файла с использованием `rxDataStep`.|                          |
| *airlineWithIntCol*   | Параметр *DayOfWeek*, преобразованный в целое число, а не в строку. Эта таблица также добавляет столбец *rowNum*.|
| *airlineWithIndex*    | Здесь содержатся те же данные, что и в таблице *airlineWithIntCol*, но с одним кластеризованным индексом с применением столбца *rowNum*.|
| *airlineWithPageComp* | Здесь содержатся те же данные, что и в таблице *airlineWithIndex*, но с включенным сжатием страниц. Эта таблица также добавляет два столбца, *CRSDepHour* и *Late*, которые вычисляются из параметров *CRSDepTime* и *ArrDelay*. |
| *airlineWithRowComp*  | Здесь содержатся те же данные, что и в таблице *airlineWithIndex*, но с включенным сжатием строк. Эта таблица также добавляет два столбца, *CRSDepHour* и *Late*, которые вычисляются из параметров *CRSDepTime* и *ArrDelay*. |
| *airlineColumnar*     | Хранилище столбцов с одним кластеризованным индексом. Эта таблица заполняется данными из очищенного CSV-файла.|

Каждый тест состоял из следующих действий:

1. Перед выполнением каждого теста вызывалась сборка мусора R.
2. Модель логистической регрессии был создан на основе данных таблицы. Для параметра *rowsPerRead* каждого теста было задано значение 500 000.
3. Показатели, созданные с помощью обученной модели
4. Каждый тест выполнен шесть раз. Время первого запуска («холодный запуск»), был удален. Чтобы разрешить случайные выбросы, **максимальное** времени среди оставшихся пяти выполнений также были удалены. На основе среднего значения продолжительности четырех оставшихся выполнений вычислено среднее значение времени, затраченного на выполнение каждого теста.
5. Тесты проводились с помощью *reportProgress* параметр со значением 3 (= временные параметры отчета и ход выполнения). Каждый выходной файл содержит сведения о времени, затраченного на операции ввода-ВЫВОДА, время перехода и вычисления. Эти значения полезны для устранения неполадок и диагностики.
6. В выходных данных консоли также был направлен в файл в выходном каталоге.
7. Сценарии тестирования обработки значения времени в этих файлах, чтобы вычислить среднее время для всех выполнений.

Например следующие результаты являются значения времени из одного теста. Нам нужны значения **общего времени чтения** (время ввода-вывода) и **времени перехода** (дополнительное время на настройку процессов для вычисления).

**Пример временных интервалов**

```text
Running IntCol Test. Using airlineWithIntCol table.
run 1 took 3.66 seconds
run 2 took 3.44 seconds
run 3 took 3.44 seconds
run 4 took 3.44 seconds
run 5 took 3.45 seconds
run 6 took 3.75 seconds
  
Average Time: 3.4425
metric time pct
1 Total time 3.4425 100.00
2 Overall compute time 2.8512 82.82
3 Total read time 2.5378 73.72
4 Transition time 0.5913 17.18
5 Total non IO time 0.3134 9.10
```

Мы рекомендуем скачать и изменить скрипты тестов для устранения проблем со службами R или с помощью функций RevoScaleR.

### <a name="test-results-all"></a>(Все) результаты теста

В этом разделе сравниваются до и после результатов для каждого из тестов.

#### <a name="data-size-with-compression-and-a-columnar-table-store"></a>Размер данных со сжатием и один столбец табличным хранилищем

Первый тест по сравнению с использование сжатия и таблицы столбцов для уменьшения объема данных.

| Имя таблицы            | Строки     | Зарезервировано   | Данные       | index_size | Не используется  | Процент сохранения (зарезервировано) |
|-----------------------|----------|------------|------------|------------|---------|---------------------|
| *airlineWithIndex*    | 10 000 000 | 2 978 816 КБ | 2 972 160 КБ | 6128 КБ    | 528 КБ  | 0                   |
| *airlineWithPageComp* | 10 000 000 | 625 784 КБ  | 623 744 КБ  | 1352 КБ    | 688 КБ  | 79 %                 |
| *airlineWithRowComp*  | 10 000 000 | 1 262 520 КБ | 1 258 880 КБ | 2552 КБ    | 1088 КБ | 58 %                 |
| *airlineColumnar*     | 9 999 999  | 201 992 КБ  | 201 624 КБ  | н/д        | 368 КБ  | 93 %                 |

**Заключение**

Наибольшее уменьшение размера данных достигалось путем применения индекса columnstore, следуют сжатие страниц.

#### <a name="effects-of-compression"></a>Влияние сжатия

Этот тест по сравнению с преимуществами сжатия строк, сжатие страниц и отсутствие сжатия. Модель была обучена с помощью `rxLinMod` на данные из трех таблиц данных. Для всех таблиц использованы те же формулы и запросы.

| Имя таблицы            | Имя теста       | numTasks | Среднее время |
|-----------------------|-----------------|----------|--------------|
| *airlineWithIndex*    | NoCompression   | 1        | 5,6775       |
|                       | NoCompression - параллельном режиме| 4        | 5,1775       |
| *airlineWithPageComp* | PageCompression | 1        | 6,7875       |
|                       | PageCompression - параллельном режиме | 4        | 5,3225       |
| *airlineWithRowComp*  | RowCompression  | 1        | 6,1325       |
|                       | RowCompression - параллельном режиме  | 4        | 5,2375       |

**Заключение**

Чтобы помочь не только сжатие. В этом примере повышение нагрузки ЦП для обработки сжатия компенсирует уменьшение времени ввода-ВЫВОДА.

Однако при выполнении теста в параллельном режиме (для параметра *numTasks* задано значение 4) значение среднего времени сокращается.

Для более крупных наборов данных влияние сжатия может быть более заметным. Сжатие зависит от набора данных и значений. Поэтому, чтобы определить, как сжатие влияет на ваш набор данных, нужно поэкспериментировать.

### <a name="effect-of-windows-power-plan-options"></a>Влияние вариантов схемы электропитания Windows

В этом эксперименте параметр `rxLinMod` использовался с таблицей *airlineWithIntCol*. План электропитания Windows были заданы значения **Сбалансированный** или **высокопроизводительных**. Для всех тестов для параметра *numTasks* было задано значение 1. Тест выполнен шесть раз и дважды с включением обоих параметров электропитания для изучения Разброс результатов.

**Высокая производительность** вариант электропитания:

| Имя теста | Выполнить \# | Истекшее время | Среднее время |
|-----------|--------|--------------|--------------|
| IntCol    | 1      | 3,57 с |              |
|           | 2      | 3,45 с |              |
|           | 3      | 3,45 с |              |
|           | 4      | 3,55 с |              |
|           | 5      | 3,55 с |              |
|           | 6      | 3,45 с |              |
|           |        |              | 3.475        |
|           | 1      | 3,45 с |              |
|           | 2      | 3,53 с |              |
|           | 3      | 3,63 с |              |
|           | 4      | 3,49 с |              |
|           | 5      | 3,54 с |              |
|           | 6      | 3,47 с |              |
|           |        |              | 3,5075       |

Вариант **сбалансированного** электропитания:

| Имя теста | Выполнить \# | Истекшее время | Среднее время |
|-----------|--------|--------------|--------------|
| IntCol    | 1      | 3,89 с |              |
|           | 2      | 4,15 с |              |
|           | 3      | 3,77 с |              |
|           | 4      | 5 с    |              |
|           | 5      | 3,92 с |              |
|           | 6      | 3,8 с  |              |
|           |        |              | 3,91         |
|           | 1      | 3,82 с |              |
|           | 2      | 3,84 с |              |
|           | 3      | 3,86 с |              |
|           | 4      | 4,07 с |              |
|           | 5      | 4,86 с |              |
|           | 6      | 3,75 с |              |
|           |        |              | 3,88         |

**Заключение**

Время выполнения — более согласованные и низкие при использовании Windows **высокопроизводительных** схемы управления питанием.

#### <a name="using-integer-vs-strings-in-formulas"></a>С помощью целого числа и строки в формулах

Этот тест оценить влияние изменения кода R, чтобы избежать распространенной проблемой с коэффициентами в виде строк. В частности, модель была обучена с помощью `rxLinMod` с помощью двух таблиц: в первом факторов, хранятся в виде строки; во второй таблице, факторов, хранятся в виде целых чисел.

+ Для *авиакомпании* таблицы, столбца [DayOfWeek] содержит строки. _ColInfo_ параметр был использован для указания уровней факторов (понедельник, Вторник,...)

+  Для *airlineWithIndex* таблицы [DayOfWeek] должно быть целым числом. _ColInfo_ не указан.

+ В обоих случаях использовалась одна формула: `ArrDelay ~ CRSDepTime + DayOfWeek`.

| Имя таблицы          | Имя теста   | Среднее время |
|---------------------|-------------|--------------|
| *Авиакомпании*           | *FactorCol* | 10,72        |
| *airlineWithIntCol* | *IntCol*    | 3,4475       |

**Заключение**

Нет очевидное преимущество при использовании целых чисел, а не строк для факторов.

### <a name="avoiding-transformation-functions"></a>Как избежать функции преобразования

В этом тесте модель была обучена с помощью `rxLinMod`, но был изменен код между двумя запусками:

+ При первом запуске функции преобразования был применен как часть построения модели. 
+ Во время выполнения второй значения компонента были предварительно вычисляемые и доступны, таким образом, чтобы функция преобразования не требовалось.

| Имя теста             | Среднее время |
|-----------------------|--------------|
| WithTransformation    | 5,1675       |
| WithoutTransformation | 4,7          |

**Заключение**

Время на обучение был короче when **не** с функцией преобразования. Другими словами модель была обучена быстрее при использовании столбцов, которые предварительно вычисленные и сохраняются в таблице.

Экономия должен быть больше, если было больше преобразований и набор данных был большего размера (\> 100 млн строк).

### <a name="using-columnar-store"></a>Использование хранилища столбцов

Этот тест оценили преимущества производительности, используя хранилище по столбцам данных и индекс. Ту же модель была обучена с помощью `rxLinMod` и без преобразования данных.

+ Во время первого запуска в таблице данных используется хранилище standard строк.
+ Во время выполнения второй использовался хранилища столбцов.

| Имя таблицы         | Имя теста | Среднее время |
|--------------------|-----------|--------------|
| *airlineWithIndex* | RowStore  | 4,67         |
| *airlineColumnar*  | ColStore  | 4,555        |

**Заключение**

Производительность повышается с помощью хранилища столбцов, чем в хранилище standard строки. Значительная разница в производительности можно ожидать на более крупных наборов данных (\> 100 млн строк).

### <a name="effect-of-using-the-cube-parameter"></a>Результат использования параметра куба

Цель этого теста — определить ли вариант в RevoScaleR использования предварительно вычисляемых **куба** может повысить производительность. Модель была обучена с помощью `rxLinMod`, используя следующую формулу:

```R
ArrDelay ~ Origin:DayOfWeek + Month + DayofMonth + CRSDepTime
```

В таблице, факторы *DayOfWeek* хранится в виде строки.

| Имя теста     | Параметр куба | numTasks | Среднее время | Однострочный прогнозирования (ArrDelay_Pred) |
|---------------|----------------|----------|--------------|---------------------------------|
| CubeArgEffect | `cube = F`     | 1        | 91,0725      | 9,959204                        |
|               |                | 4        | 44,09        | 9,959204                        |
|               | `cube = T`     | 1        | 21,1125      | 9,959204                        |
|               |                | 4        | 8,08         | 9,959204                        |

**Заключение**

Использование аргумента параметра куба очевидно, что повышает производительность.

### <a name="effect-of-changing-maxdepth-for-rxdtree-models"></a>Эффект от изменения maxDepth для rxDTree моделей

В этом эксперименте `rxDTree` алгоритм был использован для создания модели на *airlineColumnar* таблицы. Для этого теста для параметра *numTasks* задано значение 4. Несколько разных значений *maxDepth* были использованы, чтобы продемонстрировать, как изменение глубина дерева влияет на время выполнения.

| Имя теста       | maxDepth | Среднее время |
|-----------------|----------|--------------|
| TreeDepthEffect | 1        | 10,1975      |
|                 | 2        | 13,2575      |
|                 | 4        | 19,27        |
|                 | 8        | 45,5775      |
|                 | 16       | 339,54       |

**Заключение**

При увеличении глубины дерева, общее число узлов увеличивается экспоненциально. Значительно расширен время для создания модели.

### <a name="prediction-on-a-stored-model"></a>Прогноз на хранимой модели

Цель этого теста — определить влияние на производительность на оценки при обученная модель сохраняется в таблицу SQL Server, а не создается как часть текущим исполняемым кодом. Для оценки, сохраненную модель загружается из базы данных и прогнозы создаются с помощью кадр одну строку данных в памяти (Локальный Контекст вычислений).

В результатах теста показано время сохранения модели и время, необходимое для загрузки модели и прогнозирования.

| Имя таблицы | Имя теста | Среднее время (для обучения модели) | Время сохранения и загрузки модели|
|------------|------------|------------|------------|
| airline    | SaveModel| 21,59| 2,08|
| airline    | LoadModelAndPredict | | 2,09 (со временем для прогнозирования) |

**Заключение**

Загрузка обученной модели из таблицы четко — более быстрый способ сделать прогноз. Рекомендуется избегать создания модели и выполнения оценки в тот же скрипт.

## <a name="case-study-optimization-for-the-resume-matching-task"></a>Пример внедрения: Оптимизация для задачи подбора резюме

Модель подбора резюме был разработан, специалист по обработке данных Майкрософт Хаун Ke для тестирования производительности кода R в SQL Server и, выполнив так справочные данные по обработке и анализу создавать масштабируемые, решений корпоративного уровня.

### <a name="methods"></a>Методы

Пакеты RevoScaleR и MicrosoftML использовались для обучения модели прогнозирования в решении сложных R, связанные с большими наборами данных. Запросы SQL и R кода были бы одинаковыми во всех тестах. Тесты проводились на отдельной виртуальной Машины с установленным SQL Server. Затем автор по сравнению с оценки времени, с и без следующие оптимизации, предоставляемым SQL Server:

- Таблицы в памяти
- Soft-NUMA
- Resource Governor

Чтобы оценить влияние архитектуры soft-NUMA на выполнение скрипта R, команды обработки и анализа данных тестировать решение на виртуальной машине Azure с 20 физических ядер. На этих физических ядер на четырех узлов программной архитектуры NUMA были созданы автоматически, таким образом, что каждый узел содержит пять ядер.

Сопоставить ЦП был принудительно применен в сценарии подбора резюме, чтобы оценить влияние заданий R. Четыре **пулы ресурсов SQL** и четыре **внешние пулы ресурсов** были созданы, и сходство ЦП был указан для того, в каждом узле будет использоваться одинаковый набор процессоров.

Каждый из пулов ресурсов был назначен группе отличается от рабочей нагрузки, оптимизации использования оборудования. Причина в том, что программная архитектура NUMA, а также соответствие Процессоров невозможно разделить физической памяти в физических узлов NUMA; Таким образом по определению все обратимо узлов NUMA, основанные на одном физическом узле NUMA необходимо использовать память в одном блоке памяти операционной системы. Другими словами есть без соответствия памяти и процессора.

Следующий процесс был использован для создания этой конфигурации:

1. Уменьшите объем памяти, выделенной по умолчанию для SQL Server.

2. Создайте четыре новых пулов для выполнения заданий r. в параллельном режиме.

3. Создайте четыре группы рабочей нагрузки таким образом, каждая группа рабочей нагрузки связана с пулом ресурсов.

4. Перезапустите регулятора ресурсов с помощью новых групп рабочей нагрузки и назначений.

5. Создайте определяемые пользователем функцию (UDF), чтобы назначить различные задачи в группах отличается от рабочей нагрузки.

6. Обновите конфигурацию регулятора ресурсов для использования функции для групп соответствующую рабочую нагрузку.

### <a name="results"></a>Результаты

Настройка, для оптимальной производительности в подбора резюме изучить была следующим образом:

-   Четыре внутренние пулы ресурсов (для SQL Server)

-   Четыре внешних пулов ресурсов (для внешних скриптов заданий)

-   Каждый пул ресурсов связан с группу рабочей нагрузки

-   Каждого пула ресурсов, назначенные разным ЦП

-   Максимальный объем памяти для внутреннего использования (для SQL Server) = 30%

-   Максимальный объем памяти для использования сеансов R = 70%

Для модели подбора резюме использования внешних скриптов было активно и возникли другие базы данных под управлением службы ядра СУБД. Таким образом ресурсы, выделенные для внешних скриптов было увеличено до 70%, что оказалось оптимальные для производительности с использованием сценария.

Эта конфигурация был получен, поэкспериментировав с различными значениями. Если используется другое оборудование или другое решение, оптимальной конфигурации могут отличаться. Всегда экспериментировать с целью нахождения оптимальной конфигурации для конкретных вариантов!

Оптимизированные решения в течение 8,5 секунд на компьютере 20 ядрами рейтинги 1.1 миллионов строк данных (с помощью функций 100). Оптимизация значительно повышена производительность с точки зрения времени оценки.

Результаты также рекомендуется **число функций** бы значительное влияние на время оценки. Улучшение стало еще важнее, при возможности были использованы в модели прогнозирования.

Мы рекомендуем ознакомиться с этой записи блога и сопутствующие руководства подробные сведения.

-   [Оптимизация советы и рекомендации для машинного обучения в SQL Server](https://azure.microsoft.com/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/)

Многие пользователи отметили, что имеется небольшой паузы в первый раз после загрузки среды выполнения R (или Python). По этой причине как описано в этих тестах время первого запуска часто она измеряется, но позже уничтожен. Кэширование может привести к важные различия в производительности между первым и во-вторых, выполняется. Есть также некоторые издержки при перемещении данных между SQL Server и внешней средой выполнения, особенно в том случае, если данные, передаваемые по сети, а не которые загружаются непосредственно из SQL Server.

По этим причинам не существует не один решения по устранению рисков на этот раз начальной загрузки как влияние на производительность существенно изменяется в зависимости от задачи. Например кэширование выполняется для одной строки оценки в пакетах; Таким образом последовательные операции оценки выполняется гораздо быстрее и среды выполнения R, ни модель загружается. Можно также использовать [собственной оценки](../sql-native-scoring.md) следует избегать загрузки среды выполнения R полностью.

Для обучаете большие модели или оценки в больших пакетах, могут определяться мала по сравнению с выигрыш без перемещения данных или потоковой передачи и параллельной обработки. См. в записи блога Дополнительные сведения:

+ [С помощью языка R для обнаружения мошенничества в 1 миллион транзакций в секунду](https://blog.revolutionanalytics.com/2016/09/fraud-detection.html/)

## <a name="resources"></a>Ресурсы

Ниже приведены ссылки на сведения, инструменты и скрипты, используемые при разработке этих тестов.

+ Тестирование сценариев, а также ссылки на данные производительности: [Образцы данных и сценарии для оптимизации использования SQL Server](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning)

+ Статьи, в которых подбора резюме решения: [Советы по оптимизации и рекомендации для SQL Server R Services](https://azure.microsoft.com/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/)

+ Скрипты, используемые в оптимизации SQL для подбора резюме решения: [Репозиторий GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips)

### <a name="learn-about-windows-server-management"></a>Дополнительные сведения об управлении Windows server

+ [Как определить размер файла подкачки для 64-разрядных версий Windows](https://support.microsoft.com/kb/2860880)

+ [Понимание архитектуры NUMA](https://technet.microsoft.com/library/ms178144.aspx)

+ [Как SQL Server поддерживает архитектуру NUMA](https://technet.microsoft.com/library/ms180954.aspx)

+ [Программная архитектура NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server)

### <a name="learn-about-sql-server-optimizations"></a>Дополнительные сведения об оптимизации SQL Server

+ [Реорганизация и перестроение индексов](../../relational-databases/indexes/reorganize-and-rebuild-indexes.md)

+ [Сведения о таблицах, оптимизированных для памяти](https://docs.microsoft.com/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables)

+ [Демонстрация. Улучшение производительности выполняющейся в памяти OLTP](https://docs.microsoft.com/sql/relational-databases/in-memory-oltp/demonstration-performance-improvement-of-in-memory-oltp)

+ [Сжатие данных](../../relational-databases/data-compression/data-compression.md)

+ [Включение сжатия таблицы или индекса](../../relational-databases/data-compression/enable-compression-on-a-table-or-index.md)

+ [Отключение сжатия таблицы или индекса](../../relational-databases/data-compression/disable-compression-on-a-table-or-index.md)

### <a name="learn-about-managing-sql-server"></a>Дополнительные сведения об управлении SQL Server

+ [Наблюдение и настройка производительности](../../relational-databases/performance/monitor-and-tune-for-performance.md)

+ [Регулятор ресурсов](../../relational-databases/resource-governor/resource-governor.md)

+ [Знакомство с регулятором ресурсов](https://technet.microsoft.com/library/bb895232.aspx)

+ [Управление ресурсами для служб R](resource-governance-for-r-services.md)

+ [Создание пула ресурсов для R](how-to-create-a-resource-pool-for-r.md)

+ [Пример настройки регулятора ресурсов](https://blog.sqlauthority.com/2012/06/04/sql-server-simple-example-to-configure-resource-governor-introduction-to-resource-governor/)

### <a name="tools"></a>Инструменты

+ [Генератор загрузки хранилища DISKSPD. Тестовое средство производительности](https://github.com/microsoft/diskspd)

+ [Fsutil](https://technet.microsoft.com/library/cc753059.aspx)


## <a name="other-articles-in-this-series"></a>Другие статьи этой серии

[Производительность Настройка для R — введение](sql-server-r-services-performance-tuning.md)

[Настройка производительности для R — конфигурация SQL Server](sql-server-configuration-r-services.md)

[Настройка производительности для R — R оптимизации кода и данных](r-and-data-optimization-r-services.md)

[Помощник по настройке производительности - пример внедрения результатов](performance-case-study-r-services.md)
