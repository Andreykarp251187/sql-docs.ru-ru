---
title: Преобразование кода R для хранимых процедур
description: Перенос кода R в SQL Server хранимую процедуру для развертывания решения и доступа к данным в реляционных данных на SQL Server.
ms.prod: sql
ms.technology: machine-learning
ms.date: 04/15/2018
ms.topic: conceptual
author: dphansen
ms.author: davidph
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: 536be600d319335173dbf112ec2d8f67cc7bf14b
ms.sourcegitcommit: 321497065ecd7ecde9bff378464db8da426e9e14
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/01/2019
ms.locfileid: "68715738"
---
# <a name="convert-r-code-for-execution-in-sql-server-in-database-instances"></a>Преобразование кода R для выполнения в экземплярах SQL Server (в базе данных)
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

В этой статье содержатся рекомендации по изменению кода R для работы в SQL Server. 

При перемещении кода R из R Studio или другой среды в SQL Server, чаще всего код работает без дальнейшего изменения: например, если код прост, например, функция, принимающая некоторые входные данные и возвращающая значение. Также проще переносить решения, использующие пакеты **RevoScaleR** или **MicrosoftML** , которые поддерживают выполнение в разных контекстах выполнения с минимальными изменениями.

Однако код может потребовать внесения значительных изменений, если применяется одно из следующих условий.

+ Вы используете библиотеки R, которые обращаются к сети или не могут быть установлены на SQL Server.
+ Код выполняет отдельные вызовы источников данных вне SQL Server, таких как листы Excel, файлы в общих папках и другие базы данных. 
+ Необходимо выполнить код в *@script* параметре [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md) , а также параметризовать хранимую процедуру.
+ Исходное решение включает в себя несколько шагов, которые могут быть более эффективными в рабочей среде, если они выполняются независимо, например подготовка данных или проектирование функций, а также обучение модели, оценка или отчетность.
+ Вы хотите повысить производительность, изменив библиотеки, используя параллельное выполнение, или разгрузим обработку в SQL Server. 

## <a name="step-1-plan-requirements-and-resources"></a>Шаг 1. Требования и ресурсы плана

**Пакеты**

+ Определите, какие пакеты необходимы, и убедитесь, что они работают с SQL Server.
 
+ Предварительная установка пакетов в библиотеке пакетов по умолчанию, используемой Службы машинного обучения. Пользовательские библиотеки не поддерживаются.

**Источники данных** 

+ Если вы собираетесь внедрить код R в [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), выявление первичного и вторичного источников данных. 

    + **Первичные** источники данных — это большие наборы, такие как обучающие данные модели, или входные данные для прогнозов. Запланируйте соответствие самого крупного набора данных с входным параметром [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md).

    + **Вторичные** источники данных обычно представляют собой небольшие наборы данных, такие как списки факторов или дополнительные переменные группирования. 
    
    В настоящее время sp_execute_external_script поддерживает только один набор данных в качестве входа для хранимой процедуры. Однако можно добавить несколько скалярных или бинарных входов.

    Вызовы хранимых процедур с префиксом EXECUTE не могут использоваться в качестве входных данных для [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). Можно использовать запросы, представления или любую другую допустимую инструкцию SELECT.

+ Определите нужные выходные данные. При выполнении кода R с помощью sp_execute_external_script хранимая процедура может выводить только один кадр данных. Однако можно также выводить несколько скалярных выходов, включая графики и модели в двоичном формате, а также другие скалярные значения, полученные из кода R или параметров SQL.

**Типы данных**

+ Составьте контрольный список возможных проблем с типами данных.

    Службы SQL Server машинного обучения поддерживают все типы данных R. Однако поддерживает [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] более разнообразные типы данных, чем R. Поэтому при отправке [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] данных в R и наоборот выполняются некоторые неявные преобразования типов данных. Может потребоваться явное приведение или преобразование некоторых данных. 

    Значения NULL поддерживаются. Однако R использует `na` конструкцию данных для представления отсутствующего значения, которое аналогично значению NULL.

+ Рекомендуется исключить зависимость от данных, которые не могут использоваться в R: например, типы данных ROWID и GUID из SQL Server не могут быть использованы R и создают ошибки.

    Дополнительные сведения см. в разделе [библиотеки R и типы данных](../r/r-libraries-and-data-types.md).

## <a name="step-2-convert-or-repackage-code"></a>Шаг 2. Преобразование или переупаковка кода

Степень изменения кода зависит от того, планируется ли отправить код R с удаленного клиента для выполнения в SQL Server контексте вычислений или планируется развернуть код как часть хранимой процедуры, что обеспечивает лучшую производительность и безопасность данных. Заключение кода в хранимую процедуру накладывает некоторые дополнительные требования. 

+ Чтобы избежать перемещения данных, определите первичные входные данные как SQL-запрос везде, где это возможно.

+ При запуске R в хранимой процедуре можно передавать несколько **скалярных** входных данных. Для всех параметров, которые необходимо использовать в выходных данных, добавьте ключевое слово **Output** . 

    Например, следующие скалярные входные `@model_name` данные содержат имя модели, которое также выводится в виде собственного столбца в результатах:

    ```sql
    EXEC sp_execute_external_script @model_name="DefaultModel" OUTPUT, @language=N'R', @script=N'R code here'
    ``` 

+ Любые переменные, передаваемые в качестве параметров хранимой процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md) , должны быть сопоставлены с переменными в коде R. По умолчанию переменные сопоставляются по имени.

    Все столбцы входного набора данных также должны быть сопоставлены с переменными в скрипте R.  Например, предположим, что сценарий R содержит формулу, подобную следующей:

    ```R
    formula <- ArrDelay ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    ```
    
    Если входной набор данных не содержит столбцов с совпадающими именами ArrDelay, CRSDepTime, DayOfWeek, CRSDepHour и DayOfWeek, возникает ошибка.

+ В некоторых случаях для результатов необходимо заранее определить выходную схему.

    Например, чтобы вставить данные в таблицу, необходимо использовать предложение **WITH RESULT SET** , чтобы указать схему.

    Выходная схема также необходима, если в скрипте R используется аргумент `@parallel=1`. Дело в том, что SQL Server может распределить запрос между несколькими параллельными процессами и собирать результаты в конце. Поэтому перед созданием параллельных процессов необходимо подготовить выходную схему.
    
    В других случаях результирующую схему можно опустить с помощью параметра **с результирующими наборами undefine**. Эта инструкция возвращает набор данных из скрипта R без присвоения имен столбцам или указания типов данных SQL.

+ Рассмотрите возможность создания данных времени или отслеживания с помощью T-SQL, а не R.

    Например, можно передать системное время или другие сведения, используемые для аудита и хранения, добавив вызов T-SQL, который передается в результаты, вместо того, чтобы создавать аналогичные данные в скрипте R. 

**Повышение производительности и безопасности**

+ Избегайте записи прогнозов или промежуточных результатов в файл. Вместо этого напишите прогнозы в таблицу, чтобы избежать перемещения данных.

+ Выполните все запросы заранее и изучите SQL Server планы запросов, чтобы найти задачи, которые можно выполнять параллельно.

    Если входной запрос можно выполнить параллельно, задайте в `@parallel=1` качестве части аргументов значение [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). 

    Параллельная обработка с использованием этого параметра обычно поддерживается, если SQL Server может работать с секционированными таблицами или распределять запрос между несколькими процессами и выполнять статистическую обработку результатов в конце. Параллельная обработка с использованием этого параметра обычно не поддерживается, если для обучения моделей применяются алгоритмы, требующие считывания всех данных, или если требуется создать агрегаты.

+ Определите, нет ли в коде R действий, которые можно выполнять отдельно или более эффективно с помощью вызова отдельной хранимой процедуры. Например, можно получить лучшую производительность, выполнив отдельное Проектирование компонентов или компонентов и сохранив значения в таблице.

+ Поиск способов использования T-SQL вместо кода R для вычислений на основе наборов.

    Например, это решение R показывает, как пользовательские функции T-SQL и R могут выполнять одну и ту же задачу по проектированию функций: [Пошаговое руководство по](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md)обработке и анализу данных.

+ По возможности замените обычные функции R функциями **масштабирования** , поддерживающими распределенное выполнение. Дополнительные сведения см. в разделе [Сравнение базовых функций r и Scale](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/revoscaler-compared-to-base-r).

+ Обратитесь к разработчику базы данных, чтобы определить способы повышения производительности с помощью SQL Serverных функций, таких как оптимизированные для [памяти таблицы](https://docs.microsoft.com/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables), или, если используется выпуск Enterprise Edition, [Resource Governor](https://docs.microsoft.com/sql/relational-databases/resource-governor/resource-governor)).

    Дополнительные сведения см. в статье [Советы и рекомендации по оптимизации SQL Server для служб аналитики](https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services) .

### <a name="step-3-prepare-for-deployment"></a>Шаг 3. Подготовка к развертыванию

+ Обратитесь к администратору, чтобы установить и протестировать пакеты до развертывания кода. 

    В среде разработки можно устанавливать пакеты как часть кода, но это неплохой подход в рабочей среде. 

    Пользовательские библиотеки не поддерживаются независимо от того, используете ли вы хранимую процедуру или выполнение кода R в SQL Server контексте вычислений.

**Упаковка кода R в хранимую процедуру**

+ Если код относительно прост, его можно внедрить в определяемую пользователем функцию T-SQL без изменения, как описано в следующих примерах:

    + [Создание функции R, которая выполняется в rxExec](../tutorials/deepdive-create-a-simple-simulation.md)
    + [Проектирование характеристик с помощью T-SQL и R](../tutorials/sqldev-create-data-features-using-t-sql.md)

+ Если код более сложен, используйте пакет R **sqlrutils** для преобразования кода. Этот пакет призван помочь опытным пользователям R написать хороший код хранимой процедуры. 

    Первый шаг — переписать код R как единую функцию с четко определенными входными и выходными данными.

    Затем используйте пакет **sqlrutils** для создания входных и выходных данных в правильном формате. Пакет **sqlrutils** создает полный код хранимой процедуры и может также зарегистрировать хранимую процедуру в базе данных. 

    Дополнительные сведения и примеры см. в разделе [sqlrutils (SQL)](ref-r-sqlrutils.md).

**Интеграция с другими рабочими процессами**

+ Использование средств T-SQL и процессов ETL. Проведите проектирование функций, извлечение признаков и очистку данных в рамках рабочих процессов данных.

    При работе в выделенной среде разработки R, такой как [!INCLUDE[rsql_rtvs_md](../../includes/rsql-rtvs-md.md)] или RStudio, можно извлечь данные на компьютер, выполнить итеративный анализ данных, а затем выписать или отобразить результаты. 
    
    Однако при переносе отдельного кода R в SQL Server большую часть этого процесса можно упростить или делегировать другим средствам SQL Server. 

+ Используйте безопасные асинхронные стратегии визуализации.

    Пользователи SQL Server часто не могут получить доступ к файлам на сервере, а клиентские средства SQL обычно не поддерживают графическое устройство R. При создании графиков или других графических элементов в рамках решения рассмотрите возможность экспорта графиков в виде двоичных данных и сохранения их в таблице или записи.

+ Переносите функции прогнозирования и оценки в хранимых процедурах для прямого доступа приложений.

### <a name="other-resources"></a>Другие ресурсы

Примеры развертывания решения R в SQL Server см. в следующих примерах:

+ [Создание прогнозной модели для компании Ski аренды с помощью R и SQL Server](https://microsoft.github.io/sql-ml-tutorials/R/rentalprediction/)

+ [Аналитика в базе данных для РАЗРАБОТЧИКА SQL](../tutorials/sqldev-in-database-r-for-sql-developers.md) Демонстрируется, как можно сделать код R более модульным, заключив его в хранимые процедуры.

+ [Комплексное решение для обработки и анализа данных](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md) Содержит сравнение технических характеристик в R и T-SQL
