---
title: Диагностика общих проблем производительности с оптимизированными для памяти хэш-индексов | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 1954a997-7585-4713-81fd-76d429b8d095
author: stevestein
ms.author: sstein
manager: craigg
ms.openlocfilehash: d7ed4098feb8bfd2d156e3de2f81fbf7329915aa
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62842539"
---
# <a name="troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes"></a>Диагностика общих проблем с производительностью хэш-индексов оптимизированными для памяти таблиц
  В этом разделе рассматривается устранение неполадок и обходные пути для распространенных проблем с хэш-индексами.  
  
## <a name="search-requires-a-subset-of-hash-index-key-columns"></a>Поиску требуется подмножество ключевых столбцов хэш-индекса  
 **Проблема:** Хэш-индексы требуют значений для всех ключевых столбцов индекса, чтобы вычислить значение хэша и найти соответствующие строки в хэш-таблице. Поэтому если запрос включает предикаты равенства только для подмножества ключей индекса в предложении WHERE, то [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не может использовать поиск по индексу для нахождения строк, соответствующих предикатам в предложении WHERE.  
  
 Наоборот, упорядоченные индексы, так же как дисковые некластеризованные индексы и оптимизированные для памяти некластеризованные индексы, поддерживают поиск по индексу для подмножества ключевых столбцов индекса, если такие столбцы находятся в первых столбцах в индексе.  
  
 **Симптом:** Это приводит к снижению производительности, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] необходимо выполнить полное сканирование таблиц, а не поиска по индексу, в которой обычно является более быстрой операцией.  
  
 **Способы устранения неполадок:** Помимо снижения производительности Проверка планов запросов покажет полный просмотр вместо поиска по индексу. Если запрос простой, проверка текста запроса и определения индекса также покажет, требуется ли поиску подмножество ключевых столбцов индекса.  
  
 Рассмотрим следующую таблицу и запрос.  
  
```sql  
CREATE TABLE [dbo].[od]  
(  
     o_id INT NOT NULL,  
     od_id INT NOT NULL,  
     p_id INT NOT NULL,  
     CONSTRAINT PK_od PRIMARY KEY NONCLUSTERED HASH (o_id, od_id) WITH (BUCKET_COUNT = 10000)  
)  
WITH (MEMORY_OPTIMIZED = ON)  
  
 SELECT p_id  
 FROM dbo.od  
 WHERE o_id=1  
```  
  
 Таблица содержит хэш-индекс для двух столбцов (o_id, od_id), в то время как в запросе есть предикат равенства для (o_id). Так как запрос имеет предикаты равенства только для подмножества ключевых столбцов индекса, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не сможет выполнить поиск по индексу с помощью PK_od, вместо этого [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вынужденно вернется к полному просмотру индекса.  
  
 **Решения.** Существует ряд возможных решений. Пример:  
  
-   Создайте заново индекс некластеризованного типа вместо некластеризованного хэша. Оптимизированный для памяти некластеризованный индекс упорядочен, поэтому [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] сможет выполнить поиск по индексу в тех ключевых столбцах индекса, которые находятся в начале. Результирующее определение первичного ключа в этом примере будет следующим: `constraint PK_od primary key nonclustered`.  
  
-   Измените текущий ключ индекса так, чтобы он соответствовал столбцам в предложении WHERE.  
  
-   Добавьте новый хэш-индекс, который совпадает со столбцами в предложении WHERE запроса. В данном случае определение результирующей таблицы будет выглядеть следующим образом.  
  
    ```sql  
    CREATE TABLE dbo.od  
     ( o_id INT NOT NULL,  
     od_id INT NOT NULL,  
     p_id INT NOT NULL,  
  
     CONSTRAINT PK_od PRIMARY KEY   
     NONCLUSTERED HASH (o_id,od_id) WITH (BUCKET_COUNT=10000),  
  
     INDEX ix_o_id NONCLUSTERED HASH (o_id) WITH (BUCKET_COUNT=10000)  
  
     ) WITH (MEMORY_OPTIMIZED=ON)  
    ```  
  
 Обратите внимание, что оптимизированные для памяти хэш-индекс работать медленнее, если существует много повторяющихся строк для заданного значения ключа индекса: в примере, если количество уникальных значений для столбца o_id значительно меньше, чем количество строк в таблице , он не будет добавлять индекс для (o_id); Вместо этого изменение тип индекса PK_od с хэша на некластеризованный будет лучшим решением. Дополнительные сведения см. в разделе [Determining the Correct Bucket Count for Hash Indexes](../relational-databases/indexes/indexes.md).  
  
## <a name="see-also"></a>См. также  
 [Индексы для оптимизированных для памяти таблиц](../relational-databases/in-memory-oltp/memory-optimized-tables.md)  
  
  
