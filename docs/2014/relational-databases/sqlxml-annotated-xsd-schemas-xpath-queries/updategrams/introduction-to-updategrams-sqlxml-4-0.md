---
title: Общие сведения о диаграммах обновления (SQLXML 4.0) | Документация Майкрософт
ms.custom: ''
ms.date: 04/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- explicit schema mapping [SQLXML]
- updategrams [SQLXML], mapping schema specifying
- namespaces [SQLXML]
- updategrams [SQLXML], about updategrams
- attribute-centric mapping
- invalid characters [SQLXML]
- element-centric mapping [SQLXML]
- mapping schema [SQLXML], updategrams
- namespaces [SQLXML], updategrams
- executing updategrams [SQLXML]
- implicit schema mapping
ms.assetid: cfe24e82-a645-4f93-ab16-39c21f90cce6
author: douglaslMS
ms.author: douglasl
manager: craigg
ms.openlocfilehash: 82f6c6d8e7ecfa3a1ca29805c186d601ed65bd00
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63060362"
---
# <a name="introduction-to-updategrams-sqlxml-40"></a>Общие сведения о диаграммах обновления (SQLXML 4.0)
  Можно изменить (вставки, обновления или удаления) базы данных в [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] из существующего XML-документа с помощью диаграммы обновления или OPENXML [!INCLUDE[tsql](../../../includes/tsql-md.md)] функции.  
  
 Функция OPENXML изменяет базу данных, разделяя существующий XML-документ и формируя набор строк, который можно передавать инструкциям INSERT, UPDATE и DELETE. С помощью функции OPENXML операции выполняются непосредственно с таблицами базы данных. Поэтому использование функции OPENXML является наиболее оптимальным вариантом во всех случаях, когда поставщики наборов строк, например таблицы, могут быть источниками.  
  
 Диаграммы обновления, подобно функции OPENXML, позволяют вставлять, обновлять и удалять данные в базе данных. Однако диаграммы обновления работают не с таблицами, а с XML-представлениями, создаваемыми аннотированной XSD-схемой (или XDR-схемой); например, обновления применяются к XML-представлению, созданному сопоставляемой схемой. Схема сопоставления в свою очередь содержит данные, необходимые для сопоставления XML-элементов и атрибутов с соответствующими таблицами и столбцами базы данных. Диаграмма обновления использует эти данные сопоставления, чтобы выполнить обновление таблиц и столбцов базы данных.  
  
> [!NOTE]  
>  Настоящая документация предназначена для тех, кто знаком с шаблонами и поддержкой схем сопоставления в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в разделе [введение в схемы XSD с заметками &#40;SQLXML 4.0&#41;](../../sqlxml/annotated-xsd-schemas/introduction-to-annotated-xsd-schemas-sqlxml-4-0.md). Для приложений прежних версий, которые используют XDR, см. в разделе [аннотированные схемы XDR &#40;в SQLXML 4.0&#41;](../../sqlxml/annotated-xsd-schemas/annotated-xdr-schemas-deprecated-in-sqlxml-4-0.md).  
  
## <a name="required-namespaces-in-the-updategram"></a>Обязательные пространства имен в диаграмме обновления  
 Ключевые слова в диаграмме обновления, такие как  **\<синхронизации >**,  **\<перед >**, и  **\<после >**, существуют в `urn:schemas-microsoft-com:xml-updategram`пространства имен. Префикс пространства имен может быть произвольным. В этой документации префикс `updg` обозначает пространство имен `updategram`.  
  
## <a name="reviewing-syntax"></a>Обзор синтаксиса  
 Диаграмма обновления является шаблоном с  **\<синхронизации >**,  **\<перед >**, и  **\<после >** блоки, формирующими синтаксис Диаграмма обновления. Следующий код показывает этот синтаксис в его простейшей форме:  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
  <updg:sync [mapping-schema= "AnnotatedSchemaFile.xml"] >  
    <updg:before>  
        ...  
    </updg:before>  
    <updg:after>  
        ...  
    </updg:after>  
  </updg:sync>  
</ROOT>  
```  
  
 Следующие определения описывают роль каждого блока.  
  
 **\<Прежде чем >**  
 Определяет текущее состояние (называемое также «исходным состоянием») экземпляра записи.  
  
 **\<После >**  
 Определяет новое состояние изменяемых данных.  
  
 **\<sync>**  
 Содержит  **\<перед >** и  **\<после >** блоков. Объект  **\<синхронизации >** блок может содержать более одного набора  **\<перед >** и  **\<после >** блоков. Если имеется более одного набора  **\<перед >** и  **\<после >** блоки, эти блоки (даже если они пусты) должен быть указан как пары ". Кроме того, она может иметь более одного  **\<синхронизации >** блока. Каждый  **\<синхронизации >** блок является одной единицей транзакции (что означает, что в  **\<синхронизации >** блок выполняется или не выполняется). Если задано несколько  **\<синхронизации >** блоков в диаграмме обновления, то неудачное завершение одного  **\<синхронизации >** блок не влияет на другой  **\<синхронизации >** блоков.  
  
 Ли диаграмма обновления удаляет вставляет или обновляет экземпляр записи зависит от содержимого  **\<перед >** и  **\<после >** блоков:  
  
-   Если экземпляр записи имеется только в  **\<перед >** блок без соответствующего экземпляра в  **\<после >** блок, диаграмма обновления выполняет операцию удаления.  
  
-   Если экземпляр записи имеется только в  **\<после >** блок без соответствующего экземпляра в  **\<перед >** блок, он выполняет операцию вставки.  
  
-   Если экземпляр записи имеется в  **\<перед >** блокировку и имеет соответствующий экземпляр в  **\<после >** блок, он является операцией обновления. В этом случае диаграмма обновления обновляет экземпляр записи со значениями, которые указаны в  **\<после >** блока.  
  
## <a name="specifying-a-mapping-schema-in-the-updategram"></a>Указание сопоставления схемы в диаграмме обновления  
 В диаграмме обновления XML-абстракция, созданная сопоставляемой схемой (поддерживаются схемы XSD и XDR), может быть явной или неявной (то есть диаграмма обновления может работать как с заданной схемой сопоставления, так и без нее). Если вы не укажете схему сопоставления, то диаграмма обновления предполагает неявное сопоставление (сопоставление по умолчанию), где каждый элемент  **\<перед >** блока или  **\<после >** блок сопоставляется с таблицей и каждый его дочерний элемент или атрибут сопоставляется со столбцом в базе данных. Если схема сопоставления указана явно, то элементы и атрибуты в диаграмме обновления должны совпадать с элементами и атрибутами сопоставляемой схемы.  
  
### <a name="implicit-default-mapping"></a>Неявное сопоставление (по умолчанию)  
 В большинстве случаев диаграмма обновления, выполняющая простые обновления, не требует схемы сопоставления. В такой ситуации диаграмма обновления полагается на схему сопоставления, принятую по умолчанию.  
  
 В следующей диаграмме обновления показано неявное сопоставление. В этом примере диаграмма обновления применяется для вставки данных нового клиента в таблицу Sales.Customer. Так как в этой диаграмме обновления используется неявное сопоставление \<Sales.Customer > элемент сопоставляется с таблицей Sales.Customer, а атрибуты CustomerID и SalesPersonID сопоставляются соответствующим столбцам в таблице Sales.Customer.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
<updg:before>  
</updg:before>  
<updg:after>  
    <Sales.Customer CustomerID="1" SalesPersonID="277" />  
    </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="explicit-mapping"></a>Явное сопоставление  
 Если указывается схема сопоставления (XSD или XDR), диаграмма обновления использует эту схему для определения подлежащих обновлению таблиц и столбцов базы данных.  
  
 Если диаграмма обновления выполняет сложное обновление (например, вставку записей в несколько таблиц на основе связи «родители-потомки», заданной в схеме сопоставления), необходимо явно задать схему сопоставления с помощью атрибута `mapping-schema`, по которому выполняется диаграмма обновления.  
  
 Диаграмма обновления является шаблоном, поэтому заданный в ней путь для схемы сопоставления зависит от расположения файла шаблона (является относительным). Дополнительные сведения см. в разделе [определение схемы с заметками сопоставления в диаграмме обновления &#40;SQLXML 4.0&#41;](specifying-an-annotated-mapping-schema-in-an-updategram-sqlxml-4-0.md).  
  
## <a name="element-centric-and-attribute-centric-mapping-in-updategrams"></a>Элементная и атрибутивная модель сопоставления в диаграммах обновления  
 При сопоставлении по умолчанию (когда сопоставляемая схема не указывается в диаграмме обновления), элементы диаграммы обновления сопоставляются с таблицами и дочерними элементами (в случае элементной модели сопоставления), а атрибуты сопоставляются со столбцами (в случае атрибутивной модели сопоставления).  
  
### <a name="element-centric-mapping"></a>Сопоставление, ориентированное на элементы  
 В диаграмме обновления, основанной на элементах, элемент содержит дочерние элементы, обозначающие свойства этого элемента. В качестве примера см. следующую диаграмму обновления.  **\<Person.Contact >** элемент содержит **\<FirstName >** и **\<LastName>** дочерних элементов. Эти дочерние элементы являются свойствами  **\<Person.Contact >** элемент.  
  
 Эта диаграмма обновления не указывает схему сопоставления, поэтому в ней используется неявное сопоставление, где  **\<Person.Contact >** элемент сопоставляется с таблицей Person.Contact и его дочерние элементы сопоставляются FirstName и Столбцы LastName.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:after>  
    <Person.Contact>  
       <FirstName>Catherine</FirstName>  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="attribute-centric-mapping"></a>атрибутивное сопоставление  
 В атрибутивной модели сопоставления элементы имеют атрибуты. В следующей диаграмме обновления используется атрибутивная модель сопоставления. В этом примере  **\<Person.Contact >** элемент состоит из **FirstName** и **LastName** атрибуты. Эти атрибуты являются свойствами  **\<Person.Contact >** элемент. Как показано в предыдущем примере, эта диаграмма обновления не указана схема сопоставления, поэтому он используется неявное сопоставление для сопоставления  **\<Person.Contact >** таблицы Person.Contact и атрибуты этого элемента для элемента соответствующие столбцы в таблице.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" LastName="Abel" />  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="using-both-element-centric-and-attribute-centric-mapping"></a>Одновременное использование элементной и атрибутивной моделей сопоставления  
 Можно использовать сочетание элементной и атрибутивной моделей сопоставления, как показано в следующей диаграмме обновления. Обратите внимание, что  **\<Person.Contact >** элемент содержит и атрибут, так и дочерний элемент. Кроме того, в этой диаграмме обновления используется неявное сопоставление. Таким образом **FirstName** атрибут и  **\<LastName >** сопоставляются с соответствующими столбцами в таблице Person.Contact.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" >  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
## <a name="working-with-characters-valid-in-sql-server-but-not-valid-in-xml"></a>Работа с символами, допустимыми в SQL Server, но не допустимыми в XML  
 В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] имена таблиц могут содержать пробелы. Но в XML имена таблиц такого типа не допускаются.  
  
 Для кодирования символов, которые являются допустимыми [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] идентификаторы, но это не идентификаторах XML, используйте "__xHHHH\_\_" как значение кодировки, где HHHH обозначает из четырех цифр шестнадцатеричный код UCS-2 для символа, в наиболее значительные порядке старшинства бит. С помощью этой схемы кодирования, символ пробела замещается x0020 (из четырех цифр шестнадцатеричный код пробела); Таким образом, имя таблицы [Order Details] в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] становится _x005B_Order_x0020_Details_x005D\_ в формате XML.  
  
 Аналогичным образом, может потребоваться указать имена элементов трех частей, например \<[база данных]. [ Владелец]. [таблица] >. Поскольку символы скобок ([и]) являются недопустимыми в формате XML, необходимо указать его в виде \<_x005B_database_x005D\_._x005B_owner_x005D\_._x005B_table_x005D\_>, где _x005B\_ — Кодировка для левую скобку ([) и _x005D\_ кодировка правая квадратная скобка (]).  
  
## <a name="executing-updategrams"></a>Выполнение диаграмм обновления  
 Диаграмма обновления является шаблоном, поэтому к ней применяются все механизмы обработки шаблона. В SQLXML 4.0 диаграмму обновления можно выполнить следующими способами:  
  
-   с помощью команды ADO;  
  
-   с помощью команды OLE DB.  
  
## <a name="see-also"></a>См. также  
 [Вопросы безопасности диаграмм обновления &#40;SQLXML 4.0&#41;](../security/updategram-security-considerations-sqlxml-4-0.md)  
  
  
