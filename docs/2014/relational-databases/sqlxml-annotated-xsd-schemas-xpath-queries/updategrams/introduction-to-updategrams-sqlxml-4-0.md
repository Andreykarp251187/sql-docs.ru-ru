---
title: Введение в диаграмм обновления (SQLXML 4,0) | Документация Майкрософт
ms.custom: ''
ms.date: 04/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- explicit schema mapping [SQLXML]
- updategrams [SQLXML], mapping schema specifying
- namespaces [SQLXML]
- updategrams [SQLXML], about updategrams
- attribute-centric mapping
- invalid characters [SQLXML]
- element-centric mapping [SQLXML]
- mapping schema [SQLXML], updategrams
- namespaces [SQLXML], updategrams
- executing updategrams [SQLXML]
- implicit schema mapping
ms.assetid: cfe24e82-a645-4f93-ab16-39c21f90cce6
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 114bc96623b608cfbb520a9d2f35f23a04310a74
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "66014803"
---
# <a name="introduction-to-updategrams-sqlxml-40"></a>Общие сведения о диаграммах обновления (SQLXML 4.0)
  Можно изменить (вставить, обновить или удалить) базу данных [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] из существующего XML-документа с помощью функции диаграмма обновления или OPENXML [!INCLUDE[tsql](../../../includes/tsql-md.md)] .  
  
 Функция OPENXML изменяет базу данных, разделяя существующий XML-документ и формируя набор строк, который можно передавать инструкциям INSERT, UPDATE и DELETE. С помощью функции OPENXML операции выполняются непосредственно с таблицами базы данных. Поэтому использование функции OPENXML является наиболее оптимальным вариантом во всех случаях, когда поставщики наборов строк, например таблицы, могут быть источниками.  
  
 Диаграммы обновления, подобно функции OPENXML, позволяют вставлять, обновлять и удалять данные в базе данных. Однако диаграммы обновления работают не с таблицами, а с XML-представлениями, создаваемыми аннотированной XSD-схемой (или XDR-схемой); например, обновления применяются к XML-представлению, созданному сопоставляемой схемой. Схема сопоставления в свою очередь содержит данные, необходимые для сопоставления XML-элементов и атрибутов с соответствующими таблицами и столбцами базы данных. Диаграмма обновления использует эти данные сопоставления, чтобы выполнить обновление таблиц и столбцов базы данных.  
  
> [!NOTE]  
>  Настоящая документация предназначена для тех, кто знаком с шаблонами и поддержкой схем сопоставления в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]. Дополнительные сведения см. [в разделе Введение в схемы XSD с Заметками &#40;SQLXML 4,0&#41;](../../sqlxml/annotated-xsd-schemas/introduction-to-annotated-xsd-schemas-sqlxml-4-0.md). Дополнительные сведения о устаревших приложениях, использующих XDR, см. [в разделе схемы XDR с Заметками &#40;не рекомендуется в SQLXML 4,0&#41;](../../sqlxml/annotated-xsd-schemas/annotated-xdr-schemas-deprecated-in-sqlxml-4-0.md).  
  
## <a name="required-namespaces-in-the-updategram"></a>Обязательные пространства имен в диаграмме обновления  
 Ключевые слова в диаграмма обновления, такие как ** \<Sync>**, ** \<до>** и ** \<после>**, существуют в `urn:schemas-microsoft-com:xml-updategram` пространстве имен. Префикс пространства имен может быть произвольным. В этой документации префикс `updg` обозначает пространство имен `updategram`.  
  
## <a name="reviewing-syntax"></a>Обзор синтаксиса  
 Диаграмма обновления — это шаблон с ** \<>синхронизации **, ** \<до>** и ** \<после блоков>** , образующих синтаксис диаграмма обновления. Следующий код показывает этот синтаксис в его простейшей форме:  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
  <updg:sync [mapping-schema= "AnnotatedSchemaFile.xml"] >  
    <updg:before>  
        ...  
    </updg:before>  
    <updg:after>  
        ...  
    </updg:after>  
  </updg:sync>  
</ROOT>  
```  
  
 Следующие определения описывают роль каждого блока.  
  
 **\<до>**  
 Определяет текущее состояние (называемое также «исходным состоянием») экземпляра записи.  
  
 **\<После>**  
 Определяет новое состояние изменяемых данных.  
  
 **\<>синхронизации**  
 Содержит блоки ** \<Before>** и ** \<After>** . Блок ** \<>синхронизации** может содержать более одного набора ** \<перед>** и ** \<после блоков>** . Если имеется более одного набора ** \<перед>** и ** \<после блоков>** , эти блоки (даже если они пусты) должны быть указаны в виде пар. Кроме того, диаграмма обновления может иметь несколько блоков ** \<синхронизации>** . Каждый ** \<блок синхронизации>** является одной единицей транзакции (что означает, что все в блоке ** \<синхронизации>** выполняется или ничего не происходит). При указании нескольких ** \<блоков Sync>** в диаграмма обновления сбой одного ** \<** блока синхронизации>не влияет на другие ** \<блоки синхронизации>** .  
  
 Будет ли диаграмма обновления удалять, вставлять или обновлять экземпляр записи, зависит от содержимого блоков ** \<Before>** и ** \<After>** .  
  
-   Если экземпляр записи отображается только в блоке ** \<Before>** без соответствующего экземпляра в блоке ** \<After>** , диаграмма обновления выполняет операцию удаления.  
  
-   Если экземпляр записи отображается только в блоке ** \<After>** без соответствующего экземпляра в блоке ** \<Before>** , это операция вставки.  
  
-   Если экземпляр записи отображается в блоке ** \<Before>** и имеет соответствующий экземпляр в блоке ** \<After>** , это операция обновления. В этом случае диаграмма обновления обновляет экземпляр записи значениями, указанными в блоке ** \<After>** .  
  
## <a name="specifying-a-mapping-schema-in-the-updategram"></a>Указание сопоставления схемы в диаграмме обновления  
 В диаграмме обновления XML-абстракция, созданная сопоставляемой схемой (поддерживаются схемы XSD и XDR), может быть явной или неявной (то есть диаграмма обновления может работать как с заданной схемой сопоставления, так и без нее). Если схема сопоставления не указана, диаграмма обновления предполагает неявное сопоставление (сопоставление по умолчанию), где каждый элемент в блоке ** \<Before>** или ** \<после>** блок сопоставляется с таблицей, а дочерний элемент или атрибут каждого элемента сопоставляется со столбцом в базе данных. Если схема сопоставления указана явно, то элементы и атрибуты в диаграмме обновления должны совпадать с элементами и атрибутами сопоставляемой схемы.  
  
### <a name="implicit-default-mapping"></a>Неявное сопоставление (по умолчанию)  
 В большинстве случаев диаграмма обновления, выполняющая простые обновления, не требует схемы сопоставления. В такой ситуации диаграмма обновления полагается на схему сопоставления, принятую по умолчанию.  
  
 В следующей диаграмме обновления показано неявное сопоставление. В этом примере диаграмма обновления применяется для вставки данных нового клиента в таблицу Sales.Customer. Так как в \<этом диаграмма обновления используется неявное сопоставление, элемент Sales. Customer> сопоставляется с таблицей Sales. Customer, а атрибуты CustomerID и SalesPersonID сопоставляются с соответствующими столбцами в таблице Sales. Customer.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
<updg:before>  
</updg:before>  
<updg:after>  
    <Sales.Customer CustomerID="1" SalesPersonID="277" />  
    </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="explicit-mapping"></a>Явное сопоставление  
 Если указывается схема сопоставления (XSD или XDR), диаграмма обновления использует эту схему для определения подлежащих обновлению таблиц и столбцов базы данных.  
  
 Если диаграмма обновления выполняет сложное обновление (например, вставку записей в несколько таблиц на основе связи «родители-потомки», заданной в схеме сопоставления), необходимо явно задать схему сопоставления с помощью атрибута `mapping-schema`, по которому выполняется диаграмма обновления.  
  
 Диаграмма обновления является шаблоном, поэтому заданный в ней путь для схемы сопоставления зависит от расположения файла шаблона (является относительным). Дополнительные сведения см. [в разделе Указание схемы сопоставления с заметками в диаграмма обновления &#40;SQLXML 4,0&#41;](specifying-an-annotated-mapping-schema-in-an-updategram-sqlxml-4-0.md).  
  
## <a name="element-centric-and-attribute-centric-mapping-in-updategrams"></a>Элементная и атрибутивная модель сопоставления в диаграммах обновления  
 При сопоставлении по умолчанию (когда сопоставляемая схема не указывается в диаграмме обновления), элементы диаграммы обновления сопоставляются с таблицами и дочерними элементами (в случае элементной модели сопоставления), а атрибуты сопоставляются со столбцами (в случае атрибутивной модели сопоставления).  
  
### <a name="element-centric-mapping"></a>Сопоставление, ориентированное на элементы  
 В диаграмме обновления, основанной на элементах, элемент содержит дочерние элементы, обозначающие свойства этого элемента. В качестве примера см. следующую диаграмму обновления. Элемент ** \<Person. Contact>** содержит дочерние элементы ** \<FirstName>** и ** \<LastName>** . Эти дочерние элементы являются свойствами элемента ** \<Person. Contact>** .  
  
 Так как в этом диаграмма обновления не указана схема сопоставления, диаграмма обновления использует неявное сопоставление, где элемент ** \<Person. Contact>** сопоставляется с таблицей Person. Contact, а ее дочерние элементы сопоставляются со столбцами FirstName и LastName.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:after>  
    <Person.Contact>  
       <FirstName>Catherine</FirstName>  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="attribute-centric-mapping"></a>атрибутивное сопоставление  
 В атрибутивной модели сопоставления элементы имеют атрибуты. В следующей диаграмме обновления используется атрибутивная модель сопоставления. В этом примере элемент ** \<Person. Contact>** состоит из атрибутов **FirstName** и **LastName** . Эти атрибуты являются свойствами элемента ** \<Person. Contact>** . Как и в предыдущем примере, в этом диаграмма обновления не указана схема сопоставления, поэтому она использует неявное сопоставление для сопоставления элемента ** \<Person** . Contact>с таблицей Person. Contact и атрибутами элемента с соответствующими столбцами в таблице.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" LastName="Abel" />  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="using-both-element-centric-and-attribute-centric-mapping"></a>Одновременное использование элементной и атрибутивной моделей сопоставления  
 Можно использовать сочетание элементной и атрибутивной моделей сопоставления, как показано в следующей диаграмме обновления. Обратите внимание, что элемент ** \<Person. Contact>** содержит как атрибут, так и дочерний элемент. Кроме того, в этой диаграмме обновления используется неявное сопоставление. Таким образом, атрибут **FirstName** и дочерний элемент ** \<LastName>** сопоставляются с соответствующими столбцами в таблице Person. Contact.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" >  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
## <a name="working-with-characters-valid-in-sql-server-but-not-valid-in-xml"></a>Работа с символами, допустимыми в SQL Server, но не допустимыми в XML  
 В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] имена таблиц могут содержать пробелы. Но в XML имена таблиц такого типа не допускаются.  
  
 Для кодирования символов, которые являются [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] допустимыми идентификаторами, но не являются допустимыми XML-идентификаторами, используйте "__xHHHH\_\_" в качестве значения кодировки, где HHHH означает шестнадцатеричный код UCS-2 для символа в наиболее значительном порядке. При использовании этой схемы кодирования символ пробела заменяется на x0020 (шестнадцатеричный код из четырех цифр для символа пробела); Таким же именем таблица [Order Details] в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] _x005B_Order_x0020_Details_x005Dся\_ в XML.  
  
 Аналогичным образом может потребоваться указать имена элементов из трех частей, например \<[Database]. [владелец]. [Таблица] >. Поскольку символы квадратной скобки ([и]) недопустимы в XML, необходимо указать это как \<_x005B_database_x005D\_. _x005B_owner_x005D\_. _x005B_table_x005D\_>, где _x005B\_ — это кодировка для левой квадратной скобки ([\_ ), а _x005D — это кодировка правой квадратной скобки (]).  
  
## <a name="executing-updategrams"></a>Выполнение диаграмм обновления  
 Диаграмма обновления является шаблоном, поэтому к ней применяются все механизмы обработки шаблона. В SQLXML 4.0 диаграмму обновления можно выполнить следующими способами:  
  
-   с помощью команды ADO;  
  
-   с помощью команды OLE DB.  
  
## <a name="see-also"></a>См. также:  
 [Вопросы безопасности диаграмма обновления &#40;SQLXML 4,0&#41;](../security/updategram-security-considerations-sqlxml-4-0.md)  
  
  
