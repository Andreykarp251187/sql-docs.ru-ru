---
title: Выборка итоговых данных | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: b803ca3742f9cb831e51105aab9d0ed75ad78e16
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2019
ms.locfileid: "63200080"
---
# <a name="fetching-result-data"></a>Выборка итоговых данных
  Приложение ODBC имеет три параметра для выборки данных результата.  
  
 Первый параметр основан на [SQLBindCol](../native-client-odbc-api/sqlbindcol.md). До выборки результирующего набора, приложение использует **SQLBindCol** для привязки каждого столбца в результирующем наборе к программной переменной. После привязки столбцов драйвер передает данные текущей строки в переменные, привязанные к столбцам результирующего набора каждый раз, когда приложение вызывает **SQLFetch** или [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md). Если столбец результирующего набора и программная переменная имеют разные типы данных, драйвер выполняет преобразования данных. Если приложение использует атрибут SQL_ATTR_ROW_ARRAY_SIZE больше 1, он может привязать столбцы результата к массивам переменных, которые будут все заполнены при каждом вызове **SQLFetchScroll**.  
  
 Второй параметр основан на [SQLGetData](../native-client-odbc-api/sqlgetdata.md). Приложение не использует **SQLBindCol** для привязки результата столбцы набора к переменным программы. После каждого вызова **SQLFetch**, приложение вызывает **SQLGetData** один раз для каждого столбца в результирующий набор. **SQLGetData** Указывает драйверу передавать данные из конкретного столбца результирующего набора в конкретную программную переменную и задает типы данных столбцов и переменных. Это позволяет драйверу преобразовать данные, если столбец результата и программная переменная имеют разные типы данных. **Текст**, **ntext**, и **изображение** столбцов обычно являются слишком велик для программной переменной, но по-прежнему может быть получен посредством **SQLGetData**. Если **текст**, **ntext**, или **изображение** данных в столбце результатов больше, чем программной переменной, **SQLGetData** возвращает SQL_SUCCESS_ WITH_INFO и SQLSTATE 01004 (строковые данные, усечение справа). Последовательные вызовы **SQLGetData** возвращают успешные фрагменты из **текст** или **изображение** данных. При достижении конца данных **SQLGetData** возвращает значение SQL_SUCCESS. Если SQL_ATTR_ROW_ARRAY_SIZE больше 1, то каждая выборка возвращает набор строк. Перед использованием **SQLGetData**, необходимо сначала воспользоваться **SQLSetPos** для указания конкретной строки в наборе строк как текущую строку.  
  
 Третий вариант — использовать сочетание **SQLBindCol** и **SQLGetData**. Приложение может, например, привязать первые десять столбцов результирующего набора и затем для каждой выборки, вызовите метод **SQLGetData** три раза, чтобы получить данные из трех несвязанных столбцов. Это обычно используется, если результирующий набор содержит один или несколько **текст** или **изображение** столбцов.  
  
 В зависимости от параметров курсора, заданных для результирующего набора, приложение может также использовать параметры прокрутки функции **SQLFetchScroll** для прокрутки результирующего набора.  
  
 Злоупотребление использованием **SQLBindCol** для привязки результирующего столбца набора к программной переменной является ресурсоемким поскольку **SQLBindCol** вызывает драйвер ODBC для выделения памяти. При привязке столбца результата к переменной, что привязка остается в силе до вызова [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) для освобождения дескриптора инструкции или вызов [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) с *fOption* значение SQL_UNBIND. По завершении инструкции привязки автоматически не снимаются.  
  
 Эта логика позволяет эффективно выполнять инструкцию SELECT несколько раз с различными параметрами. Так как результирующий набор сохраняет ту же структуру, можно один раз привязать результирующий набор, обработка всех инструкций SELECT, затем вызвать **SQLFreeStmt** с *fOption* равным SQL_UNBIND после последнего выполнения. Не следует вызывать **SQLBindCol** для привязки столбцов в результирующем наборе без предварительного вызова функции **SQLFreeStmt** с *fOption* равным SQL_UNBIND для всех предшествующих привязок.  
  
 При использовании **SQLBindCol**, можно осуществлять привязку на уровне строки или на уровне столбца. Привязка параметров на уровне строк быстрее, чем привязка на уровне столбцов.  
  
 Можно использовать **SQLGetData** для получения данных на основе по столбцам вместо привязки результирующего набора столбцов с помощью **SQLBindCol**. Если результирующий набор содержит лишь несколько строк, с помощью **SQLGetData** вместо **SQLBindCol** быстрее; в противном случае — значение **SQLBindCol** обеспечивает наилучшую производительность. Если вы не всегда помещаются данные в тот же набор переменных, следует использовать **SQLGetData** вместо постоянной повторной привязки. Можно использовать только **SQLGetData** на столбцы, которые находятся в списке выбора после столбцов, привязанных с **SQLBindCol**. Столбец также должен располагаться после всех столбцов, на которых вы уже использовали **SQLGetData**.  
  
 Функции ODBC, работающие с перемещением данных в или из переменных программы, такие как **SQLGetData**, **SQLBindCol**, и [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), поддерживают неявный тип данных преобразование. Например, если приложение привязывает целочисленный столбец к строковой программной переменной, драйвер автоматически преобразует данные из целочисленного в символьный тип перед тем, как поместить их в программную переменную.  
  
 Количество преобразований данных в приложениях должно быть минимальным. Если преобразование данных не требуется для вычислений, производимых приложением, приложения привяжут столбцы и параметры к программным переменным того же типа данных. Однако, если данные должны быть преобразованы из одного типа в другой, более эффективным будет преобразовать данные с помощью драйвера, чем делать это в приложении. Драйвер для собственного клиента ODBC [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обычно только передает данные непосредственно из сетевых буферов в переменные приложения. Обращение к драйверу для добавления преобразования данных приведет к буферизации данных драйвером и использованию времени ЦП для преобразования данных.  
  
 Программные переменные должны быть достаточно большим, чтобы хранить данные, переданные из столбца, за исключением **текст**, **ntext**, и **изображение** данных. Если приложение пытается получить результирующий набор данных и сохранить его в переменной недостаточного размера, драйвер сформирует предупреждение. Это заставит драйвер выделить память для сообщения, а драйвер и приложение будут вынуждены тратить время ЦП на обработку сообщения и ошибок. Приложение должно либо выделить достаточно большую переменную для сохранения полученных данных, либо использовать функцию SUBSTRING в списке выбора для уменьшения размера столбца в результирующем наборе.  
  
 Следует соблюдать осторожность при использовании SQL_C_DEFAULT для указания типа переменной C. SQL_C_DEFAULT указывает, что тип переменной C соответствует типу данных SQL столбца или параметра. Если SQL_C_DEFAULT указан для **ntext**, **nchar**, или **nvarchar** столбца, возвращает данные в Юникоде в приложение. Это может привести к возникновению различных проблем, если приложение не было настроено для обработки данных в Юникоде. Те же типы проблем могут возникать с **uniqueidentifier** тип данных (SQL_GUID).  
  
 **текст**, **ntext**, и **изображение** данные обычно слишком велик для обработки в одной программной переменной и они обычно обрабатываются с помощью **SQLGetData** вместо **SQLBindCol**. При использовании серверных курсоров, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] драйвер ODBC собственного клиента оптимизирован для запрещения передачи данных непривязанным **текст**, **ntext**, или **образа** на столбцы время выборки строки. **Текст**, **ntext**, или **изображение** данных не производится на сервере до проблем приложений **SQLGetData** для столбец.  
  
 Эта оптимизация может применяться к приложениям, чтобы не **текст**, **ntext**, или **изображения** данные отображаются во время как пользователь прокручивает вверх и вниз курсора. После того как пользователь выберет строку, приложение может вызвать **SQLGetData** извлекаемого **текст**, **ntext**, или **изображение** данных. Это экономит передачу столбцов **текст**, **ntext**, или **изображения** данные для строк пользователь не выбрал и может сэкономить передачу очень больших объемов данных.  
  
## <a name="see-also"></a>См. также  
 [Обработка результатов &#40;ODBC&#41;](processing-results-odbc.md)  
  
  
